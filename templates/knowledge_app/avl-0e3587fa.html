
{% extends 'knowledge_app/base.html' %}

{% block title %}AVL树可视化系统 - 计算机科学学习平台{% endblock %}

{% block extra_css %}
<style>.breadcrumb {color:white;margin-bottom:20px;opacity:0.9}.breadcrumb a {color:white;text-decoration:none}.breadcrumb a:hover {text-decoration:underline}.knowledge-header {background:rgba(255, 255, 255, 0.1);backdrop-filter:blur(10px);border-radius:15px;padding:30px;margin-bottom:30px;color:white;text-align:center;position:relative;z-index:2}.knowledge-header h1 {font-size:2.5rem;margin-bottom:15px;display:flex;align-items:center;justify-content:center;gap:15px}.knowledge-header p {font-size:1.1rem;opacity:0.9;line-height:1.6}.main-card {background:white;border-radius:15px;box-shadow:0 10px 30px rgba(0, 0, 0, 0.1);margin-bottom:30px;overflow:hidden;position:relative;z-index:1;padding:30px}.knowledge-header {background:rgba(255, 255, 255, 0.15);backdrop-filter:blur(20px);border-radius:20px;padding:40px 30px;margin-bottom:30px;color:white;text-align:center;position:relative;border:1px solid rgba(255, 255, 255, 0.2);box-shadow:0 8px 32px rgba(0, 0, 0, 0.1)}.knowledge-header h1 {font-size:2.8rem;margin-bottom:15px;display:flex;align-items:center;justify-content:center;gap:15px;font-weight:700;letter-spacing:-0.5px}.knowledge-header p {font-size:1.2rem;opacity:0.95;line-height:1.6;max-width:600px;margin:0 auto}.main-card {background:white;border-radius:20px;box-shadow:0 20px 60px rgba(0, 0, 0, 0.1);padding:30px;margin-bottom:30px;position:relative;border:1px solid rgba(0, 0, 0, 0.05)}.visualization-container {display:grid;grid-template-columns:1fr 420px;grid-template-rows:1fr auto;gap:30px;height:800px;margin-bottom:30px}.canvas-container {grid-column:1;grid-row:1 / 3;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:20px;padding:25px;border:2px solid #e9ecef;display:flex;flex-direction:column;box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.05)}.canvas-header {display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:20px;border-bottom:2px solid #e9ecef}.canvas-title {font-size:1.4rem;font-weight:700;color:#333;display:flex;align-items:center;gap:12px}.tree-stats {display:flex;gap:25px;font-size:0.9rem}.stat-item {display:flex;flex-direction:column;align-items:center;text-align:center;background:white;padding:12px 16px;border-radius:12px;box-shadow:0 2px 8px rgba(0, 0, 0, 0.05);border:1px solid #f0f0f0;min-width:80px}.stat-value {font-size:1.4rem;font-weight:700;color:#667eea;margin-bottom:4px}.stat-label {font-size:0.8rem;color:#666;font-weight:500}.controls-panel {grid-column:2;grid-row:1;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:20px;padding:25px;border:2px solid #e9ecef;overflow-y:auto;box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.05)}.rotation-info-panel {grid-column:2;grid-row:2;background:white;border-radius:20px;padding:25px;border:2px solid #e9ecef;max-height:280px;overflow-y:auto;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);scroll-behavior:smooth;position:relative}.rotation-info-panel::-webkit-scrollbar {width:8px}.rotation-info-panel::-webkit-scrollbar-track {background:#f1f1f1;border-radius:4px}.rotation-info-panel::-webkit-scrollbar-thumb {background:#667eea;border-radius:4px;opacity:0.7}.rotation-info-panel::-webkit-scrollbar-thumb:hover {background:#5a6fd8}.new-content-indicator {position:absolute;top:10px;right:10px;background:#667eea;color:white;padding:4px 8px;border-radius:12px;font-size:12px;font-weight:600;opacity:0;transform:scale(0.8);transition:all 0.3s ease;z-index:10}.new-content-indicator.show {opacity:1;transform:scale(1)}.analysis-item {transition:all 0.5s ease;transform:translateY(10px);opacity:0}.analysis-item.fade-in {transform:translateY(0);opacity:1}.highlight-new {animation:highlightPulse 2s ease-in-out}@keyframes highlightPulse {0% {box-shadow:0 0 0 0 rgba(102, 126, 234, 0.7)}70% {box-shadow:0 0 0 10px rgba(102, 126, 234, 0)}100% {box-shadow:0 0 0 0 rgba(102, 126, 234, 0)}}.rotation-alert {background:linear-gradient(135deg, #FF6B6B, #FF8E53);color:white;padding:18px;border-radius:15px;margin:15px 0;animation:pulse 2s infinite;border:none;box-shadow:0 6px 20px rgba(255, 107, 107, 0.3)}.rotation-alert h4 {margin:0 0 12px 0;font-size:1.2rem;display:flex;align-items:center;gap:10px;font-weight:600}.rotation-alert p {margin:6px 0;font-size:0.95rem;line-height:1.5}.balance-explanation {background:linear-gradient(145deg, #E3F2FD, #f8f9ff);border:2px solid #2196F3;border-radius:12px;padding:18px;margin:15px 0;box-shadow:0 4px 16px rgba(33, 150, 243, 0.1)}.balance-explanation h4 {color:#1976D2;margin:0 0 12px 0;font-weight:600}.balance-factors {display:grid;grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));gap:12px;margin:15px 0}.balance-item {background:white;padding:12px;border-radius:8px;text-align:center;border:2px solid #e0e0e0;font-size:0.9rem;transition:all 0.3s ease}.balance-item.unbalanced {background:linear-gradient(145deg, #FFEBEE, #fff5f5);border-color:#F44336;color:#C62828;font-weight:600;box-shadow:0 2px 8px rgba(244, 67, 54, 0.2)}.balance-item.new-node {background:linear-gradient(145deg, #E3F2FD, #f0f8ff);border-color:#2196F3;color:#1976D2;font-weight:600;box-shadow:0 2px 8px rgba(33, 150, 243, 0.2)}.rotation-countdown {background:linear-gradient(145deg, #FFF3E0, #fffbf5);border:2px solid #FF9800;border-radius:12px;padding:18px;margin:15px 0;text-align:center;box-shadow:0 4px 16px rgba(255, 152, 0, 0.1)}.countdown-timer {font-size:2.2rem;font-weight:700;color:#E65100;margin:12px 0;text-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}@keyframes pulse {0% {transform:scale(1)}50% {transform:scale(1.02)}100% {transform:scale(1)}}@keyframes shake {0%, 100% {transform:translateX(0)}25% {transform:translateX(-5px)}75% {transform:translateX(5px)}}.shake {animation:shake 0.5s ease-in-out}#avlCanvas {width:100%;flex:1;border:2px solid #e0e0e0;border-radius:15px;background:white;cursor:pointer;box-shadow:0 4px 20px rgba(0, 0, 0, 0.08);transition:box-shadow 0.3s ease}#avlCanvas:hover {box-shadow:0 6px 25px rgba(0, 0, 0, 0.12)}.control-group {margin-bottom:25px;padding:22px;background:white;border-radius:15px;border:1px solid #e0e0e0;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);transition:box-shadow 0.3s ease}.control-group:hover {box-shadow:0 6px 20px rgba(0, 0, 0, 0.08)}.control-group h3 {margin:0 0 20px 0;color:#333;font-size:1.15rem;font-weight:600;padding-bottom:12px;border-bottom:2px solid #f5f5f5}.control-row {display:flex;gap:12px;margin-bottom:12px;align-items:center}.control-input {padding:12px 16px;border:2px solid #e0e0e0;border-radius:10px;font-size:14px;flex:1;transition:border-color 0.3s ease, box-shadow 0.3s ease;background:white}.control-input:focus {outline:none;border-color:#667eea;box-shadow:0 0 0 3px rgba(102, 126, 234, 0.1)}.control-btn {padding:12px 20px;border:none;border-radius:10px;background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;box-shadow:0 4px 12px rgba(102, 126, 234, 0.2)}.control-btn:hover {transform:translateY(-2px);box-shadow:0 8px 20px rgba(102, 126, 234, 0.3)}.control-btn:active {transform:translateY(0);box-shadow:0 4px 12px rgba(102, 126, 234, 0.2)}.control-btn:disabled {background:#ccc;cursor:not-allowed;transform:none;box-shadow:none}.info-panel {background:white;border-radius:15px;padding:22px;border:1px solid #e0e0e0;margin-top:25px;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);transition:box-shadow 0.3s ease}.info-panel:hover {box-shadow:0 6px 20px rgba(0, 0, 0, 0.08)}.info-panel h4 {margin:0 0 18px 0;color:#333;font-weight:600;font-size:1.1rem;padding-bottom:12px;border-bottom:2px solid #f5f5f5}.info-item {display:flex;justify-content:space-between;margin:8px 0;padding:8px 0;border-bottom:1px solid #f5f5f5;font-size:0.95rem}.info-item:last-child {border-bottom:none}.info-item span:first-child {font-weight:500;color:#666}.info-item span:last-child {font-weight:600;color:#333}.status-display {padding:18px;border-radius:15px;margin:20px 0;font-weight:500;font-size:0.95rem;box-shadow:0 4px 16px rgba(0, 0, 0, 0.08);transition:all 0.3s ease;border:2px solid transparent}.status-normal {background:linear-gradient(145deg, #d4edda, #f0fff0);color:#155724;border-color:#c3e6cb}.status-rotating {background:linear-gradient(145deg, #fff3cd, #fffef0);color:#856404;border-color:#ffeaa7}.status-error {background:linear-gradient(145deg, #f8d7da, #fff5f5);color:#721c24;border-color:#f5c6cb}.theory-section {margin-top:30px;padding:25px;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:15px;border-left:5px solid #667eea;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05)}.theory-section h3 {color:#333;margin-bottom:18px;font-size:1.3rem;font-weight:600}.theory-section p {line-height:1.8;color:#555;margin-bottom:12px;font-size:1rem}.theory-section ul {margin:15px 0;padding-left:20px}.theory-section li {margin-bottom:8px;line-height:1.6;color:#555}.highlight {background:linear-gradient(145deg, #fff3cd, #fffef0);padding:3px 8px;border-radius:5px;font-weight:600;color:#856404}.speed-control {display:flex;align-items:center;gap:12px}.speed-control input[type="range"] {flex:1;height:6px;border-radius:3px;background:#e0e0e0;outline:none;cursor:pointer}.speed-control input[type="range"]::-webkit-slider-thumb {appearance:none;width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;box-shadow:0 2px 6px rgba(102, 126, 234, 0.3)}.speed-control input[type="range"]::-moz-range-thumb {width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;border:none;box-shadow:0 2px 6px rgba(102, 126, 234, 0.3)}.speed-value {background:#667eea;color:white;padding:4px 8px;border-radius:6px;font-size:12px;font-weight:600;min-width:24px;text-align:center}@media (max-width:1400px) {.container {max-width:1400px}.visualization-container {grid-template-columns:1fr 380px;height:750px}}@media (max-width:1200px) {.visualization-container {grid-template-columns:1fr 350px;height:700px}}@media (max-width:992px) {.visualization-container {grid-template-columns:1fr;grid-template-rows:auto auto auto;height:auto}.canvas-container {grid-column:1;grid-row:1;height:500px}.controls-panel {grid-column:1;grid-row:2;height:auto}.rotation-info-panel {grid-column:1;grid-row:3;max-height:350px}}@media (max-width:768px) {body {padding:15px}.knowledge-header h1 {font-size:2.2rem}.main-card {padding:20px}.canvas-container {height:400px;padding:15px}.tree-stats {flex-direction:column;gap:15px}.balance-factors {grid-template-columns:1fr 1fr}.control-row {flex-direction:column;gap:8px}.control-row .control-btn {width:100%}}.fade-in {animation:fadeIn 0.6s ease-out}@keyframes fadeIn {from {opacity:0;transform:translateY(20px)}to {opacity:1;transform:translateY(0)}}</style>
{% endblock %}

{% block content %}
<div class="container"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a> ><span>数据结构</span> ><span>AVL树</span></div><!-- 知识点头部 --><div class="knowledge-header"><h1><span>⚖️</span>
            AVL 自平衡二叉搜索树
        </h1><p>数据结构 - 通过动态可视化深入理解AVL树的平衡机制、旋转操作和实时分析过程</p></div><!-- 主要内容卡片 --><div class="main-card"><!-- 可视化容器 --><div class="visualization-container"><!-- Canvas 画布区域 --><div class="canvas-container"><div class="canvas-header"><div class="canvas-title"><span>🌳</span>
                            AVL树可视化
                        </div><div class="tree-stats"><div class="stat-item"><div class="stat-value" id="nodeCount">0</div><div class="stat-label">节点总数</div></div><div class="stat-item"><div class="stat-value" id="treeHeight">0</div><div class="stat-label">树高度</div></div><div class="stat-item"><div class="stat-value" id="balanceStatus">平衡</div><div class="stat-label">平衡状态</div></div></div></div><canvas id="avlCanvas"></canvas></div><!-- 右侧控制面板 --><div class="controls-panel"><!-- 基本操作 --><div class="control-group"><h3>🎯 基本操作</h3><div class="control-row"><input type="number" id="valueInput" class="control-input" placeholder="输入数值 (1-100)" min="1" max="100"><button id="insertBtn" class="control-btn">插入节点</button></div><div class="control-row"><input type="number" id="deleteInput" class="control-input" placeholder="删除数值" min="1" max="100"><button id="deleteBtn" class="control-btn">删除节点</button></div><div class="control-row"><button id="clearBtn" class="control-btn" style="width: 100%;">清空整棵树</button></div></div><!-- 动画控制 --><div class="control-group"><h3>⚡ 动画控制</h3><div class="control-row"><label style="min-width: 70px;">动画速度:</label><div class="speed-control"><input type="range" id="speedSlider" min="1" max="10" value="5"><span class="speed-value" id="speedValue">5</span></div></div><div class="control-row"><button id="pauseBtn" class="control-btn">暂停/继续</button><button id="stepBtn" class="control-btn">单步执行</button></div></div><!-- 树信息显示 --><div class="info-panel"><h4>📊 操作详情</h4><div class="info-item"><span>插入序列:</span><span id="insertOrder">-</span></div><div class="info-item"><span>旋转次数:</span><span id="rotationCount">0</span></div><div class="info-item"><span>最后操作:</span><span id="lastOperation">无</span></div></div><!-- 状态显示 --><div id="statusDisplay" class="status-display status-normal">
                        🚀 系统就绪 - 开始构建你的AVL树
                    </div></div><!-- 旋转信息面板 --><div class="rotation-info-panel" id="rotationInfoPanel"><div class="new-content-indicator" id="newContentIndicator">新内容</div><div id="rotationInfo"><h3>🔄 平衡分析</h3><p>当插入或删除节点破坏AVL树平衡性时，这里会显示详细的平衡因子分析、旋转类型判断和修复过程...</p></div></div></div><!-- 理论知识部分 --><div class="theory-section"><h3>🧠 AVL树核心原理</h3><p><strong>AVL树</strong>是一种<span class="highlight">自平衡二叉搜索树</span>，由Adelson-Velsky和Landis在1962年发明，是计算机科学中第一个被发明的自平衡二叉搜索树。</p><p><strong>平衡因子定义：</strong>每个节点的平衡因子等于其<span class="highlight">右子树高度减去左子树高度</span>，AVL树要求每个节点的平衡因子只能是-1、0或1，这保证了树的高度始终保持在O(log n)水平。</p><p><strong>四种基本旋转操作：</strong></p><ul><li><strong>左旋转(LL)：</strong>当节点的右子树过高（平衡因子>1）且右子树的平衡因子≥0时执行</li><li><strong>右旋转(RR)：</strong>当节点的左子树过高（平衡因子<-1）且左子树的平衡因子≤0时执行</li><li><strong>左右双旋转(LR)：</strong>先对左子树执行左旋转，再对当前节点执行右旋转</li><li><strong>右左双旋转(RL)：</strong>先对右子树执行右旋转，再对当前节点执行左旋转</li></ul><p><strong>性能优势：</strong>AVL树保证所有基本操作（查找、插入、删除）的时间复杂度都是<span class="highlight">O(log n)</span>，这使得它在需要频繁查询的场景中表现优异。虽然插入和删除操作可能需要进行旋转调整，但旋转操作的时间复杂度是O(1)，因此总体性能依然优秀。</p></div></div></div><script>class AVLNode { constructor(value) { this.value = value; this.left = null; this.right = null; this.height = 1; this.balanceFactor = 0; this.x = 0; this.y = 0; this.targetX = 0; this.targetY = 0; this.animating = false; this.highlight = false; this.color = '#4CAF50'; } } class AVLTreeVisualizer { constructor(canvasId) { this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d'); this.root = null; this.nodeRadius = 28; this.levelHeight = 85; this.animationSpeed = 5; this.isAnimating = false; this.isPaused = false; this.animationQueue = []; this.rotationAnimations = []; this.rotationStep = 0; this.pendingRotation = null; this.rotationCountdown = 0; this.insertOrder = []; this.rotationCount = 0; this.lastOperation = '无'; this.initializeCanvas(); this.setupEventListeners(); this.draw(); } initializeCanvas() { this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas()); } resizeCanvas() { const container = this.canvas.parentElement; const rect = container.getBoundingClientRect(); this.canvas.width = rect.width - 50; this.canvas.height = rect.height - 120; } setupEventListeners() { document.getElementById('insertBtn').addEventListener('click', () => { this.handleInsert(); }); document.getElementById('deleteBtn').addEventListener('click', () => { this.handleDelete(); }); document.getElementById('clearBtn').addEventListener('click', () => { this.clear(); }); document.getElementById('speedSlider').addEventListener('input', (e) => { this.animationSpeed = parseInt(e.target.value); document.getElementById('speedValue').textContent = e.target.value; }); document.getElementById('pauseBtn').addEventListener('click', () => { this.togglePause(); }); document.getElementById('stepBtn').addEventListener('click', () => { this.stepAnimation(); }); document.addEventListener('keypress', (e) => { if (e.key === 'Enter') { const activeElement = document.activeElement; if (activeElement.id === 'valueInput') { this.handleInsert(); } else if (activeElement.id === 'deleteInput') { this.handleDelete(); } } }); } scrollToLatestContent() { const panel = document.getElementById('rotationInfoPanel'); const indicator = document.getElementById('newContentIndicator'); indicator.classList.add('show'); setTimeout(() => { indicator.classList.remove('show'); }, 2000); setTimeout(() => { panel.scrollTo({ top: panel.scrollHeight, behavior: 'smooth' }); }, 100); } addAnimatedContent(htmlContent) { const rotationInfo = document.getElementById('rotationInfo'); const newElement = document.createElement('div'); newElement.className = 'analysis-item'; newElement.innerHTML = htmlContent; rotationInfo.appendChild(newElement); setTimeout(() => { newElement.classList.add('fade-in'); }, 50); newElement.classList.add('highlight-new'); this.scrollToLatestContent(); return newElement; } addProgressiveContent(contentArray, delay = 1500) { contentArray.forEach((content, index) => { setTimeout(() => { this.addAnimatedContent(content); }, index * delay); }); } clearRotationInfo() { const rotationInfo = document.getElementById('rotationInfo'); rotationInfo.innerHTML = ` <h3>🔄 平衡分析</h3><p>当插入或删除节点破坏AVL树平衡性时，这里会显示详细的平衡因子分析、旋转类型判断和修复过程...</p> `; const indicator = document.getElementById('newContentIndicator'); indicator.classList.remove('show'); const panel = document.getElementById('rotationInfoPanel'); panel.scrollTo({ top: 0, behavior: 'smooth' }); } handleInsert() { const value = parseInt(document.getElementById('valueInput').value); if (this.validateInput(value, 'insert')) { this.insert(value); document.getElementById('valueInput').value = ''; } } handleDelete() { const value = parseInt(document.getElementById('deleteInput').value); if (this.validateInput(value, 'delete')) { this.delete(value); document.getElementById('deleteInput').value = ''; } } validateInput(value, operation) { if (!value || value < 1 || value > 100) { this.setStatus('请输入1-100之间的有效数值', 'error'); return false; } if (this.isAnimating) { this.setStatus('请等待当前操作完成', 'error'); return false; } if (operation === 'insert' && this.findNode(this.root, value)) { this.setStatus(`节点 ${value} 已存在`, 'error'); return false; } if (operation === 'delete' && !this.findNode(this.root, value)) { this.setStatus(`节点 ${value} 不存在`, 'error'); return false; } return true; } getHeight(node) { return node ? node.height : 0; } getBalanceFactor(node) { return node ? this.getHeight(node.right) - this.getHeight(node.left) : 0; } updateHeight(node) { if (node) { node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1; node.balanceFactor = this.getBalanceFactor(node); } } rotateRight(node) { const newRoot = node.left; node.left = newRoot.right; newRoot.right = node; this.updateHeight(node); this.updateHeight(newRoot); this.addRotationAnimation('右旋转', node, newRoot, 'right'); return newRoot; } rotateLeft(node) { const newRoot = node.right; node.right = newRoot.left; newRoot.left = node; this.updateHeight(node); this.updateHeight(newRoot); this.addRotationAnimation('左旋转', node, newRoot, 'left'); return newRoot; } insert(value) { this.insertOrder.push(value); this.lastOperation = `插入 ${value}`; this.updateDetailedInfo(); this.setStatus(`🔄 插入节点 ${value}`, 'normal'); this.clearRotationInfo(); this.root = this.insertNodeBST(this.root, value); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { this.analyzeTreeBalance(value); }); } insertNodeBST(node, value) { if (!node) { const newNode = new AVLNode(value); newNode.color = '#4CAF50'; newNode.isNew = true; return newNode; } if (value < node.value) { node.left = this.insertNodeBST(node.left, value); } else if (value > node.value) { node.right = this.insertNodeBST(node.right, value); } else { return node; } this.updateHeight(node); return node; } analyzeTreeBalance(insertedValue) { this.traverseTree(this.root, node => { if (node.isNew) { node.isNew = false; node.color = '#2196F3'; setTimeout(() => { node.color = '#4CAF50'; this.draw(); }, 3000); } }); this.showDetailedBalanceAnalysis(insertedValue); const unbalancedNodes = this.findUnbalancedNodes(this.root); if (unbalancedNodes.length > 0) { this.handleUnbalancedState(unbalancedNodes, insertedValue); } else { this.handleBalancedState(insertedValue); } } handleUnbalancedState(unbalancedNodes, insertedValue) { unbalancedNodes.forEach(node => { node.color = '#F44336'; node.highlight = true; }); this.draw(); const alertHtml = ` <div class="rotation-alert"><h4>⚠️ 检测到不平衡状态！</h4><p><strong>插入节点：</strong>${insertedValue}</p><p><strong>不平衡节点：</strong>${unbalancedNodes.map(n => `${n.value}(${n.balanceFactor})`).join(', ')}</p><p><strong>状态：</strong>树失去AVL平衡特性，需要旋转修复</p></div> `; this.addAnimatedContent(alertHtml); this.setStatus('🔍 检测到不平衡，分析修复方案...', 'rotating'); setTimeout(() => { this.planRotationFix(unbalancedNodes); }, 3000); } handleBalancedState(insertedValue) { const balanceHtml = ` <div class="balance-explanation"><h4>✅ 树保持平衡！</h4><p><strong>插入节点：</strong>${insertedValue}</p><p><strong>状态：</strong>所有节点平衡因子都在[-1, 1]范围内</p><p><strong>结果：</strong>无需旋转，插入操作完成</p></div> `; this.addAnimatedContent(balanceHtml); this.setStatus('✅ 插入完成，树保持平衡', 'normal'); } showDetailedBalanceAnalysis(insertedValue) { let balanceHtml = ` <div class="balance-explanation"><h4>📊 插入节点 ${insertedValue} 后的平衡分析</h4><p><strong>平衡因子计算：</strong>右子树高度 - 左子树高度</p><p><strong>AVL约束：</strong>每个节点的平衡因子必须在 [-1, 0, 1] 范围内</p><div class="balance-factors"> `; const nodeInfos = this.collectNodeInfo(); nodeInfos.forEach(info => { balanceHtml += this.createBalanceItemHTML(info); }); balanceHtml += '</div></div>'; this.addAnimatedContent(balanceHtml); } collectNodeInfo() { const nodeInfos = []; this.traverseTree(this.root, node => { const balance = this.getBalanceFactor(node); const leftHeight = this.getHeight(node.left); const rightHeight = this.getHeight(node.right); const isUnbalanced = Math.abs(balance) > 1; nodeInfos.push({ value: node.value, balance, leftHeight, rightHeight, height: node.height, isUnbalanced, isNew: node.isNew }); }); return nodeInfos.sort((a, b) => a.value - b.value); } createBalanceItemHTML(info) { return ` <div class="balance-item ${info.isUnbalanced ? 'unbalanced' : ''} ${info.isNew ? 'new-node' : ''}"><div><strong>节点 ${info.value}</strong> ${info.isNew ? '(新)' : ''}</div><div>平衡因子: <strong>${info.balance}</strong></div><div style="font-size: 0.8em; color: #666;"> 左高度: ${info.leftHeight}, 右高度: ${info.rightHeight} </div><div style="font-size: 0.8em; color: #666;"> 节点高度: ${info.height} </div></div> `; } planRotationFix(unbalancedNodes) { const targetNode = this.findDeepestUnbalancedNode(this.root); if (!targetNode) return; const rotationPlan = this.determineRotationType(targetNode); this.displayRotationPlan(targetNode, rotationPlan); setTimeout(() => { this.startRotationCountdown(() => { this.executeRotationFix(); }); }, 3500); } determineRotationType(targetNode) { const balance = this.getBalanceFactor(targetNode); let rotationType = ''; let rotationSteps = ''; if (balance < -1) { const leftBalance = this.getBalanceFactor(targetNode.left); if (leftBalance <= 0) { rotationType = '右旋转 (LL Case)'; rotationSteps = `1. 以节点${targetNode.value}为轴心执行右旋转\n2. 节点${targetNode.left.value}成为新的根节点`; } else { rotationType = '左右双旋转 (LR Case)'; rotationSteps = `1. 先对节点${targetNode.left.value}执行左旋转\n2. 再对节点${targetNode.value}执行右旋转`; } } else if (balance > 1) { const rightBalance = this.getBalanceFactor(targetNode.right); if (rightBalance >= 0) { rotationType = '左旋转 (RR Case)'; rotationSteps = `1. 以节点${targetNode.value}为轴心执行左旋转\n2. 节点${targetNode.right.value}成为新的根节点`; } else { rotationType = '右左双旋转 (RL Case)'; rotationSteps = `1. 先对节点${targetNode.right.value}执行右旋转\n2. 再对节点${targetNode.value}执行左旋转`; } } return { rotationType, rotationSteps, balance }; } displayRotationPlan(targetNode, rotationPlan) { const planContent = [ `<div class="rotation-alert"><h4>🔧 旋转修复计划</h4><p><strong>目标节点：</strong>${targetNode.value} (平衡因子: ${rotationPlan.balance})</p><p><strong>旋转类型：</strong>${rotationPlan.rotationType}</p></div>`, `<div class="rotation-alert"><h4>📋 修复步骤详解</h4><pre style="white-space: pre-line; font-size: 0.9em; margin: 5px 0; line-height: 1.4;">${rotationPlan.rotationSteps}</pre></div>`, `<div class="rotation-countdown"><p>即将开始旋转修复操作...</p><div class="countdown-timer" id="countdownTimer">3</div><p>请观察树结构的变化过程</p></div>` ]; this.addProgressiveContent(planContent, 1000); } executeRotationFix() { this.setStatus('🔄 正在执行旋转修复...', 'rotating'); this.rotationCount++; this.lastOperation = '旋转修复'; this.updateDetailedInfo(); this.traverseTree(this.root, node => { node.highlight = false; }); this.root = this.balanceTree(this.root); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { setTimeout(() => { this.showFixResult(); }, 1000); }); } showFixResult() { const unbalancedNodes = this.findUnbalancedNodes(this.root); if (unbalancedNodes.length === 0) { const resultContent = [ `<div class="balance-explanation"><h4>✅ 旋转修复完成！</h4><p><strong>结果：</strong>树已恢复AVL平衡特性</p><p><strong>状态：</strong>所有节点平衡因子都在[-1, 1]范围内</p></div>`, `<div class="balance-explanation"><h4>📈 修复统计</h4><p><strong>修复统计：</strong>本次操作共执行了 ${this.rotationCount} 次旋转</p><p><strong>性能：</strong>AVL树保证了 O(log n) 的操作复杂度</p></div>` ]; this.addProgressiveContent(resultContent, 1000); this.setStatus('✅ 旋转修复完成，树已平衡', 'normal'); setTimeout(() => { this.showDetailedBalanceAnalysis('修复后'); }, 2500); setTimeout(() => { this.clearRotationInfo(); }, 12000); } else { this.setStatus('⚠️ 修复异常，请检查算法实现', 'error'); } } balanceTree(node) { if (!node) return node; node.left = this.balanceTree(node.left); node.right = this.balanceTree(node.right); this.updateHeight(node); const balance = this.getBalanceFactor(node); if (balance < -1 && this.getBalanceFactor(node.left) <= 0) { return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) >= 0) { return this.rotateLeft(node); } if (balance < -1 && this.getBalanceFactor(node.left) > 0) { node.left = this.rotateLeft(node.left); return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) < 0) { node.right = this.rotateRight(node.right); return this.rotateLeft(node); } return node; } findUnbalancedNodes(node) { const unbalanced = []; if (!node) return unbalanced; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) { unbalanced.push(node); } unbalanced.push(...this.findUnbalancedNodes(node.left)); unbalanced.push(...this.findUnbalancedNodes(node.right)); return unbalanced; } findDeepestUnbalancedNode(node) { if (!node) return null; const leftDeepest = this.findDeepestUnbalancedNode(node.left); if (leftDeepest) return leftDeepest; const rightDeepest = this.findDeepestUnbalancedNode(node.right); if (rightDeepest) return rightDeepest; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) { return node; } return null; } delete(value) { this.setStatus(`🗑️ 删除节点 ${value}`, 'rotating'); this.lastOperation = `删除 ${value}`; this.updateDetailedInfo(); this.root = this.deleteNode(this.root, value); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { this.setStatus('✅ 删除完成', 'normal'); }); } deleteNode(node, value) { if (!node) return node; if (value < node.value) { node.left = this.deleteNode(node.left, value); } else if (value > node.value) { node.right = this.deleteNode(node.right, value); } else { if (!node.left || !node.right) { const temp = node.left || node.right; if (!temp) { node = null; } else { Object.assign(node, temp); } } else { const temp = this.getMinValueNode(node.right); node.value = temp.value; node.right = this.deleteNode(node.right, temp.value); } } if (!node) return node; this.updateHeight(node); const balance = this.getBalanceFactor(node); if (balance < -1 && this.getBalanceFactor(node.left) <= 0) { return this.rotateRight(node); } if (balance < -1 && this.getBalanceFactor(node.left) > 0) { node.left = this.rotateLeft(node.left); return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) >= 0) { return this.rotateLeft(node); } if (balance > 1 && this.getBalanceFactor(node.right) < 0) { node.right = this.rotateRight(node.right); return this.rotateLeft(node); } return node; } getMinValueNode(node) { while (node.left) node = node.left; return node; } findNode(node, value) { if (!node) return null; if (value === node.value) return node; if (value < node.value) return this.findNode(node.left, value); return this.findNode(node.right, value); } calculatePositions() { if (!this.root) return; const treeWidth = this.getTreeWidth(this.root); const startX = Math.max((this.canvas.width - treeWidth) / 2 + treeWidth / 2, treeWidth / 2); this.assignPositions(this.root, startX, 60, treeWidth / 2); } getTreeWidth(node) { if (!node) return 0; const nodeCount = this.getNodeCount(node); return Math.max(nodeCount * 70, 300); } getNodeCount(node) { if (!node) return 0; return 1 + this.getNodeCount(node.left) + this.getNodeCount(node.right); } assignPositions(node, x, y, offset) { if (!node) return; node.targetX = x; node.targetY = y; if (node.left) { this.assignPositions(node.left, x - offset, y + this.levelHeight, offset / 2); } if (node.right) { this.assignPositions(node.right, x + offset, y + this.levelHeight, offset / 2); } } startRotationCountdown(callback = null) { this.rotationCountdown = 3; this.isAnimating = true; const countdownInterval = setInterval(() => { const timer = document.getElementById('countdownTimer'); if (timer) { timer.textContent = this.rotationCountdown; timer.classList.add('shake'); setTimeout(() => timer.classList.remove('shake'), 500); } this.rotationCountdown--; if (this.rotationCountdown < 0) { clearInterval(countdownInterval); if (callback) { callback(); } } }, 1000); } addRotationAnimation(type, oldRoot, newRoot, direction) { this.rotationAnimations.push({ type, oldRoot, newRoot, direction, step: 0, maxSteps: 120, startTime: Date.now() }); } animateToPositions(callback = null) { this.isAnimating = true; const animate = () => { if (this.isPaused) { requestAnimationFrame(animate); return; } if (this.rotationAnimations.length > 0) { this.processRotationAnimations(); this.draw(); requestAnimationFrame(animate); return; } let allAtTarget = true; this.traverseTree(this.root, node => { const dx = node.targetX - node.x; const dy = node.targetY - node.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 1) { allAtTarget = false; const speed = this.animationSpeed * 0.025; node.x += dx * speed; node.y += dy * speed; } else { node.x = node.targetX; node.y = node.targetY; } }); this.draw(); if (!allAtTarget) { requestAnimationFrame(animate); } else { this.isAnimating = false; if (callback) callback(); } }; requestAnimationFrame(animate); } processRotationAnimations() { this.rotationAnimations = this.rotationAnimations.filter(animation => { animation.step += 1; const progress = animation.step / animation.maxSteps; if (progress <= 1) { this.updateRotationPositions(animation, progress); const stepText = animation.step <= 40 ? '准备旋转' : animation.step <= 80 ? '执行旋转' : '完成旋转'; this.setStatus(`${animation.type} - ${stepText} (${Math.round(progress * 100)}%)`, 'rotating'); return true; } else { this.calculatePositions(); setTimeout(() => { this.traverseTree(this.root, node => { node.highlight = false; node.color = '#4CAF50'; }); this.draw(); }, 500); return false; } }); } updateRotationPositions(animation, progress) { const { oldRoot, newRoot, direction } = animation; const easeProgress = this.easeInOutQuart(progress); if (!oldRoot.originalX) { oldRoot.originalX = oldRoot.targetX; oldRoot.originalY = oldRoot.targetY; } if (!newRoot.originalX) { newRoot.originalX = newRoot.targetX; newRoot.originalY = newRoot.targetY; } const rotationRadius = 90; const angle = (direction === 'right' ? Math.PI * 0.6 : -Math.PI * 0.6) * easeProgress; oldRoot.highlight = true; newRoot.highlight = true; oldRoot.color = '#FF9800'; newRoot.color = '#4CAF50'; const centerX = (oldRoot.originalX + newRoot.originalX) / 2; const centerY = (oldRoot.originalY + newRoot.originalY) / 2; if (direction === 'right') { oldRoot.x = centerX + rotationRadius * Math.cos(angle); oldRoot.y = centerY + rotationRadius * Math.sin(angle); newRoot.x = centerX - rotationRadius * Math.cos(angle); newRoot.y = centerY - rotationRadius * Math.sin(angle); } else { oldRoot.x = centerX + rotationRadius * Math.cos(angle); oldRoot.y = centerY + rotationRadius * Math.sin(angle); newRoot.x = centerX - rotationRadius * Math.cos(angle); newRoot.y = centerY - rotationRadius * Math.sin(angle); } if (progress >= 1) { delete oldRoot.originalX; delete oldRoot.originalY; delete newRoot.originalX; delete newRoot.originalY; } } easeInOutQuart(t) { return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2; } togglePause() { this.isPaused = !this.isPaused; const btn = document.getElementById('pauseBtn'); btn.textContent = this.isPaused ? '继续动画' : '暂停动画'; if (this.isPaused) { this.setStatus('⏸️ 动画已暂停', 'normal'); } else { this.setStatus('▶️ 动画继续播放', 'normal'); } } stepAnimation() { if (this.isPaused && this.isAnimating) { this.isPaused = false; setTimeout(() => { this.isPaused = true; }, 100); this.setStatus('⏭️ 单步执行中...', 'normal'); } } traverseTree(node, callback) { if (!node) return; callback(node); this.traverseTree(node.left, callback); this.traverseTree(node.right, callback); } draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); if (this.root) { this.drawConnections(this.root); this.drawNodes(this.root); } else { this.drawEmptyState(); } } drawConnections(node) { if (!node) return; this.ctx.strokeStyle = '#888'; this.ctx.lineWidth = 2.5; this.ctx.lineCap = 'round'; if (node.left) { this.ctx.beginPath(); this.ctx.moveTo(node.x, node.y); this.ctx.lineTo(node.left.x, node.left.y); this.ctx.stroke(); this.drawConnections(node.left); } if (node.right) { this.ctx.beginPath(); this.ctx.moveTo(node.x, node.y); this.ctx.lineTo(node.right.x, node.right.y); this.ctx.stroke(); this.drawConnections(node.right); } } drawNodes(node) { if (!node) return; this.ctx.fillStyle = node.color; this.ctx.beginPath(); this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.strokeStyle = node.highlight ? '#FF5722' : '#333'; this.ctx.lineWidth = node.highlight ? 3 : 2; this.ctx.stroke(); this.ctx.fillStyle = 'white'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(node.value.toString(), node.x, node.y); this.ctx.fillStyle = this.getBalanceFactorColor(node.balanceFactor); this.ctx.font = 'bold 12px Arial'; this.ctx.fillText( node.balanceFactor.toString(), node.x + this.nodeRadius + 12, node.y - this.nodeRadius - 5 ); this.drawNodes(node.left); this.drawNodes(node.right); } getBalanceFactorColor(balanceFactor) { if (balanceFactor === 0) return '#4CAF50'; if (Math.abs(balanceFactor) === 1) return '#FF9800'; return '#F44336'; } drawEmptyState() { this.ctx.fillStyle = '#999'; this.ctx.font = '18px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText( '输入数值并点击"插入节点"开始构建AVL树', this.canvas.width / 2, this.canvas.height / 2 ); } updateDetailedInfo() { document.getElementById('insertOrder').textContent = this.insertOrder.length > 0 ? this.insertOrder.join(' → ') : '-'; document.getElementById('rotationCount').textContent = this.rotationCount; document.getElementById('lastOperation').textContent = this.lastOperation; } updateTreeInfo() { const nodeCount = this.getNodeCount(this.root); const height = this.getHeight(this.root); const isBalanced = this.checkBalance(this.root); document.getElementById('nodeCount').textContent = nodeCount; document.getElementById('treeHeight').textContent = height; const balanceStatusEl = document.getElementById('balanceStatus'); balanceStatusEl.textContent = isBalanced ? '平衡' : '不平衡'; balanceStatusEl.style.color = isBalanced ? '#4CAF50' : '#F44336'; } checkBalance(node) { if (!node) return true; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) return false; return this.checkBalance(node.left) && this.checkBalance(node.right); } setStatus(message, type = 'normal') { const statusDiv = document.getElementById('statusDisplay'); statusDiv.textContent = message; statusDiv.className = `status-display status-${type}`; } clear() { this.root = null; this.isAnimating = false; this.isPaused = false; this.animationQueue = []; this.rotationAnimations = []; this.insertOrder = []; this.rotationCount = 0; this.lastOperation = '清空树'; this.updateTreeInfo(); this.updateDetailedInfo(); this.draw(); this.clearRotationInfo(); this.setStatus('🗑️ 树已清空，准备开始新的操作', 'normal'); } } let avlVisualizer; document.addEventListener('DOMContentLoaded', function() { console.log('AVL树可视化系统加载完成'); const card = document.querySelector('.main-card'); if (card) { card.style.opacity = '0'; card.style.transform = 'translateY(30px)'; setTimeout(() => { card.style.transition = 'all 0.8s cubic-bezier(0.4, 0, 0.2, 1)'; card.style.opacity = '1'; card.style.transform = 'translateY(0)'; }, 200); } avlVisualizer = new AVLTreeVisualizer('avlCanvas'); avlVisualizer.updateTreeInfo(); avlVisualizer.clearRotationInfo(); document.getElementById('valueInput').focus(); });</script></div></div>
{% endblock %}