
{% extends 'knowledge_app/base.html' %}

{% block title %}AVLæ ‘å¯è§†åŒ–ç³»ç»Ÿ - è®¡ç®—æœºç§‘å­¦å­¦ä¹ å¹³å°{% endblock %}

{% block extra_css %}
<style>.breadcrumb {color:white;margin-bottom:20px;opacity:0.9}.breadcrumb a {color:white;text-decoration:none}.breadcrumb a:hover {text-decoration:underline}.knowledge-header {background:rgba(255, 255, 255, 0.1);backdrop-filter:blur(10px);border-radius:15px;padding:30px;margin-bottom:30px;color:white;text-align:center;position:relative;z-index:2}.knowledge-header h1 {font-size:2.5rem;margin-bottom:15px;display:flex;align-items:center;justify-content:center;gap:15px}.knowledge-header p {font-size:1.1rem;opacity:0.9;line-height:1.6}.main-card {background:white;border-radius:15px;box-shadow:0 10px 30px rgba(0, 0, 0, 0.1);margin-bottom:30px;overflow:hidden;position:relative;z-index:1;padding:30px}.knowledge-header {background:rgba(255, 255, 255, 0.15);backdrop-filter:blur(20px);border-radius:20px;padding:40px 30px;margin-bottom:30px;color:white;text-align:center;position:relative;border:1px solid rgba(255, 255, 255, 0.2);box-shadow:0 8px 32px rgba(0, 0, 0, 0.1)}.knowledge-header h1 {font-size:2.8rem;margin-bottom:15px;display:flex;align-items:center;justify-content:center;gap:15px;font-weight:700;letter-spacing:-0.5px}.knowledge-header p {font-size:1.2rem;opacity:0.95;line-height:1.6;max-width:600px;margin:0 auto}.main-card {background:white;border-radius:20px;box-shadow:0 20px 60px rgba(0, 0, 0, 0.1);padding:30px;margin-bottom:30px;position:relative;border:1px solid rgba(0, 0, 0, 0.05)}.visualization-container {display:grid;grid-template-columns:1fr 420px;grid-template-rows:1fr auto;gap:30px;height:800px;margin-bottom:30px}.canvas-container {grid-column:1;grid-row:1 / 3;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:20px;padding:25px;border:2px solid #e9ecef;display:flex;flex-direction:column;box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.05)}.canvas-header {display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:20px;border-bottom:2px solid #e9ecef}.canvas-title {font-size:1.4rem;font-weight:700;color:#333;display:flex;align-items:center;gap:12px}.tree-stats {display:flex;gap:25px;font-size:0.9rem}.stat-item {display:flex;flex-direction:column;align-items:center;text-align:center;background:white;padding:12px 16px;border-radius:12px;box-shadow:0 2px 8px rgba(0, 0, 0, 0.05);border:1px solid #f0f0f0;min-width:80px}.stat-value {font-size:1.4rem;font-weight:700;color:#667eea;margin-bottom:4px}.stat-label {font-size:0.8rem;color:#666;font-weight:500}.controls-panel {grid-column:2;grid-row:1;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:20px;padding:25px;border:2px solid #e9ecef;overflow-y:auto;box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.05)}.rotation-info-panel {grid-column:2;grid-row:2;background:white;border-radius:20px;padding:25px;border:2px solid #e9ecef;max-height:280px;overflow-y:auto;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);scroll-behavior:smooth;position:relative}.rotation-info-panel::-webkit-scrollbar {width:8px}.rotation-info-panel::-webkit-scrollbar-track {background:#f1f1f1;border-radius:4px}.rotation-info-panel::-webkit-scrollbar-thumb {background:#667eea;border-radius:4px;opacity:0.7}.rotation-info-panel::-webkit-scrollbar-thumb:hover {background:#5a6fd8}.new-content-indicator {position:absolute;top:10px;right:10px;background:#667eea;color:white;padding:4px 8px;border-radius:12px;font-size:12px;font-weight:600;opacity:0;transform:scale(0.8);transition:all 0.3s ease;z-index:10}.new-content-indicator.show {opacity:1;transform:scale(1)}.analysis-item {transition:all 0.5s ease;transform:translateY(10px);opacity:0}.analysis-item.fade-in {transform:translateY(0);opacity:1}.highlight-new {animation:highlightPulse 2s ease-in-out}@keyframes highlightPulse {0% {box-shadow:0 0 0 0 rgba(102, 126, 234, 0.7)}70% {box-shadow:0 0 0 10px rgba(102, 126, 234, 0)}100% {box-shadow:0 0 0 0 rgba(102, 126, 234, 0)}}.rotation-alert {background:linear-gradient(135deg, #FF6B6B, #FF8E53);color:white;padding:18px;border-radius:15px;margin:15px 0;animation:pulse 2s infinite;border:none;box-shadow:0 6px 20px rgba(255, 107, 107, 0.3)}.rotation-alert h4 {margin:0 0 12px 0;font-size:1.2rem;display:flex;align-items:center;gap:10px;font-weight:600}.rotation-alert p {margin:6px 0;font-size:0.95rem;line-height:1.5}.balance-explanation {background:linear-gradient(145deg, #E3F2FD, #f8f9ff);border:2px solid #2196F3;border-radius:12px;padding:18px;margin:15px 0;box-shadow:0 4px 16px rgba(33, 150, 243, 0.1)}.balance-explanation h4 {color:#1976D2;margin:0 0 12px 0;font-weight:600}.balance-factors {display:grid;grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));gap:12px;margin:15px 0}.balance-item {background:white;padding:12px;border-radius:8px;text-align:center;border:2px solid #e0e0e0;font-size:0.9rem;transition:all 0.3s ease}.balance-item.unbalanced {background:linear-gradient(145deg, #FFEBEE, #fff5f5);border-color:#F44336;color:#C62828;font-weight:600;box-shadow:0 2px 8px rgba(244, 67, 54, 0.2)}.balance-item.new-node {background:linear-gradient(145deg, #E3F2FD, #f0f8ff);border-color:#2196F3;color:#1976D2;font-weight:600;box-shadow:0 2px 8px rgba(33, 150, 243, 0.2)}.rotation-countdown {background:linear-gradient(145deg, #FFF3E0, #fffbf5);border:2px solid #FF9800;border-radius:12px;padding:18px;margin:15px 0;text-align:center;box-shadow:0 4px 16px rgba(255, 152, 0, 0.1)}.countdown-timer {font-size:2.2rem;font-weight:700;color:#E65100;margin:12px 0;text-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}@keyframes pulse {0% {transform:scale(1)}50% {transform:scale(1.02)}100% {transform:scale(1)}}@keyframes shake {0%, 100% {transform:translateX(0)}25% {transform:translateX(-5px)}75% {transform:translateX(5px)}}.shake {animation:shake 0.5s ease-in-out}#avlCanvas {width:100%;flex:1;border:2px solid #e0e0e0;border-radius:15px;background:white;cursor:pointer;box-shadow:0 4px 20px rgba(0, 0, 0, 0.08);transition:box-shadow 0.3s ease}#avlCanvas:hover {box-shadow:0 6px 25px rgba(0, 0, 0, 0.12)}.control-group {margin-bottom:25px;padding:22px;background:white;border-radius:15px;border:1px solid #e0e0e0;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);transition:box-shadow 0.3s ease}.control-group:hover {box-shadow:0 6px 20px rgba(0, 0, 0, 0.08)}.control-group h3 {margin:0 0 20px 0;color:#333;font-size:1.15rem;font-weight:600;padding-bottom:12px;border-bottom:2px solid #f5f5f5}.control-row {display:flex;gap:12px;margin-bottom:12px;align-items:center}.control-input {padding:12px 16px;border:2px solid #e0e0e0;border-radius:10px;font-size:14px;flex:1;transition:border-color 0.3s ease, box-shadow 0.3s ease;background:white}.control-input:focus {outline:none;border-color:#667eea;box-shadow:0 0 0 3px rgba(102, 126, 234, 0.1)}.control-btn {padding:12px 20px;border:none;border-radius:10px;background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;box-shadow:0 4px 12px rgba(102, 126, 234, 0.2)}.control-btn:hover {transform:translateY(-2px);box-shadow:0 8px 20px rgba(102, 126, 234, 0.3)}.control-btn:active {transform:translateY(0);box-shadow:0 4px 12px rgba(102, 126, 234, 0.2)}.control-btn:disabled {background:#ccc;cursor:not-allowed;transform:none;box-shadow:none}.info-panel {background:white;border-radius:15px;padding:22px;border:1px solid #e0e0e0;margin-top:25px;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05);transition:box-shadow 0.3s ease}.info-panel:hover {box-shadow:0 6px 20px rgba(0, 0, 0, 0.08)}.info-panel h4 {margin:0 0 18px 0;color:#333;font-weight:600;font-size:1.1rem;padding-bottom:12px;border-bottom:2px solid #f5f5f5}.info-item {display:flex;justify-content:space-between;margin:8px 0;padding:8px 0;border-bottom:1px solid #f5f5f5;font-size:0.95rem}.info-item:last-child {border-bottom:none}.info-item span:first-child {font-weight:500;color:#666}.info-item span:last-child {font-weight:600;color:#333}.status-display {padding:18px;border-radius:15px;margin:20px 0;font-weight:500;font-size:0.95rem;box-shadow:0 4px 16px rgba(0, 0, 0, 0.08);transition:all 0.3s ease;border:2px solid transparent}.status-normal {background:linear-gradient(145deg, #d4edda, #f0fff0);color:#155724;border-color:#c3e6cb}.status-rotating {background:linear-gradient(145deg, #fff3cd, #fffef0);color:#856404;border-color:#ffeaa7}.status-error {background:linear-gradient(145deg, #f8d7da, #fff5f5);color:#721c24;border-color:#f5c6cb}.theory-section {margin-top:30px;padding:25px;background:linear-gradient(145deg, #f8f9fa, #ffffff);border-radius:15px;border-left:5px solid #667eea;box-shadow:0 4px 16px rgba(0, 0, 0, 0.05)}.theory-section h3 {color:#333;margin-bottom:18px;font-size:1.3rem;font-weight:600}.theory-section p {line-height:1.8;color:#555;margin-bottom:12px;font-size:1rem}.theory-section ul {margin:15px 0;padding-left:20px}.theory-section li {margin-bottom:8px;line-height:1.6;color:#555}.highlight {background:linear-gradient(145deg, #fff3cd, #fffef0);padding:3px 8px;border-radius:5px;font-weight:600;color:#856404}.speed-control {display:flex;align-items:center;gap:12px}.speed-control input[type="range"] {flex:1;height:6px;border-radius:3px;background:#e0e0e0;outline:none;cursor:pointer}.speed-control input[type="range"]::-webkit-slider-thumb {appearance:none;width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;box-shadow:0 2px 6px rgba(102, 126, 234, 0.3)}.speed-control input[type="range"]::-moz-range-thumb {width:18px;height:18px;border-radius:50%;background:#667eea;cursor:pointer;border:none;box-shadow:0 2px 6px rgba(102, 126, 234, 0.3)}.speed-value {background:#667eea;color:white;padding:4px 8px;border-radius:6px;font-size:12px;font-weight:600;min-width:24px;text-align:center}@media (max-width:1400px) {.container {max-width:1400px}.visualization-container {grid-template-columns:1fr 380px;height:750px}}@media (max-width:1200px) {.visualization-container {grid-template-columns:1fr 350px;height:700px}}@media (max-width:992px) {.visualization-container {grid-template-columns:1fr;grid-template-rows:auto auto auto;height:auto}.canvas-container {grid-column:1;grid-row:1;height:500px}.controls-panel {grid-column:1;grid-row:2;height:auto}.rotation-info-panel {grid-column:1;grid-row:3;max-height:350px}}@media (max-width:768px) {body {padding:15px}.knowledge-header h1 {font-size:2.2rem}.main-card {padding:20px}.canvas-container {height:400px;padding:15px}.tree-stats {flex-direction:column;gap:15px}.balance-factors {grid-template-columns:1fr 1fr}.control-row {flex-direction:column;gap:8px}.control-row .control-btn {width:100%}}.fade-in {animation:fadeIn 0.6s ease-out}@keyframes fadeIn {from {opacity:0;transform:translateY(20px)}to {opacity:1;transform:translateY(0)}}</style>
{% endblock %}

{% block content %}
<div class="container"><!-- é¢åŒ…å±‘å¯¼èˆª --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">é¦–é¡µ</a> ><span>æ•°æ®ç»“æ„</span> ><span>AVLæ ‘</span></div><!-- çŸ¥è¯†ç‚¹å¤´éƒ¨ --><div class="knowledge-header"><h1><span>âš–ï¸</span>
            AVL è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘
        </h1><p>æ•°æ®ç»“æ„ - é€šè¿‡åŠ¨æ€å¯è§†åŒ–æ·±å…¥ç†è§£AVLæ ‘çš„å¹³è¡¡æœºåˆ¶ã€æ—‹è½¬æ“ä½œå’Œå®æ—¶åˆ†æè¿‡ç¨‹</p></div><!-- ä¸»è¦å†…å®¹å¡ç‰‡ --><div class="main-card"><!-- å¯è§†åŒ–å®¹å™¨ --><div class="visualization-container"><!-- Canvas ç”»å¸ƒåŒºåŸŸ --><div class="canvas-container"><div class="canvas-header"><div class="canvas-title"><span>ğŸŒ³</span>
                            AVLæ ‘å¯è§†åŒ–
                        </div><div class="tree-stats"><div class="stat-item"><div class="stat-value" id="nodeCount">0</div><div class="stat-label">èŠ‚ç‚¹æ€»æ•°</div></div><div class="stat-item"><div class="stat-value" id="treeHeight">0</div><div class="stat-label">æ ‘é«˜åº¦</div></div><div class="stat-item"><div class="stat-value" id="balanceStatus">å¹³è¡¡</div><div class="stat-label">å¹³è¡¡çŠ¶æ€</div></div></div></div><canvas id="avlCanvas"></canvas></div><!-- å³ä¾§æ§åˆ¶é¢æ¿ --><div class="controls-panel"><!-- åŸºæœ¬æ“ä½œ --><div class="control-group"><h3>ğŸ¯ åŸºæœ¬æ“ä½œ</h3><div class="control-row"><input type="number" id="valueInput" class="control-input" placeholder="è¾“å…¥æ•°å€¼ (1-100)" min="1" max="100"><button id="insertBtn" class="control-btn">æ’å…¥èŠ‚ç‚¹</button></div><div class="control-row"><input type="number" id="deleteInput" class="control-input" placeholder="åˆ é™¤æ•°å€¼" min="1" max="100"><button id="deleteBtn" class="control-btn">åˆ é™¤èŠ‚ç‚¹</button></div><div class="control-row"><button id="clearBtn" class="control-btn" style="width: 100%;">æ¸…ç©ºæ•´æ£µæ ‘</button></div></div><!-- åŠ¨ç”»æ§åˆ¶ --><div class="control-group"><h3>âš¡ åŠ¨ç”»æ§åˆ¶</h3><div class="control-row"><label style="min-width: 70px;">åŠ¨ç”»é€Ÿåº¦:</label><div class="speed-control"><input type="range" id="speedSlider" min="1" max="10" value="5"><span class="speed-value" id="speedValue">5</span></div></div><div class="control-row"><button id="pauseBtn" class="control-btn">æš‚åœ/ç»§ç»­</button><button id="stepBtn" class="control-btn">å•æ­¥æ‰§è¡Œ</button></div></div><!-- æ ‘ä¿¡æ¯æ˜¾ç¤º --><div class="info-panel"><h4>ğŸ“Š æ“ä½œè¯¦æƒ…</h4><div class="info-item"><span>æ’å…¥åºåˆ—:</span><span id="insertOrder">-</span></div><div class="info-item"><span>æ—‹è½¬æ¬¡æ•°:</span><span id="rotationCount">0</span></div><div class="info-item"><span>æœ€åæ“ä½œ:</span><span id="lastOperation">æ— </span></div></div><!-- çŠ¶æ€æ˜¾ç¤º --><div id="statusDisplay" class="status-display status-normal">
                        ğŸš€ ç³»ç»Ÿå°±ç»ª - å¼€å§‹æ„å»ºä½ çš„AVLæ ‘
                    </div></div><!-- æ—‹è½¬ä¿¡æ¯é¢æ¿ --><div class="rotation-info-panel" id="rotationInfoPanel"><div class="new-content-indicator" id="newContentIndicator">æ–°å†…å®¹</div><div id="rotationInfo"><h3>ğŸ”„ å¹³è¡¡åˆ†æ</h3><p>å½“æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹ç ´åAVLæ ‘å¹³è¡¡æ€§æ—¶ï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºè¯¦ç»†çš„å¹³è¡¡å› å­åˆ†æã€æ—‹è½¬ç±»å‹åˆ¤æ–­å’Œä¿®å¤è¿‡ç¨‹...</p></div></div></div><!-- ç†è®ºçŸ¥è¯†éƒ¨åˆ† --><div class="theory-section"><h3>ğŸ§  AVLæ ‘æ ¸å¿ƒåŸç†</h3><p><strong>AVLæ ‘</strong>æ˜¯ä¸€ç§<span class="highlight">è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘</span>ï¼Œç”±Adelson-Velskyå’ŒLandisåœ¨1962å¹´å‘æ˜ï¼Œæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç¬¬ä¸€ä¸ªè¢«å‘æ˜çš„è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚</p><p><strong>å¹³è¡¡å› å­å®šä¹‰ï¼š</strong>æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ç­‰äºå…¶<span class="highlight">å³å­æ ‘é«˜åº¦å‡å»å·¦å­æ ‘é«˜åº¦</span>ï¼ŒAVLæ ‘è¦æ±‚æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­åªèƒ½æ˜¯-1ã€0æˆ–1ï¼Œè¿™ä¿è¯äº†æ ‘çš„é«˜åº¦å§‹ç»ˆä¿æŒåœ¨O(log n)æ°´å¹³ã€‚</p><p><strong>å››ç§åŸºæœ¬æ—‹è½¬æ“ä½œï¼š</strong></p><ul><li><strong>å·¦æ—‹è½¬(LL)ï¼š</strong>å½“èŠ‚ç‚¹çš„å³å­æ ‘è¿‡é«˜ï¼ˆå¹³è¡¡å› å­>1ï¼‰ä¸”å³å­æ ‘çš„å¹³è¡¡å› å­â‰¥0æ—¶æ‰§è¡Œ</li><li><strong>å³æ—‹è½¬(RR)ï¼š</strong>å½“èŠ‚ç‚¹çš„å·¦å­æ ‘è¿‡é«˜ï¼ˆå¹³è¡¡å› å­<-1ï¼‰ä¸”å·¦å­æ ‘çš„å¹³è¡¡å› å­â‰¤0æ—¶æ‰§è¡Œ</li><li><strong>å·¦å³åŒæ—‹è½¬(LR)ï¼š</strong>å…ˆå¯¹å·¦å­æ ‘æ‰§è¡Œå·¦æ—‹è½¬ï¼Œå†å¯¹å½“å‰èŠ‚ç‚¹æ‰§è¡Œå³æ—‹è½¬</li><li><strong>å³å·¦åŒæ—‹è½¬(RL)ï¼š</strong>å…ˆå¯¹å³å­æ ‘æ‰§è¡Œå³æ—‹è½¬ï¼Œå†å¯¹å½“å‰èŠ‚ç‚¹æ‰§è¡Œå·¦æ—‹è½¬</li></ul><p><strong>æ€§èƒ½ä¼˜åŠ¿ï¼š</strong>AVLæ ‘ä¿è¯æ‰€æœ‰åŸºæœ¬æ“ä½œï¼ˆæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ï¼‰çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯<span class="highlight">O(log n)</span>ï¼Œè¿™ä½¿å¾—å®ƒåœ¨éœ€è¦é¢‘ç¹æŸ¥è¯¢çš„åœºæ™¯ä¸­è¡¨ç°ä¼˜å¼‚ã€‚è™½ç„¶æ’å…¥å’Œåˆ é™¤æ“ä½œå¯èƒ½éœ€è¦è¿›è¡Œæ—‹è½¬è°ƒæ•´ï¼Œä½†æ—‹è½¬æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(1)ï¼Œå› æ­¤æ€»ä½“æ€§èƒ½ä¾ç„¶ä¼˜ç§€ã€‚</p></div></div></div><script>class AVLNode { constructor(value) { this.value = value; this.left = null; this.right = null; this.height = 1; this.balanceFactor = 0; this.x = 0; this.y = 0; this.targetX = 0; this.targetY = 0; this.animating = false; this.highlight = false; this.color = '#4CAF50'; } } class AVLTreeVisualizer { constructor(canvasId) { this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d'); this.root = null; this.nodeRadius = 28; this.levelHeight = 85; this.animationSpeed = 5; this.isAnimating = false; this.isPaused = false; this.animationQueue = []; this.rotationAnimations = []; this.rotationStep = 0; this.pendingRotation = null; this.rotationCountdown = 0; this.insertOrder = []; this.rotationCount = 0; this.lastOperation = 'æ— '; this.initializeCanvas(); this.setupEventListeners(); this.draw(); } initializeCanvas() { this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas()); } resizeCanvas() { const container = this.canvas.parentElement; const rect = container.getBoundingClientRect(); this.canvas.width = rect.width - 50; this.canvas.height = rect.height - 120; } setupEventListeners() { document.getElementById('insertBtn').addEventListener('click', () => { this.handleInsert(); }); document.getElementById('deleteBtn').addEventListener('click', () => { this.handleDelete(); }); document.getElementById('clearBtn').addEventListener('click', () => { this.clear(); }); document.getElementById('speedSlider').addEventListener('input', (e) => { this.animationSpeed = parseInt(e.target.value); document.getElementById('speedValue').textContent = e.target.value; }); document.getElementById('pauseBtn').addEventListener('click', () => { this.togglePause(); }); document.getElementById('stepBtn').addEventListener('click', () => { this.stepAnimation(); }); document.addEventListener('keypress', (e) => { if (e.key === 'Enter') { const activeElement = document.activeElement; if (activeElement.id === 'valueInput') { this.handleInsert(); } else if (activeElement.id === 'deleteInput') { this.handleDelete(); } } }); } scrollToLatestContent() { const panel = document.getElementById('rotationInfoPanel'); const indicator = document.getElementById('newContentIndicator'); indicator.classList.add('show'); setTimeout(() => { indicator.classList.remove('show'); }, 2000); setTimeout(() => { panel.scrollTo({ top: panel.scrollHeight, behavior: 'smooth' }); }, 100); } addAnimatedContent(htmlContent) { const rotationInfo = document.getElementById('rotationInfo'); const newElement = document.createElement('div'); newElement.className = 'analysis-item'; newElement.innerHTML = htmlContent; rotationInfo.appendChild(newElement); setTimeout(() => { newElement.classList.add('fade-in'); }, 50); newElement.classList.add('highlight-new'); this.scrollToLatestContent(); return newElement; } addProgressiveContent(contentArray, delay = 1500) { contentArray.forEach((content, index) => { setTimeout(() => { this.addAnimatedContent(content); }, index * delay); }); } clearRotationInfo() { const rotationInfo = document.getElementById('rotationInfo'); rotationInfo.innerHTML = ` <h3>ğŸ”„ å¹³è¡¡åˆ†æ</h3><p>å½“æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹ç ´åAVLæ ‘å¹³è¡¡æ€§æ—¶ï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºè¯¦ç»†çš„å¹³è¡¡å› å­åˆ†æã€æ—‹è½¬ç±»å‹åˆ¤æ–­å’Œä¿®å¤è¿‡ç¨‹...</p> `; const indicator = document.getElementById('newContentIndicator'); indicator.classList.remove('show'); const panel = document.getElementById('rotationInfoPanel'); panel.scrollTo({ top: 0, behavior: 'smooth' }); } handleInsert() { const value = parseInt(document.getElementById('valueInput').value); if (this.validateInput(value, 'insert')) { this.insert(value); document.getElementById('valueInput').value = ''; } } handleDelete() { const value = parseInt(document.getElementById('deleteInput').value); if (this.validateInput(value, 'delete')) { this.delete(value); document.getElementById('deleteInput').value = ''; } } validateInput(value, operation) { if (!value || value < 1 || value > 100) { this.setStatus('è¯·è¾“å…¥1-100ä¹‹é—´çš„æœ‰æ•ˆæ•°å€¼', 'error'); return false; } if (this.isAnimating) { this.setStatus('è¯·ç­‰å¾…å½“å‰æ“ä½œå®Œæˆ', 'error'); return false; } if (operation === 'insert' && this.findNode(this.root, value)) { this.setStatus(`èŠ‚ç‚¹ ${value} å·²å­˜åœ¨`, 'error'); return false; } if (operation === 'delete' && !this.findNode(this.root, value)) { this.setStatus(`èŠ‚ç‚¹ ${value} ä¸å­˜åœ¨`, 'error'); return false; } return true; } getHeight(node) { return node ? node.height : 0; } getBalanceFactor(node) { return node ? this.getHeight(node.right) - this.getHeight(node.left) : 0; } updateHeight(node) { if (node) { node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1; node.balanceFactor = this.getBalanceFactor(node); } } rotateRight(node) { const newRoot = node.left; node.left = newRoot.right; newRoot.right = node; this.updateHeight(node); this.updateHeight(newRoot); this.addRotationAnimation('å³æ—‹è½¬', node, newRoot, 'right'); return newRoot; } rotateLeft(node) { const newRoot = node.right; node.right = newRoot.left; newRoot.left = node; this.updateHeight(node); this.updateHeight(newRoot); this.addRotationAnimation('å·¦æ—‹è½¬', node, newRoot, 'left'); return newRoot; } insert(value) { this.insertOrder.push(value); this.lastOperation = `æ’å…¥ ${value}`; this.updateDetailedInfo(); this.setStatus(`ğŸ”„ æ’å…¥èŠ‚ç‚¹ ${value}`, 'normal'); this.clearRotationInfo(); this.root = this.insertNodeBST(this.root, value); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { this.analyzeTreeBalance(value); }); } insertNodeBST(node, value) { if (!node) { const newNode = new AVLNode(value); newNode.color = '#4CAF50'; newNode.isNew = true; return newNode; } if (value < node.value) { node.left = this.insertNodeBST(node.left, value); } else if (value > node.value) { node.right = this.insertNodeBST(node.right, value); } else { return node; } this.updateHeight(node); return node; } analyzeTreeBalance(insertedValue) { this.traverseTree(this.root, node => { if (node.isNew) { node.isNew = false; node.color = '#2196F3'; setTimeout(() => { node.color = '#4CAF50'; this.draw(); }, 3000); } }); this.showDetailedBalanceAnalysis(insertedValue); const unbalancedNodes = this.findUnbalancedNodes(this.root); if (unbalancedNodes.length > 0) { this.handleUnbalancedState(unbalancedNodes, insertedValue); } else { this.handleBalancedState(insertedValue); } } handleUnbalancedState(unbalancedNodes, insertedValue) { unbalancedNodes.forEach(node => { node.color = '#F44336'; node.highlight = true; }); this.draw(); const alertHtml = ` <div class="rotation-alert"><h4>âš ï¸ æ£€æµ‹åˆ°ä¸å¹³è¡¡çŠ¶æ€ï¼</h4><p><strong>æ’å…¥èŠ‚ç‚¹ï¼š</strong>${insertedValue}</p><p><strong>ä¸å¹³è¡¡èŠ‚ç‚¹ï¼š</strong>${unbalancedNodes.map(n => `${n.value}(${n.balanceFactor})`).join(', ')}</p><p><strong>çŠ¶æ€ï¼š</strong>æ ‘å¤±å»AVLå¹³è¡¡ç‰¹æ€§ï¼Œéœ€è¦æ—‹è½¬ä¿®å¤</p></div> `; this.addAnimatedContent(alertHtml); this.setStatus('ğŸ” æ£€æµ‹åˆ°ä¸å¹³è¡¡ï¼Œåˆ†æä¿®å¤æ–¹æ¡ˆ...', 'rotating'); setTimeout(() => { this.planRotationFix(unbalancedNodes); }, 3000); } handleBalancedState(insertedValue) { const balanceHtml = ` <div class="balance-explanation"><h4>âœ… æ ‘ä¿æŒå¹³è¡¡ï¼</h4><p><strong>æ’å…¥èŠ‚ç‚¹ï¼š</strong>${insertedValue}</p><p><strong>çŠ¶æ€ï¼š</strong>æ‰€æœ‰èŠ‚ç‚¹å¹³è¡¡å› å­éƒ½åœ¨[-1, 1]èŒƒå›´å†…</p><p><strong>ç»“æœï¼š</strong>æ— éœ€æ—‹è½¬ï¼Œæ’å…¥æ“ä½œå®Œæˆ</p></div> `; this.addAnimatedContent(balanceHtml); this.setStatus('âœ… æ’å…¥å®Œæˆï¼Œæ ‘ä¿æŒå¹³è¡¡', 'normal'); } showDetailedBalanceAnalysis(insertedValue) { let balanceHtml = ` <div class="balance-explanation"><h4>ğŸ“Š æ’å…¥èŠ‚ç‚¹ ${insertedValue} åçš„å¹³è¡¡åˆ†æ</h4><p><strong>å¹³è¡¡å› å­è®¡ç®—ï¼š</strong>å³å­æ ‘é«˜åº¦ - å·¦å­æ ‘é«˜åº¦</p><p><strong>AVLçº¦æŸï¼š</strong>æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­å¿…é¡»åœ¨ [-1, 0, 1] èŒƒå›´å†…</p><div class="balance-factors"> `; const nodeInfos = this.collectNodeInfo(); nodeInfos.forEach(info => { balanceHtml += this.createBalanceItemHTML(info); }); balanceHtml += '</div></div>'; this.addAnimatedContent(balanceHtml); } collectNodeInfo() { const nodeInfos = []; this.traverseTree(this.root, node => { const balance = this.getBalanceFactor(node); const leftHeight = this.getHeight(node.left); const rightHeight = this.getHeight(node.right); const isUnbalanced = Math.abs(balance) > 1; nodeInfos.push({ value: node.value, balance, leftHeight, rightHeight, height: node.height, isUnbalanced, isNew: node.isNew }); }); return nodeInfos.sort((a, b) => a.value - b.value); } createBalanceItemHTML(info) { return ` <div class="balance-item ${info.isUnbalanced ? 'unbalanced' : ''} ${info.isNew ? 'new-node' : ''}"><div><strong>èŠ‚ç‚¹ ${info.value}</strong> ${info.isNew ? '(æ–°)' : ''}</div><div>å¹³è¡¡å› å­: <strong>${info.balance}</strong></div><div style="font-size: 0.8em; color: #666;"> å·¦é«˜åº¦: ${info.leftHeight}, å³é«˜åº¦: ${info.rightHeight} </div><div style="font-size: 0.8em; color: #666;"> èŠ‚ç‚¹é«˜åº¦: ${info.height} </div></div> `; } planRotationFix(unbalancedNodes) { const targetNode = this.findDeepestUnbalancedNode(this.root); if (!targetNode) return; const rotationPlan = this.determineRotationType(targetNode); this.displayRotationPlan(targetNode, rotationPlan); setTimeout(() => { this.startRotationCountdown(() => { this.executeRotationFix(); }); }, 3500); } determineRotationType(targetNode) { const balance = this.getBalanceFactor(targetNode); let rotationType = ''; let rotationSteps = ''; if (balance < -1) { const leftBalance = this.getBalanceFactor(targetNode.left); if (leftBalance <= 0) { rotationType = 'å³æ—‹è½¬ (LL Case)'; rotationSteps = `1. ä»¥èŠ‚ç‚¹${targetNode.value}ä¸ºè½´å¿ƒæ‰§è¡Œå³æ—‹è½¬\n2. èŠ‚ç‚¹${targetNode.left.value}æˆä¸ºæ–°çš„æ ¹èŠ‚ç‚¹`; } else { rotationType = 'å·¦å³åŒæ—‹è½¬ (LR Case)'; rotationSteps = `1. å…ˆå¯¹èŠ‚ç‚¹${targetNode.left.value}æ‰§è¡Œå·¦æ—‹è½¬\n2. å†å¯¹èŠ‚ç‚¹${targetNode.value}æ‰§è¡Œå³æ—‹è½¬`; } } else if (balance > 1) { const rightBalance = this.getBalanceFactor(targetNode.right); if (rightBalance >= 0) { rotationType = 'å·¦æ—‹è½¬ (RR Case)'; rotationSteps = `1. ä»¥èŠ‚ç‚¹${targetNode.value}ä¸ºè½´å¿ƒæ‰§è¡Œå·¦æ—‹è½¬\n2. èŠ‚ç‚¹${targetNode.right.value}æˆä¸ºæ–°çš„æ ¹èŠ‚ç‚¹`; } else { rotationType = 'å³å·¦åŒæ—‹è½¬ (RL Case)'; rotationSteps = `1. å…ˆå¯¹èŠ‚ç‚¹${targetNode.right.value}æ‰§è¡Œå³æ—‹è½¬\n2. å†å¯¹èŠ‚ç‚¹${targetNode.value}æ‰§è¡Œå·¦æ—‹è½¬`; } } return { rotationType, rotationSteps, balance }; } displayRotationPlan(targetNode, rotationPlan) { const planContent = [ `<div class="rotation-alert"><h4>ğŸ”§ æ—‹è½¬ä¿®å¤è®¡åˆ’</h4><p><strong>ç›®æ ‡èŠ‚ç‚¹ï¼š</strong>${targetNode.value} (å¹³è¡¡å› å­: ${rotationPlan.balance})</p><p><strong>æ—‹è½¬ç±»å‹ï¼š</strong>${rotationPlan.rotationType}</p></div>`, `<div class="rotation-alert"><h4>ğŸ“‹ ä¿®å¤æ­¥éª¤è¯¦è§£</h4><pre style="white-space: pre-line; font-size: 0.9em; margin: 5px 0; line-height: 1.4;">${rotationPlan.rotationSteps}</pre></div>`, `<div class="rotation-countdown"><p>å³å°†å¼€å§‹æ—‹è½¬ä¿®å¤æ“ä½œ...</p><div class="countdown-timer" id="countdownTimer">3</div><p>è¯·è§‚å¯Ÿæ ‘ç»“æ„çš„å˜åŒ–è¿‡ç¨‹</p></div>` ]; this.addProgressiveContent(planContent, 1000); } executeRotationFix() { this.setStatus('ğŸ”„ æ­£åœ¨æ‰§è¡Œæ—‹è½¬ä¿®å¤...', 'rotating'); this.rotationCount++; this.lastOperation = 'æ—‹è½¬ä¿®å¤'; this.updateDetailedInfo(); this.traverseTree(this.root, node => { node.highlight = false; }); this.root = this.balanceTree(this.root); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { setTimeout(() => { this.showFixResult(); }, 1000); }); } showFixResult() { const unbalancedNodes = this.findUnbalancedNodes(this.root); if (unbalancedNodes.length === 0) { const resultContent = [ `<div class="balance-explanation"><h4>âœ… æ—‹è½¬ä¿®å¤å®Œæˆï¼</h4><p><strong>ç»“æœï¼š</strong>æ ‘å·²æ¢å¤AVLå¹³è¡¡ç‰¹æ€§</p><p><strong>çŠ¶æ€ï¼š</strong>æ‰€æœ‰èŠ‚ç‚¹å¹³è¡¡å› å­éƒ½åœ¨[-1, 1]èŒƒå›´å†…</p></div>`, `<div class="balance-explanation"><h4>ğŸ“ˆ ä¿®å¤ç»Ÿè®¡</h4><p><strong>ä¿®å¤ç»Ÿè®¡ï¼š</strong>æœ¬æ¬¡æ“ä½œå…±æ‰§è¡Œäº† ${this.rotationCount} æ¬¡æ—‹è½¬</p><p><strong>æ€§èƒ½ï¼š</strong>AVLæ ‘ä¿è¯äº† O(log n) çš„æ“ä½œå¤æ‚åº¦</p></div>` ]; this.addProgressiveContent(resultContent, 1000); this.setStatus('âœ… æ—‹è½¬ä¿®å¤å®Œæˆï¼Œæ ‘å·²å¹³è¡¡', 'normal'); setTimeout(() => { this.showDetailedBalanceAnalysis('ä¿®å¤å'); }, 2500); setTimeout(() => { this.clearRotationInfo(); }, 12000); } else { this.setStatus('âš ï¸ ä¿®å¤å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥ç®—æ³•å®ç°', 'error'); } } balanceTree(node) { if (!node) return node; node.left = this.balanceTree(node.left); node.right = this.balanceTree(node.right); this.updateHeight(node); const balance = this.getBalanceFactor(node); if (balance < -1 && this.getBalanceFactor(node.left) <= 0) { return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) >= 0) { return this.rotateLeft(node); } if (balance < -1 && this.getBalanceFactor(node.left) > 0) { node.left = this.rotateLeft(node.left); return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) < 0) { node.right = this.rotateRight(node.right); return this.rotateLeft(node); } return node; } findUnbalancedNodes(node) { const unbalanced = []; if (!node) return unbalanced; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) { unbalanced.push(node); } unbalanced.push(...this.findUnbalancedNodes(node.left)); unbalanced.push(...this.findUnbalancedNodes(node.right)); return unbalanced; } findDeepestUnbalancedNode(node) { if (!node) return null; const leftDeepest = this.findDeepestUnbalancedNode(node.left); if (leftDeepest) return leftDeepest; const rightDeepest = this.findDeepestUnbalancedNode(node.right); if (rightDeepest) return rightDeepest; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) { return node; } return null; } delete(value) { this.setStatus(`ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹ ${value}`, 'rotating'); this.lastOperation = `åˆ é™¤ ${value}`; this.updateDetailedInfo(); this.root = this.deleteNode(this.root, value); this.updateTreeInfo(); this.calculatePositions(); this.animateToPositions(() => { this.setStatus('âœ… åˆ é™¤å®Œæˆ', 'normal'); }); } deleteNode(node, value) { if (!node) return node; if (value < node.value) { node.left = this.deleteNode(node.left, value); } else if (value > node.value) { node.right = this.deleteNode(node.right, value); } else { if (!node.left || !node.right) { const temp = node.left || node.right; if (!temp) { node = null; } else { Object.assign(node, temp); } } else { const temp = this.getMinValueNode(node.right); node.value = temp.value; node.right = this.deleteNode(node.right, temp.value); } } if (!node) return node; this.updateHeight(node); const balance = this.getBalanceFactor(node); if (balance < -1 && this.getBalanceFactor(node.left) <= 0) { return this.rotateRight(node); } if (balance < -1 && this.getBalanceFactor(node.left) > 0) { node.left = this.rotateLeft(node.left); return this.rotateRight(node); } if (balance > 1 && this.getBalanceFactor(node.right) >= 0) { return this.rotateLeft(node); } if (balance > 1 && this.getBalanceFactor(node.right) < 0) { node.right = this.rotateRight(node.right); return this.rotateLeft(node); } return node; } getMinValueNode(node) { while (node.left) node = node.left; return node; } findNode(node, value) { if (!node) return null; if (value === node.value) return node; if (value < node.value) return this.findNode(node.left, value); return this.findNode(node.right, value); } calculatePositions() { if (!this.root) return; const treeWidth = this.getTreeWidth(this.root); const startX = Math.max((this.canvas.width - treeWidth) / 2 + treeWidth / 2, treeWidth / 2); this.assignPositions(this.root, startX, 60, treeWidth / 2); } getTreeWidth(node) { if (!node) return 0; const nodeCount = this.getNodeCount(node); return Math.max(nodeCount * 70, 300); } getNodeCount(node) { if (!node) return 0; return 1 + this.getNodeCount(node.left) + this.getNodeCount(node.right); } assignPositions(node, x, y, offset) { if (!node) return; node.targetX = x; node.targetY = y; if (node.left) { this.assignPositions(node.left, x - offset, y + this.levelHeight, offset / 2); } if (node.right) { this.assignPositions(node.right, x + offset, y + this.levelHeight, offset / 2); } } startRotationCountdown(callback = null) { this.rotationCountdown = 3; this.isAnimating = true; const countdownInterval = setInterval(() => { const timer = document.getElementById('countdownTimer'); if (timer) { timer.textContent = this.rotationCountdown; timer.classList.add('shake'); setTimeout(() => timer.classList.remove('shake'), 500); } this.rotationCountdown--; if (this.rotationCountdown < 0) { clearInterval(countdownInterval); if (callback) { callback(); } } }, 1000); } addRotationAnimation(type, oldRoot, newRoot, direction) { this.rotationAnimations.push({ type, oldRoot, newRoot, direction, step: 0, maxSteps: 120, startTime: Date.now() }); } animateToPositions(callback = null) { this.isAnimating = true; const animate = () => { if (this.isPaused) { requestAnimationFrame(animate); return; } if (this.rotationAnimations.length > 0) { this.processRotationAnimations(); this.draw(); requestAnimationFrame(animate); return; } let allAtTarget = true; this.traverseTree(this.root, node => { const dx = node.targetX - node.x; const dy = node.targetY - node.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 1) { allAtTarget = false; const speed = this.animationSpeed * 0.025; node.x += dx * speed; node.y += dy * speed; } else { node.x = node.targetX; node.y = node.targetY; } }); this.draw(); if (!allAtTarget) { requestAnimationFrame(animate); } else { this.isAnimating = false; if (callback) callback(); } }; requestAnimationFrame(animate); } processRotationAnimations() { this.rotationAnimations = this.rotationAnimations.filter(animation => { animation.step += 1; const progress = animation.step / animation.maxSteps; if (progress <= 1) { this.updateRotationPositions(animation, progress); const stepText = animation.step <= 40 ? 'å‡†å¤‡æ—‹è½¬' : animation.step <= 80 ? 'æ‰§è¡Œæ—‹è½¬' : 'å®Œæˆæ—‹è½¬'; this.setStatus(`${animation.type} - ${stepText} (${Math.round(progress * 100)}%)`, 'rotating'); return true; } else { this.calculatePositions(); setTimeout(() => { this.traverseTree(this.root, node => { node.highlight = false; node.color = '#4CAF50'; }); this.draw(); }, 500); return false; } }); } updateRotationPositions(animation, progress) { const { oldRoot, newRoot, direction } = animation; const easeProgress = this.easeInOutQuart(progress); if (!oldRoot.originalX) { oldRoot.originalX = oldRoot.targetX; oldRoot.originalY = oldRoot.targetY; } if (!newRoot.originalX) { newRoot.originalX = newRoot.targetX; newRoot.originalY = newRoot.targetY; } const rotationRadius = 90; const angle = (direction === 'right' ? Math.PI * 0.6 : -Math.PI * 0.6) * easeProgress; oldRoot.highlight = true; newRoot.highlight = true; oldRoot.color = '#FF9800'; newRoot.color = '#4CAF50'; const centerX = (oldRoot.originalX + newRoot.originalX) / 2; const centerY = (oldRoot.originalY + newRoot.originalY) / 2; if (direction === 'right') { oldRoot.x = centerX + rotationRadius * Math.cos(angle); oldRoot.y = centerY + rotationRadius * Math.sin(angle); newRoot.x = centerX - rotationRadius * Math.cos(angle); newRoot.y = centerY - rotationRadius * Math.sin(angle); } else { oldRoot.x = centerX + rotationRadius * Math.cos(angle); oldRoot.y = centerY + rotationRadius * Math.sin(angle); newRoot.x = centerX - rotationRadius * Math.cos(angle); newRoot.y = centerY - rotationRadius * Math.sin(angle); } if (progress >= 1) { delete oldRoot.originalX; delete oldRoot.originalY; delete newRoot.originalX; delete newRoot.originalY; } } easeInOutQuart(t) { return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2; } togglePause() { this.isPaused = !this.isPaused; const btn = document.getElementById('pauseBtn'); btn.textContent = this.isPaused ? 'ç»§ç»­åŠ¨ç”»' : 'æš‚åœåŠ¨ç”»'; if (this.isPaused) { this.setStatus('â¸ï¸ åŠ¨ç”»å·²æš‚åœ', 'normal'); } else { this.setStatus('â–¶ï¸ åŠ¨ç”»ç»§ç»­æ’­æ”¾', 'normal'); } } stepAnimation() { if (this.isPaused && this.isAnimating) { this.isPaused = false; setTimeout(() => { this.isPaused = true; }, 100); this.setStatus('â­ï¸ å•æ­¥æ‰§è¡Œä¸­...', 'normal'); } } traverseTree(node, callback) { if (!node) return; callback(node); this.traverseTree(node.left, callback); this.traverseTree(node.right, callback); } draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); if (this.root) { this.drawConnections(this.root); this.drawNodes(this.root); } else { this.drawEmptyState(); } } drawConnections(node) { if (!node) return; this.ctx.strokeStyle = '#888'; this.ctx.lineWidth = 2.5; this.ctx.lineCap = 'round'; if (node.left) { this.ctx.beginPath(); this.ctx.moveTo(node.x, node.y); this.ctx.lineTo(node.left.x, node.left.y); this.ctx.stroke(); this.drawConnections(node.left); } if (node.right) { this.ctx.beginPath(); this.ctx.moveTo(node.x, node.y); this.ctx.lineTo(node.right.x, node.right.y); this.ctx.stroke(); this.drawConnections(node.right); } } drawNodes(node) { if (!node) return; this.ctx.fillStyle = node.color; this.ctx.beginPath(); this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.strokeStyle = node.highlight ? '#FF5722' : '#333'; this.ctx.lineWidth = node.highlight ? 3 : 2; this.ctx.stroke(); this.ctx.fillStyle = 'white'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(node.value.toString(), node.x, node.y); this.ctx.fillStyle = this.getBalanceFactorColor(node.balanceFactor); this.ctx.font = 'bold 12px Arial'; this.ctx.fillText( node.balanceFactor.toString(), node.x + this.nodeRadius + 12, node.y - this.nodeRadius - 5 ); this.drawNodes(node.left); this.drawNodes(node.right); } getBalanceFactorColor(balanceFactor) { if (balanceFactor === 0) return '#4CAF50'; if (Math.abs(balanceFactor) === 1) return '#FF9800'; return '#F44336'; } drawEmptyState() { this.ctx.fillStyle = '#999'; this.ctx.font = '18px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText( 'è¾“å…¥æ•°å€¼å¹¶ç‚¹å‡»"æ’å…¥èŠ‚ç‚¹"å¼€å§‹æ„å»ºAVLæ ‘', this.canvas.width / 2, this.canvas.height / 2 ); } updateDetailedInfo() { document.getElementById('insertOrder').textContent = this.insertOrder.length > 0 ? this.insertOrder.join(' â†’ ') : '-'; document.getElementById('rotationCount').textContent = this.rotationCount; document.getElementById('lastOperation').textContent = this.lastOperation; } updateTreeInfo() { const nodeCount = this.getNodeCount(this.root); const height = this.getHeight(this.root); const isBalanced = this.checkBalance(this.root); document.getElementById('nodeCount').textContent = nodeCount; document.getElementById('treeHeight').textContent = height; const balanceStatusEl = document.getElementById('balanceStatus'); balanceStatusEl.textContent = isBalanced ? 'å¹³è¡¡' : 'ä¸å¹³è¡¡'; balanceStatusEl.style.color = isBalanced ? '#4CAF50' : '#F44336'; } checkBalance(node) { if (!node) return true; const balance = Math.abs(this.getBalanceFactor(node)); if (balance > 1) return false; return this.checkBalance(node.left) && this.checkBalance(node.right); } setStatus(message, type = 'normal') { const statusDiv = document.getElementById('statusDisplay'); statusDiv.textContent = message; statusDiv.className = `status-display status-${type}`; } clear() { this.root = null; this.isAnimating = false; this.isPaused = false; this.animationQueue = []; this.rotationAnimations = []; this.insertOrder = []; this.rotationCount = 0; this.lastOperation = 'æ¸…ç©ºæ ‘'; this.updateTreeInfo(); this.updateDetailedInfo(); this.draw(); this.clearRotationInfo(); this.setStatus('ğŸ—‘ï¸ æ ‘å·²æ¸…ç©ºï¼Œå‡†å¤‡å¼€å§‹æ–°çš„æ“ä½œ', 'normal'); } } let avlVisualizer; document.addEventListener('DOMContentLoaded', function() { console.log('AVLæ ‘å¯è§†åŒ–ç³»ç»ŸåŠ è½½å®Œæˆ'); const card = document.querySelector('.main-card'); if (card) { card.style.opacity = '0'; card.style.transform = 'translateY(30px)'; setTimeout(() => { card.style.transition = 'all 0.8s cubic-bezier(0.4, 0, 0.2, 1)'; card.style.opacity = '1'; card.style.transform = 'translateY(0)'; }, 200); } avlVisualizer = new AVLTreeVisualizer('avlCanvas'); avlVisualizer.updateTreeInfo(); avlVisualizer.clearRotationInfo(); document.getElementById('valueInput').focus(); });</script></div></div>
{% endblock %}