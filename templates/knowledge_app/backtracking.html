{% extends 'knowledge_app/base.html' %}

{% block title %}回溯算法 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>算法设计</span><span>></span><span>回溯算法</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🔄</span>
            回溯算法 (Backtracking)
        </h1><p>通过试探和回退来寻找问题解的经典算法思想</p></div><!-- 主要内容 --><div class="content-card slide-in-right"><!-- 算法概述 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🔍</span>
                什么是回溯算法
            </h2><div class="concept-explanation"><p class="concept-intro">
                    回溯算法是一种通过<strong>试探</strong>来寻找问题解的算法。它采用试错的思想，
                    当发现已不满足求解条件时，就"回溯"返回，尝试别的路径。
                </p><div class="key-points"><div class="point-item"><span class="point-icon">🎯</span><div class="point-content"><h4>核心思想</h4><p>在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就"回溯"返回，尝试别的路径</p></div></div><div class="point-item"><span class="point-icon">🔄</span><div class="point-content"><h4>工作方式</h4><p>递归地尝试分步的去解决一个问题，在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算</p></div></div><div class="point-item"><span class="point-icon">⚡</span><div class="point-content"><h4>适用场景</h4><p>组合优化问题、约束满足问题、图的遍历问题等需要穷举搜索的场景</p></div></div></div></div></div><!-- 算法模板 --><div class="content-section"><h2 class="section-title"><span class="section-icon">📝</span>
                算法模板
            </h2><div class="code-example"><div class="code-header"><span class="code-title">回溯算法通用模板</span><button class="copy-btn" onclick="copyCode('backtrack-template')">复制代码</button></div><pre id="backtrack-template"><code class="language-python">def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.append(路径)
        return

    for 选择 in 选择列表:
        # 做选择
        路径.append(选择)

        # 递归
        backtrack(路径, 选择列表)

        # 撤销选择
        路径.pop()

# 使用示例
result = []
backtrack([], 选择列表)</code></pre></div></div><p class="card-description">可视化演示和交互式练习</p></div><div class="grid-card"><span class="card-icon">💡</span><h4 class="card-title">深入理解</h4><p class="card-description">从基础到高级的完整学习路径</p></div></div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
                返回首页
            </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
                探索CS宇宙
            </a><!-- N皇后问题演示 --><div class="content-section"><h2 class="section-title"><span class="section-icon">👑</span>
                N皇后问题演示
            </h2><div class="interactive-demo"><div class="demo-controls"><label>棋盘大小：</label><select id="board-size" onchange="initNQueens()"><option value="4">4×4</option><option value="8" selected>8×8</option></select><button class="demo-btn" onclick="solveNQueens()">开始求解</button><button class="demo-btn" onclick="resetNQueens()">重置</button></div><div id="chess-board" class="chess-board"></div><div class="solution-info"><div class="info-item"><span class="info-label">当前步骤：</span><span id="current-step">0</span></div><div class="info-item"><span class="info-label">回溯次数：</span><span id="backtrack-count">0</span></div><div class="info-item"><span class="info-label">解的数量：</span><span id="solution-count">0</span></div></div></div></div><!-- 算法分析 --><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                算法分析
            </h2><div class="analysis-grid"><div class="analysis-card"><h4 class="analysis-title">时间复杂度</h4><div class="complexity-info"><p><strong>最坏情况：</strong>O(N!)</p><p><strong>平均情况：</strong>取决于剪枝效果</p></div></div><div class="analysis-card"><h4 class="analysis-title">空间复杂度</h4><div class="complexity-info"><p><strong>递归栈：</strong>O(N)</p><p><strong>存储解：</strong>O(解的数量)</p></div></div><div class="analysis-card"><h4 class="analysis-title">应用场景</h4><div class="application-list"><div class="app-item">🧩 组合优化问题</div><div class="app-item">🎮 游戏AI求解</div><div class="app-item">🔍 约束满足问题</div></div></div></div></div></div><!-- 学习提示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">💡</span>
                学习建议
            </h2><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">📚</span><strong>理论学习：</strong>先理解回溯的基本思想和递归结构。
                </div><div class="info-box info-box-success"><span class="info-icon">💻</span><strong>实践练习：</strong>从简单的全排列开始，逐步练习复杂问题。
                </div><div class="info-box info-box-warning"><span class="info-icon">🔄</span><strong>剪枝优化：</strong>学会识别无效分支，提高算法效率。
                </div><div class="info-box info-box-info"><span class="info-icon">🎯</span><strong>模板应用：</strong>掌握回溯算法的通用模板和变形。
                </div></div></div></div></div><style>.interactive-demo {background:#f8f9fa;border-radius:12px;padding:25px;margin:20px 0}.demo-controls {display:flex;align-items:center;gap:15px;margin-bottom:20px;flex-wrap:wrap}.demo-controls label {font-weight:600;color:#333}.demo-controls select {padding:8px 12px;border:1px solid #ddd;border-radius:6px;background:white}.demo-btn {padding:8px 16px;background:#007bff;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:500;transition:all 0.3s ease}.demo-btn:hover {background:#0056b3;transform:translateY(-1px)}.chess-board {display:grid;gap:2px;background:#333;border-radius:8px;padding:10px;margin:20px auto;width:fit-content}.chess-cell {width:40px;height:40px;display:flex;align-items:center;justify-content:center;font-size:24px;cursor:pointer;transition:all 0.3s ease}.chess-cell.white {background:#f0d9b5}.chess-cell.black {background:#b58863}.chess-cell.queen {background:#ff6b6b !important;color:white}.chess-cell.attacking {background:#ffa8a8 !important}.solution-info {display:flex;justify-content:space-around;margin-top:20px;padding:15px;background:white;border-radius:8px;border:1px solid #e9ecef}.info-item {text-align:center}.info-label {display:block;font-size:14px;color:#666;margin-bottom:5px}.info-item span:last-child {font-size:18px;font-weight:600;color:#007bff}.analysis-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:20px;margin:20px 0}.analysis-card {background:#f8f9fa;padding:20px;border-radius:12px;border:1px solid #e9ecef}.analysis-title {color:#333;margin-bottom:15px;font-size:1.2rem}.complexity-info p {margin:8px 0;color:#555}.application-list {display:flex;flex-direction:column;gap:8px}.app-item {padding:8px 12px;background:white;border-radius:6px;color:#555;font-size:14px}@media (max-width:768px) {.demo-controls {flex-direction:column;align-items:stretch}.demo-controls > * {margin-bottom:10px}.chess-cell {width:30px;height:30px;font-size:18px}.solution-info {flex-direction:column;gap:10px}.analysis-grid {grid-template-columns:1fr}}</style><script>let boardSize = 8; let board = []; let solving = false; let stepCount = 0; let backtrackCount = 0; let solutionCount = 0; function initNQueens() { boardSize = parseInt(document.getElementById('board-size').value); board = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); stepCount = 0; backtrackCount = 0; solutionCount = 0; updateDisplay(); renderBoard(); } function renderBoard() { const boardElement = document.getElementById('chess-board'); boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`; boardElement.innerHTML = ''; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { const cell = document.createElement('div'); cell.className = `chess-cell ${(i + j) % 2 === 0 ? 'white' : 'black'}`; cell.id = `cell-${i}-${j}`; if (board[i][j] === 1) { cell.textContent = '♛'; cell.classList.add('queen'); } boardElement.appendChild(cell); } } } function updateDisplay() { document.getElementById('current-step').textContent = stepCount; document.getElementById('backtrack-count').textContent = backtrackCount; document.getElementById('solution-count').textContent = solutionCount; } function isSafe(row, col) { for (let i = 0; i < row; i++) { if (board[i][col] === 1) return false; } for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) { if (board[i][j] === 1) return false; } for (let i = row - 1, j = col + 1; i >= 0 && j < boardSize; i--, j++) { if (board[i][j] === 1) return false; } return true; } async function solveNQueensRecursive(row) { if (row >= boardSize) { solutionCount++; updateDisplay(); return true; } for (let col = 0; col < boardSize; col++) { if (isSafe(row, col)) { board[row][col] = 1; stepCount++; updateDisplay(); renderBoard(); await new Promise(resolve => setTimeout(resolve, 300)); if (await solveNQueensRecursive(row + 1)) { return true; } board[row][col] = 0; backtrackCount++; updateDisplay(); renderBoard(); await new Promise(resolve => setTimeout(resolve, 200)); } } return false; } async function solveNQueens() { if (solving) return; solving = true; resetNQueens(); const success = await solveNQueensRecursive(0); if (success) { alert(`找到解决方案！用了 ${stepCount} 步，回溯 ${backtrackCount} 次`); } else { alert('没有找到解决方案'); } solving = false; } function resetNQueens() { board = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); stepCount = 0; backtrackCount = 0; solutionCount = 0; updateDisplay(); renderBoard(); } function copyCode(elementId) { const codeElement = document.getElementById(elementId); const text = codeElement.textContent; navigator.clipboard.writeText(text).then(() => { alert('代码已复制到剪贴板！'); }).catch(() => { alert('复制失败，请手动复制'); }); } document.addEventListener('DOMContentLoaded', function() { initNQueens(); });</script>

{% endblock %}