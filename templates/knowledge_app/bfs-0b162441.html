
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS) å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 350px 300px;
            height: 100vh;
            gap: 15px;
            padding: 15px;
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
            overflow-y: auto;
        }

        h1 {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .section h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #4ecdc4;
        }

        .algorithm-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }

        .queue-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            min-height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }

        .queue-item {
            display: inline-block;
            background: linear-gradient(45deg, #9b59b6, #3498db);
            color: white;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 15px;
            font-size: 0.8em;
            animation: queueEnqueue 0.3s ease;
        }

        @keyframes queueEnqueue {
            from { transform: translateX(-30px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .visited-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .visited-node {
            background: rgba(78, 205, 196, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            animation: fadeInScale 0.5s ease;
        }

        @keyframes fadeInScale {
            from { transform: scale(0) rotate(180deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .graph-examples {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .example-btn {
            padding: 8px;
            font-size: 0.8em;
            background: rgba(255, 255, 255, 0.2);
        }

        .status-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .status-ready { background: rgba(78, 205, 196, 0.8); }
        .status-running { background: rgba(255, 193, 7, 0.8); }
        .status-completed { background: rgba(40, 167, 69, 0.8); }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
        }

        /* å­˜å‚¨ç»“æ„é¢æ¿æ ·å¼ */
        .storage-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
            overflow-y: auto;
        }

        .storage-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* é‚»æ¥è¡¨æ ·å¼ */
        .adjacency-list {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .list-item {
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .list-item.highlight {
            background: rgba(243, 156, 18, 0.3);
            border-left-color: #f39c12;
            transform: translateX(5px);
        }

        .list-item.visited {
            background: rgba(46, 204, 113, 0.2);
            border-left-color: #2ecc71;
        }

        .node-label {
            color: #4ecdc4;
            font-weight: bold;
        }

        .neighbors {
            color: #ecf0f1;
        }

        .neighbor-node {
            display: inline-block;
            margin: 0 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .neighbor-node.active {
            background: #f39c12;
            color: white;
            transform: scale(1.1);
        }

        .neighbor-node.visited {
            background: #2ecc71;
            color: white;
        }

        .neighbor-node.queued {
            background: #9b59b6;
            color: white;
        }

        /* é‚»æ¥çŸ©é˜µæ ·å¼ */
        .adjacency-matrix {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .matrix-table th,
        .matrix-table td {
            padding: 6px 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .matrix-table th {
            background: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            font-weight: bold;
        }

        .matrix-table td {
            color: #ecf0f1;
        }

        .matrix-table td.highlight {
            background: rgba(243, 156, 18, 0.5);
            color: white;
            transform: scale(1.1);
        }

        .matrix-table td.visited {
            background: rgba(46, 204, 113, 0.3);
        }

        .matrix-explanation {
            margin-top: 10px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 6px;
            font-size: 0.8em;
            border-left: 4px solid #3498db;
        }

        /* ä»£ç è¯­è¨€åˆ‡æ¢æ ·å¼ */
        .language-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .lang-btn {
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
            text-align: center;
        }

        .lang-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .lang-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .code-container {
            position: relative;
        }

        .code-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .code-display .keyword { color: #ff79c6; }
        .code-display .string { color: #f1fa8c; }
        .code-display .comment { color: #6272a4; font-style: italic; }
        .code-display .function { color: #50fa7b; }
        .code-display .type { color: #8be9fd; }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(78, 205, 196, 0.8);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 1);
            transform: translateY(-1px);
        }

        .copy-btn.copied {
            background: rgba(46, 204, 113, 0.9);
        }

        /* ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡†æ ·å¼ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            width: 90%;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }

        .modal-title {
            font-size: 1.8em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .instruction-section {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4ecdc4;
        }

        .instruction-section h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instruction-section p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .instruction-list {
            list-style: none;
            padding: 0;
        }

        .instruction-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
            color: rgba(255,255,255,0.9);
        }

        .instruction-list li::before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #4ecdc4;
            font-weight: bold;
        }

        .highlight-text {
            color: #f39c12;
            font-weight: bold;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .feature-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .feature-item h4 {
            color: #ff6b6b;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .feature-item p {
            font-size: 0.9em;
            margin: 0;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto auto;
            }

            .control-panel, .storage-panel {
                max-height: 300px;
            }

            .language-selector {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                width: 95%;
                padding: 20px;
                max-height: 90vh;
            }

            .modal-title {
                font-size: 1.4em;
            }

            .feature-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .instruction-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-panel">
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>

        <div class="control-panel">
            <h1>ğŸ” BFS ç®—æ³•å¯è§†åŒ–</h1>

            <div class="section">
                <div id="status" class="status-indicator status-ready">
                    å‡†å¤‡å¼€å§‹ - é€‰æ‹©èµ·å§‹èŠ‚ç‚¹
                </div>
            </div>

            <div class="section">
                <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
                <div class="controls">
                    <button id="startBtn" onclick="startBFS()">å¼€å§‹ BFS</button>
                    <button id="pauseBtn" onclick="togglePause()" disabled>æš‚åœ</button>
                    <button id="resetBtn" onclick="resetVisualization()">é‡ç½®</button>
                    <button id="stepBtn" onclick="stepBFS()" disabled>å•æ­¥æ‰§è¡Œ</button>
                </div>

                <div class="speed-control">
                    <span>é€Ÿåº¦:</span>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <button class="full-width" onclick="showInstructions()" style="background: linear-gradient(45deg, #9b59b6, #3498db); margin-top: 10px;">
                    ğŸ“– ä½¿ç”¨è¯´æ˜
                </button>
            </div>

            <div class="section">
                <h3>ğŸ“Š é¢„è®¾å›¾ä¾‹</h3>
                <div class="graph-examples">
                    <button class="example-btn" onclick="loadExample('simple')">ç®€å•å›¾</button>
                    <button class="example-btn" onclick="loadExample('tree')">æ ‘ç»“æ„</button>
                    <button class="example-btn" onclick="loadExample('cycle')">ç¯å½¢å›¾</button>
                    <button class="example-btn" onclick="loadExample('complex')">å¤æ‚å›¾</button>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š BFS é˜Ÿåˆ—</h3>
                <div id="queueDisplay" class="queue-display">
                    é˜Ÿåˆ—ä¸ºç©º
                </div>
            </div>

            <div class="section">
                <h3>âœ… è®¿é—®é¡ºåº</h3>
                <div id="visitedList" class="visited-list">
                    å°šæœªå¼€å§‹
                </div>
            </div>

            <div class="section">
                <h3>ğŸ¨ å›¾ä¾‹</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>æœªè®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>æ­£åœ¨è®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>å·²è®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>èµ·å§‹èŠ‚ç‚¹</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ’» BFS ç®—æ³•ä»£ç </h3>
                <div class="language-selector">
                    <button class="lang-btn active" data-lang="javascript" onclick="changeCodeLanguage('javascript')">JavaScript</button>
                    <button class="lang-btn" data-lang="python" onclick="changeCodeLanguage('python')">Python</button>
                    <button class="lang-btn" data-lang="cpp" onclick="changeCodeLanguage('cpp')">C++</button>
                    <button class="lang-btn" data-lang="java" onclick="changeCodeLanguage('java')">Java</button>
                </div>
                <div class="code-container">
                    <button class="copy-btn" onclick="copyCode()" id="copyBtn">ğŸ“‹ å¤åˆ¶</button>
                    <div id="codeDisplay" class="code-display"></div>
                </div>
            </div>
        </div>

        <div class="storage-panel">
            <h1>ğŸ—ƒï¸ å›¾çš„å­˜å‚¨ç»“æ„</h1>

            <div class="storage-toggle">
                <button class="toggle-btn active" id="listToggle" onclick="showAdjacencyList()">é‚»æ¥è¡¨</button>
                <button class="toggle-btn" id="matrixToggle" onclick="showAdjacencyMatrix()">é‚»æ¥çŸ©é˜µ</button>
            </div>

            <div id="adjacencyListView" class="section">
                <h3>ğŸ“‹ é‚»æ¥è¡¨ (Adjacency List)</h3>
                <div class="adjacency-list" id="adjacencyListContent">
                    é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥è¡¨
                </div>
                <div class="matrix-explanation">
                    ğŸ’¡ é‚»æ¥è¡¨ç”¨é“¾è¡¨å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…ï¼Œç©ºé—´æ•ˆç‡é«˜ï¼Œé€‚åˆç¨€ç–å›¾ã€‚
                </div>
            </div>

            <div id="adjacencyMatrixView" class="section" style="display: none;">
                <h3>ğŸ“Š é‚»æ¥çŸ©é˜µ (Adjacency Matrix)</h3>
                <div class="adjacency-matrix" id="adjacencyMatrixContent">
                    é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥çŸ©é˜µ
                </div>
                <div class="matrix-explanation">
                    ğŸ’¡ é‚»æ¥çŸ©é˜µç”¨äºŒç»´æ•°ç»„å­˜å‚¨ï¼ŒæŸ¥è¯¢è¾¹çš„å­˜åœ¨æ€§ä¸ºO(1)ï¼Œé€‚åˆç¨ å¯†å›¾ã€‚
                </div>
            </div>

            <div class="section">
                <h3>ğŸ” å½“å‰æ“ä½œ</h3>
                <div id="currentOperation" class="algorithm-info">
                    ç­‰å¾…å¼€å§‹BFS...
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š BFS vs DFS å¯¹æ¯”</h3>
                <div class="algorithm-info" style="font-size: 0.75em;">
<strong>å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS):</strong><br>
â€¢ æ•°æ®ç»“æ„: é˜Ÿåˆ— (FIFO)<br>
â€¢ æœç´¢ç­–ç•¥: å±‚æ¬¡éå†<br>
â€¢ æ—¶é—´å¤æ‚åº¦: O(V + E)<br>
â€¢ ç©ºé—´å¤æ‚åº¦: O(V)<br>
â€¢ åº”ç”¨: æœ€çŸ­è·¯å¾„ã€è¿é€šæ€§<br><br>
<strong>æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS):</strong><br>
â€¢ æ•°æ®ç»“æ„: æ ˆ (LIFO)<br>
â€¢ æœç´¢ç­–ç•¥: æ·±åº¦éå†<br>
â€¢ æ—¶é—´å¤æ‚åº¦: O(V + E)<br>
â€¢ ç©ºé—´å¤æ‚åº¦: O(V)<br>
â€¢ åº”ç”¨: æ‹“æ‰‘æ’åºã€ç¯æ£€æµ‹
                </div>
            </div>
        </div>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡† -->
    <div id="instructionModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ğŸ“– BFS å¯è§†åŒ–å·¥å…·ä½¿ç”¨è¯´æ˜</h2>
                <button class="close-btn" onclick="hideInstructions()">Ã—</button>
            </div>

            <div class="instruction-section">
                <h3>ğŸš€ å¿«é€Ÿå¼€å§‹</h3>
                <ul class="instruction-list">
                    <li>é€‰æ‹©ä¸€ä¸ªé¢„è®¾å›¾ä¾‹æˆ–ä¿æŒé»˜è®¤çš„ç®€å•å›¾</li>
                    <li><span class="highlight-text">ç‚¹å‡»ä»»æ„èŠ‚ç‚¹</span>é€‰æ‹©ä¸ºèµ·å§‹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹ä¼šå˜æˆè“è‰²ï¼‰</li>
                    <li>ç‚¹å‡»<span class="highlight-text">"å¼€å§‹ BFS"</span>æŒ‰é’®è§‚çœ‹ç®—æ³•æ‰§è¡Œ</li>
                    <li>ä½¿ç”¨é€Ÿåº¦æ»‘å—è°ƒèŠ‚åŠ¨ç”»é€Ÿåº¦ï¼ˆ1-10çº§ï¼‰</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ® æ§åˆ¶åŠŸèƒ½</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>â–¶ï¸ å¼€å§‹ BFS</h4>
                        <p>å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•çš„è‡ªåŠ¨æ‰§è¡Œ</p>
                    </div>
                    <div class="feature-item">
                        <h4>â¸ï¸ æš‚åœ/ç»§ç»­</h4>
                        <p>æš‚åœæˆ–æ¢å¤æ­£åœ¨æ‰§è¡Œçš„ç®—æ³•åŠ¨ç”»</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ”„ é‡ç½®</h4>
                        <p>æ¸…é™¤æ‰€æœ‰çŠ¶æ€ï¼Œé‡æ–°å¼€å§‹æ¼”ç¤º</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ‘† å•æ­¥æ‰§è¡Œ</h4>
                        <p>é€æ­¥æ‰§è¡Œç®—æ³•ï¼Œæ·±å…¥ç†è§£æ¯ä¸€æ­¥</p>
                    </div>
                </div>
            </div>

            <div class="instruction-section">
                <h3>ğŸ” BFS vs DFS æ ¸å¿ƒå·®å¼‚</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>ğŸŒŠ BFS - å±‚å±‚æ‰©æ•£</h4>
                        <p>åƒæ°´æ³¢ä¸€æ ·å±‚æ¬¡æ‰©æ•£ï¼Œå…ˆè®¿é—®æ‰€æœ‰è·ç¦»ä¸º1çš„èŠ‚ç‚¹ï¼Œå†è®¿é—®è·ç¦»ä¸º2çš„èŠ‚ç‚¹</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ”ï¸ DFS - æ·±åº¦æ¢ç´¢</h4>
                        <p>å°½å¯èƒ½æ·±å…¥åœ°æ¢ç´¢ï¼Œç›´åˆ°æ— è·¯å¯èµ°æ‰å›å¤´</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ“ é˜Ÿåˆ— vs æ ˆ</h4>
                        <p>BFSä½¿ç”¨é˜Ÿåˆ—(å…ˆè¿›å…ˆå‡º)ï¼ŒDFSä½¿ç”¨æ ˆ(åè¿›å…ˆå‡º)</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ¯ åº”ç”¨åœºæ™¯</h4>
                        <p>BFSé€‚åˆæœ€çŸ­è·¯å¾„é—®é¢˜ï¼ŒDFSé€‚åˆæ‹“æ‰‘æ’åºå’Œç¯æ£€æµ‹</p>
                    </div>
                </div>
            </div>

            <div class="instruction-section">
                <h3>ğŸ¨ å¯è§†åŒ–å…ƒç´ </h3>
                <ul class="instruction-list">
                    <li><span style="color: #e74c3c;">â—</span> <span class="highlight-text">çº¢è‰²èŠ‚ç‚¹</span>ï¼šæœªè®¿é—®çš„èŠ‚ç‚¹</li>
                    <li><span style="color: #3498db;">â—</span> <span class="highlight-text">è“è‰²èŠ‚ç‚¹</span>ï¼šé€‰ä¸­çš„èµ·å§‹èŠ‚ç‚¹</li>
                    <li><span style="color: #f39c12;">â—</span> <span class="highlight-text">æ©™è‰²èŠ‚ç‚¹</span>ï¼šæ­£åœ¨è®¿é—®çš„èŠ‚ç‚¹ï¼ˆå¸¦è„‰å†²æ•ˆæœï¼‰</li>
                    <li><span style="color: #2ecc71;">â—</span> <span class="highlight-text">ç»¿è‰²èŠ‚ç‚¹</span>ï¼šå·²è®¿é—®å®Œæˆçš„èŠ‚ç‚¹</li>
                    <li><span style="color: #f39c12;">â¤</span> <span class="highlight-text">æ©™è‰²è¾¹</span>ï¼šå½“å‰æ­£åœ¨éå†çš„è¾¹</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ“š é˜Ÿåˆ—å¯è§†åŒ–</h3>
                <p>ä¸DFSçš„æ ˆä¸åŒï¼ŒBFSä½¿ç”¨é˜Ÿåˆ—æ¥ç®¡ç†å¾…è®¿é—®èŠ‚ç‚¹ï¼š</p>
                <ul class="instruction-list">
                    <li><span class="highlight-text">é˜Ÿå¤´ï¼ˆå·¦ä¾§ï¼‰</span>ï¼šä¸‹ä¸€ä¸ªè¦å¤„ç†çš„èŠ‚ç‚¹</li>
                    <li><span class="highlight-text">é˜Ÿå°¾ï¼ˆå³ä¾§ï¼‰</span>ï¼šæœ€æ–°åŠ å…¥çš„èŠ‚ç‚¹</li>
                    <li><span class="highlight-text">å…ˆè¿›å…ˆå‡º</span>ï¼šä¿è¯æŒ‰è·ç¦»é¡ºåºè®¿é—®</li>
                    <li><span class="highlight-text">å±‚æ¬¡éå†</span>ï¼šåŒä¸€å±‚çš„èŠ‚ç‚¹ä¼šè¿ç»­å¤„ç†</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ—ƒï¸ å­˜å‚¨ç»“æ„</h3>
                <p>åœ¨å³ä¾§é¢æ¿å¯ä»¥åˆ‡æ¢æŸ¥çœ‹ä¸¤ç§å›¾çš„å­˜å‚¨æ–¹å¼ï¼š</p>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>ğŸ“‹ é‚»æ¥è¡¨</h4>
                        <p>æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶é‚»å±…åˆ—è¡¨ï¼ŒBFSä¼šå°†æ‰€æœ‰é‚»å±…åŠ å…¥é˜Ÿåˆ—</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ“Š é‚»æ¥çŸ©é˜µ</h4>
                        <p>äºŒç»´è¡¨æ ¼å­˜å‚¨ï¼Œä¾¿äºå¿«é€ŸæŸ¥è¯¢èŠ‚ç‚¹é—´è¿æ¥å…³ç³»</p>
                    </div>
                </div>
                <p><span class="highlight-text">å®æ—¶é«˜äº®</span>ï¼šç®—æ³•æ‰§è¡Œæ—¶ä¼šé«˜äº®æ˜¾ç¤ºå½“å‰å¤„ç†çš„èŠ‚ç‚¹è¡Œ</p>
            </div>

            <div class="instruction-section">
                <h3>ğŸ’» ä»£ç å­¦ä¹ </h3>
                <p>åº•éƒ¨æä¾›å››ç§ç¼–ç¨‹è¯­è¨€çš„BFSå®ç°ï¼š</p>
                <ul class="instruction-list">
                    <li><span class="highlight-text">JavaScript</span>ï¼šç°ä»£Webå¼€å‘ï¼Œé€‚åˆå‰ç«¯å­¦ä¹ </li>
                    <li><span class="highlight-text">Python</span>ï¼šè¯­æ³•ç®€æ´ï¼Œåˆå­¦è€…å‹å¥½</li>
                    <li><span class="highlight-text">C++</span>ï¼šé«˜æ€§èƒ½å®ç°ï¼Œç®—æ³•ç«èµ›å¸¸ç”¨</li>
                    <li><span class="highlight-text">Java</span>ï¼šä¼ä¸šçº§å¼€å‘ï¼Œé¢å‘å¯¹è±¡</li>
                </ul>
                <p>ç‚¹å‡»<span class="highlight-text">"ğŸ“‹ å¤åˆ¶"</span>æŒ‰é’®å¯ä»¥ä¸€é”®å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿ï¼</p>
            </div>

            <div class="instruction-section">
                <h3>ğŸ’¡ å­¦ä¹ å»ºè®®</h3>
                <ul class="instruction-list">
                    <li><span class="highlight-text">å¯¹æ¯”DFSå’ŒBFS</span>ï¼Œç†è§£ä¸¤ç§æœç´¢ç­–ç•¥çš„å·®å¼‚</li>
                    <li><span class="highlight-text">è§‚å¯Ÿé˜Ÿåˆ—å˜åŒ–</span>ï¼Œç†è§£å…ˆè¿›å…ˆå‡ºçš„åŸç†</li>
                    <li><span class="highlight-text">æ³¨æ„å±‚æ¬¡éå†</span>ï¼ŒBFSä¼šé€å±‚è®¿é—®èŠ‚ç‚¹</li>
                    <li><span class="highlight-text">æ€è€ƒåº”ç”¨åœºæ™¯</span>ï¼Œä»€ä¹ˆæ—¶å€™ç”¨BFSæ›´åˆé€‚</li>
                    <li><span class="highlight-text">æ¯”è¾ƒå­˜å‚¨ç»“æ„</span>ï¼Œä¸åŒç»“æ„å¯¹ç®—æ³•çš„å½±å“</li>
                    <li><span class="highlight-text">ç»ƒä¹ ä»£ç å®ç°</span>ï¼ŒåŠ æ·±å¯¹ç®—æ³•çš„ç†è§£</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ¯ å¸¸è§é—®é¢˜</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>Q: BFSä¸ºä»€ä¹ˆèƒ½æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Ÿ</h4>
                        <p>A: å› ä¸ºBFSæŒ‰å±‚æ¬¡éå†ï¼Œå…ˆåˆ°è¾¾çš„è·¯å¾„å¿…ç„¶æœ€çŸ­</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: é˜Ÿåˆ—å’Œæ ˆçš„åŒºåˆ«ï¼Ÿ</h4>
                        <p>A: é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºï¼Œæ ˆåè¿›å…ˆå‡ºï¼Œå¯¼è‡´ä¸åŒçš„éå†é¡ºåº</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: BFSçš„ç©ºé—´å¤æ‚åº¦ï¼Ÿ</h4>
                        <p>A: æœ€åæƒ…å†µO(V)ï¼Œé˜Ÿåˆ—å¯èƒ½å­˜å‚¨ä¸€æ•´å±‚çš„èŠ‚ç‚¹</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: ä½•æ—¶é€‰æ‹©BFSï¼Ÿ</h4>
                        <p>A: éœ€è¦æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå†æˆ–æœ€å°æ­¥æ•°æ—¶ä¼˜é€‰BFS</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        let graph = {};
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let isRunning = false;
        let isPaused = false;
        let bfsState = {
            visited: new Set(),
            queue: [],
            currentNode: null,
            visitOrder: [],
            step: 0
        };

        let animationSpeed = 1000; // æ¯«ç§’
        let storageView = 'list'; // 'list' or 'matrix'
        let currentLanguage = 'javascript'; // å½“å‰é€‰æ‹©çš„ç¼–ç¨‹è¯­è¨€

        // é˜Ÿåˆ—å¯è§†åŒ–ç›¸å…³
        let queueVisualization = {
            x: 0, // å°†åœ¨resizeCanvasä¸­è®¾ç½®
            y: 50,
            width: 120,
            itemHeight: 40,
            items: [], // {value, x, animating, action} action: 'enqueue' | 'dequeue'
            animations: []
        };

        // å¤šè¯­è¨€BFSä»£ç å®ç°
        const bfsCodeImplementations = {
            javascript: `<span class="comment">// JavaScript å®ç° - æ ‡å‡†é˜Ÿåˆ—ç‰ˆæœ¬</span>
<span class="keyword">function</span> <span class="function">BFS</span>(graph, start) {
    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="type">Set</span>();
    <span class="keyword">let</span> queue = [start];
    <span class="keyword">let</span> result = [];

    <span class="keyword">while</span> (queue.length > <span class="string">0</span>) {
        <span class="keyword">let</span> node = queue.<span class="function">shift</span>(); <span class="comment">// å‡ºé˜Ÿï¼ˆä»å¤´éƒ¨å–ï¼‰</span>

        <span class="keyword">if</span> (!visited.<span class="function">has</span>(node)) {
            visited.<span class="function">add</span>(node);
            result.<span class="function">push</span>(node);

            <span class="comment">// å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</span>
            <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> graph[node]) {
                <span class="keyword">if</span> (!visited.<span class="function">has</span>(neighbor)) {
                    queue.<span class="function">push</span>(neighbor); <span class="comment">// å…¥é˜Ÿï¼ˆä»å°¾éƒ¨åŠ ï¼‰</span>
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}

<span class="comment">// ä½¿ç”¨ç¤ºä¾‹</span>
<span class="keyword">const</span> graph = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],
    <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>],
    <span class="string">'C'</span>: [<span class="string">'A'</span>, <span class="string">'F'</span>],
    <span class="string">'D'</span>: [<span class="string">'B'</span>],
    <span class="string">'E'</span>: [<span class="string">'B'</span>],
    <span class="string">'F'</span>: [<span class="string">'C'</span>]
};
<span class="keyword">const</span> result = <span class="function">BFS</span>(graph, <span class="string">'A'</span>);`,

            python: `<span class="comment"># Python å®ç° - ä½¿ç”¨collections.deque</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> <span class="function">bfs</span>(graph, start):
    visited = <span class="function">set</span>()
    queue = <span class="function">deque</span>([start])  <span class="comment"># åŒç«¯é˜Ÿåˆ—ï¼Œæ•ˆç‡æ›´é«˜</span>
    result = []

    <span class="keyword">while</span> queue:
        node = queue.<span class="function">popleft</span>()  <span class="comment"># å‡ºé˜Ÿï¼ˆä»å·¦ä¾§å–ï¼‰</span>

        <span class="keyword">if</span> node <span class="keyword">not in</span> visited:
            visited.<span class="function">add</span>(node)
            result.<span class="function">append</span>(node)

            <span class="comment"># å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</span>
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    queue.<span class="function">append</span>(neighbor)  <span class="comment"># å…¥é˜Ÿï¼ˆä»å³ä¾§åŠ ï¼‰</span>

    <span class="keyword">return</span> result

<span class="comment"># ä½¿ç”¨ç¤ºä¾‹</span>
graph = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],
    <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>],
    <span class="string">'C'</span>: [<span class="string">'A'</span>, <span class="string">'F'</span>],
    <span class="string">'D'</span>: [<span class="string">'B'</span>],
    <span class="string">'E'</span>: [<span class="string">'B'</span>],
    <span class="string">'F'</span>: [<span class="string">'C'</span>]
}
result = <span class="function">bfs</span>(graph, <span class="string">'A'</span>)
<span class="function">print</span>(result)  <span class="comment"># è¾“å‡º: ['A', 'B', 'C', 'D', 'E', 'F']</span>`,

            cpp: `<span class="comment">// C++ å®ç°</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;queue&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_set&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>

<span class="keyword">using namespace</span> std;

<span class="type">vector</span>&lt;<span class="type">int</span>&gt; <span class="function">BFS</span>(<span class="type">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt;& graph, <span class="type">int</span> start) {
    <span class="type">unordered_set</span>&lt;<span class="type">int</span>&gt; visited;
    <span class="type">queue</span>&lt;<span class="type">int</span>&gt; q;
    <span class="type">vector</span>&lt;<span class="type">int</span>&gt; result;

    q.<span class="function">push</span>(start);

    <span class="keyword">while</span> (!q.<span class="function">empty</span>()) {
        <span class="type">int</span> node = q.<span class="function">front</span>();
        q.<span class="function">pop</span>();  <span class="comment">// å‡ºé˜Ÿ</span>

        <span class="keyword">if</span> (visited.<span class="function">find</span>(node) == visited.<span class="function">end</span>()) {
            visited.<span class="function">insert</span>(node);
            result.<span class="function">push_back</span>(node);

            <span class="comment">// å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</span>
            <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) {
                <span class="keyword">if</span> (visited.<span class="function">find</span>(neighbor) == visited.<span class="function">end</span>()) {
                    q.<span class="function">push</span>(neighbor);  <span class="comment">// å…¥é˜Ÿ</span>
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}

<span class="comment">// ä¸»å‡½æ•°ç¤ºä¾‹</span>
<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt; graph = {
        {<span class="string">1</span>, {<span class="string">2</span>, <span class="string">3</span>}},
        {<span class="string">2</span>, {<span class="string">1</span>, <span class="string">4</span>, <span class="string">5</span>}},
        {<span class="string">3</span>, {<span class="string">1</span>, <span class="string">6</span>}},
        {<span class="string">4</span>, {<span class="string">2</span>}},
        {<span class="string">5</span>, {<span class="string">2</span>}},
        {<span class="string">6</span>, {<span class="string">3</span>}}
    };

    <span class="type">vector</span>&lt;<span class="type">int</span>&gt; result = <span class="function">BFS</span>(graph, <span class="string">1</span>);

    <span class="keyword">for</span> (<span class="type">int</span> node : result) {
        cout &lt;&lt; node &lt;&lt; <span class="string">" "</span>;
    }

    <span class="keyword">return</span> <span class="string">0</span>;
}`,

            java: `<span class="comment">// Java å®ç°</span>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="type">BFSImplementation</span> {

    <span class="keyword">public static</span> <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="function">BFS</span>(<span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; graph, <span class="type">int</span> start) {
        <span class="type">Set</span>&lt;<span class="type">Integer</span>&gt; visited = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;&gt;();
        <span class="type">Queue</span>&lt;<span class="type">Integer</span>&gt; queue = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();
        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();

        queue.<span class="function">offer</span>(start);  <span class="comment">// å…¥é˜Ÿ</span>

        <span class="keyword">while</span> (!queue.<span class="function">isEmpty</span>()) {
            <span class="type">int</span> node = queue.<span class="function">poll</span>();  <span class="comment">// å‡ºé˜Ÿ</span>

            <span class="keyword">if</span> (!visited.<span class="function">contains</span>(node)) {
                visited.<span class="function">add</span>(node);
                result.<span class="function">add</span>(node);

                <span class="comment">// å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</span>
                <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; neighbors = graph.<span class="function">get</span>(node);
                <span class="keyword">if</span> (neighbors != <span class="keyword">null</span>) {
                    <span class="keyword">for</span> (<span class="type">int</span> neighbor : neighbors) {
                        <span class="keyword">if</span> (!visited.<span class="function">contains</span>(neighbor)) {
                            queue.<span class="function">offer</span>(neighbor);  <span class="comment">// å…¥é˜Ÿ</span>
                        }
                    }
                }
            }
        }

        <span class="keyword">return</span> result;
    }

    <span class="comment">// ä¸»å‡½æ•°ç¤ºä¾‹</span>
    <span class="keyword">public static</span> <span class="keyword">void</span> <span class="function">main</span>(<span class="type">String</span>[] args) {
        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; graph = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();
        graph.<span class="function">put</span>(<span class="string">1</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">2</span>, <span class="string">3</span>));
        graph.<span class="function">put</span>(<span class="string">2</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">1</span>, <span class="string">4</span>, <span class="string">5</span>));
        graph.<span class="function">put</span>(<span class="string">3</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">1</span>, <span class="string">6</span>));
        graph.<span class="function">put</span>(<span class="string">4</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">2</span>));
        graph.<span class="function">put</span>(<span class="string">5</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">2</span>));
        graph.<span class="function">put</span>(<span class="string">6</span>, <span class="type">Arrays</span>.<span class="function">asList</span>(<span class="string">3</span>));

        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; result = <span class="function">BFS</span>(graph, <span class="string">1</span>);
        <span class="type">System</span>.out.<span class="function">println</span>(result);
    }
}`
        };

        // è·å–çº¯æ–‡æœ¬ä»£ç ï¼ˆç”¨äºå¤åˆ¶ï¼‰
        const bfsCodePlainText = {
            javascript: `// JavaScript å®ç° - æ ‡å‡†é˜Ÿåˆ—ç‰ˆæœ¬
function BFS(graph, start) {
    let visited = new Set();
    let queue = [start];
    let result = [];

    while (queue.length > 0) {
        let node = queue.shift(); // å‡ºé˜Ÿï¼ˆä»å¤´éƒ¨å–ï¼‰

        if (!visited.has(node)) {
            visited.add(node);
            result.push(node);

            // å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
            for (let neighbor of graph[node]) {
                if (!visited.has(neighbor)) {
                    queue.push(neighbor); // å…¥é˜Ÿï¼ˆä»å°¾éƒ¨åŠ ï¼‰
                }
            }
        }
    }

    return result;
}

// ä½¿ç”¨ç¤ºä¾‹
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B'],
    'F': ['C']
};
const result = BFS(graph, 'A');`,

            python: `# Python å®ç° - ä½¿ç”¨collections.deque
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])  # åŒç«¯é˜Ÿåˆ—ï¼Œæ•ˆç‡æ›´é«˜
    result = []

    while queue:
        node = queue.popleft()  # å‡ºé˜Ÿï¼ˆä»å·¦ä¾§å–ï¼‰

        if node not in visited:
            visited.add(node)
            result.append(node)

            # å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)  # å…¥é˜Ÿï¼ˆä»å³ä¾§åŠ ï¼‰

    return result

# ä½¿ç”¨ç¤ºä¾‹
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B'],
    'F': ['C']
}
result = bfs(graph, 'A')
print(result)  # è¾“å‡º: ['A', 'B', 'C', 'D', 'E', 'F']`,

            cpp: `// C++ å®ç°
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>

using namespace std;

vector<int> BFS(unordered_map<int, vector<int>>& graph, int start) {
    unordered_set<int> visited;
    queue<int> q;
    vector<int> result;

    q.push(start);

    while (!q.empty()) {
        int node = q.front();
        q.pop();  // å‡ºé˜Ÿ

        if (visited.find(node) == visited.end()) {
            visited.insert(node);
            result.push_back(node);

            // å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
            for (int neighbor : graph[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    q.push(neighbor);  // å…¥é˜Ÿ
                }
            }
        }
    }

    return result;
}

// ä¸»å‡½æ•°ç¤ºä¾‹
int main() {
    unordered_map<int, vector<int>> graph = {
        {1, {2, 3}},
        {2, {1, 4, 5}},
        {3, {1, 6}},
        {4, {2}},
        {5, {2}},
        {6, {3}}
    };

    vector<int> result = BFS(graph, 1);

    for (int node : result) {
        cout << node << " ";
    }

    return 0;
}`,

            java: `// Java å®ç°
import java.util.*;

public class BFSImplementation {

    public static List<Integer> BFS(Map<Integer, List<Integer>> graph, int start) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();

        queue.offer(start);  // å…¥é˜Ÿ

        while (!queue.isEmpty()) {
            int node = queue.poll();  // å‡ºé˜Ÿ

            if (!visited.contains(node)) {
                visited.add(node);
                result.add(node);

                // å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
                List<Integer> neighbors = graph.get(node);
                if (neighbors != null) {
                    for (int neighbor : neighbors) {
                        if (!visited.contains(neighbor)) {
                            queue.offer(neighbor);  // å…¥é˜Ÿ
                        }
                    }
                }
            }
        }

        return result;
    }

    // ä¸»å‡½æ•°ç¤ºä¾‹
    public static void main(String[] args) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(1, Arrays.asList(2, 3));
        graph.put(2, Arrays.asList(1, 4, 5));
        graph.put(3, Arrays.asList(1, 6));
        graph.put(4, Arrays.asList(2));
        graph.put(5, Arrays.asList(2));
        graph.put(6, Arrays.asList(3));

        List<Integer> result = BFS(graph, 1);
        System.out.println(result);
    }
}`
        };

        // ç”»å¸ƒè®¾ç½®
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            // è®¾ç½®é˜Ÿåˆ—å¯è§†åŒ–ä½ç½®ï¼ˆå³ä¾§ï¼‰
            queueVisualization.x = rect.width - 150;
            queueVisualization.maxHeight = rect.height - 100;
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.state = 'unvisited'; // unvisited, visiting, visited
                this.visitOrder = -1;
            }

            draw() {
                ctx.save();

                // ç»˜åˆ¶èŠ‚ç‚¹
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // æ ¹æ®çŠ¶æ€è®¾ç½®é¢œè‰²
                let color;
                switch(this.state) {
                    case 'unvisited': color = '#e74c3c'; break;
                    case 'visiting': color = '#f39c12'; break;
                    case 'visited': color = '#2ecc71'; break;
                    case 'start': color = '#3498db'; break;
                }

                if (this.state === 'visiting') {
                    // è„‰å†²æ•ˆæœ
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                }

                ctx.fillStyle = color;
                ctx.fill();

                // è¾¹æ¡†
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();

                // å‘å…‰æ•ˆæœ
                if (this.state === 'visiting' || this.state === 'start') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = color;
                    ctx.fill();
                }

                ctx.restore();

                // ç»˜åˆ¶èŠ‚ç‚¹æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                // ç»˜åˆ¶è®¿é—®é¡ºåº
                if (this.visitOrder >= 0) {
                    ctx.fillStyle = '#ffdc00';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(this.visitOrder + 1, this.x + 20, this.y - 20);
                }
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        // è¾¹ç±»
        class Edge {
            constructor(from, to) {
                this.from = from;
                this.to = to;
                this.isActive = false;
            }

            draw() {
                const fromNode = nodes.find(n => n.id === this.from);
                const toNode = nodes.find(n => n.id === this.to);

                if (!fromNode || !toNode) return;

                ctx.save();

                // è®¡ç®—è¾¹çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆé¿å…ä¸èŠ‚ç‚¹é‡å ï¼‰
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;

                const startX = fromNode.x + unitX * fromNode.radius;
                const startY = fromNode.y + unitY * fromNode.radius;
                const endX = toNode.x - unitX * toNode.radius;
                const endY = toNode.y - unitY * toNode.radius;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);

                if (this.isActive) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f39c12';
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                }

                ctx.stroke();
                ctx.restore();

                // ç»˜åˆ¶ç®­å¤´
                this.drawArrow(endX, endY, Math.atan2(dy, dx));
            }

            drawArrow(x, y, angle) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-15, -8);
                ctx.lineTo(-15, 8);
                ctx.closePath();

                if (this.isActive) {
                    ctx.fillStyle = '#f39c12';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                }
                ctx.fill();

                ctx.restore();
            }
        }

        // ç»˜åˆ¶å‡½æ•°
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            drawGrid();

            // ç»˜åˆ¶è¾¹
            edges.forEach(edge => edge.draw());

            // ç»˜åˆ¶èŠ‚ç‚¹
            nodes.forEach(node => node.draw());

            // ç»˜åˆ¶é˜Ÿåˆ—å¯è§†åŒ–
            drawQueueVisualization();

            requestAnimationFrame(draw);
        }

        function drawGrid() {
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            const gridSize = 30;
            const rect = canvas.getBoundingClientRect();
            const maxX = rect.width - 180; // ç»™é˜Ÿåˆ—ç•™å‡ºç©ºé—´

            for (let x = 0; x < maxX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, rect.height);
                ctx.stroke();
            }

            for (let y = 0; y < rect.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // é˜Ÿåˆ—å¯è§†åŒ–ç»˜åˆ¶å‡½æ•°
        function drawQueueVisualization() {
            const queue = queueVisualization;

            // ç»˜åˆ¶é˜Ÿåˆ—å®¹å™¨èƒŒæ™¯
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.fillRect(queue.x - 10, queue.y - 10, queue.width + 20, queue.maxHeight + 20);
            ctx.strokeRect(queue.x - 10, queue.y - 10, queue.width + 20, queue.maxHeight + 20);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BFS é˜Ÿåˆ—', queue.x + queue.width / 2, queue.y - 20);

            // ç»˜åˆ¶é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡ç¤º
            if (queue.items.length > 0) {
                // é˜Ÿå¤´æŒ‡ç¤º
                ctx.fillStyle = '#f39c12';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('é˜Ÿå¤´ â†’', queue.x - 60, queue.y + 20);

                // é˜Ÿå°¾æŒ‡ç¤º
                const tailY = queue.y + queue.items.length * 50;
                ctx.fillText('é˜Ÿå°¾ â†’', queue.x - 60, Math.min(tailY, queue.y + queue.maxHeight - 20));
            }

            ctx.restore();

            // ç»˜åˆ¶é˜Ÿåˆ—ä¸­çš„å…ƒç´ 
            queue.items.forEach((item, index) => {
                drawQueueItem(item, index);
            });
        }

        function drawQueueItem(item, index) {
            const queue = queueVisualization;
            let y = item.y || (queue.y + index * 50);

            ctx.save();

            // æ ¹æ®åŠ¨ç”»çŠ¶æ€è®¾ç½®é€æ˜åº¦å’Œä½ç½®
            let alpha = 1;
            let x = queue.x + queue.width / 2;

            if (item.animating) {
                if (item.action === 'enqueue') {
                    const progress = (Date.now() - item.animationStart) / 300;
                    alpha = Math.min(1, progress);
                    x = queue.x + queue.width / 2 - (1 - progress) * 50; // ä»å·¦ä¾§æ»‘å…¥
                } else if (item.action === 'dequeue') {
                    const progress = (Date.now() - item.animationStart) / 500;
                    alpha = Math.max(0, 1 - progress);
                    x = queue.x + queue.width / 2 + progress * 50; // å‘å³ä¾§æ»‘å‡º
                }
            }

            ctx.globalAlpha = alpha;

            // ç»˜åˆ¶é˜Ÿåˆ—å…ƒç´ èƒŒæ™¯
            ctx.save();
            ctx.translate(x, y + 25);

            // å…ƒç´ èƒŒæ™¯
            let gradient = ctx.createLinearGradient(-40, -20, 40, 20);
            if (item.action === 'enqueue') {
                gradient.addColorStop(0, '#9b59b6');
                gradient.addColorStop(1, '#3498db');
            } else if (item.action === 'dequeue') {
                gradient.addColorStop(0, '#f39c12');
                gradient.addColorStop(1, '#e74c3c');
            } else {
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(-40, -20, 80, 40);

            // è¾¹æ¡†
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(-40, -20, 80, 40);

            // å‘å…‰æ•ˆæœ
            if (item.animating) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = item.action === 'enqueue' ? '#3498db' : '#f39c12';
                ctx.fillRect(-40, -20, 80, 40);
            }

            ctx.restore();

            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(item.value, x, y + 25);

            ctx.restore();
        }

        // é˜Ÿåˆ—åŠ¨ç”»å‡½æ•°
        function enqueueToVisualization(value) {
            const newItem = {
                value: value,
                animating: true,
                action: 'enqueue',
                animationStart: Date.now()
            };

            queueVisualization.items.push(newItem);

            // åŠ¨ç”»ç»“æŸåç§»é™¤åŠ¨ç”»çŠ¶æ€
            setTimeout(() => {
                newItem.animating = false;
                newItem.action = null;
            }, 300);
        }

        function dequeueFromVisualization() {
            if (queueVisualization.items.length === 0) return null;

            const item = queueVisualization.items[0];
            item.animating = true;
            item.action = 'dequeue';
            item.animationStart = Date.now();

            // åŠ¨ç”»ç»“æŸåç§»é™¤å…ƒç´ 
            setTimeout(() => {
                queueVisualization.items.shift();
            }, 500);

            return item;
        }

        function clearQueueVisualization() {
            queueVisualization.items = [];
        }

        // é¢„è®¾å›¾ä¾‹
        function loadExample(type) {
            resetVisualization();

            switch(type) {
                case 'simple':
                    loadSimpleGraph();
                    break;
                case 'tree':
                    loadTreeGraph();
                    break;
                case 'cycle':
                    loadCycleGraph();
                    break;
                case 'complex':
                    loadComplexGraph();
                    break;
            }
        }

        function loadSimpleGraph() {
            nodes = [
                new Node('A', 100, 100),
                new Node('B', 250, 100),
                new Node('C', 100, 250),
                new Node('D', 250, 250)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'C'),
                new Edge('B', 'D'),
                new Edge('C', 'D')
            ];

            buildGraph();
        }

        function loadTreeGraph() {
            nodes = [
                new Node('A', 200, 80),
                new Node('B', 120, 180),
                new Node('C', 280, 180),
                new Node('D', 70, 280),
                new Node('E', 170, 280),
                new Node('F', 230, 280),
                new Node('G', 330, 280)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'C'),
                new Edge('B', 'D'),
                new Edge('B', 'E'),
                new Edge('C', 'F'),
                new Edge('C', 'G')
            ];

            buildGraph();
        }

        function loadCycleGraph() {
            const centerX = 180;
            const centerY = 180;
            const radius = 80;
            const nodeCount = 6;

            nodes = [];
            edges = [];

            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push(new Node(String.fromCharCode(65 + i), x, y));
            }

            for (let i = 0; i < nodeCount; i++) {
                const from = String.fromCharCode(65 + i);
                const to = String.fromCharCode(65 + (i + 1) % nodeCount);
                edges.push(new Edge(from, to));
            }

            buildGraph();
        }

        function loadComplexGraph() {
            nodes = [
                new Node('A', 100, 100),
                new Node('B', 250, 80),
                new Node('C', 400, 100),
                new Node('D', 150, 200),
                new Node('E', 300, 180),
                new Node('F', 350, 280),
                new Node('G', 200, 300),
                new Node('H', 450, 250)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'D'),
                new Edge('B', 'C'),
                new Edge('B', 'E'),
                new Edge('C', 'E'),
                new Edge('C', 'H'),
                new Edge('D', 'G'),
                new Edge('E', 'F'),
                new Edge('F', 'G'),
                new Edge('F', 'H')
            ];

            buildGraph();
        }

        function buildGraph() {
            graph = {};
            nodes.forEach(node => {
                graph[node.id] = [];
            });

            edges.forEach(edge => {
                if (graph[edge.from]) {
                    graph[edge.from].push(edge.to);
                }
            });

            // æ›´æ–°å­˜å‚¨ç»“æ„æ˜¾ç¤º
            updateStorageStructure();
        }

        // å­˜å‚¨ç»“æ„ç›¸å…³å‡½æ•°
        function showAdjacencyList() {
            storageView = 'list';
            document.getElementById('listToggle').classList.add('active');
            document.getElementById('matrixToggle').classList.remove('active');
            document.getElementById('adjacencyListView').style.display = 'block';
            document.getElementById('adjacencyMatrixView').style.display = 'none';
            updateStorageStructure();
        }

        function showAdjacencyMatrix() {
            storageView = 'matrix';
            document.getElementById('matrixToggle').classList.add('active');
            document.getElementById('listToggle').classList.remove('active');
            document.getElementById('adjacencyListView').style.display = 'none';
            document.getElementById('adjacencyMatrixView').style.display = 'block';
            updateStorageStructure();
        }

        function updateStorageStructure() {
            if (storageView === 'list') {
                updateAdjacencyList();
            } else {
                updateAdjacencyMatrix();
            }
        }

        function updateAdjacencyList() {
            const container = document.getElementById('adjacencyListContent');
            if (nodes.length === 0) {
                container.innerHTML = 'é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥è¡¨';
                return;
            }

            let html = '';
            const sortedNodes = nodes.map(n => n.id).sort();

            sortedNodes.forEach(nodeId => {
                const neighbors = graph[nodeId] || [];
                const isHighlight = bfsState.currentNode === nodeId;
                const isVisited = bfsState.visited.has(nodeId);

                let listItemClass = 'list-item';
                if (isHighlight) listItemClass += ' highlight';
                else if (isVisited) listItemClass += ' visited';

                html += `<div class="${listItemClass}">`;
                html += `<span class="node-label">${nodeId}</span> â†’ `;

                if (neighbors.length === 0) {
                    html += `<span class="neighbors">[ ]</span>`;
                } else {
                    html += `<span class="neighbors">[ `;
                    neighbors.forEach((neighbor, index) => {
                        let neighborClass = 'neighbor-node';
                        if (bfsState.queue.includes(neighbor) && isHighlight) {
                            neighborClass += ' queued';
                        } else if (bfsState.visited.has(neighbor)) {
                            neighborClass += ' visited';
                        }

                        html += `<span class="${neighborClass}">${neighbor}</span>`;
                        if (index < neighbors.length - 1) html += ', ';
                    });
                    html += ` ]</span>`;
                }
                html += '</div>';
            });

            container.innerHTML = html;
        }

        function updateAdjacencyMatrix() {
            const container = document.getElementById('adjacencyMatrixContent');
            if (nodes.length === 0) {
                container.innerHTML = 'é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥çŸ©é˜µ';
                return;
            }

            const sortedNodes = nodes.map(n => n.id).sort();
            const size = sortedNodes.length;

            // æ„å»ºé‚»æ¥çŸ©é˜µ
            const matrix = {};
            sortedNodes.forEach(from => {
                matrix[from] = {};
                sortedNodes.forEach(to => {
                    matrix[from][to] = 0;
                });
            });

            edges.forEach(edge => {
                if (matrix[edge.from] && matrix[edge.from][edge.to] !== undefined) {
                    matrix[edge.from][edge.to] = 1;
                }
            });

            // ç”ŸæˆHTMLè¡¨æ ¼
            let html = '<table class="matrix-table">';

            // è¡¨å¤´
            html += '<tr><th></th>';
            sortedNodes.forEach(nodeId => {
                html += `<th>${nodeId}</th>`;
            });
            html += '</tr>';

            // è¡¨æ ¼å†…å®¹
            sortedNodes.forEach(fromNode => {
                html += `<tr><th>${fromNode}</th>`;
                sortedNodes.forEach(toNode => {
                    const value = matrix[fromNode][toNode];
                    let cellClass = '';

                    if (bfsState.currentNode === fromNode) {
                        cellClass = 'highlight';
                    } else if (bfsState.visited.has(fromNode)) {
                        cellClass = 'visited';
                    }

                    html += `<td class="${cellClass}">${value}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';

            container.innerHTML = html;
        }

        function updateCurrentOperation(operation) {
            document.getElementById('currentOperation').innerHTML = operation;
        }

        // ä»£ç è¯­è¨€åˆ‡æ¢åŠŸèƒ½
        function changeCodeLanguage(language) {
            currentLanguage = language;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === language) {
                    btn.classList.add('active');
                }
            });

            // æ›´æ–°ä»£ç æ˜¾ç¤º
            updateCodeDisplay();
        }

        function updateCodeDisplay() {
            const codeDisplay = document.getElementById('codeDisplay');
            codeDisplay.innerHTML = bfsCodeImplementations[currentLanguage];
        }

        // å¤åˆ¶ä»£ç åŠŸèƒ½
        async function copyCode() {
            const copyBtn = document.getElementById('copyBtn');
            const codeText = bfsCodePlainText[currentLanguage];

            try {
                await navigator.clipboard.writeText(codeText);

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                copyBtn.classList.add('copied');

                // 2ç§’åæ¢å¤åŸçŠ¶
                setTimeout(() => {
                    copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶';
                    copyBtn.classList.remove('copied');
                }, 2000);

            } catch (err) {
                // å¦‚æœclipboard APIä¸å¯ç”¨ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
                fallbackCopyTextToClipboard(codeText);
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                copyBtn.classList.add('copied');

                setTimeout(() => {
                    copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶';
                    copyBtn.classList.remove('copied');
                }, 2000);
            }
        }

        // å¤‡ç”¨å¤åˆ¶æ–¹æ³•
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;

            // é¿å…æ»šåŠ¨åˆ°åº•éƒ¨
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('æ— æ³•å¤åˆ¶ä»£ç ', err);
            }

            document.body.removeChild(textArea);
        }

        // ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡†æ§åˆ¶
        function showInstructions() {
            document.getElementById('instructionModal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
        }

        function hideInstructions() {
            document.getElementById('instructionModal').style.display = 'none';
            document.body.style.overflow = 'auto'; // æ¢å¤æ»šåŠ¨
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('instructionModal');
            if (e.target === modal) {
                hideInstructions();
            }
        });

        // æŒ‰ESCé”®å…³é—­æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideInstructions();
            }
        });

        // BFSç®—æ³•å®ç°
        async function startBFS() {
            if (!selectedNode) {
                updateStatus('è¯·å…ˆç‚¹å‡»é€‰æ‹©èµ·å§‹èŠ‚ç‚¹ï¼', 'ready');
                return;
            }

            isRunning = true;
            isPaused = false;
            updateControls();
            updateStatus('BFS æ‰§è¡Œä¸­...', 'running');

            // åˆå§‹åŒ–çŠ¶æ€
            bfsState = {
                visited: new Set(),
                queue: [selectedNode.id],
                currentNode: null,
                visitOrder: [],
                step: 0
            };

            selectedNode.state = 'start';

            // åˆå§‹åŒ–é˜Ÿåˆ—å¯è§†åŒ–
            clearQueueVisualization();
            enqueueToVisualization(selectedNode.id);

            updateQueueDisplay();
            updateCurrentOperation(`
                <div style="padding: 15px; background: rgba(52, 152, 219, 0.3); border-radius: 10px; border-left: 5px solid #3498db;">
                    <h4 style="color: #3498db; margin: 0 0 10px 0;">ğŸš€ BFSç®—æ³•å¼€å§‹ï¼</h4>
                    <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px; margin-bottom: 8px;">
                        <strong>èµ·å§‹èŠ‚ç‚¹ï¼š</strong><span style="color: #f39c12; font-size: 1.1em;">${selectedNode.id}</span>
                    </div>
                    <p style="margin: 0; font-size: 0.9em;">ğŸ“¥ <strong>åˆå§‹åŒ–ï¼š</strong>å°†èµ·å§‹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—</p>
                    <p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.9;">ğŸ’¡ BFSä½¿ç”¨é˜Ÿåˆ—ç¡®ä¿æŒ‰è·ç¦»å±‚æ¬¡è®¿é—®èŠ‚ç‚¹</p>
                </div>
            `);
            updateStorageStructure();

            await sleep(500); // ç»™ä¸€ç‚¹æ—¶é—´æ˜¾ç¤ºåˆå§‹çŠ¶æ€

            // æ‰§è¡ŒBFS
            await executeBFS();
        }

        async function executeBFS() {
            while (bfsState.queue.length > 0 && isRunning) {
                if (isPaused) {
                    await new Promise(resolve => {
                        const checkPause = () => {
                            if (!isPaused || !isRunning) {
                                resolve();
                            } else {
                                setTimeout(checkPause, 100);
                            }
                        };
                        checkPause();
                    });
                }

                if (!isRunning) break;

                await stepBFSInternal();
                await sleep(animationSpeed);
            }

            if (isRunning) {
                updateStatus('BFS å®Œæˆï¼', 'completed');
                updateCurrentOperation(`
                    <div style="padding: 15px; background: rgba(39, 174, 96, 0.3); border-radius: 10px; border-left: 5px solid #27ae60;">
                        <h4 style="color: #27ae60; margin: 0 0 10px 0;">ğŸ‰ BFSéå†å®Œæˆï¼</h4>
                        <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px; margin-bottom: 8px;">
                            <strong>è®¿é—®é¡ºåºï¼š</strong><span style="color: #f39c12;">[${bfsState.visitOrder.join(' â†’ ')}]</span>
                        </div>
                        <p style="margin: 0; font-size: 0.9em;">âœ… æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹éƒ½å·²æŒ‰å±‚æ¬¡é¡ºåºè®¿é—®å®Œæ¯•</p>
                        <p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.9;">ğŸ“Š æ€»å…±è®¿é—®äº† ${bfsState.visitOrder.length} ä¸ªèŠ‚ç‚¹</p>
                    </div>
                `);
                isRunning = false;
                updateControls();
            }
        }

        async function stepBFSInternal() {
            if (bfsState.queue.length === 0) return false;

            const nodeId = bfsState.queue.shift(); // å‡ºé˜Ÿï¼ˆä»é˜Ÿå¤´å–ï¼‰
            const node = nodes.find(n => n.id === nodeId);

            // é˜Ÿåˆ—å¯è§†åŒ–å‡ºé˜ŸåŠ¨ç”»
            dequeueFromVisualization();

            updateCurrentOperation(`
                <div style="padding: 10px; background: rgba(52, 152, 219, 0.2); border-radius: 8px; margin-bottom: 10px;">
                    <h4 style="color: #3498db; margin: 0 0 8px 0;">ğŸ” ç¬¬${bfsState.step + 1}æ­¥ï¼šå‡ºé˜Ÿæ“ä½œ</h4>
                    <p style="margin: 0; font-size: 0.9em;">ä»é˜Ÿåˆ—<strong>é˜Ÿå¤´</strong>å–å‡ºèŠ‚ç‚¹ <strong style="color: #f39c12;">${nodeId}</strong></p>
                    <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">ğŸ’¡ BFSä½¿ç”¨é˜Ÿåˆ—ï¼šå…ˆè¿›å…ˆå‡ºï¼Œä¿è¯æŒ‰è·ç¦»å±‚æ¬¡è®¿é—®</p>
                </div>
            `);
            updateStorageStructure();

            await sleep(animationSpeed / 2);

            if (!bfsState.visited.has(nodeId)) {
                updateCurrentOperation(`
                    <div style="padding: 10px; background: rgba(46, 204, 113, 0.2); border-radius: 8px; margin-bottom: 10px;">
                        <h4 style="color: #2ecc71; margin: 0 0 8px 0;">âœ… è®¿é—®æ–°èŠ‚ç‚¹</h4>
                        <p style="margin: 0; font-size: 0.9em;">æ­£åœ¨è®¿é—®èŠ‚ç‚¹ <strong style="color: #f39c12;">${nodeId}</strong>ï¼ˆç¬¬${bfsState.visitOrder.length + 1}ä¸ªè®¿é—®çš„èŠ‚ç‚¹ï¼‰</p>
                        <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">ğŸ“ å°†èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è®¿é—®ï¼ŒåŠ å…¥è®¿é—®åºåˆ—</p>
                    </div>
                `);

                // è®¿é—®èŠ‚ç‚¹
                bfsState.visited.add(nodeId);
                bfsState.visitOrder.push(nodeId);
                bfsState.currentNode = nodeId;

                if (node.state !== 'start') {
                    node.state = 'visiting';
                }
                node.visitOrder = bfsState.visitOrder.length - 1;

                // æ›´æ–°æ˜¾ç¤º
                updateQueueDisplay();
                updateVisitedList();
                updateStorageStructure();

                await sleep(animationSpeed / 2);

                // æ·»åŠ é‚»å±…åˆ°é˜Ÿåˆ—ä¸­
                const neighbors = graph[nodeId] || [];
                if (neighbors.length > 0) {
                    updateCurrentOperation(`
                        <div style="padding: 10px; background: rgba(155, 89, 182, 0.2); border-radius: 8px; margin-bottom: 10px;">
                            <h4 style="color: #9b59b6; margin: 0 0 8px 0;">ğŸ” æŸ¥æ‰¾é‚»å±…èŠ‚ç‚¹</h4>
                            <p style="margin: 0; font-size: 0.9em;">èŠ‚ç‚¹ <strong>${nodeId}</strong> çš„é‚»å±…æœ‰ï¼š<strong style="color: #e67e22;">[${neighbors.join(', ')}]</strong></p>
                            <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">ğŸ¯ å‡†å¤‡å°†æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</p>
                        </div>
                    `);
                } else {
                    updateCurrentOperation(`
                        <div style="padding: 10px; background: rgba(149, 165, 166, 0.2); border-radius: 8px; margin-bottom: 10px;">
                            <h4 style="color: #95a5a6; margin: 0 0 8px 0;">ğŸ“­ æ²¡æœ‰é‚»å±…</h4>
                            <p style="margin: 0; font-size: 0.9em;">èŠ‚ç‚¹ <strong>${nodeId}</strong> æ²¡æœ‰è¿æ¥çš„é‚»å±…èŠ‚ç‚¹</p>
                            <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">â­ï¸ ç»§ç»­å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹</p>
                        </div>
                    `);
                }

                await sleep(animationSpeed / 3);

                const unvisitedNeighbors = [];
                const alreadyInQueue = [];
                const alreadyVisited = [];

                for (let neighbor of neighbors) {
                    if (bfsState.visited.has(neighbor)) {
                        alreadyVisited.push(neighbor);
                    } else if (bfsState.queue.includes(neighbor)) {
                        alreadyInQueue.push(neighbor);
                    } else {
                        unvisitedNeighbors.push(neighbor);
                        bfsState.queue.push(neighbor); // å…¥é˜Ÿï¼ˆä»é˜Ÿå°¾åŠ ï¼‰

                        // é˜Ÿåˆ—å¯è§†åŒ–å…¥é˜ŸåŠ¨ç”»
                        enqueueToVisualization(neighbor);

                        // é«˜äº®è¾¹
                        const edge = edges.find(e => e.from === nodeId && e.to === neighbor);
                        if (edge) {
                            edge.isActive = true;
                            setTimeout(() => {
                                edge.isActive = false;
                            }, animationSpeed);
                        }

                        await sleep(animationSpeed / 4);
                    }
                }

                // è¯¦ç»†è¯´æ˜é‚»å±…å¤„ç†ç»“æœ
                let neighborSummary = `
                    <div style="padding: 10px; background: rgba(52, 73, 94, 0.2); border-radius: 8px; margin-bottom: 10px;">
                        <h4 style="color: #34495e; margin: 0 0 8px 0;">ğŸ“Š é‚»å±…å¤„ç†ç»“æœ</h4>
                `;

                if (unvisitedNeighbors.length > 0) {
                    neighborSummary += `<p style="margin: 0; font-size: 0.9em;">ğŸ†• æ–°åŠ å…¥é˜Ÿåˆ—ï¼š<strong style="color: #2ecc71;">[${unvisitedNeighbors.join(', ')}]</strong></p>`;
                }
                if (alreadyVisited.length > 0) {
                    neighborSummary += `<p style="margin: 0; font-size: 0.9em;">âœ… å·²è®¿é—®è¿‡ï¼š<strong style="color: #95a5a6;">[${alreadyVisited.join(', ')}]</strong></p>`;
                }
                if (alreadyInQueue.length > 0) {
                    neighborSummary += `<p style="margin: 0; font-size: 0.9em;">â³ å·²åœ¨é˜Ÿåˆ—ä¸­ï¼š<strong style="color: #f39c12;">[${alreadyInQueue.join(', ')}]</strong></p>`;
                }

                neighborSummary += `<p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.8;">ğŸ’¡ BFSåªå°†æœªè®¿é—®ä¸”ä¸åœ¨é˜Ÿåˆ—ä¸­çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—</p>`;
                neighborSummary += `</div>`;

                updateCurrentOperation(neighborSummary);

                await sleep(animationSpeed / 2);

                if (node.state !== 'start') {
                    node.state = 'visited';
                }

                updateCurrentOperation(`
                    <div style="padding: 10px; background: rgba(39, 174, 96, 0.2); border-radius: 8px; margin-bottom: 10px;">
                        <h4 style="color: #27ae60; margin: 0 0 8px 0;">âœ¨ èŠ‚ç‚¹å¤„ç†å®Œæˆ</h4>
                        <p style="margin: 0; font-size: 0.9em;">èŠ‚ç‚¹ <strong>${nodeId}</strong> å¤„ç†å®Œæ¯•ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®</p>
                        <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">ğŸ“ˆ å½“å‰é˜Ÿåˆ—é•¿åº¦ï¼š${bfsState.queue.length}ï¼Œå·²è®¿é—®èŠ‚ç‚¹ï¼š${bfsState.visited.size}</p>
                    </div>
                `);

                bfsState.step++;
            } else {
                updateCurrentOperation(`
                    <div style="padding: 10px; background: rgba(230, 126, 34, 0.2); border-radius: 8px; margin-bottom: 10px;">
                        <h4 style="color: #e67e22; margin: 0 0 8px 0;">âš ï¸ èŠ‚ç‚¹å·²è®¿é—®</h4>
                        <p style="margin: 0; font-size: 0.9em;">èŠ‚ç‚¹ <strong>${nodeId}</strong> ä¹‹å‰å·²ç»è®¿é—®è¿‡äº†</p>
                        <p style="margin: 0; font-size: 0.8em; opacity: 0.8;">â­ï¸ è·³è¿‡æ­¤èŠ‚ç‚¹ï¼Œç»§ç»­å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ª</p>
                    </div>
                `);
            }

            updateQueueDisplay();
            updateStorageStructure();
            return true;
        }

        function stepBFS() {
            if (isRunning && !isPaused) return;

            if (!selectedNode) {
                updateStatus('è¯·å…ˆé€‰æ‹©èµ·å§‹èŠ‚ç‚¹ï¼', 'ready');
                return;
            }

            if (bfsState.queue.length === 0 && bfsState.visitOrder.length === 0) {
                // åˆå§‹åŒ–
                bfsState = {
                    visited: new Set(),
                    queue: [selectedNode.id],
                    currentNode: null,
                    visitOrder: [],
                    step: 0
                };
                selectedNode.state = 'start';

                // åˆå§‹åŒ–é˜Ÿåˆ—å¯è§†åŒ–
                clearQueueVisualization();
                enqueueToVisualization(selectedNode.id);

                updateQueueDisplay();
                updateCurrentOperation(`
                    <div style="padding: 15px; background: rgba(155, 89, 182, 0.3); border-radius: 10px; border-left: 5px solid #9b59b6;">
                        <h4 style="color: #9b59b6; margin: 0 0 10px 0;">ğŸ‘† å•æ­¥æ¨¡å¼å¯åŠ¨</h4>
                        <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px; margin-bottom: 8px;">
                            <strong>èµ·å§‹èŠ‚ç‚¹ï¼š</strong><span style="color: #f39c12; font-size: 1.1em;">${selectedNode.id}</span>
                        </div>
                        <p style="margin: 0; font-size: 0.9em;">ğŸ“¥ <strong>å‡†å¤‡ï¼š</strong>èµ·å§‹èŠ‚ç‚¹å·²åŠ å…¥é˜Ÿåˆ—</p>
                        <p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.9;">ğŸ® ç‚¹å‡»"å•æ­¥æ‰§è¡Œ"æŸ¥çœ‹æ¯ä¸€æ­¥çš„è¯¦ç»†è¿‡ç¨‹</p>
                    </div>
                `);
                updateStorageStructure();
                updateStatus('å•æ­¥æ¨¡å¼ - æŒ‰ä¸‹"å•æ­¥æ‰§è¡Œ"ç»§ç»­', 'running');
            } else {
                stepBFSInternal();
                if (bfsState.queue.length === 0) {
                    updateStatus('BFS å®Œæˆï¼', 'completed');
                    updateCurrentOperation(`
                        <div style="padding: 15px; background: rgba(39, 174, 96, 0.3); border-radius: 10px; border-left: 5px solid #27ae60;">
                            <h4 style="color: #27ae60; margin: 0 0 10px 0;">ğŸ‰ å•æ­¥æ¨¡å¼ - BFSå®Œæˆï¼</h4>
                            <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px; margin-bottom: 8px;">
                                <strong>æœ€ç»ˆè®¿é—®é¡ºåºï¼š</strong><span style="color: #f39c12;">[${bfsState.visitOrder.join(' â†’ ')}]</span>
                            </div>
                            <p style="margin: 0; font-size: 0.9em;">âœ… é˜Ÿåˆ—ä¸ºç©ºï¼Œæ‰€æœ‰å¯è¾¾èŠ‚ç‚¹éƒ½å·²è®¿é—®</p>
                            <p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.9;">ğŸ”„ ç‚¹å‡»"é‡ç½®"å¼€å§‹æ–°çš„æ¼”ç¤º</p>
                        </div>
                    `);
                }
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';

            if (!isPaused && isRunning) {
                executeBFS();
            }
        }

        function resetVisualization() {
            isRunning = false;
            isPaused = false;
            selectedNode = null;

            // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
            nodes.forEach(node => {
                node.state = 'unvisited';
                node.visitOrder = -1;
            });

            // é‡ç½®æ‰€æœ‰è¾¹çŠ¶æ€
            edges.forEach(edge => {
                edge.isActive = false;
            });

            // é‡ç½®BFSçŠ¶æ€
            bfsState = {
                visited: new Set(),
                queue: [],
                currentNode: null,
                visitOrder: [],
                step: 0
            };

            // æ¸…ç©ºé˜Ÿåˆ—å¯è§†åŒ–
            clearQueueVisualization();

            updateControls();
            updateQueueDisplay();
            updateVisitedList();
            updateStorageStructure();
            updateCurrentOperation('ç­‰å¾…å¼€å§‹BFS...');
            updateStatus('å‡†å¤‡å¼€å§‹ - é€‰æ‹©èµ·å§‹èŠ‚ç‚¹', 'ready');
        }

        // UIæ›´æ–°å‡½æ•°
        function updateControls() {
            document.getElementById('startBtn').disabled = isRunning || !selectedNode;
            document.getElementById('pauseBtn').disabled = !isRunning;
            document.getElementById('stepBtn').disabled = isRunning && !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-indicator status-${type}`;
        }

        function updateQueueDisplay() {
            const queueEl = document.getElementById('queueDisplay');
            if (bfsState.queue.length === 0) {
                queueEl.innerHTML = 'é˜Ÿåˆ—ä¸ºç©º';
            } else {
                queueEl.innerHTML = bfsState.queue
                    .map((nodeId, index) => {
                        if (index === 0) {
                            return `<span class="queue-item" style="border: 2px solid #f39c12;">${nodeId} (é˜Ÿå¤´)</span>`;
                        } else if (index === bfsState.queue.length - 1) {
                            return `<span class="queue-item" style="border: 2px solid #9b59b6;">${nodeId} (é˜Ÿå°¾)</span>`;
                        } else {
                            return `<span class="queue-item">${nodeId}</span>`;
                        }
                    })
                    .join('');
            }
        }

        function updateVisitedList() {
            const visitedEl = document.getElementById('visitedList');
            if (bfsState.visitOrder.length === 0) {
                visitedEl.innerHTML = 'å°šæœªå¼€å§‹';
            } else {
                visitedEl.innerHTML = bfsState.visitOrder
                    .map((nodeId, index) => `<span class="visited-node">${index + 1}. ${nodeId}</span>`)
                    .join('');
            }
        }

        // å·¥å…·å‡½æ•°
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // äº‹ä»¶ç›‘å¬
        canvas.addEventListener('click', (e) => {
            if (isRunning) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹
            const clickedNode = nodes.find(node => node.contains(x, y));

            if (clickedNode) {
                // é‡ç½®ä¹‹å‰é€‰æ‹©çš„èŠ‚ç‚¹
                if (selectedNode) {
                    selectedNode.state = 'unvisited';
                }

                selectedNode = clickedNode;
                selectedNode.state = 'start';
                updateStatus(`å·²é€‰æ‹©èµ·å§‹èŠ‚ç‚¹: ${selectedNode.id}`, 'ready');
                updateControls();
            }
        });

        // é€Ÿåº¦æ§åˆ¶
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            animationSpeed = 2000 - (speed - 1) * 180; // 200ms to 1800ms
            document.getElementById('speedValue').textContent = speed;
        });

        // åˆå§‹åŒ–
        window.addEventListener('load', () => {
            resizeCanvas();
            loadExample('simple');
            updateCodeDisplay(); // åˆå§‹åŒ–ä»£ç æ˜¾ç¤º
            draw();
        });

        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>