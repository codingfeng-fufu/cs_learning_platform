{% extends 'knowledge_app/base.html' %}

{% block title %}二分查找算法 - 计算机科学学习平台{% endblock %}

{% block content %}
<style>
    .visualization-container {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .concept-card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        border-left: 4px solid #2196F3;
    }

    .key-term {
        display: inline-block;
        background: #e3f2fd;
        padding: 4px 8px;
        border-radius: 4px;
        margin: 2px;
        font-weight: 600;
    }

    .difficulty-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 20px;
        font-weight: bold;
        margin: 10px 0;
    }

    .difficulty-easy {
        background: #d4edda;
        color: #155724;
    }

    .code-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        border-bottom: 2px solid #e0e0e0;
    }

    .code-tab {
        padding: 10px 20px;
        cursor: pointer;
        background: #f5f5f5;
        border: none;
        border-radius: 8px 8px 0 0;
        transition: all 0.3s;
    }

    .code-tab.active {
        background: #2196F3;
        color: white;
    }

    .code-content {
        display: none;
        background: #2d2d2d;
        color: #f8f8f2;
        padding: 20px;
        border-radius: 0 8px 8px 8px;
        position: relative;
        font-family: 'Courier New', monospace;
        overflow-x: auto;
    }

    .code-content.active {
        display: block;
    }

    .copy-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        background: #2196F3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
    }

    .copy-btn:hover {
        background: #1976D2;
    }

    #binaryCanvas {
        border: 2px solid #ddd;
        border-radius: 8px;
        margin: 20px auto;
        display: block;
        background: white;
    }

    .array-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin: 20px 0;
        gap: 5px;
    }

    .array-element {
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-weight: bold;
        font-size: 18px;
        transition: all 0.3s;
        position: relative;
    }

    .array-element.left-bound {
        border-color: #4CAF50;
        background: #e8f5e9;
    }

    .array-element.right-bound {
        border-color: #f44336;
        background: #ffebee;
    }

    .array-element.mid {
        border-color: #FF9800;
        background: #fff3e0;
        transform: scale(1.1);
    }

    .array-element.found {
        border-color: #9C27B0;
        background: #f3e5f5;
        animation: pulse 0.5s;
    }

    .array-element.eliminated {
        opacity: 0.3;
        background: #f5f5f5;
    }

    .array-index {
        position: absolute;
        bottom: -20px;
        font-size: 12px;
        color: #666;
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }

    .control-panel {
        text-align: center;
        margin: 20px 0;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }

    .control-btn {
        padding: 10px 20px;
        background: #2196F3;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
    }

    .control-btn:hover {
        background: #1976D2;
        transform: translateY(-2px);
    }

    .control-btn.secondary {
        background: #4CAF50;
    }

    .control-btn.secondary:hover {
        background: #45a049;
    }

    .control-btn.danger {
        background: #f44336;
    }

    .control-btn.danger:hover {
        background: #da190b;
    }

    .input-group {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin: 10px;
    }

    .input-field {
        padding: 8px 12px;
        border: 2px solid #2196F3;
        border-radius: 6px;
        font-size: 14px;
    }

    .stats-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin: 20px 0;
    }

    .stat-card {
        background: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #2196F3;
    }

    .stat-label {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
    }

    .comparison-box {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        text-align: center;
    }

    .comparison-box h3 {
        margin-bottom: 15px;
        color: #333;
    }

    .comparison-result {
        font-size: 24px;
        font-weight: bold;
        margin: 10px 0;
    }

    .speed-control {
        display: inline-block;
        margin: 0 15px;
    }

    .speed-control label {
        margin-right: 10px;
        font-weight: 600;
    }

    .quiz-item {
        background: #f8f9fa;
        padding: 20px;
        margin: 15px 0;
        border-radius: 8px;
        border: 2px solid #e9ecef;
    }

    .quiz-question {
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
    }

    .show-answer-btn {
        padding: 8px 16px;
        background: #17a2b8;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
    }

    .quiz-answer {
        display: none;
        background: #d4edda;
        padding: 15px;
        border-radius: 6px;
        margin-top: 10px;
        border-left: 4px solid #28a745;
    }

    .analogy-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 12px;
        margin: 20px 0;
    }

    .application-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin: 20px 0;
    }

    .app-card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.3s;
    }

    .app-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .highlight {
        background: #ffeb3b;
        padding: 2px 4px;
        border-radius: 3px;
    }

    .formula-box {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        font-size: 18px;
        margin: 20px 0;
        font-family: 'Courier New', monospace;
    }

    .algorithm-step {
        background: #f8f9fa;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #2196F3;
    }

    .step-number {
        display: inline-block;
        width: 30px;
        height: 30px;
        background: #2196F3;
        color: white;
        border-radius: 50%;
        text-align: center;
        line-height: 30px;
        margin-right: 10px;
        font-weight: bold;
    }

    .step-history {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        max-height: 200px;
        overflow-y: auto;
    }

    .step-item {
        padding: 8px;
        margin: 5px 0;
        background: #f8f9fa;
        border-radius: 4px;
        border-left: 3px solid #2196F3;
    }
</style>

<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>算法</span>
        <span>></span>
        <span>二分查找</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">🔍</span>
            二分查找算法（Binary Search）
        </h1>
        <p>高效查找的经典算法 - 每次排除一半的搜索空间</p>
    </div>

    <!-- 知识点概述 -->
    <div class="content-card slide-in-right">
        <h2 class="section-title">
            <span class="section-icon">📋</span>
            知识点概述
        </h2>

        <div class="concept-card">
            <p style="font-size: 18px; line-height: 1.6;">
                <strong>核心概念：</strong>二分查找就像在<span class="highlight">字典里查单词</span>，每次打开中间页，根据字母顺序决定往前翻还是往后翻，每次都能排除一半的内容，快速定位目标！
            </p>

            <div style="margin: 20px 0;">
                <h4>🔤 关键术语：</h4>
                <span class="key-term">有序数组</span> - 前提条件，数组必须已排序<br>
                <span class="key-term">搜索区间</span> - 当前查找的范围[left, right]<br>
                <span class="key-term">中间元素</span> - mid = (left + right) / 2<br>
                <span class="key-term">时间复杂度</span> - O(log n)，对数级别<br>
                <span class="key-term">空间复杂度</span> - O(1)，只需几个变量
            </div>

            <div class="difficulty-badge difficulty-easy">
                📊 学习难度：入门
            </div>

            <div style="margin-top: 15px;">
                <strong>前置知识：</strong>数组、循环、条件判断
            </div>
        </div>
    </div>

    <!-- 概念详解 -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">🔍</span>
            概念详解
        </h2>

        <div class="analogy-box">
            <h3>📚 生活类比：猜数字游戏</h3>
            <p>朋友心里想了1-100之间的数字，让你猜：</p>
            <ul style="list-style: none; padding-left: 0;">
                <li>🎯 第一次猜50，朋友说"太大了"</li>
                <li>➡️ 范围缩小到1-49</li>
                <li>🎯 第二次猜25，朋友说"太小了"</li>
                <li>➡️ 范围缩小到26-49</li>
                <li>🎯 继续二分，最多7次就能猜中（log₂100 ≈ 7）</li>
                <li>💡 比从1开始逐个猜（最多100次）快得多！</li>
            </ul>
        </div>

        <div class="concept-card">
            <h4>1️⃣ 算法原理</h4>
            <p><strong>核心思想：</strong>利用数组的有序性，每次比较中间元素，排除一半的搜索空间。</p>

            <div class="formula-box">
                mid = left + (right - left) / 2<br>
                <small>避免(left + right)溢出的写法</small>
            </div>

            <p><strong>三种情况：</strong></p>
            <ul>
                <li>arr[mid] == target：找到目标，返回索引</li>
                <li>arr[mid] < target：目标在右半部分，left = mid + 1</li>
                <li>arr[mid] > target：目标在左半部分，right = mid - 1</li>
            </ul>
        </div>

        <div class="concept-card">
            <h4>2️⃣ 时间复杂度分析</h4>
            <p><strong>为什么是O(log n)？</strong></p>
            <ul>
                <li>第1次比较后，剩余 n/2 个元素</li>
                <li>第2次比较后，剩余 n/4 个元素</li>
                <li>第3次比较后，剩余 n/8 个元素</li>
                <li>第k次比较后，剩余 n/2^k 个元素</li>
                <li>当 n/2^k = 1 时，k = log₂n</li>
            </ul>

            <p><strong>具体例子：</strong></p>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background: #f0f0f0;">
                    <th style="padding: 10px; border: 1px solid #ddd;">数组大小</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">最多比较次数</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">线性查找</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">10</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">4</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">10</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">100</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">7</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">100</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">1,000</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">10</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">1,000</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">1,000,000</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">20</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">1,000,000</td>
                </tr>
            </table>
        </div>

        <div class="concept-card">
            <h4>3️⃣ 算法执行步骤</h4>
            <div class="algorithm-step">
                <span class="step-number">1</span>
                初始化：left = 0, right = n - 1
            </div>
            <div class="algorithm-step">
                <span class="step-number">2</span>
                计算中间位置：mid = left + (right - left) / 2
            </div>
            <div class="algorithm-step">
                <span class="step-number">3</span>
                比较arr[mid]与target
            </div>
            <div class="algorithm-step">
                <span class="step-number">4</span>
                根据比较结果调整left或right
            </div>
            <div class="algorithm-step">
                <span class="step-number">5</span>
                重复2-4直到找到或left > right
            </div>
        </div>

        <div class="concept-card" style="background: #fff3cd; border-left-color: #ffc107;">
            <h4>⚠️ 初学者易错点</h4>
            <ul>
                <li><strong>边界条件：</strong>是 left <= right 还是 left < right？</li>
                <li><strong>更新边界：</strong>是 mid 还是 mid ± 1？</li>
                <li><strong>整数溢出：</strong>mid = (left + right) / 2 可能溢出</li>
                <li><strong>数组必须有序：</strong>这是前提条件！</li>
                <li><strong>重复元素：</strong>标准二分找到的可能不是第一个</li>
            </ul>
        </div>
    </div>

    <!-- 可视化展示 -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">📊</span>
            可视化展示
        </h2>

        <div class="visualization-container">
            <h3 style="text-align: center;">🎯 二分查找动态演示</h3>

            <div class="input-group">
                <label>查找目标：</label>
                <input type="number" id="targetInput" class="input-field" value="42" min="1" max="100">
                <button class="control-btn" onclick="startSearch()">🔍 开始查找</button>
            </div>

            <div class="input-group">
                <label>数组大小：</label>
                <select id="arraySizeSelect" class="input-field" onchange="generateArray()">
                    <option value="10">10个元素</option>
                    <option value="15" selected>15个元素</option>
                    <option value="20">20个元素</option>
                    <option value="30">30个元素</option>
                </select>
            </div>

            <canvas id="binaryCanvas" width="800" height="400"></canvas>

            <div class="array-container" id="arrayContainer">
                <!-- 动态生成数组元素 -->
            </div>

            <div class="comparison-box">
                <h3>当前比较</h3>
                <div id="comparisonInfo">
                    <p>等待开始查找...</p>
                </div>
            </div>

            <div class="control-panel">
                <button class="control-btn" onclick="stepSearch()">⏭️ 单步执行</button>
                <button class="control-btn secondary" onclick="resetSearch()">🔄 重置</button>
                <button class="control-btn secondary" onclick="generateArray()">🎲 随机数组</button>

                <div class="speed-control">
                    <label for="speedSlider">速度：</label>
                    <input type="range" id="speedSlider" min="300" max="2000" value="1000" step="100">
                    <span id="speedValue">1000ms</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-value" id="stepCount">0</div>
                    <div class="stat-label">比较次数</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="leftBound">-</div>
                    <div class="stat-label">左边界</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="rightBound">-</div>
                    <div class="stat-label">右边界</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="midPoint">-</div>
                    <div class="stat-label">中间位置</div>
                </div>
            </div>

            <div class="step-history">
                <h4>查找历史</h4>
                <div id="stepHistory">
                    <!-- 动态生成步骤历史 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 代码示例 -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">💻</span>
            代码实现
        </h2>

        <div class="code-tabs">
            <button class="code-tab active" onclick="switchCode('python', event)">Python</button>
            <button class="code-tab" onclick="switchCode('cpp', event)">C++</button>
            <button class="code-tab" onclick="switchCode('java', event)">Java</button>
        </div>

        <div id="python-code" class="code-content active">
            <button class="copy-btn" onclick="copyCode('python', event)">📋 复制代码</button>
            <pre><code>def binary_search(arr, target):
    """
    标准二分查找
    Args:
        arr: 有序数组
        target: 查找目标
    Returns:
        目标元素的索引，如果不存在返回-1
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        # 防止溢出的写法
        mid = left + (right - left) // 2

        if arr[mid] == target:
            return mid  # 找到目标
        elif arr[mid] < target:
            left = mid + 1  # 目标在右半部分
        else:
            right = mid - 1  # 目标在左半部分

    return -1  # 未找到


def binary_search_recursive(arr, target, left=0, right=None):
    """
    递归版本的二分查找
    """
    if right is None:
        right = len(arr) - 1

    if left > right:
        return -1

    mid = left + (right - left) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)


def binary_search_first(arr, target):
    """
    查找第一个等于target的元素
    用于处理有重复元素的情况
    """
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid
            right = mid - 1  # 继续在左边查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result


def binary_search_last(arr, target):
    """
    查找最后一个等于target的元素
    """
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid
            left = mid + 1  # 继续在右边查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result


def binary_search_insert_position(arr, target):
    """
    查找插入位置
    返回target应该插入的位置，保持数组有序
    """
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2

        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left


def binary_search_range(arr, target):
    """
    查找目标元素的范围 [first, last]
    """
    first = binary_search_first(arr, target)
    if first == -1:
        return [-1, -1]

    last = binary_search_last(arr, target)
    return [first, last]


def binary_search_rotated(arr, target):
    """
    在旋转排序数组中查找
    例如：[4,5,6,7,0,1,2]
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            return mid

        # 判断哪一半是有序的
        if arr[left] <= arr[mid]:  # 左半部分有序
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # 右半部分有序
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1


def binary_search_peak(arr):
    """
    寻找峰值元素
    峰值：大于左右相邻元素的元素
    """
    left, right = 0, len(arr) - 1

    while left < right:
        mid = left + (right - left) // 2

        if arr[mid] < arr[mid + 1]:
            left = mid + 1  # 峰值在右边
        else:
            right = mid  # 峰值在左边或就是mid

    return left


def binary_search_2d_matrix(matrix, target):
    """
    在二维矩阵中查找
    矩阵每行递增，每行的第一个元素大于上一行的最后一个元素
    """
    if not matrix or not matrix[0]:
        return False

    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1

    while left <= right:
        mid = left + (right - left) // 2
        # 将一维索引转换为二维坐标
        row, col = mid // n, mid % n

        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            left = mid + 1
        else:
            right = mid - 1

    return False


# 测试示例
if __name__ == "__main__":
    # 基础测试
    arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    print("数组:", arr)

    # 标准二分查找
    target = 7
    result = binary_search(arr, target)
    print(f"查找 {target}: 索引 = {result}")

    # 递归版本
    result = binary_search_recursive(arr, target)
    print(f"递归查找 {target}: 索引 = {result}")

    # 有重复元素的情况
    arr_dup = [1, 2, 2, 2, 3, 4, 4, 5]
    print(f"\n有重复元素的数组: {arr_dup}")
    print(f"第一个2的位置: {binary_search_first(arr_dup, 2)}")
    print(f"最后一个2的位置: {binary_search_last(arr_dup, 2)}")
    print(f"2的范围: {binary_search_range(arr_dup, 2)}")

    # 插入位置
    print(f"\n插入3.5的位置: {binary_search_insert_position(arr, 8)}")

    # 旋转数组
    rotated = [4, 5, 6, 7, 0, 1, 2]
    print(f"\n旋转数组: {rotated}")
    print(f"查找0: {binary_search_rotated(rotated, 0)}")

    # 寻找峰值
    peak_arr = [1, 2, 3, 1]
    print(f"\n数组 {peak_arr} 的峰值索引: {binary_search_peak(peak_arr)}")</code></pre>
        </div>

        <div id="cpp-code" class="code-content">
            <button class="copy-btn" onclick="copyCode('cpp', event)">📋 复制代码</button>
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// 标准二分查找
int binarySearch(vector&lt;int&gt;& arr, int target) {
    int left = 0, right = arr.size() - 1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;  // 防止溢出

        if (arr[mid] == target) {
            return mid;  // 找到目标
        } else if (arr[mid] &lt; target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1;  // 目标在左半部分
        }
    }

    return -1;  // 未找到
}

// 递归版本
int binarySearchRecursive(vector&lt;int&gt;& arr, int target, int left, int right) {
    if (left &gt; right) {
        return -1;
    }

    int mid = left + (right - left) / 2;

    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] &lt; target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

// 查找第一个等于target的元素
int binarySearchFirst(vector&lt;int&gt;& arr, int target) {
    int left = 0, right = arr.size() - 1;
    int result = -1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;  // 继续在左边查找
        } else if (arr[mid] &lt; target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

// 查找最后一个等于target的元素
int binarySearchLast(vector&lt;int&gt;& arr, int target) {
    int left = 0, right = arr.size() - 1;
    int result = -1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            result = mid;
            left = mid + 1;  // 继续在右边查找
        } else if (arr[mid] &lt; target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

// 查找插入位置
int searchInsertPosition(vector&lt;int&gt;& arr, int target) {
    int left = 0, right = arr.size();

    while (left &lt; right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] &lt; target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

// 查找元素范围
vector&lt;int&gt; searchRange(vector&lt;int&gt;& arr, int target) {
    int first = binarySearchFirst(arr, target);
    if (first == -1) {
        return {-1, -1};
    }

    int last = binarySearchLast(arr, target);
    return {first, last};
}

// 在旋转排序数组中查找
int searchRotated(vector&lt;int&gt;& arr, int target) {
    int left = 0, right = arr.size() - 1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        }

        // 判断哪一半是有序的
        if (arr[left] &lt;= arr[mid]) {  // 左半部分有序
            if (arr[left] &lt;= target && target &lt; arr[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // 右半部分有序
            if (arr[mid] &lt; target && target &lt;= arr[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// 寻找峰值
int findPeakElement(vector&lt;int&gt;& arr) {
    int left = 0, right = arr.size() - 1;

    while (left &lt; right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] &lt; arr[mid + 1]) {
            left = mid + 1;  // 峰值在右边
        } else {
            right = mid;  // 峰值在左边或就是mid
        }
    }

    return left;
}

// 二分查找模板类（支持自定义比较）
template&lt;typename T&gt;
class BinarySearcher {
public:
    // 标准二分查找
    static int search(const vector&lt;T&gt;& arr, const T& target) {
        int left = 0, right = arr.size() - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return -1;
    }

    // 使用自定义比较函数
    template&lt;typename Compare&gt;
    static int searchWithCompare(const vector&lt;T&gt;& arr, const T& target, Compare comp) {
        int left = 0, right = arr.size() - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;

            if (!comp(arr[mid], target) && !comp(target, arr[mid])) {
                return mid;  // 相等
            } else if (comp(arr[mid], target)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return -1;
    }
};

// 打印数组
void printArray(const vector&lt;int&gt;& arr) {
    for (int x : arr) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

int main() {
    // 基础测试
    vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    cout &lt;&lt; "数组: ";
    printArray(arr);

    // 标准二分查找
    int target = 7;
    int result = binarySearch(arr, target);
    cout &lt;&lt; "查找 " &lt;&lt; target &lt;&lt; ": 索引 = " &lt;&lt; result &lt;&lt; endl;

    // 递归版本
    result = binarySearchRecursive(arr, target, 0, arr.size() - 1);
    cout &lt;&lt; "递归查找 " &lt;&lt; target &lt;&lt; ": 索引 = " &lt;&lt; result &lt;&lt; endl;

    // 有重复元素
    vector&lt;int&gt; arrDup = {1, 2, 2, 2, 3, 4, 4, 5};
    cout &lt;&lt; "\n有重复元素的数组: ";
    printArray(arrDup);
    cout &lt;&lt; "第一个2的位置: " &lt;&lt; binarySearchFirst(arrDup, 2) &lt;&lt; endl;
    cout &lt;&lt; "最后一个2的位置: " &lt;&lt; binarySearchLast(arrDup, 2) &lt;&lt; endl;

    auto range = searchRange(arrDup, 2);
    cout &lt;&lt; "2的范围: [" &lt;&lt; range[0] &lt;&lt; ", " &lt;&lt; range[1] &lt;&lt; "]" &lt;&lt; endl;

    // 插入位置
    cout &lt;&lt; "\n在原数组中插入8的位置: " &lt;&lt; searchInsertPosition(arr, 8) &lt;&lt; endl;

    // 旋转数组
    vector&lt;int&gt; rotated = {4, 5, 6, 7, 0, 1, 2};
    cout &lt;&lt; "\n旋转数组: ";
    printArray(rotated);
    cout &lt;&lt; "查找0: " &lt;&lt; searchRotated(rotated, 0) &lt;&lt; endl;

    // 寻找峰值
    vector&lt;int&gt; peakArr = {1, 2, 3, 1};
    cout &lt;&lt; "\n数组 ";
    printArray(peakArr);
    cout &lt;&lt; "峰值索引: " &lt;&lt; findPeakElement(peakArr) &lt;&lt; endl;

    // 使用模板类
    cout &lt;&lt; "\n使用模板类查找: " &lt;&lt; BinarySearcher&lt;int&gt;::search(arr, 13) &lt;&lt; endl;

    return 0;
}</code></pre>
        </div>

        <div id="java-code" class="code-content">
            <button class="copy-btn" onclick="copyCode('java', event)">📋 复制代码</button>
            <pre><code>import java.util.*;

public class BinarySearch {

    // 标准二分查找
    public static int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;  // 防止溢出

            if (arr[mid] == target) {
                return mid;  // 找到目标
            } else if (arr[mid] &lt; target) {
                left = mid + 1;  // 目标在右半部分
            } else {
                right = mid - 1;  // 目标在左半部分
            }
        }

        return -1;  // 未找到
    }

    // 递归版本
    public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left &gt; right) {
            return -1;
        }

        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] &lt; target) {
            return binarySearchRecursive(arr, target, mid + 1, right);
        } else {
            return binarySearchRecursive(arr, target, left, mid - 1);
        }
    }

    // 查找第一个等于target的元素
    public static int binarySearchFirst(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int result = -1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                result = mid;
                right = mid - 1;  // 继续在左边查找
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    // 查找最后一个等于target的元素
    public static int binarySearchLast(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int result = -1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                result = mid;
                left = mid + 1;  // 继续在右边查找
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    // 查找插入位置
    public static int searchInsertPosition(int[] arr, int target) {
        int left = 0, right = arr.length;

        while (left &lt; right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    // 查找元素范围
    public static int[] searchRange(int[] arr, int target) {
        int first = binarySearchFirst(arr, target);
        if (first == -1) {
            return new int[]{-1, -1};
        }

        int last = binarySearchLast(arr, target);
        return new int[]{first, last};
    }

    // 在旋转排序数组中查找
    public static int searchRotated(int[] arr, int target) {
        int left = 0, right = arr.length - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            // 判断哪一半是有序的
            if (arr[left] &lt;= arr[mid]) {  // 左半部分有序
                if (arr[left] &lt;= target && target &lt; arr[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {  // 右半部分有序
                if (arr[mid] &lt; target && target &lt;= arr[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }

    // 寻找峰值
    public static int findPeakElement(int[] arr) {
        int left = 0, right = arr.length - 1;

        while (left &lt; right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] &lt; arr[mid + 1]) {
                left = mid + 1;  // 峰值在右边
            } else {
                right = mid;  // 峰值在左边或就是mid
            }
        }

        return left;
    }

    // 二分查找的泛型实现
    public static &lt;T extends Comparable&lt;T&gt;&gt; int binarySearchGeneric(T[] arr, T target) {
        int left = 0, right = arr.length - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            int cmp = arr[mid].compareTo(target);

            if (cmp == 0) {
                return mid;
            } else if (cmp &lt; 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return -1;
    }

    // 打印数组
    public static void printArray(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    public static void main(String[] args) {
        // 基础测试
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        System.out.print("数组: ");
        printArray(arr);

        // 标准二分查找
        int target = 7;
        int result = binarySearch(arr, target);
        System.out.println("查找 " + target + ": 索引 = " + result);

        // 递归版本
        result = binarySearchRecursive(arr, target, 0, arr.length - 1);
        System.out.println("递归查找 " + target + ": 索引 = " + result);

        // 有重复元素
        int[] arrDup = {1, 2, 2, 2, 3, 4, 4, 5};
        System.out.print("\n有重复元素的数组: ");
        printArray(arrDup);
        System.out.println("第一个2的位置: " + binarySearchFirst(arrDup, 2));
        System.out.println("最后一个2的位置: " + binarySearchLast(arrDup, 2));

        int[] range = searchRange(arrDup, 2);
        System.out.println("2的范围: " + Arrays.toString(range));

        // 插入位置
        System.out.println("\n在原数组中插入8的位置: " + searchInsertPosition(arr, 8));

        // 旋转数组
        int[] rotated = {4, 5, 6, 7, 0, 1, 2};
        System.out.print("\n旋转数组: ");
        printArray(rotated);
        System.out.println("查找0: " + searchRotated(rotated, 0));

        // 寻找峰值
        int[] peakArr = {1, 2, 3, 1};
        System.out.print("\n数组 ");
        printArray(peakArr);
        System.out.println("峰值索引: " + findPeakElement(peakArr));

        // 使用泛型
        Integer[] integerArr = {1, 3, 5, 7, 9};
        System.out.println("\n泛型查找5: " + binarySearchGeneric(integerArr, 5));

        // 使用Java内置的二分查找
        System.out.println("\nJava Arrays.binarySearch: " +
                          Arrays.binarySearch(arr, 13));
    }
}</code></pre>
        </div>
    </div>

    <!-- 实际应用 -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">🌟</span>
            实际应用
        </h2>

        <div class="application-grid">
            <div class="app-card">
                <h3>📚 字典查询</h3>
                <p>电子词典、数据库索引等使用二分查找快速定位</p>
            </div>

            <div class="app-card">
                <h3>🎮 游戏开发</h3>
                <p>在排行榜中快速查找玩家排名，碰撞检测优化</p>
            </div>

            <div class="app-card">
                <h3>💾 文件系统</h3>
                <p>在已排序的文件列表中快速查找文件</p>
            </div>

            <div class="app-card">
                <h3>🔢 数值计算</h3>
                <p>求平方根、方程求解等数值方法</p>
            </div>

            <div class="app-card">
                <h3>📊 数据分析</h3>
                <p>在时间序列数据中查找特定时间点的数据</p>
            </div>

            <div class="app-card">
                <h3>🏭 工业控制</h3>
                <p>在传感器数据中快速定位异常值</p>
            </div>
        </div>
    </div>

    <!-- 学习检验 -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">✅</span>
            学习检验
        </h2>

        <div class="quiz-item">
            <div class="quiz-question">
                ❓ 问题1：二分查找的前提条件是什么？为什么需要这些条件？
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(1, event)">查看答案</button>
            <div id="answer1" class="quiz-answer">
                <strong>答案：</strong>二分查找需要两个前提条件：

                <p><strong>1. 数组必须有序</strong></p>
                <ul>
                    <li>原因：只有有序才能确定目标在哪一半</li>
                    <li>如果无序，比较结果无法指导搜索方向</li>
                </ul>

                <p><strong>2. 支持随机访问（数组结构）</strong></p>
                <ul>
                    <li>原因：需要O(1)时间访问中间元素</li>
                    <li>链表不适合，访问中间节点需要O(n)</li>
                </ul>

                <p><strong>额外考虑：</strong></p>
                <ul>
                    <li>数据量较大时才有优势（小数据量线性查找可能更快）</li>
                    <li>静态或很少变化的数据（频繁插入删除会破坏有序性）</li>
                </ul>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                ❓ 问题2：while (left <= right) 和 while (left < right) 的区别？
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(2, event)">查看答案</button>
            <div id="answer2" class="quiz-answer">
                <strong>答案：</strong>这是二分查找最常见的边界问题。

                <p><strong>while (left <= right)：</strong></p>
                <ul>
                    <li>搜索区间：[left, right]，两端都包含</li>
                    <li>终止条件：left > right，区间为空</li>
                    <li>更新方式：left = mid + 1, right = mid - 1</li>
                    <li>适用：标准的查找某个值</li>
                </ul>

                <p><strong>while (left < right)：</strong></p>
                <ul>
                    <li>搜索区间：[left, right)，左闭右开</li>
                    <li>终止条件：left == right</li>
                    <li>更新方式：left = mid + 1, right = mid</li>
                    <li>适用：查找边界位置</li>
                </ul>

                <p><strong>示例对比：</strong></p>
                <pre style="background: #f0f0f0; padding: 10px;">
// 标准查找
while (left <= right) {
    mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
}

// 查找左边界
while (left < right) {
    mid = left + (right - left) / 2;
    if (arr[mid] < target) left = mid + 1;
    else right = mid;
}
                </pre>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                ❓ 问题3：为什么要写 mid = left + (right - left) / 2 而不是 mid = (left + right) / 2？
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(3, event)">查看答案</button>
            <div id="answer3" class="quiz-answer">
                <strong>答案：</strong>防止整数溢出！

                <p><strong>问题分析：</strong></p>
                <ul>
                    <li>当left和right都很大时，left + right可能超过整数最大值</li>
                    <li>例如：left = 2^30, right = 2^30，相加会溢出</li>
                    <li>溢出后结果变成负数，导致程序错误</li>
                </ul>

                <p><strong>解决方案：</strong></p>
                <ol>
                    <li><code>mid = left + (right - left) / 2</code>（推荐）</li>
                    <li><code>mid = left + ((right - left) >> 1)</code>（位运算版本）</li>
                    <li><code>mid = (left + right) >>> 1</code>（Java无符号右移）</li>
                </ol>

                <p><strong>其他语言的处理：</strong></p>
                <ul>
                    <li>Python：整数无限大，不存在溢出问题</li>
                    <li>JavaScript：使用Math.floor((left + right) / 2)</li>
                </ul>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                ❓ 问题4：如何用二分查找解决"寻找旋转数组的最小值"问题？
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(4, event)">查看答案</button>
            <div id="answer4" class="quiz-answer">
                <strong>答案：</strong>利用旋转数组的特性进行二分。

                <p><strong>问题描述：</strong></p>
                <p>数组原本有序，被旋转了若干位。如：[4,5,6,7,0,1,2]</p>

                <p><strong>解题思路：</strong></p>
                <ol>
                    <li>最小值一定在"断层"处</li>
                    <li>比较mid与right：
                        <ul>
                            <li>arr[mid] > arr[right]：最小值在右半部分</li>
                            <li>arr[mid] < arr[right]：最小值在左半部分（包括mid）</li>
                            <li>arr[mid] == arr[right]：无法判断，right--</li>
                        </ul>
                    </li>
                </ol>

                <p><strong>代码实现：</strong></p>
                <pre style="background: #f0f0f0; padding: 10px;">
def findMin(arr):
    left, right = 0, len(arr) - 1

    while left < right:
        mid = left + (right - left) // 2

        if arr[mid] > arr[right]:
            left = mid + 1  # 最小值在右边
        elif arr[mid] < arr[right]:
            right = mid     # 最小值在左边或就是mid
        else:
            right -= 1      # 处理重复元素

    return arr[left]
                </pre>

                <p><strong>时间复杂度：</strong>O(log n)，有重复时最坏O(n)</p>
            </div>
        </div>

        <div style="margin-top: 30px; padding: 20px; background: #e3f2fd; border-radius: 8px;">
            <h4>📚 进阶学习建议</h4>
            <ol>
                <li><strong>掌握变种：</strong>查找第一个/最后一个、查找范围</li>
                <li><strong>扩展应用：</strong>二分答案、三分查找</li>
                <li><strong>相关算法：</strong>快速选择、插值查找</li>
                <li><strong>实战练习：</strong>LeetCode二分查找专题</li>
            </ol>
        </div>
    </div>

    <!-- 返回导航 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<script>
// 全局变量
let array = [];
let target = 42;
let left = -1;
let right = -1;
let mid = -1;
let steps = 0;
let found = false;
let animationRunning = false;
let animationSpeed = 1000;
let stepHistory = [];

// Canvas相关
const canvas = document.getElementById('binaryCanvas');
const ctx = canvas.getContext('2d');

// 生成有序数组
function generateArray() {
    const size = parseInt(document.getElementById('arraySizeSelect').value);
    array = [];
    stepHistory = [];

    // 生成随机有序数组
    let current = Math.floor(Math.random() * 5) + 1;
    for (let i = 0; i < size; i++) {
        array.push(current);
        current += Math.floor(Math.random() * 10) + 1;
    }

    resetSearch();
    displayArray();
    drawCanvas();
}

// 显示数组元素
function displayArray() {
    const container = document.getElementById('arrayContainer');
    container.innerHTML = '';

    for (let i = 0; i < array.length; i++) {
        const element = document.createElement('div');
        element.className = 'array-element';
        element.id = `elem-${i}`;
        element.innerHTML = `
            ${array[i]}
            <div class="array-index">${i}</div>
        `;
        container.appendChild(element);
    }
}

// 更新元素样式
function updateElementStyles() {
    for (let i = 0; i < array.length; i++) {
        const element = document.getElementById(`elem-${i}`);
        if (!element) continue;

        // 重置样式
        element.className = 'array-element';

        // 应用样式
        if (i === mid && !found) {
            element.classList.add('mid');
        }
        if (i === left) {
            element.classList.add('left-bound');
        }
        if (i === right) {
            element.classList.add('right-bound');
        }
        if (i < left || i > right) {
            element.classList.add('eliminated');
        }
        if (found && i === mid) {
            element.classList.add('found');
        }
    }
}

// 绘制Canvas可视化
function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (array.length === 0) return;

    const barWidth = canvas.width / array.length;
    const maxValue = Math.max(...array);
    const scale = (canvas.height - 60) / maxValue;

    // 绘制条形图
    for (let i = 0; i < array.length; i++) {
        const barHeight = array[i] * scale;
        const x = i * barWidth;
        const y = canvas.height - barHeight - 30;

        // 设置颜色
        if (i === mid && !found) {
            ctx.fillStyle = '#FF9800';
        } else if (i === left || i === right) {
            ctx.fillStyle = i === left ? '#4CAF50' : '#f44336';
        } else if (i < left || i > right) {
            ctx.fillStyle = '#e0e0e0';
        } else {
            ctx.fillStyle = '#2196F3';
        }

        if (found && i === mid) {
            ctx.fillStyle = '#9C27B0';
        }

        // 绘制条形
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);

        // 绘制数值
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(array[i], x + barWidth / 2, canvas.height - 10);

        // 绘制索引
        ctx.fillStyle = '#666';
        ctx.font = '10px Arial';
        ctx.fillText(i, x + barWidth / 2, canvas.height - 20);
    }

    // 绘制指针
    if (left >= 0 && left < array.length) {
        drawPointer(left * barWidth + barWidth / 2, 20, 'L', '#4CAF50');
    }
    if (right >= 0 && right < array.length) {
        drawPointer(right * barWidth + barWidth / 2, 20, 'R', '#f44336');
    }
    if (mid >= 0 && mid < array.length && !found) {
        drawPointer(mid * barWidth + barWidth / 2, 40, 'M', '#FF9800');
    }
}

// 绘制指针
function drawPointer(x, y, label, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - 10, y - 15);
    ctx.lineTo(x + 10, y - 15);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, x, y - 5);
}

// 二分查找步骤
async function binarySearchStep() {
    if (left > right) {
        found = false;
        updateLog('❌ 未找到目标元素');
        addStepToHistory(`未找到 ${target}`);
        animationRunning = false;
        return false;
    }

    mid = Math.floor(left + (right - left) / 2);
    steps++;

    updateStats();
    updateElementStyles();
    drawCanvas();

    // 更新比较信息
    const compInfo = document.getElementById('comparisonInfo');
    compInfo.innerHTML = `
        <p><strong>第 ${steps} 步</strong></p>
        <p>比较: arr[${mid}] = ${array[mid]} 与 target = ${target}</p>
    `;

    await sleep(animationSpeed);

    if (array[mid] === target) {
        found = true;
        compInfo.innerHTML += `<p class="comparison-result" style="color: #9C27B0;">✅ 找到了！</p>`;
        updateLog(`🎉 找到目标！位置: ${mid}，比较次数: ${steps}`);
        addStepToHistory(`找到 ${target} 在位置 ${mid}`);
        updateElementStyles();
        drawCanvas();
        animationRunning = false;
        return false;
    } else if (array[mid] < target) {
        compInfo.innerHTML += `<p class="comparison-result">${array[mid]} < ${target} → 搜索右半部分</p>`;
        addStepToHistory(`arr[${mid}]=${array[mid]} < ${target}，搜索右边`);
        left = mid + 1;
    } else {
        compInfo.innerHTML += `<p class="comparison-result">${array[mid]} > ${target} → 搜索左半部分</p>`;
        addStepToHistory(`arr[${mid}]=${array[mid]} > ${target}，搜索左边`);
        right = mid - 1;
    }

    return true;
}

// 开始搜索
async function startSearch() {
    if (animationRunning) return;

    target = parseInt(document.getElementById('targetInput').value);
    resetSearch();
    animationRunning = true;

    while (await binarySearchStep()) {
        if (!animationRunning) break;
        await sleep(animationSpeed / 2);
    }
}

// 单步执行
async function stepSearch() {
    if (animationRunning) return;

    if (steps === 0) {
        target = parseInt(document.getElementById('targetInput').value);
        resetSearch();
    }

    await binarySearchStep();
}

// 重置搜索
function resetSearch() {
    left = 0;
    right = array.length - 1;
    mid = -1;
    steps = 0;
    found = false;
    animationRunning = false;
    stepHistory = [];

    updateStats();
    updateElementStyles();
    drawCanvas();

    document.getElementById('comparisonInfo').innerHTML = '<p>等待开始查找...</p>';
    document.getElementById('stepHistory').innerHTML = '';
}

// 更新统计信息
function updateStats() {
    document.getElementById('stepCount').textContent = steps;
    document.getElementById('leftBound').textContent = left >= 0 ? left : '-';
    document.getElementById('rightBound').textContent = right >= 0 ? right : '-';
    document.getElementById('midPoint').textContent = mid >= 0 ? mid : '-';
}

// 添加步骤到历史
function addStepToHistory(message) {
    stepHistory.push(message);
    const historyDiv = document.getElementById('stepHistory');
    const stepDiv = document.createElement('div');
    stepDiv.className = 'step-item';
    stepDiv.textContent = `步骤 ${stepHistory.length}: ${message}`;
    historyDiv.appendChild(stepDiv);
    historyDiv.scrollTop = historyDiv.scrollHeight;
}

// 辅助函数
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function updateLog(message) {
    console.log(message);
}

// 代码切换
function switchCode(lang, event) {
    document.querySelectorAll('.code-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.code-content').forEach(content => content.classList.remove('active'));

    event.target.classList.add('active');
    document.getElementById(`${lang}-code`).classList.add('active');
}

// 复制代码
function copyCode(lang, event) {
    const codeElement = document.getElementById(`${lang}-code`).querySelector('code');
    const text = codeElement.textContent;

    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = '✅ 已复制！';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }).catch(err => {
        // 降级方案
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();

        try {
            document.execCommand('copy');
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✅ 已复制！';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        } catch (err) {
            alert('复制失败，请手动复制代码');
        }

        document.body.removeChild(textArea);
    });
}

// 显示/隐藏答案
function toggleAnswer(num, event) {
    const answer = document.getElementById(`answer${num}`);
    const btn = event.target;

    if (answer.style.display === 'block') {
        answer.style.display = 'none';
        btn.textContent = '查看答案';
    } else {
        answer.style.display = 'block';
        btn.textContent = '隐藏答案';
    }
}

// 速度控制
document.getElementById('speedSlider').addEventListener('input', (e) => {
    animationSpeed = parseInt(e.target.value);
    document.getElementById('speedValue').textContent = `${animationSpeed}ms`;
});

// 初始化
generateArray();
</script>

{% endblock %}