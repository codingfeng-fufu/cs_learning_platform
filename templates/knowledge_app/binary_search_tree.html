{% extends 'knowledge_app/base.html' %}

{% block title %}二叉搜索树 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>二叉搜索树</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🌳</span>
            二叉搜索树 (Binary Search Tree)
        </h1><p>具有特殊性质的二叉树，支持高效的搜索、插入和删除操作</p></div><!-- 主要内容 --><div class="content-card slide-in-right"><!-- 概念介绍 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🔍</span>
                什么是二叉搜索树
            </h2><div class="concept-explanation"><p class="concept-intro">
                    二叉搜索树（BST）是一种特殊的二叉树，对于树中的每个节点，
                    其<strong>左子树</strong>中所有节点的值都小于该节点的值，
                    其<strong>右子树</strong>中所有节点的值都大于该节点的值。
                </p><div class="key-points"><div class="point-item"><span class="point-icon">📏</span><div class="point-content"><h4>有序性质</h4><p>左子树 < 根节点 < 右子树，这个性质递归适用于所有子树</p></div></div><div class="point-item"><span class="point-icon">🔍</span><div class="point-content"><h4>高效搜索</h4><p>利用有序性质，每次比较可以排除一半的搜索空间</p></div></div><div class="point-item"><span class="point-icon">🔄</span><div class="point-content"><h4>动态操作</h4><p>支持动态插入和删除，同时保持树的有序性质</p></div></div></div></div></div><!-- 可视化演示 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🎮</span>
                交互式演示
            </h2><div class="interactive-demo"><div class="demo-controls"><div class="control-group"><input type="number" id="node-value" placeholder="输入节点值" min="1" max="99"><button class="demo-btn primary" onclick="insertNode()">插入节点</button><button class="demo-btn" onclick="searchNode()">查找节点</button><button class="demo-btn" onclick="deleteNode()">删除节点</button><button class="demo-btn" onclick="clearTree()">清空树</button></div><div class="control-group"><button class="demo-btn" onclick="generateRandomTree()">生成随机树</button><button class="demo-btn" onclick="showTraversal('inorder')">中序遍历</button><button class="demo-btn" onclick="showTraversal('preorder')">前序遍历</button><button class="demo-btn" onclick="showTraversal('postorder')">后序遍历</button></div></div><div id="tree-display" class="tree-display"><div class="empty-tree">树为空，请插入节点</div></div><div class="tree-info"><div class="info-row"><div class="info-item"><span class="info-label">节点数量：</span><span id="node-count">0</span></div><div class="info-item"><span class="info-label">树的高度：</span><span id="tree-height">0</span></div><div class="info-item"><span class="info-label">最小值：</span><span id="min-value">-</span></div><div class="info-item"><span class="info-label">最大值：</span><span id="max-value">-</span></div></div><div class="operation-result" id="operation-result"></div><div class="traversal-result" id="traversal-result"></div></div></div></div><!-- 基本操作 --><div class="content-section"><h2 class="section-title"><span class="section-icon">⚙️</span>
                基本操作
            </h2><div class="operations-grid"><div class="operation-card"><h4 class="operation-title"><span class="op-icon">🔍</span>
                        搜索操作
                    </h4><div class="operation-steps"><p>1. 从根节点开始</p><p>2. 如果目标值等于当前节点，返回找到</p><p>3. 如果目标值小于当前节点，搜索左子树</p><p>4. 如果目标值大于当前节点，搜索右子树</p><p>5. 如果到达空节点，返回未找到</p></div><div class="complexity">时间复杂度：O(h)，h为树高</div></div><div class="operation-card"><h4 class="operation-title"><span class="op-icon">➕</span>
                        插入操作
                    </h4><div class="operation-steps"><p>1. 从根节点开始搜索插入位置</p><p>2. 如果新值小于当前节点，向左子树搜索</p><p>3. 如果新值大于当前节点，向右子树搜索</p><p>4. 找到空位置时，创建新节点</p><p>5. 将新节点连接到父节点</p></div><div class="complexity">时间复杂度：O(h)，h为树高</div></div><div class="operation-card"><h4 class="operation-title"><span class="op-icon">➖</span>
                        删除操作
                    </h4><div class="operation-steps"><p>1. 找到要删除的节点</p><p>2. 情况1：叶子节点，直接删除</p><p>3. 情况2：只有一个子节点，用子节点替换</p><p>4. 情况3：有两个子节点，用后继节点替换</p><p>5. 递归删除后继节点</p></div><div class="complexity">时间复杂度：O(h)，h为树高</div></div></div></div><!-- 遍历方式 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🔄</span>
                树的遍历
            </h2><div class="traversal-methods"><div class="traversal-card"><h4 class="traversal-title"><span class="traversal-icon">📝</span>
                        中序遍历 (Inorder)
                    </h4><div class="traversal-order">左子树 → 根节点 → 右子树</div><div class="traversal-feature"><strong>特点：</strong>对BST进行中序遍历得到有序序列
                    </div><div class="traversal-code"><code>inorder(node.left) → visit(node) → inorder(node.right)</code></div></div><div class="traversal-card"><h4 class="traversal-title"><span class="traversal-icon">📋</span>
                        前序遍历 (Preorder)
                    </h4><div class="traversal-order">根节点 → 左子树 → 右子树</div><div class="traversal-feature"><strong>特点：</strong>可用于复制树或获取树的前缀表达式
                    </div><div class="traversal-code"><code>visit(node) → preorder(node.left) → preorder(node.right)</code></div></div><div class="traversal-card"><h4 class="traversal-title"><span class="traversal-icon">📄</span>
                        后序遍历 (Postorder)
                    </h4><div class="traversal-order">左子树 → 右子树 → 根节点</div><div class="traversal-feature"><strong>特点：</strong>可用于安全删除树或计算目录大小
                    </div><div class="traversal-code"><code>postorder(node.left) → postorder(node.right) → visit(node)</code></div></div></div></div><!-- 代码实现 --><div class="content-section"><h2 class="section-title"><span class="section-icon">💻</span>
                代码实现
            </h2><div class="code-example"><div class="code-header"><span class="code-title">Python实现</span><button class="copy-btn" onclick="copyCode('bst-code')">复制代码</button></div><pre id="bst-code"><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """插入节点"""
        self.root = self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        if node is None:
            return TreeNode(val)
        
        if val < node.val:
            node.left = self._insert_recursive(node.left, val)
        elif val > node.val:
            node.right = self._insert_recursive(node.right, val)
        
        return node
    
    def search(self, val):
        """搜索节点"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if node is None or node.val == val:
            return node
        
        if val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)
    
    def delete(self, val):
        """删除节点"""
        self.root = self._delete_recursive(self.root, val)
    
    def _delete_recursive(self, node, val):
        if node is None:
            return node
        
        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            # 找到要删除的节点
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            
            # 节点有两个子节点，找到右子树的最小值
            min_node = self._find_min(node.right)
            node.val = min_node.val
            node.right = self._delete_recursive(node.right, min_node.val)
        
        return node
    
    def _find_min(self, node):
        """找到子树中的最小值节点"""
        while node.left:
            node = node.left
        return node
    
    def inorder_traversal(self):
        """中序遍历"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.val)
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self):
        """前序遍历"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        if node:
            result.append(node.val)
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self):
        """后序遍历"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        if node:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append(node.val)

# 使用示例
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80]
for val in values:
    bst.insert(val)

print("中序遍历:", bst.inorder_traversal())  # [20, 30, 40, 50, 60, 70, 80]
print("查找40:", bst.search(40) is not None)  # True
bst.delete(30)
print("删除30后:", bst.inorder_traversal())  # [20, 40, 50, 60, 70, 80]</code></pre></div></div><!-- 性能分析 --><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                性能分析
            </h2><div class="performance-comparison"><div class="perf-scenario"><h4 class="scenario-title"><span class="scenario-icon">🏆</span>
                        平衡树
                    </h4><div class="scenario-visual"><div class="tree-shape balanced"><div class="tree-level">50</div><div class="tree-level">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;70</div><div class="tree-level">20&nbsp;&nbsp;40&nbsp;&nbsp;60&nbsp;&nbsp;80</div></div></div><div class="scenario-stats"><p><strong>高度：</strong>O(log n)</p><p><strong>搜索：</strong>O(log n)</p><p><strong>插入：</strong>O(log n)</p><p><strong>删除：</strong>O(log n)</p></div></div><div class="perf-scenario"><h4 class="scenario-title"><span class="scenario-icon">⚠️</span>
                        退化树
                    </h4><div class="scenario-visual"><div class="tree-shape degenerate"><div class="tree-level">10</div><div class="tree-level">&nbsp;&nbsp;20</div><div class="tree-level">&nbsp;&nbsp;&nbsp;&nbsp;30</div><div class="tree-level">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40</div></div></div><div class="scenario-stats"><p><strong>高度：</strong>O(n)</p><p><strong>搜索：</strong>O(n)</p><p><strong>插入：</strong>O(n)</p><p><strong>删除：</strong>O(n)</p></div></div></div></div><!-- 应用场景 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🎯</span>
                实际应用
            </h2><div class="application-grid"><div class="app-card"><span class="app-icon">🗃️</span><h4>数据库索引</h4><p>B树和B+树是BST的变种</p></div><div class="app-card"><span class="app-icon">📁</span><h4>文件系统</h4><p>目录结构和文件索引</p></div><div class="app-card"><span class="app-icon">🔍</span><h4>搜索引擎</h4><p>倒排索引和关键词搜索</p></div><div class="app-card"><span class="app-icon">🎮</span><h4>游戏开发</h4><p>碰撞检测和空间分割</p></div></div></div></div><!-- 学习提示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">💡</span>
                学习要点
            </h2><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">📏</span><strong>BST性质：</strong>深入理解左小右大的有序性质。
                </div><div class="info-box info-box-success"><span class="info-icon">🔄</span><strong>递归思维：</strong>掌握递归实现各种操作的方法。
                </div><div class="info-box info-box-warning"><span class="info-icon">⚠️</span><strong>退化问题：</strong>了解BST可能退化为链表的情况。
                </div><div class="info-box info-box-info"><span class="info-icon">⚖️</span><strong>平衡优化：</strong>学习AVL树、红黑树等自平衡变种。
                </div></div></div></div></div><style>.interactive-demo {background:#f8f9fa;border-radius:12px;padding:25px;margin:20px 0}.demo-controls {display:flex;flex-direction:column;gap:15px;margin-bottom:25px}.control-group {display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center}.control-group input {padding:8px 12px;border:1px solid #ddd;border-radius:6px;width:150px}.demo-btn {padding:8px 16px;background:#6c757d;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:500;transition:all 0.3s ease;font-size:14px}.demo-btn.primary {background:#007bff}.demo-btn:hover {transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,0.2)}.tree-display {background:white;border-radius:8px;padding:30px;border:1px solid #e9ecef;margin:20px 0;min-height:300px;display:flex;justify-content:center;align-items:center;overflow:auto}.empty-tree {color:#999;font-style:italic;font-size:18px}.tree-node {position:relative;display:inline-block;margin:10px}.node-circle {width:40px;height:40px;border-radius:50%;background:#007bff;color:white;display:flex;align-items:center;justify-content:center;font-weight:600;font-size:14px;transition:all 0.3s ease;position:relative;z-index:2}.node-circle.highlight {background:#ffc107;color:#333;transform:scale(1.2);box-shadow:0 4px 12px rgba(255,193,7,0.4)}.node-circle.found {background:#28a745;animation:pulse 1s infinite}.node-circle.deleted {background:#dc3545;animation:fadeOut 1s ease-out}.tree-info {background:white;border-radius:8px;padding:20px;border:1px solid #e9ecef}.info-row {display:grid;grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));gap:15px;margin-bottom:15px}.info-item {text-align:center;padding:10px;background:#f8f9fa;border-radius:6px}.info-label {display:block;font-size:14px;color:#666;margin-bottom:5px}.info-item span:last-child {font-size:18px;font-weight:600;color:#007bff}.operation-result, .traversal-result {text-align:center;padding:15px;border-radius:8px;font-weight:600;margin-top:15px}.operation-result.success, .traversal-result {background:#d4edda;color:#155724;border:1px solid #c3e6cb}.operation-result.error {background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}.operations-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:20px;margin:20px 0}.operation-card {background:#f8f9fa;padding:20px;border-radius:12px;border:1px solid #e9ecef}.operation-title {display:flex;align-items:center;gap:10px;margin-bottom:15px;color:#333}.operation-steps {margin:15px 0}.operation-steps p {margin:5px 0;color:#555;font-size:14px}.complexity {background:#e9ecef;padding:8px 12px;border-radius:6px;font-size:14px;color:#495057;font-weight:600;margin-top:10px}.traversal-methods {display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:20px;margin:20px 0}.traversal-card {background:#f8f9fa;padding:20px;border-radius:12px;border:1px solid #e9ecef}.traversal-title {display:flex;align-items:center;gap:10px;margin-bottom:15px;color:#333}.traversal-order {background:#e9ecef;padding:10px;border-radius:6px;text-align:center;font-weight:600;margin:10px 0;color:#495057}.traversal-feature {color:#666;margin:10px 0;font-size:14px}.traversal-code {background:#2d3748;color:#e2e8f0;padding:10px;border-radius:6px;font-family:'Courier New', monospace;font-size:13px;margin-top:10px}.performance-comparison {display:grid;grid-template-columns:repeat(auto-fit, minmax(350px, 1fr));gap:30px;margin:20px 0}.perf-scenario {background:#f8f9fa;padding:25px;border-radius:12px;border:1px solid #e9ecef;text-align:center}.scenario-title {display:flex;align-items:center;justify-content:center;gap:10px;margin-bottom:20px;color:#333}.scenario-visual {margin:20px 0;padding:20px;background:white;border-radius:8px;border:1px solid #ddd}.tree-shape {font-family:'Courier New', monospace;font-size:14px;line-height:1.8}.tree-shape.balanced {color:#28a745}.tree-shape.degenerate {color:#dc3545}.tree-level {margin:5px 0}.scenario-stats p {margin:8px 0;color:#555;font-size:14px}.application-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:20px;margin:20px 0}.app-card {background:#f8f9fa;padding:20px;border-radius:12px;text-align:center;border:1px solid #e9ecef;transition:all 0.3s ease}.app-card:hover {transform:translateY(-5px);box-shadow:0 8px 25px rgba(0,0,0,0.1);background:white}.app-icon {font-size:2rem;display:block;margin-bottom:15px}.app-card h4 {color:#333;margin-bottom:10px}.app-card p {color:#666;font-size:14px}@keyframes pulse {0%, 100% {transform:scale(1.2)}50% {transform:scale(1.4)}}@keyframes fadeOut {from {opacity:1;transform:scale(1)}to {opacity:0;transform:scale(0.8)}}@media (max-width:768px) {.control-group {flex-direction:column;align-items:stretch}.control-group input {width:100%}.demo-btn {width:100%;margin:2px 0}.info-row {grid-template-columns:1fr}.operations-grid, .traversal-methods, .performance-comparison {grid-template-columns:1fr}.tree-display {padding:15px;overflow-x:auto}}</style><script>class TreeNode { constructor(val) { this.val = val; this.left = null; this.right = null; } } class BinarySearchTree { constructor() { this.root = null; this.nodeCount = 0; } insert(val) { if (this.search(val)) { return { success: false, message: `节点 ${val} 已存在` }; } this.root = this._insertRecursive(this.root, val); this.nodeCount++; return { success: true, message: `成功插入节点 ${val}` }; } _insertRecursive(node, val) { if (node === null) { return new TreeNode(val); } if (val < node.val) { node.left = this._insertRecursive(node.left, val); } else if (val > node.val) { node.right = this._insertRecursive(node.right, val); } return node; } search(val) { return this._searchRecursive(this.root, val); } _searchRecursive(node, val) { if (node === null) { return false; } if (val === node.val) { return true; } if (val < node.val) { return this._searchRecursive(node.left, val); } else { return this._searchRecursive(node.right, val); } } delete(val) { if (!this.search(val)) { return { success: false, message: `节点 ${val} 不存在` }; } this.root = this._deleteRecursive(this.root, val); this.nodeCount--; return { success: true, message: `成功删除节点 ${val}` }; } _deleteRecursive(node, val) { if (node === null) { return node; } if (val < node.val) { node.left = this._deleteRecursive(node.left, val); } else if (val > node.val) { node.right = this._deleteRecursive(node.right, val); } else { if (node.left === null) { return node.right; } else if (node.right === null) { return node.left; } const minNode = this._findMin(node.right); node.val = minNode.val; node.right = this._deleteRecursive(node.right, minNode.val); } return node; } _findMin(node) { while (node.left !== null) { node = node.left; } return node; } getHeight() { return this._getHeightRecursive(this.root); } _getHeightRecursive(node) { if (node === null) { return 0; } const leftHeight = this._getHeightRecursive(node.left); const rightHeight = this._getHeightRecursive(node.right); return Math.max(leftHeight, rightHeight) + 1; } getMin() { if (this.root === null) return null; const minNode = this._findMin(this.root); return minNode.val; } getMax() { if (this.root === null) return null; let node = this.root; while (node.right !== null) { node = node.right; } return node.val; } inorderTraversal() { const result = []; this._inorderRecursive(this.root, result); return result; } _inorderRecursive(node, result) { if (node !== null) { this._inorderRecursive(node.left, result); result.push(node.val); this._inorderRecursive(node.right, result); } } preorderTraversal() { const result = []; this._preorderRecursive(this.root, result); return result; } _preorderRecursive(node, result) { if (node !== null) { result.push(node.val); this._preorderRecursive(node.left, result); this._preorderRecursive(node.right, result); } } postorderTraversal() { const result = []; this._postorderRecursive(this.root, result); return result; } _postorderRecursive(node, result) { if (node !== null) { this._postorderRecursive(node.left, result); this._postorderRecursive(node.right, result); result.push(node.val); } } clear() { this.root = null; this.nodeCount = 0; } } let bst = new BinarySearchTree(); function displayTree() { const displayElement = document.getElementById('tree-display'); if (bst.root === null) { displayElement.innerHTML = '<div class="empty-tree">树为空，请插入节点</div>'; return; } const inorder = bst.inorderTraversal(); displayElement.innerHTML = ` <div style="text-align: center;"><div style="margin-bottom: 20px; font-size: 18px; color: #333;"> 树结构（中序遍历） </div><div style="display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;"> ${inorder.map(val => ` <div class="node-circle" id="node-${val}"> ${val} </div> `).join('')} </div><div style="margin-top: 15px; font-size: 14px; color: #666;"> 有序序列：${inorder.join(' → ')} </div></div> `; } function updateInfo() { document.getElementById('node-count').textContent = bst.nodeCount; document.getElementById('tree-height').textContent = bst.getHeight(); document.getElementById('min-value').textContent = bst.getMin() || '-'; document.getElementById('max-value').textContent = bst.getMax() || '-'; } function showOperationResult(result) { const resultElement = document.getElementById('operation-result'); resultElement.textContent = result.message; resultElement.className = `operation-result ${result.success ? 'success' : 'error'}`; } function insertNode() { const input = document.getElementById('node-value'); const value = parseInt(input.value); if (isNaN(value) || value < 1 || value > 99) { showOperationResult({ success: false, message: '请输入1-99之间的数字' }); return; } const result = bst.insert(value); displayTree(); updateInfo(); showOperationResult(result); if (result.success) { setTimeout(() => { const nodeElement = document.getElementById(`node-${value}`); if (nodeElement) { nodeElement.classList.add('highlight'); setTimeout(() => { nodeElement.classList.remove('highlight'); }, 2000); } }, 100); } input.value = ''; } function searchNode() { const input = document.getElementById('node-value'); const value = parseInt(input.value); if (isNaN(value)) { showOperationResult({ success: false, message: '请输入要查找的数字' }); return; } const found = bst.search(value); const result = { success: found, message: found ? `找到节点 ${value}` : `未找到节点 ${value}` }; showOperationResult(result); if (found) { setTimeout(() => { const nodeElement = document.getElementById(`node-${value}`); if (nodeElement) { nodeElement.classList.add('found'); setTimeout(() => { nodeElement.classList.remove('found'); }, 2000); } }, 100); } } function deleteNode() { const input = document.getElementById('node-value'); const value = parseInt(input.value); if (isNaN(value)) { showOperationResult({ success: false, message: '请输入要删除的数字' }); return; } const result = bst.delete(value); displayTree(); updateInfo(); showOperationResult(result); input.value = ''; } function clearTree() { bst.clear(); displayTree(); updateInfo(); showOperationResult({ success: true, message: '树已清空' }); document.getElementById('node-value').value = ''; document.getElementById('traversal-result').textContent = ''; } function generateRandomTree() { bst.clear(); const count = Math.floor(Math.random() * 4) + 5; const values = new Set(); while (values.size < count) { values.add(Math.floor(Math.random() * 90) + 10); } Array.from(values).forEach(val => bst.insert(val)); displayTree(); updateInfo(); showOperationResult({ success: true, message: `生成了包含 ${count} 个节点的随机树` }); } function showTraversal(type) { if (bst.nodeCount === 0) { showOperationResult({ success: false, message: '树为空，无法遍历' }); return; } let result, typeName; switch (type) { case 'inorder': result = bst.inorderTraversal(); typeName = '中序遍历'; break; case 'preorder': result = bst.preorderTraversal(); typeName = '前序遍历'; break; case 'postorder': result = bst.postorderTraversal(); typeName = '后序遍历'; break; } const resultElement = document.getElementById('traversal-result'); resultElement.textContent = `${typeName}结果：${result.join(' → ')}`; resultElement.className = 'traversal-result'; } function copyCode(elementId) { const codeElement = document.getElementById(elementId); const text = codeElement.textContent; navigator.clipboard.writeText(text).then(() => { alert('代码已复制到剪贴板！'); }).catch(() => { alert('复制失败，请手动复制'); }); } document.addEventListener('DOMContentLoaded', function() { displayTree(); updateInfo(); document.getElementById('node-value').addEventListener('keypress', function(e) { if (e.key === 'Enter') { insertNode(); } }); });</script>

{% endblock %}
