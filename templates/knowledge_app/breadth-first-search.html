{% extends 'knowledge_app/base.html' %}

{% block title %}{{ page_title|default:"队列与广度优先搜索" }} - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>{{ breadcrumb_category|default:"数据结构与算法" }}</span>
        <span>></span>
        <span>{{ page_title|default:"队列与广度优先搜索" }}</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">{{ page_icon|default:"🚶‍♂️" }}</span>
            {{ page_title|default:"队列与广度优先搜索" }}
        </h1>
        <p>{{ page_description|default:"探索队列如何驱动BFS算法，实现层层推进的搜索策略" }}</p>
    </div>

    <!-- 📋 知识点概述 -->
    <div class="content-card slide-in-right">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📋</span>
                知识点概述
            </h2>
            <div class="overview-content">
                <div class="concept-intro">
                    <p><strong>核心概念：</strong>队列就像排队买票的队伍——先到先服务！而BFS就像水波纹扩散，一圈圈向外搜索。队列的FIFO(先进先出)特性完美支撑了BFS的层次遍历需求！</p>
                </div>

                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <h3>🏷️ 关键术语</h3>
                        <ul>
                            <li><strong>队列(Queue)：</strong>FIFO线性数据结构</li>
                            <li><strong>入队(Enqueue)：</strong>在队尾添加元素</li>
                            <li><strong>出队(Dequeue)：</strong>从队头移除元素</li>
                            <li><strong>BFS：</strong>逐层搜索的图遍历算法</li>
                            <li><strong>访问顺序：</strong>按距离起点的层次访问</li>
                        </ul>
                    </div>

                    <div class="info-box info-box-success">
                        <h3>📊 学习指标</h3>
                        <p><strong>难度等级：</strong> <span class="badge badge-medium">进阶</span></p>
                        <p><strong>前置知识：</strong></p>
                        <ul>
                            <li>线性数据结构 ✓</li>
                            <li>图的基本概念 ✓</li>
                            <li>递归与迭代 ✓</li>
                            <li>算法时间复杂度 ✓</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 🔍 概念详解 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🔍</span>
                概念详解
            </h2>

            <div class="concept-details">
                <div class="concept-item">
                    <h3>🏗️ 队列的FIFO特性</h3>
                    <p>想象一个电影院的入场队列：</p>
                    <ul>
                        <li>队头(Front)：第一个排队的人，最先入场</li>
                        <li>队尾(Rear)：最后一个排队的人，最后入场</li>
                        <li>入队：新人总是排到队伍最后</li>
                        <li>出队：总是从队头开始让人入场</li>
                        <li>公平原则：先来后到，绝不插队！</li>
                    </ul>

                    <div class="fifo-demo">
                        <div class="queue-visual">
                            <div class="queue-label">队头 → 出队</div>
                            <div class="queue-container">
                                <div class="queue-element">A</div>
                                <div class="queue-element">B</div>
                                <div class="queue-element">C</div>
                                <div class="queue-element">D</div>
                            </div>
                            <div class="queue-label">队尾 ← 入队</div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🌊 BFS的层次搜索策略</h3>
                    <div class="bfs-strategy">
                        <div class="strategy-explanation">
                            <h4>🎯 BFS核心思想</h4>
                            <p>就像池塘里扔石头产生的水波纹，从起点开始一圈圈向外扩散：</p>
                            <ul>
                                <li><strong>第1层：</strong>起点本身</li>
                                <li><strong>第2层：</strong>距离起点1步的所有节点</li>
                                <li><strong>第3层：</strong>距离起点2步的所有节点</li>
                                <li><strong>第n层：</strong>距离起点n-1步的所有节点</li>
                            </ul>
                        </div>

                        <div class="ripple-demo">
                            <div class="ripple-container">
                                <div class="ripple-layer layer-1">
                                    <span>起点</span>
                                </div>
                                <div class="ripple-layer layer-2">
                                    <span>第2层</span>
                                </div>
                                <div class="ripple-layer layer-3">
                                    <span>第3层</span>
                                </div>
                                <div class="ripple-layer layer-4">
                                    <span>第4层</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🤝 队列与BFS的完美配合</h3>
                    <div class="perfect-match">
                        <div class="match-explanation">
                            <h4>💡 为什么队列是BFS的最佳搭档？</h4>
                            <div class="reason-cards">
                                <div class="reason-card">
                                    <span class="reason-icon">🎯</span>
                                    <h5>层次保证</h5>
                                    <p>队列确保先访问第k层的所有节点，再访问第k+1层</p>
                                </div>
                                <div class="reason-card">
                                    <span class="reason-icon">⚖️</span>
                                    <h5>公平性</h5>
                                    <p>同一层的节点按发现顺序访问，不会出现"插队"</p>
                                </div>
                                <div class="reason-card">
                                    <span class="reason-icon">🔄</span>
                                    <h5>状态管理</h5>
                                    <p>队列自然地维护了"待访问"节点的顺序</p>
                                </div>
                                <div class="reason-card">
                                    <span class="reason-icon">📏</span>
                                    <h5>最短路径</h5>
                                    <p>保证找到的路径是最短的（无权图）</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>⚠️ 对比：为什么不用栈？</h3>
                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>数据结构</th>
                                    <th>搜索方式</th>
                                    <th>访问顺序</th>
                                    <th>适用算法</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="queue-row">
                                    <td>队列 (FIFO)</td>
                                    <td>横向优先</td>
                                    <td>按层次，先宽后深</td>
                                    <td>BFS广度优先搜索</td>
                                </tr>
                                <tr class="stack-row">
                                    <td>栈 (LIFO)</td>
                                    <td>纵向优先</td>
                                    <td>尽量深入，先深后宽</td>
                                    <td>DFS深度优先搜索</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 📊 可视化展示 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📊</span>
                可视化展示
            </h2>

            <!-- BFS演示控制面板 -->
            <div class="visualization-container">
                <h3>🎬 BFS队列动画演示</h3>
                <div class="demo-controls">
                    <div class="control-panel">
                        <button id="autoDemo" class="unified-btn unified-btn-success">🚀 自动BFS演示</button>
                        <button id="stepDemo" class="unified-btn unified-btn-primary">👆 单步执行</button>
                        <button id="resetDemo" class="unified-btn unified-btn-secondary">🔄 重置</button>
                    </div>
                    <div class="graph-selector">
                        <label>选择演示场景：</label>
                        <select id="graphType">
                            <option value="simple">简单图遍历</option>
                            <option value="maze">迷宫路径搜索</option>
                            <option value="tree">二叉树层次遍历</option>
                            <option value="social">社交网络传播</option>
                        </select>
                        <label>起始节点：</label>
                        <select id="startNode">
                            <option value="0">节点 0</option>
                            <option value="1">节点 1</option>
                            <option value="2">节点 2</option>
                            <option value="3">节点 3</option>
                        </select>
                    </div>
                    <div class="speed-control">
                        <label>演示速度：</label>
                        <input type="range" id="speedSlider" min="500" max="3000" value="1500" step="250">
                        <span id="speedLabel">正常</span>
                    </div>
                </div>

                <div class="demo-info" id="demoInfo">
                    点击"自动BFS演示"观看完整的广度优先搜索过程
                </div>

                <!-- 主要可视化区域 -->
                <div class="visualization-area">
                    <!-- 图结构展示 -->
                    <div class="graph-area">
                        <h4>🌐 图结构</h4>
                        <canvas id="graphCanvas" width="500" height="400"></canvas>
                        <div class="graph-legend">
                            <div class="legend-item">
                                <div class="legend-dot unvisited"></div>
                                <span>未访问</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-dot current"></div>
                                <span>当前处理</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-dot visited"></div>
                                <span>已访问</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-dot queued"></div>
                                <span>在队列中</span>
                            </div>
                        </div>
                    </div>

                    <!-- 队列状态展示 -->
                    <div class="queue-area">
                        <h4>📋 队列状态</h4>
                        <div class="queue-display" id="queueDisplay">
                            <div class="queue-header">
                                <span class="queue-front-label">队头 (出队)</span>
                                <span class="queue-rear-label">队尾 (入队)</span>
                            </div>
                            <div class="queue-body" id="queueBody">
                                <div class="empty-queue">队列为空</div>
                            </div>
                        </div>
                        <div class="queue-stats" id="queueStats">
                            <div>队列长度: <span id="queueLength">0</span></div>
                            <div>已访问: <span id="visitedCount">0</span></div>
                            <div>当前层: <span id="currentLevel">0</span></div>
                        </div>
                    </div>
                </div>

                <!-- 步骤详解 -->
                <div class="step-details" id="stepDetails">
                    <h4>📝 执行步骤</h4>
                    <div class="step-list" id="stepList">
                        <div class="step-item">准备开始BFS遍历...</div>
                    </div>
                </div>
            </div>

            <!-- BFS算法伪代码 -->
            <div class="algorithm-pseudocode">
                <h3>🔧 BFS算法伪代码</h3>
                <div class="pseudocode-container">
                    <pre class="pseudocode" id="pseudocode">
<span class="keyword">function</span> <span class="function">BFS</span>(<span class="param">graph, start</span>):
    <span class="comment">// 1. 初始化</span>
    <span class="variable">queue</span> ← <span class="function">新建空队列()</span>
    <span class="variable">visited</span> ← <span class="function">新建空集合()</span>

    <span class="comment">// 2. 将起点加入队列</span>
    <span class="function">queue.enqueue</span>(<span class="variable">start</span>)
    <span class="function">visited.add</span>(<span class="variable">start</span>)

    <span class="comment">// 3. 队列不空时持续处理</span>
    <span class="keyword">while</span> <span class="function">queue.不为空</span>():
        <span class="comment">// 4. 取出队头元素</span>
        <span class="variable">current</span> ← <span class="function">queue.dequeue</span>()
        <span class="function">处理</span>(<span class="variable">current</span>)

        <span class="comment">// 5. 遍历所有邻居</span>
        <span class="keyword">for each</span> <span class="variable">neighbor</span> <span class="keyword">in</span> <span class="function">graph.邻接表</span>[<span class="variable">current</span>]:
            <span class="keyword">if</span> <span class="variable">neighbor</span> <span class="keyword">not in</span> <span class="variable">visited</span>:
                <span class="comment">// 6. 未访问的邻居加入队列</span>
                <span class="function">queue.enqueue</span>(<span class="variable">neighbor</span>)
                <span class="function">visited.add</span>(<span class="variable">neighbor</span>)
                    </pre>
                    <div class="highlight-line" id="highlightLine"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 🌟 实际应用 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🌟</span>
                实际应用场景
            </h2>

            <div class="applications">
                <div class="application-item featured">
                    <h3>🗺️ 最短路径寻找</h3>
                    <p>在无权图中寻找两点间的最短路径，如游戏中的路径规划、迷宫求解等。</p>
                    <div class="application-details">
                        <h4>应用特点：</h4>
                        <ul>
                            <li>保证找到的路径步数最少</li>
                            <li>队列确保按距离递增的顺序访问</li>
                            <li>第一次访问到目标就是最短路径</li>
                        </ul>
                        <div class="use-case">
                            <strong>典型场景：</strong>GPS导航、游戏AI寻路、网络路由
                        </div>
                    </div>
                </div>

                <div class="application-item">
                    <h3>🌳 树的层次遍历</h3>
                    <p>按层次从上到下、从左到右遍历二叉树，常用于树的序列化和打印。</p>
                    <div class="mini-example">
                        <strong>示例：</strong>打印二叉树每一层的节点
                    </div>
                </div>

                <div class="application-item">
                    <h3>🔥 病毒传播模拟</h3>
                    <p>模拟病毒在网络中的传播过程，每一轮传播对应BFS的一层扩展。</p>
                    <div class="mini-example">
                        <strong>场景：</strong>社交网络信息传播、计算机病毒扩散
                    </div>
                </div>

                <div class="application-item">
                    <h3>🏝️ 连通分量检测</h3>
                    <p>检测图中的连通分量，如岛屿数量统计、网络分区检测。</p>
                    <div class="mini-example">
                        <strong>应用：</strong>图像处理中的区域分割、网络拓扑分析
                    </div>
                </div>

                <div class="application-item">
                    <h3>🎯 状态空间搜索</h3>
                    <p>在状态图中搜索目标状态，如8数码问题、魔方求解等。</p>
                    <div class="mini-example">
                        <strong>特色：</strong>保证找到步数最少的解决方案
                    </div>
                </div>
            </div>

            <!-- 代码示例 -->
            <div class="code-examples">
                <h3>💻 代码实现</h3>
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="cpp">C++</button>
                    <button class="tab-btn" data-lang="java">Java</button>
                    <button class="tab-btn" data-lang="python">Python</button>
                </div>

                <!-- C++ 代码 -->
                <div class="code-content active" data-lang="cpp">
                    <div class="code-header">
                        <span>BFS经典实现 - C++</span>
                        <button class="copy-btn" data-clipboard-target="cpp-code">📋 复制</button>
                    </div>
                    <pre id="cpp-code"><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;

class Graph {
private:
    int V;
    std::vector&lt;std::vector&lt;int&gt;&gt; adj;

public:
    Graph(int vertices) : V(vertices), adj(vertices) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);  // 无向图
    }

    // 基本BFS遍历
    void BFS(int start) {
        std::vector&lt;bool&gt; visited(V, false);
        std::queue&lt;int&gt; q;

        // 初始化：起点入队并标记为已访问
        q.push(start);
        visited[start] = true;

        std::cout << "BFS遍历顺序: ";

        while (!q.empty()) {
            // 出队并处理当前节点
            int current = q.front();
            q.pop();
            std::cout << current << " ";

            // 遍历所有未访问的邻居
            for (int neighbor : adj[current]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                }
            }
        }
        std::cout << std::endl;
    }

    // BFS寻找最短路径
    std::vector&lt;int&gt; shortestPath(int start, int target) {
        std::vector&lt;bool&gt; visited(V, false);
        std::vector&lt;int&gt; parent(V, -1);
        std::queue&lt;int&gt; q;

        q.push(start);
        visited[start] = true;

        while (!q.empty()) {
            int current = q.front();
            q.pop();

            if (current == target) {
                // 重建路径
                std::vector&lt;int&gt; path;
                int node = target;
                while (node != -1) {
                    path.push_back(node);
                    node = parent[node];
                }
                std::reverse(path.begin(), path.end());
                return path;
            }

            for (int neighbor : adj[current]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                }
            }
        }

        return {}; // 无路径
    }

    // BFS层次遍历（返回每层的节点）
    std::vector&lt;std::vector&lt;int&gt;&gt; levelOrderTraversal(int start) {
        std::vector&lt;std::vector&lt;int&gt;&gt; levels;
        std::vector&lt;bool&gt; visited(V, false);
        std::queue&lt;int&gt; q;

        q.push(start);
        visited[start] = true;

        while (!q.empty()) {
            int levelSize = q.size();
            std::vector&lt;int&gt; currentLevel;

            // 处理当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                int current = q.front();
                q.pop();
                currentLevel.push_back(current);

                // 将下一层节点加入队列
                for (int neighbor : adj[current]) {
                    if (!visited[neighbor]) {
                        q.push(neighbor);
                        visited[neighbor] = true;
                    }
                }
            }
            levels.push_back(currentLevel);
        }

        return levels;
    }
};

// 迷宫求解示例
class MazeSolver {
private:
    std::vector&lt;std::vector&lt;int&gt;&gt; maze;
    int rows, cols;
    int dx[4] = {-1, 1, 0, 0};  // 上下左右
    int dy[4] = {0, 0, -1, 1};

public:
    MazeSolver(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; m) : maze(m) {
        rows = maze.size();
        cols = maze[0].size();
    }

    int shortestPath(int startX, int startY, int endX, int endY) {
        if (maze[startX][startY] == 1 || maze[endX][endY] == 1) {
            return -1; // 起点或终点被墙挡住
        }

        std::vector&lt;std::vector&lt;bool&gt;&gt; visited(rows,
            std::vector&lt;bool&gt;(cols, false));
        std::queue&lt;std::tuple&lt;int, int, int&gt;&gt; q; // x, y, 距离

        q.push({startX, startY, 0});
        visited[startX][startY] = true;

        while (!q.empty()) {
            auto [x, y, dist] = q.front();
            q.pop();

            if (x == endX && y == endY) {
                return dist;
            }

            // 探索四个方向
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];

                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols &&
                    !visited[nx][ny] && maze[nx][ny] == 0) {
                    q.push({nx, ny, dist + 1});
                    visited[nx][ny] = true;
                }
            }
        }

        return -1; // 无路径
    }
};
                    </code></pre>
                </div>

                <!-- Java 代码 -->
                <div class="code-content" data-lang="java">
                    <div class="code-header">
                        <span>BFS经典实现 - Java</span>
                        <button class="copy-btn" data-clipboard-target="java-code">📋 复制</button>
                    </div>
                    <pre id="java-code"><code>
import java.util.*;

public class BFSImplementation {

    // 图的BFS遍历
    static class Graph {
        private int V;
        private List&lt;Integer&gt;[] adj;

        @SuppressWarnings("unchecked")
        public Graph(int V) {
            this.V = V;
            adj = new ArrayList[V];
            for (int i = 0; i < V; i++) {
                adj[i] = new ArrayList&lt;&gt;();
            }
        }

        public void addEdge(int u, int v) {
            adj[u].add(v);
            adj[v].add(u); // 无向图
        }

        public void BFS(int start) {
            boolean[] visited = new boolean[V];
            Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

            queue.offer(start);
            visited[start] = true;

            System.out.print("BFS遍历顺序: ");

            while (!queue.isEmpty()) {
                int current = queue.poll();
                System.out.print(current + " ");

                for (int neighbor : adj[current]) {
                    if (!visited[neighbor]) {
                        queue.offer(neighbor);
                        visited[neighbor] = true;
                    }
                }
            }
            System.out.println();
        }

        // 层次遍历
        public List&lt;List&lt;Integer&gt;&gt; levelOrder(int start) {
            List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
            boolean[] visited = new boolean[V];
            Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

            queue.offer(start);
            visited[start] = true;

            while (!queue.isEmpty()) {
                int size = queue.size();
                List&lt;Integer&gt; level = new ArrayList&lt;&gt;();

                for (int i = 0; i < size; i++) {
                    int current = queue.poll();
                    level.add(current);

                    for (int neighbor : adj[current]) {
                        if (!visited[neighbor]) {
                            queue.offer(neighbor);
                            visited[neighbor] = true;
                        }
                    }
                }
                result.add(level);
            }

            return result;
        }
    }

    // 二叉树层次遍历
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) return result;

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();

            for (int i = 0; i < levelSize; i++) {
                TreeNode current = queue.poll();
                level.add(current.val);

                if (current.left != null) {
                    queue.offer(current.left);
                }
                if (current.right != null) {
                    queue.offer(current.right);
                }
            }
            result.add(level);
        }

        return result;
    }

    // 岛屿数量问题（BFS版本）
    public static int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int rows = grid.length;
        int cols = grid[0].length;
        boolean[][] visited = new boolean[rows][cols];
        int[][] directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };
        int count = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    // 发现新岛屿，使用BFS标记整个岛屿
                    Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
                    queue.offer(new int[]{i, j});
                    visited[i][j] = true;

                    while (!queue.isEmpty()) {
                        int[] current = queue.poll();
                        int x = current[0], y = current[1];

                        for (int[] dir : directions) {
                            int nx = x + dir[0];
                            int ny = y + dir[1];

                            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols &&
                                grid[nx][ny] == '1' && !visited[nx][ny]) {
                                queue.offer(new int[]{nx, ny});
                                visited[nx][ny] = true;
                            }
                        }
                    }
                    count++;
                }
            }
        }

        return count;
    }

    public static void main(String[] args) {
        // 测试图遍历
        Graph g = new Graph(6);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 3);
        g.addEdge(2, 4);
        g.addEdge(3, 5);
        g.addEdge(4, 5);

        g.BFS(0);

        System.out.println("层次遍历结果:");
        List&lt;List&lt;Integer&gt;&gt; levels = g.levelOrder(0);
        for (int i = 0; i < levels.size(); i++) {
            System.out.println("第" + (i+1) + "层: " + levels.get(i));
        }
    }
}
                    </code></pre>
                </div>

                <!-- Python 代码 -->
                <div class="code-content" data-lang="python">
                    <div class="code-header">
                        <span>BFS经典实现 - Python</span>
                        <button class="copy-btn" data-clipboard-target="python-code">📋 复制</button>
                    </div>
                    <pre id="python-code"><code>
from collections import deque
from typing import List, Optional

class Graph:
    """图的BFS实现"""

    def __init__(self, vertices: int):
        self.V = vertices
        self.adj = [[] for _ in range(vertices)]

    def add_edge(self, u: int, v: int):
        """添加边（无向图）"""
        self.adj[u].append(v)
        self.adj[v].append(u)

    def bfs(self, start: int) -> List[int]:
        """基本BFS遍历"""
        visited = [False] * self.V
        queue = deque([start])
        visited[start] = True
        result = []

        while queue:
            current = queue.popleft()
            result.append(current)

            for neighbor in self.adj[current]:
                if not visited[neighbor]:
                    queue.append(neighbor)
                    visited[neighbor] = True

        return result

    def shortest_path(self, start: int, target: int) -> Optional[List[int]]:
        """BFS寻找最短路径"""
        if start == target:
            return [start]

        visited = [False] * self.V
        parent = [-1] * self.V
        queue = deque([start])
        visited[start] = True

        while queue:
            current = queue.popleft()

            for neighbor in self.adj[current]:
                if not visited[neighbor]:
                    queue.append(neighbor)
                    visited[neighbor] = True
                    parent[neighbor] = current

                    if neighbor == target:
                        # 重建路径
                        path = []
                        node = target
                        while node != -1:
                            path.append(node)
                            node = parent[node]
                        return path[::-1]

        return None  # 无路径

    def level_order_traversal(self, start: int) -> List[List[int]]:
        """层次遍历"""
        visited = [False] * self.V
        queue = deque([start])
        visited[start] = True
        levels = []

        while queue:
            level_size = len(queue)
            current_level = []

            for _ in range(level_size):
                current = queue.popleft()
                current_level.append(current)

                for neighbor in self.adj[current]:
                    if not visited[neighbor]:
                        queue.append(neighbor)
                        visited[neighbor] = True

            levels.append(current_level)

        return levels

class TreeNode:
    """二叉树节点"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order_tree(root: TreeNode) -> List[List[int]]:
    """二叉树层次遍历"""
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        level = []

        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)

    return result

def num_islands(grid: List[List[str]]) -> int:
    """岛屿数量问题（BFS解法）"""
    if not grid or not grid[0]:
        return 0

    rows, cols = len(grid), len(grid[0])
    visited = [[False] * cols for _ in range(rows)]
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    count = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1' and not visited[i][j]:
                # 发现新岛屿，用BFS标记整个岛屿
                queue = deque([(i, j)])
                visited[i][j] = True

                while queue:
                    x, y = queue.popleft()

                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy

                        if (0 <= nx < rows and 0 <= ny < cols and
                            grid[nx][ny] == '1' and not visited[nx][ny]):
                            queue.append((nx, ny))
                            visited[nx][ny] = True

                count += 1

    return count

def shortest_path_maze(maze: List[List[int]],
                      start: tuple, end: tuple) -> int:
    """迷宫最短路径（BFS）"""
    if not maze or maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:
        return -1

    rows, cols = len(maze), len(maze[0])
    visited = [[False] * cols for _ in range(rows)]
    queue = deque([(start[0], start[1], 0)])  # x, y, 距离
    visited[start[0]][start[1]] = True
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    while queue:
        x, y, dist = queue.popleft()

        if (x, y) == end:
            return dist

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if (0 <= nx < rows and 0 <= ny < cols and
                not visited[nx][ny] and maze[nx][ny] == 0):
                queue.append((nx, ny, dist + 1))
                visited[nx][ny] = True

    return -1  # 无路径

# 病毒传播模拟
def virus_spread_simulation(network: List[List[int]],
                           initial_infected: List[int]) -> List[List[int]]:
    """模拟病毒传播过程"""
    n = len(network)
    infected = set(initial_infected)
    spread_history = [initial_infected.copy()]
    queue = deque(initial_infected)

    while queue:
        level_size = len(queue)
        new_infected = []

        for _ in range(level_size):
            current = queue.popleft()

            # 传播给邻居
            for neighbor in range(n):
                if network[current][neighbor] == 1 and neighbor not in infected:
                    infected.add(neighbor)
                    queue.append(neighbor)
                    new_infected.append(neighbor)

        if new_infected:
            spread_history.append(new_infected)

    return spread_history

# 使用示例
if __name__ == "__main__":
    # 创建图并测试
    g = Graph(6)
    edges = [(0,1), (0,2), (1,3), (2,4), (3,5), (4,5)]

    for u, v in edges:
        g.add_edge(u, v)

    print("BFS遍历:", g.bfs(0))
    print("最短路径 0->5:", g.shortest_path(0, 5))

    levels = g.level_order_traversal(0)
    for i, level in enumerate(levels):
        print(f"第{i+1}层: {level}")

    # 测试迷宫
    maze = [
        [0, 0, 1, 0, 0],
        [0, 0, 0, 0, 1],
        [1, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0]
    ]

    distance = shortest_path_maze(maze, (0, 0), (4, 4))
    print(f"迷宫最短距离: {distance}")
                    </code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- ✅ 学习检验 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">✅</span>
                学习检验
            </h2>

            <div class="quiz-container">
                <div class="quiz-item">
                    <h3>🤔 思考题1：队列与BFS的本质关系</h3>
                    <p><strong>问题：</strong>为什么BFS必须使用队列，而不能使用栈或其他数据结构？请从算法正确性角度分析。</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer1')">点击查看答案</button>
                    <div class="answer-content" id="answer1">
                        <p><strong>答案：</strong>队列的FIFO特性保证了BFS按层次访问节点，确保找到最短路径。</p>
                        <p><strong>详细解释：</strong>①<strong>层次性保证：</strong>队列确保先处理完第k层所有节点，再处理第k+1层；②<strong>最短路径：</strong>第一次访问到的路径就是最短的；③<strong>如果用栈：</strong>会变成DFS，可能先找到较长路径；④<strong>算法正确性：</strong>只有FIFO才能保证BFS的"广度优先"特性。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题2：BFS时间复杂度分析</h3>
                    <p><strong>问题：</strong>对于有V个顶点、E条边的图，BFS的时间复杂度是多少？队列操作如何影响复杂度？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer2')">点击查看答案</button>
                    <div class="answer-content" id="answer2">
                        <p><strong>答案：</strong>BFS的时间复杂度是O(V+E)，队列操作为O(1)不影响整体复杂度。</p>
                        <p><strong>分析过程：</strong>①<strong>顶点访问：</strong>每个顶点最多入队出队一次，O(V)；②<strong>边的检查：</strong>每条边最多检查一次，O(E)；③<strong>队列操作：</strong>入队出队都是O(1)操作；④<strong>总复杂度：</strong>O(V+E)，这是图遍历算法的最优复杂度。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题3：BFS变种应用</h3>
                    <p><strong>问题：</strong>如何用BFS解决"01矩阵"问题：给定只包含0和1的矩阵，求每个位置到最近0的距离？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer3')">点击查看答案</button>
                    <div class="answer-content" id="answer3">
                        <p><strong>答案：</strong>多源BFS - 将所有0位置同时作为起点，一起向外扩散。</p>
                        <p><strong>算法思路：</strong>①<strong>初始化：</strong>将所有0位置加入队列，距离设为0；②<strong>并发扩散：</strong>从所有0同时开始BFS；③<strong>距离更新：</strong>每向外扩一层，距离+1；④<strong>优势：</strong>一次遍历解决所有位置，比单独计算每个位置效率高得多。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题4：BFS与Dijkstra对比</h3>
                    <p><strong>问题：</strong>BFS只能处理无权图的最短路径，那么它和Dijkstra算法有什么本质区别？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer4')">点击查看答案</button>
                    <div class="answer-content" id="answer4">
                        <p><strong>答案：</strong>BFS用队列保证层次遍历，Dijkstra用优先队列保证距离最小的先处理。</p>
                        <p><strong>核心区别：</strong>①<strong>适用范围：</strong>BFS只适用于无权图或等权图；②<strong>数据结构：</strong>BFS用普通队列，Dijkstra用优先队列；③<strong>扩展策略：</strong>BFS按发现顺序，Dijkstra按距离大小；④<strong>复杂度：</strong>BFS是O(V+E)，Dijkstra是O((V+E)logV)。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题5：队列实现的选择</h3>
                    <p><strong>问题：</strong>在BFS实现中，用数组模拟队列、链表队列、双端队列各有什么优缺点？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer5')">点击查看答案</button>
                    <div class="answer-content" id="answer5">
                        <p><strong>答案：</strong>根据具体场景选择：空间受限用数组，动态大小用链表，需要双向操作用双端队列。</p>
                        <p><strong>详细对比：</strong>①<strong>数组队列：</strong>空间固定，缓存友好但可能溢出；②<strong>链表队列：</strong>动态扩展，内存友好但指针开销大；③<strong>双端队列：</strong>功能强大，适合复杂BFS变种；④<strong>实际选择：</strong>标准BFS用链表队列，空间敏感用数组，双向BFS用双端队列。</p>
                    </div>
                </div>
            </div>

            <!-- 进阶学习建议 -->
            <div class="learning-progress">
                <h3>📚 进阶学习路径</h3>
                <div class="progress-steps">
                    <div class="progress-step completed">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <h4>队列基础与BFS</h4>
                            <p>理解FIFO与层次遍历</p>
                        </div>
                    </div>
                    <div class="progress-step next">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <h4>BFS变种算法</h4>
                            <p>双向BFS、多源BFS</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <h4>最短路径算法</h4>
                            <p>Dijkstra、A*搜索</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">4</span>
                        <div class="step-content">
                            <h4>高级应用</h4>
                            <p>状态空间搜索、游戏AI</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<!-- CSS样式 -->
<style>
.overview-content {
    margin-top: 20px;
}

.concept-intro {
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 4px solid #2196F3;
}

.badge {
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    color: white;
}

.badge-medium {
    background: #FF9800;
}

.concept-details {
    margin-top: 20px;
}

.concept-item {
    margin-bottom: 30px;
    padding: 20px;
    background: #fafafa;
    border-radius: 8px;
    border-left: 4px solid #4CAF50;
}

.fifo-demo {
    margin-top: 15px;
    text-align: center;
}

.queue-visual {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.queue-container {
    display: flex;
    gap: 2px;
    background: #f5f5f5;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.queue-element {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #4CAF50, #66BB6A);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    font-weight: bold;
    font-size: 18px;
}

.queue-label {
    font-size: 14px;
    color: #666;
    font-weight: bold;
}

.bfs-strategy {
    margin-top: 15px;
}

.strategy-explanation h4 {
    color: #FF5722;
    margin-bottom: 10px;
}

.ripple-demo {
    margin-top: 20px;
    display: flex;
    justify-content: center;
}

.ripple-container {
    position: relative;
    width: 300px;
    height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.ripple-layer {
    position: absolute;
    border-radius: 50%;
    border: 2px solid;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 12px;
}

.layer-1 {
    width: 60px;
    height: 60px;
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.2);
    color: #2E7D32;
}

.layer-2 {
    width: 120px;
    height: 120px;
    border-color: #2196F3;
    background: rgba(33, 150, 243, 0.1);
    color: #1976D2;
}

.layer-3 {
    width: 180px;
    height: 180px;
    border-color: #FF9800;
    background: rgba(255, 152, 0, 0.1);
    color: #F57C00;
}

.layer-4 {
    width: 240px;
    height: 240px;
    border-color: #9C27B0;
    background: rgba(156, 39, 176, 0.1);
    color: #7B1FA2;
}

.perfect-match {
    margin-top: 15px;
}

.match-explanation h4 {
    color: #FF9800;
    margin-bottom: 15px;
}

.reason-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.reason-card {
    background: white;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border-top: 4px solid #4CAF50;
}

.reason-icon {
    font-size: 2em;
    display: block;
    margin-bottom: 10px;
}

.reason-card h5 {
    margin: 0 0 8px 0;
    color: #333;
}

.reason-card p {
    margin: 0;
    color: #666;
    font-size: 14px;
}

.comparison-table {
    margin-top: 15px;
    overflow-x: auto;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.comparison-table th,
.comparison-table td {
    border: 1px solid #ddd;
    padding: 12px 15px;
    text-align: center;
}

.comparison-table th {
    background: #f5f5f5;
    font-weight: bold;
    color: #333;
}

.queue-row {
    background: rgba(76, 175, 80, 0.1);
    border-left: 4px solid #4CAF50;
}

.stack-row {
    background: rgba(244, 67, 54, 0.1);
    border-left: 4px solid #f44336;
}

.visualization-container {
    margin-top: 20px;
}

.demo-controls {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.control-panel {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.graph-selector {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.graph-selector label {
    font-weight: bold;
    color: #333;
}

.graph-selector select {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
}

.speed-control {
    display: flex;
    gap: 10px;
    align-items: center;
}

.speed-control input[type="range"] {
    width: 150px;
}

.demo-info {
    text-align: center;
    padding: 15px;
    background: #e3f2fd;
    border-radius: 6px;
    font-weight: bold;
    color: #1976D2;
    margin-bottom: 20px;
}

.visualization-area {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    margin-bottom: 20px;
}

.graph-area, .queue-area {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.graph-area h4, .queue-area h4 {
    margin: 0 0 15px 0;
    color: #333;
    text-align: center;
}

#graphCanvas {
    border: 1px solid #ddd;
    border-radius: 4px;
    display: block;
    margin: 0 auto;
}

.graph-legend {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 12px;
}

.legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid #333;
}

.legend-dot.unvisited {
    background: #e0e0e0;
}

.legend-dot.current {
    background: #FF5722;
}

.legend-dot.visited {
    background: #4CAF50;
}

.legend-dot.queued {
    background: #2196F3;
}

.queue-display {
    margin-bottom: 15px;
}

.queue-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    font-size: 12px;
    color: #666;
}

.queue-body {
    min-height: 60px;
    border: 2px dashed #ddd;
    border-radius: 8px;
    padding: 10px;
    display: flex;
    gap: 5px;
    overflow-x: auto;
    align-items: center;
}

.empty-queue {
    color: #999;
    font-style: italic;
    text-align: center;
    width: 100%;
}

.queue-item {
    min-width: 40px;
    height: 40px;
    background: #2196F3;
    color: white;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    flex-shrink: 0;
}

.queue-stats {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.queue-stats div {
    padding: 8px 12px;
    background: #f5f5f5;
    border-radius: 4px;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
}

.queue-stats span {
    font-weight: bold;
    color: #2196F3;
}

.step-details {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.step-details h4 {
    margin: 0 0 15px 0;
    color: #333;
}

.step-list {
    max-height: 300px;
    overflow-y: auto;
}

.step-item {
    padding: 10px 15px;
    border-left: 4px solid #e0e0e0;
    margin-bottom: 8px;
    background: #f9f9f9;
    border-radius: 0 4px 4px 0;
    font-size: 14px;
}

.step-item.active {
    border-left-color: #FF5722;
    background: #fff3e0;
    font-weight: bold;
}

.step-item.completed {
    border-left-color: #4CAF50;
    background: #e8f5e8;
    color: #2E7D32;
}

.algorithm-pseudocode {
    margin-top: 30px;
}

.pseudocode-container {
    position: relative;
    background: #1e1e1e;
    border-radius: 8px;
    overflow: hidden;
}

.pseudocode {
    color: #f8f8f2;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.6;
    padding: 20px;
    margin: 0;
    overflow-x: auto;
}

.keyword {
    color: #66d9ef;
    font-weight: bold;
}

.function {
    color: #a6e22e;
}

.param {
    color: #fd971f;
}

.variable {
    color: #f92672;
}

.comment {
    color: #75715e;
    font-style: italic;
}

.highlight-line {
    position: absolute;
    left: 0;
    width: 100%;
    height: 25px;
    background: rgba(255, 255, 0, 0.2);
    transition: top 0.3s ease;
    pointer-events: none;
    display: none;
}

.applications {
    margin-top: 20px;
}

.application-item {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #FF5722;
}

.application-item.featured {
    background: linear-gradient(135deg, #fff3e0, #ffffff);
    border-left-color: #FF9800;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.application-details {
    margin-top: 15px;
    padding: 15px;
    background: white;
    border-radius: 6px;
    border: 1px solid #e0e0e0;
}

.application-details h4 {
    margin-top: 0;
    color: #FF9800;
}

.use-case {
    margin-top: 10px;
    padding: 10px;
    background: #f0f7ff;
    border-radius: 4px;
    border-left: 3px solid #2196F3;
}

.mini-example {
    margin-top: 10px;
    padding: 8px 12px;
    background: #e8f5e8;
    border-radius: 4px;
    font-size: 14px;
}

.code-examples {
    margin-top: 30px;
}

.code-tabs {
    display: flex;
    margin-bottom: 0;
    border-bottom: 2px solid #e0e0e0;
}

.tab-btn {
    padding: 12px 24px;
    background: #f5f5f5;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
}

.tab-btn.active {
    background: #2196F3;
    color: white;
    border-bottom-color: #2196F3;
}

.unified-btn-success {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    font-weight: bold;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.unified-btn-success:hover {
    background: linear-gradient(135deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.code-content {
    display: none;
    background: #1e1e1e;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
}

.code-content.active {
    display: block;
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: #333;
    color: white;
    font-size: 14px;
}

.copy-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.2s;
}

.copy-btn:hover {
    background: #45a049;
}

pre {
    margin: 0;
    overflow-x: auto;
}

code {
    color: #f8f8f2;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.5;
    display: block;
    padding: 20px;
}

.quiz-container {
    margin-top: 20px;
}

.quiz-item {
    margin-bottom: 25px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.quiz-item h3 {
    color: #1976D2;
    margin-top: 0;
}

.answer-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin: 10px 0;
    font-weight: bold;
    transition: background 0.2s;
}

.answer-btn:hover {
    background: #45a049;
}

.answer-content {
    display: none;
    margin-top: 15px;
    padding: 15px;
    background: #e8f5e8;
    border-radius: 5px;
    border-left: 4px solid #4CAF50;
}

.answer-content.show {
    display: block;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.learning-progress {
    margin-top: 30px;
    padding: 20px;
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    border-radius: 10px;
}

.progress-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.progress-step {
    display: flex;
    align-items: center;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    opacity: 0.6;
    transition: all 0.3s;
}

.progress-step.completed {
    opacity: 1;
    border-left: 4px solid #4CAF50;
}

.progress-step.next {
    opacity: 1;
    border-left: 4px solid #FF9800;
    transform: scale(1.05);
}

.step-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: #e0e0e0;
    color: white;
    border-radius: 50%;
    margin-right: 15px;
    font-weight: bold;
}

.progress-step.completed .step-number {
    background: #4CAF50;
}

.progress-step.next .step-number {
    background: #FF9800;
}

.step-content h4 {
    margin: 0 0 5px 0;
    color: #333;
}

.step-content p {
    margin: 0;
    color: #666;
    font-size: 14px;
}

@media (max-width: 1200px) {
    .visualization-area {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    .reason-cards {
        grid-template-columns: 1fr;
    }

    .control-panel {
        flex-direction: column;
        align-items: stretch;
    }

    .graph-selector {
        flex-direction: column;
        align-items: stretch;
    }

    .progress-steps {
        grid-template-columns: 1fr;
    }

    .code-tabs {
        flex-wrap: wrap;
    }

    .tab-btn {
        flex: 1;
        min-width: 80px;
    }

    .queue-visual {
        overflow-x: auto;
    }
}
</style>

<!-- JavaScript -->
<script>
// BFS可视化相关变量
let canvas, ctx;
let demoInProgress = false;
let stepByStep = false;
let currentStep = 0;
let animationSpeed = 1500;

// 图数据结构
let graphs = {
    simple: {
        nodes: [
            {id: 0, x: 100, y: 100, label: '0'},
            {id: 1, x: 250, y: 60, label: '1'},
            {id: 2, x: 250, y: 140, label: '2'},
            {id: 3, x: 400, y: 100, label: '3'},
            {id: 4, x: 350, y: 200, label: '4'},
            {id: 5, x: 100, y: 250, label: '5'}
        ],
        edges: [
            [0, 1], [0, 2], [1, 3], [2, 3], [2, 4], [3, 5], [4, 5]
        ]
    },
    maze: {
        nodes: [
            {id: 0, x: 50, y: 50, label: 'S'},
            {id: 1, x: 150, y: 50, label: '1'},
            {id: 2, x: 250, y: 50, label: '2'},
            {id: 3, x: 350, y: 50, label: '3'},
            {id: 4, x: 50, y: 150, label: '4'},
            {id: 5, x: 250, y: 150, label: '5'},
            {id: 6, x: 350, y: 150, label: 'E'},
            {id: 7, x: 150, y: 250, label: '7'}
        ],
        edges: [
            [0, 1], [1, 2], [2, 3], [3, 6], [0, 4], [2, 5], [4, 7], [7, 5], [5, 6]
        ]
    },
    tree: {
        nodes: [
            {id: 0, x: 250, y: 50, label: 'A'},
            {id: 1, x: 150, y: 120, label: 'B'},
            {id: 2, x: 350, y: 120, label: 'C'},
            {id: 3, x: 100, y: 190, label: 'D'},
            {id: 4, x: 200, y: 190, label: 'E'},
            {id: 5, x: 300, y: 190, label: 'F'},
            {id: 6, x: 400, y: 190, label: 'G'}
        ],
        edges: [
            [0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]
        ]
    },
    social: {
        nodes: [
            {id: 0, x: 250, y: 100, label: '源'},
            {id: 1, x: 150, y: 180, label: 'A'},
            {id: 2, x: 250, y: 200, label: 'B'},
            {id: 3, x: 350, y: 180, label: 'C'},
            {id: 4, x: 100, y: 280, label: 'D'},
            {id: 5, x: 200, y: 300, label: 'E'},
            {id: 6, x: 300, y: 300, label: 'F'},
            {id: 7, x: 400, y: 280, label: 'G'}
        ],
        edges: [
            [0, 1], [0, 2], [0, 3], [1, 4], [2, 5], [3, 6], [3, 7], [4, 5], [6, 7]
        ]
    }
};

// BFS状态
let bfsState = {
    queue: [],
    visited: new Set(),
    current: null,
    adjacencyList: {},
    nodeStates: {}, // unvisited, queued, current, visited
    steps: [],
    currentLevel: 0
};

// 初始化
document.addEventListener('DOMContentLoaded', function() {
    canvas = document.getElementById('graphCanvas');
    ctx = canvas.getContext('2d');

    initializeDemo();

    // 绑定事件
    document.getElementById('autoDemo').addEventListener('click', startAutoDemo);
    document.getElementById('stepDemo').addEventListener('click', startStepDemo);
    document.getElementById('resetDemo').addEventListener('click', resetDemo);

    document.getElementById('graphType').addEventListener('change', function() {
        resetDemo();
        updateStartNodeOptions();
    });

    document.getElementById('speedSlider').addEventListener('input', function() {
        animationSpeed = parseInt(this.value);
        updateSpeedLabel();
    });

    updateStartNodeOptions();
    updateSpeedLabel();
});

function initializeDemo() {
    const graphType = document.getElementById('graphType').value;
    const startNode = parseInt(document.getElementById('startNode').value) || 0;

    // 重置BFS状态
    bfsState = {
        queue: [],
        visited: new Set(),
        current: null,
        adjacencyList: {},
        nodeStates: {},
        steps: [],
        currentLevel: 0
    };

    // 构建邻接表
    const graph = graphs[graphType];
    for (let node of graph.nodes) {
        bfsState.adjacencyList[node.id] = [];
        bfsState.nodeStates[node.id] = 'unvisited';
    }

    for (let [u, v] of graph.edges) {
        bfsState.adjacencyList[u].push(v);
        bfsState.adjacencyList[v].push(u);
    }

    drawGraph();
    updateQueueDisplay();
    updateStepsDisplay();
}

function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const graphType = document.getElementById('graphType').value;
    const graph = graphs[graphType];

    // 绘制边
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 2;
    for (let [u, v] of graph.edges) {
        const nodeU = graph.nodes.find(n => n.id === u);
        const nodeV = graph.nodes.find(n => n.id === v);

        ctx.beginPath();
        ctx.moveTo(nodeU.x, nodeU.y);
        ctx.lineTo(nodeV.x, nodeV.y);
        ctx.stroke();
    }

    // 绘制节点
    for (let node of graph.nodes) {
        const state = bfsState.nodeStates[node.id] || 'unvisited';
        let color;

        switch (state) {
            case 'unvisited':
                color = '#e0e0e0';
                break;
            case 'queued':
                color = '#2196F3';
                break;
            case 'current':
                color = '#FF5722';
                break;
            case 'visited':
                color = '#4CAF50';
                break;
        }

        // 绘制圆圈
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 绘制标签
        ctx.fillStyle = state === 'unvisited' ? '#333' : 'white';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.label, node.x, node.y);
    }
}

function updateQueueDisplay() {
    const queueBody = document.getElementById('queueBody');
    const queueLength = document.getElementById('queueLength');
    const visitedCount = document.getElementById('visitedCount');
    const currentLevel = document.getElementById('currentLevel');

    // 更新队列显示
    if (bfsState.queue.length === 0) {
        queueBody.innerHTML = '<div class="empty-queue">队列为空</div>';
    } else {
        queueBody.innerHTML = bfsState.queue
            .map(nodeId => `<div class="queue-item">${graphs[document.getElementById('graphType').value].nodes.find(n => n.id === nodeId).label}</div>`)
            .join('');
    }

    // 更新统计信息
    queueLength.textContent = bfsState.queue.length;
    visitedCount.textContent = bfsState.visited.size;
    currentLevel.textContent = bfsState.currentLevel;
}

function updateStepsDisplay() {
    const stepList = document.getElementById('stepList');

    if (bfsState.steps.length === 0) {
        stepList.innerHTML = '<div class="step-item">准备开始BFS遍历...</div>';
    } else {
        stepList.innerHTML = bfsState.steps
            .map((step, index) => {
                let className = 'step-item';
                if (index === bfsState.steps.length - 1) {
                    className += ' active';
                } else if (index < bfsState.steps.length - 1) {
                    className += ' completed';
                }
                return `<div class="${className}">${step}</div>`;
            })
            .join('');

        // 滚动到最新步骤
        stepList.scrollTop = stepList.scrollHeight;
    }
}

function addStep(message) {
    bfsState.steps.push(message);
    updateStepsDisplay();
}

async function startAutoDemo() {
    if (demoInProgress) return;

    demoInProgress = true;
    stepByStep = false;
    currentStep = 0;

    // 禁用控制按钮
    document.getElementById('autoDemo').textContent = '演示进行中...';
    document.getElementById('autoDemo').disabled = true;
    document.getElementById('stepDemo').disabled = true;

    await performBFS();

    // 重新启用按钮
    document.getElementById('autoDemo').textContent = '🚀 自动BFS演示';
    document.getElementById('autoDemo').disabled = false;
    document.getElementById('stepDemo').disabled = false;
    demoInProgress = false;
}

async function startStepDemo() {
    if (demoInProgress) return;

    if (!stepByStep) {
        stepByStep = true;
        currentStep = 0;
        document.getElementById('stepDemo').textContent = '▶️ 下一步';

        // 初始化BFS
        const startNode = parseInt(document.getElementById('startNode').value) || 0;
        bfsState.queue.push(startNode);
        bfsState.visited.add(startNode);
        bfsState.nodeStates[startNode] = 'queued';

        addStep(`初始化：将起点${startNode}加入队列`);
        drawGraph();
        updateQueueDisplay();
    } else {
        await performBFSStep();

        if (bfsState.queue.length === 0) {
            document.getElementById('stepDemo').textContent = '👆 单步执行';
            stepByStep = false;
            addStep('BFS遍历完成！');
        }
    }
}

function resetDemo() {
    demoInProgress = false;
    stepByStep = false;
    currentStep = 0;

    document.getElementById('autoDemo').textContent = '🚀 自动BFS演示';
    document.getElementById('autoDemo').disabled = false;
    document.getElementById('stepDemo').textContent = '👆 单步执行';
    document.getElementById('stepDemo').disabled = false;

    document.getElementById('demoInfo').textContent = '点击"自动BFS演示"观看完整的广度优先搜索过程';

    initializeDemo();
}

async function performBFS() {
    const startNode = parseInt(document.getElementById('startNode').value) || 0;

    // 初始化
    bfsState.queue.push(startNode);
    bfsState.visited.add(startNode);
    bfsState.nodeStates[startNode] = 'queued';

    addStep(`初始化：将起点${startNode}加入队列`);
    drawGraph();
    updateQueueDisplay();

    await sleep(animationSpeed);

    while (bfsState.queue.length > 0) {
        await performBFSStep();
        if (!stepByStep) {
            await sleep(animationSpeed);
        }
    }

    addStep('BFS遍历完成！所有可达节点都已访问');
    document.getElementById('demoInfo').textContent = 'BFS演示完成！🎉';
}

async function performBFSStep() {
    if (bfsState.queue.length === 0) return;

    // 出队
    const current = bfsState.queue.shift();
    bfsState.current = current;
    bfsState.nodeStates[current] = 'current';

    const graphType = document.getElementById('graphType').value;
    const currentLabel = graphs[graphType].nodes.find(n => n.id === current).label;

    addStep(`出队：处理节点${currentLabel}(${current})`);
    drawGraph();
    updateQueueDisplay();

    if (!stepByStep) await sleep(animationSpeed / 2);

    // 访问所有未访问的邻居
    const neighbors = bfsState.adjacencyList[current];
    const newNeighbors = [];

    for (let neighbor of neighbors) {
        if (!bfsState.visited.has(neighbor)) {
            bfsState.queue.push(neighbor);
            bfsState.visited.add(neighbor);
            bfsState.nodeStates[neighbor] = 'queued';
            newNeighbors.push(neighbor);
        }
    }

    if (newNeighbors.length > 0) {
        const neighborLabels = newNeighbors.map(id => graphs[graphType].nodes.find(n => n.id === id).label);
        addStep(`入队：将${currentLabel}的邻居[${neighborLabels.join(', ')}]加入队列`);
    } else {
        addStep(`节点${currentLabel}的所有邻居都已访问过`);
    }

    // 标记当前节点为已访问
    bfsState.nodeStates[current] = 'visited';

    drawGraph();
    updateQueueDisplay();
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function updateStartNodeOptions() {
    const graphType = document.getElementById('graphType').value;
    const startNodeSelect = document.getElementById('startNode');
    const graph = graphs[graphType];

    startNodeSelect.innerHTML = '';
    for (let node of graph.nodes) {
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = `节点 ${node.label}`;
        startNodeSelect.appendChild(option);
    }
}

function updateSpeedLabel() {
    const speed = parseInt(document.getElementById('speedSlider').value);
    const label = document.getElementById('speedLabel');

    if (speed <= 750) {
        label.textContent = '很快';
    } else if (speed <= 1250) {
        label.textContent = '较快';
    } else if (speed <= 1750) {
        label.textContent = '正常';
    } else if (speed <= 2250) {
        label.textContent = '较慢';
    } else {
        label.textContent = '很慢';
    }
}

// 代码标签页切换
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));

        this.classList.add('active');
        const lang = this.getAttribute('data-lang');
        document.querySelector(`.code-content[data-lang="${lang}"]`).classList.add('active');
    });
});

// 复制代码功能
document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const targetId = this.getAttribute('data-clipboard-target');
        const codeElement = document.getElementById(targetId);

        if (codeElement) {
            const textarea = document.createElement('textarea');
            textarea.value = codeElement.textContent;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            const originalText = this.textContent;
            this.textContent = '✅ 已复制';
            setTimeout(() => {
                this.textContent = originalText;
            }, 2000);
        }
    });
});

// 答案切换功能
function toggleAnswer(answerId) {
    const answerElement = document.getElementById(answerId);
    const button = answerElement.previousElementSibling;

    if (answerElement.classList.contains('show')) {
        answerElement.classList.remove('show');
        button.textContent = '点击查看答案';
    } else {
        answerElement.classList.add('show');
        button.textContent = '隐藏答案';
    }
}
</script>

{% endblock %}