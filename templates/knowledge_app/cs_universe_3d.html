<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS Universe - è®¡ç®—æœºç§‘å­¦çŸ¥è¯†å®‡å®™</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            overflow: hidden;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e8f4fd;
            cursor: crosshair;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 40% 80%, rgba(119, 198, 255, 0.1) 0%, transparent 50%);
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        #container.focused {
            border-color: rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 25px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 320px;
            transition: all 0.3s ease;
            color: #a8d8ea;
        }

        #info:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        #info h1 {
            font-size: 28px;
            margin-bottom: 12px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #00f5ff);
            background-size: 200% 200%;
            animation: gradientFlow 3s ease-in-out infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        #info p {
            font-size: 13px;
            line-height: 1.6;
            opacity: 0.9;
            margin: 8px 0;
            color: #b8e6ff;
        }

        #info p strong {
            color: #7dd3fc;
            font-weight: 600;
        }

        #controls {
            position: fixed;
            left: -320px; /* é»˜è®¤éšè— */
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 20, 40, 0.9) 100%);
            padding: 20px;
            border-radius: 0 15px 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: none;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 320px;
            height: auto;
            max-height: 85vh;
            overflow: hidden; /* ç§»é™¤æ»šåŠ¨æ¡ */
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            color: #a8d8ea;
        }

        #controls.open {
            left: 0;
        }

        #controls:hover {
            box-shadow: var(--shadow-md);
        }

        #controlsToggle {
            position: fixed;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 101;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border: 1px solid rgba(0, 245, 255, 0.4);
            color: #00f5ff;
            padding: 15px 8px;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.2);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        #controlsToggle:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.4) 0%, rgba(255, 0, 255, 0.4) 100%);
            border-color: rgba(0, 245, 255, 0.8);
            transform: translateY(-50%) translateX(3px);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.4);
        }

        #controlsToggle.open {
            left: 330px;
            border-radius: 10px 0 0 10px;
            border-right: none;
            border-left: 1px solid rgba(0, 245, 255, 0.4);
        }

        .control-section {
            margin-bottom: 12px;
            font-size: 12px;
        }

        .control-title {
            font-weight: 600;
            margin-bottom: 6px;
            color: #00f5ff;
            font-size: 13px;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .legend:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            transform: translateX(5px);
            color: #00f5ff;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

        .legend-item:hover .legend-color {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-inverse);
            padding: 10px 16px;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            margin: 6px 6px 6px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border-color: rgba(0, 245, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.3);
            color: #00f5ff;
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.2);
        }

        #searchInput {
            transition: all 0.3s ease;
        }

        #searchInput:focus {
            outline: none;
            border-color: rgba(0, 245, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #tooltip {
            position: absolute;
            z-index: 200;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            color: #b8e6ff;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 280px;
            transform: translateY(10px);
        }

        #tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .cluster-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            font-size: 12px;
            transition: all 0.3s ease;
            color: #b8e6ff;
        }

        .cluster-info:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .cluster-info strong {
            color: #7dd3fc;
            text-shadow: 0 0 10px rgba(125, 211, 252, 0.3);
        }

        #fps {
            position: absolute;
            top: 20px;
            right: 50%;
            transform: translateX(50%);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(20, 20, 40, 0.7) 100%);
            padding: 10px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            font-size: 12px;
            color: #7dd3fc;
            text-align: center;
            min-width: 80px;
        }

        /* åŠ è½½å±å¹•æ ·å¼ */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-inverse);
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #loadingScreen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-container {
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .loading-logo {
            margin-bottom: 40px;
        }

        .rotating-galaxy {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 30px;
        }

        .galaxy-ring {
            position: absolute;
            border: 2px solid transparent;
            border-radius: 50%;
            animation: rotateGalaxy 8s linear infinite;
        }

        .ring-1 {
            width: 120px;
            height: 120px;
            border-top-color: #00f5ff;
            border-right-color: #00f5ff;
            animation-duration: 8s;
        }

        .ring-2 {
            width: 90px;
            height: 90px;
            top: 15px;
            left: 15px;
            border-top-color: #ff00ff;
            border-left-color: #ff00ff;
            animation-duration: 6s;
            animation-direction: reverse;
        }

        .ring-3 {
            width: 60px;
            height: 60px;
            top: 30px;
            left: 30px;
            border-bottom-color: #ffeaa7;
            border-right-color: #ffeaa7;
            animation-duration: 4s;
        }

        .galaxy-core {
            position: absolute;
            width: 30px;
            height: 30px;
            top: 45px;
            left: 45px;
            background: radial-gradient(circle, #ffffff 0%, #00f5ff 50%, transparent 100%);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes rotateGalaxy {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .loading-title {
            font-size: 32px;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #7dd3fc, #a78bfa, #7dd3fc);
            background-size: 200% 200%;
            animation: gradientFlow 3s ease-in-out infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .loading-subtitle {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 0;
            color: #b8e6ff;
        }

        .loading-progress {
            margin: 30px 0;
        }

        .progress-bar {
            position: relative;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(0, 245, 255, 0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff 0%, #ff00ff 50%, #00f5ff 100%);
            background-size: 200% 100%;
            animation: progressShimmer 2s ease-in-out infinite;
            border-radius: var(--border-radius);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-glow {
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.5), transparent);
            border-radius: 12px;
            opacity: 0;
            animation: progressGlow 3s ease-in-out infinite;
        }

        @keyframes progressShimmer {
            0%, 100% { background-position: 0% 0%; }
            50% { background-position: 100% 0%; }
        }

        @keyframes progressGlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #b8e6ff;
        }

        #progressPercentage {
            font-weight: 600;
            color: #7dd3fc;
            font-size: 16px;
        }

        #loadingStage {
            opacity: 0.9;
            font-style: italic;
            color: #a8d8ea;
        }

        .loading-details {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(20, 20, 40, 0.4) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }

        .current-task {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .task-icon {
            margin-right: 8px;
            font-size: 16px;
            animation: taskPulse 1.5s ease-in-out infinite;
        }

        @keyframes taskPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .loading-stats {
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
        }

        .loading-tips {
            position: fixed;
            bottom: 30px;
            left: 30px;
            right: 30px;
            max-width: 400px;
            margin: 0 auto;
        }

        .tip-content {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(20, 20, 40, 0.6) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .tip-content h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #00f5ff;
        }

        .tip-content ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .tip-content li {
            padding: 5px 0;
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.4;
            position: relative;
            padding-left: 15px;
        }

        .tip-content li::before {
            content: 'âœ¨';
            position: absolute;
            left: 0;
            top: 5px;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½å±å¹• -->
    <div id="loadingScreen">
        <div class="loading-container">
            <div class="loading-logo">
                <div class="rotating-galaxy">
                    <div class="galaxy-ring ring-1"></div>
                    <div class="galaxy-ring ring-2"></div>
                    <div class="galaxy-ring ring-3"></div>
                    <div class="galaxy-core"></div>
                </div>
                <h1 class="loading-title">CS Universe</h1>
                <p class="loading-subtitle">è®¡ç®—æœºç§‘å­¦çŸ¥è¯†å®‡å®™æ­£åœ¨æ„å»ºä¸­...</p>
            </div>

            <div class="loading-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-glow"></div>
                </div>
                <div class="progress-text">
                    <span id="progressPercentage">0%</span>
                    <span id="loadingStage">åˆå§‹åŒ–...</span>
                </div>
            </div>

            <div class="loading-details">
                <div class="current-task">
                    <span class="task-icon">âš¡</span>
                    <span id="currentTask">å‡†å¤‡å¯åŠ¨...</span>
                </div>
                <div class="loading-stats">
                    <span id="loadedCount">0</span> / <span id="totalCount">0</span> é¡¹å·²å®Œæˆ
                </div>
            </div>
        </div>

        <div class="loading-tips">
            <div class="tip-content">
                <h3>ğŸ’¡ æ¢ç´¢æç¤º</h3>
                <ul id="tipsList">
                    <li>ä½¿ç”¨ WASD é”®åœ¨å®‡å®™ä¸­è‡ªç”±é£è¡Œ</li>
                    <li>è§‚å¯Ÿè¡Œæ˜Ÿç»•æ’æ˜Ÿã€å«æ˜Ÿç»•è¡Œæ˜Ÿçš„è½¨é“è¿åŠ¨</li>
                    <li>ç‚¹å‡»ä»»æ„å¤©ä½“è¿›å…¥ç¯ç»•è§‚å¯Ÿæ¨¡å¼</li>
                    <li>æœç´¢åŠŸèƒ½å¯ä»¥å¿«é€Ÿå®šä½çŸ¥è¯†æ¦‚å¿µ</li>
                    <li>æ¯ä¸ªæ’æ˜Ÿéƒ½æœ‰ç‹¬ç‰¹çš„è§†è§‰ç‰¹æ•ˆ</li>
                    <li>æŒ‰ R é”®å¿«é€Ÿç¿»è½¬ 180 åº¦è§†è§’</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="info">
            <h1>CS Universe</h1>
            <p><strong>è®¡ç®—æœºç§‘å­¦çŸ¥è¯†å®‡å®™</strong></p>
            <p>â€¢ ç›¸åŒè¯¾ç¨‹èšé›†æˆçŸ¥è¯†æ˜Ÿç³»</p>
            <p>â€¢ ğŸŒŸ <span style="color: #7dd3fc;">æ’æ˜Ÿ</span>ï¼šè¯¾ç¨‹ä¸­å¿ƒï¼Œå‘å‡ºå¼ºçƒˆå…‰èŠ’</p>
            <p>â€¢ ğŸª <span style="color: #fbbf24;">è¡Œæ˜Ÿ</span>ï¼šç»•æ’æ˜Ÿæ—‹è½¬çš„ä¸»è¦åˆ†æ”¯</p>
            <p>â€¢ ğŸŒ™ <span style="color: #86efac;">å«æ˜Ÿ</span>ï¼šç»•è¡Œæ˜Ÿæ—‹è½¬çš„å…·ä½“æ¦‚å¿µ</p>
            <p>â€¢ ğŸ”¥ <span style="color: #f87171;">æ ¸å¿ƒæ¦‚å¿µ</span>ï¼šå¤šå±‚å…‰æ™•+ç²’å­æ•ˆæœ</p>
            <p>â€¢ æ¦‚å¿µå…³è”å½¢æˆè¿çº¿ç½‘ç»œ</p>
            <p>â€¢ ä¸åŒé¢œè‰²ä»£è¡¨ä¸åŒè¯¾ç¨‹é¢†åŸŸ</p>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>æ•°æ®ç»“æ„ (Data Structure)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: var(--accent-color);"></div>
                <span>ç®—æ³•è®¾è®¡ (Algorithm)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45b7d1;"></div>
                <span>è®¡ç®—æœºç½‘ç»œ (Network)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #96ceb4;"></div>
                <span>æ“ä½œç³»ç»Ÿ (OS)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffeaa7;"></div>
                <span>æ•°æ®åº“ç³»ç»Ÿ (Database)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #dda0dd;"></div>
                <span>è½¯ä»¶å·¥ç¨‹ (SE)</span>
            </div>
        </div>

        <div id="controlsToggle" onclick="toggleControlsPanel()">
            ğŸ® æ§åˆ¶é¢æ¿
        </div>

        <div id="controls">
            <div class="control-section">
                <div class="control-title">ğŸŒŒ å®‡å®™è¿è¡Œè§„å¾‹</div>
                <div style="font-size: 10px; line-height: 1.3; margin-bottom: 8px;">
                    <div>â€¢ ğŸª è¡Œæ˜Ÿç»•æ’æ˜Ÿè½¨é“è¿è¡Œ</div>
                    <div>â€¢ ğŸŒ™ å«æ˜Ÿç»•è¡Œæ˜Ÿè½¨é“è¿è¡Œ</div>
                    <div>â€¢ è·ç¦»è¶Šè¿œè½¨é“é€Ÿåº¦è¶Šæ…¢</div>
                    <div>â€¢ æ‰€æœ‰å¤©ä½“éƒ½æœ‰è‡ªè½¬æ•ˆæœ</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">ğŸ” æœç´¢æ¦‚å¿µ</div>
                <input type="text" id="searchInput" placeholder="æœç´¢çŸ¥è¯†ç‚¹ (å¦‚: æ ˆ, é˜Ÿåˆ—, TCP/IP...)"
                       style="width: 100%; padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);
                              background: rgba(0,0,0,0.5); color: var(--text-inverse); font-size: 11px; margin-bottom: 8px;"
                       onkeypress="handleSearchKeyPress(event)">
                <button onclick="searchConcept()" style="width: 100%; margin-bottom: 0; padding: 6px 12px; font-size: 11px;">ğŸ¯ æœç´¢å¹¶è·³è½¬</button>
            </div>

            <div class="control-section">
                <div class="control-title">ğŸš€ åŸºç¡€é£è¡Œæ§åˆ¶</div>
                <div style="color: #ffaa00; font-size: 10px; margin-bottom: 6px; padding: 4px; background: rgba(255, 170, 0, 0.1); border-radius: 4px;">ğŸ’¡ ç‚¹å‡»3Dåœºæ™¯è·å¾—é”®ç›˜ç„¦ç‚¹</div>
                <div style="font-size: 10px; line-height: 1.3;">
                    <div>â€¢ WASD / æ–¹å‘é”®: å‰åå·¦å³ç§»åŠ¨</div>
                    <div>â€¢ QE / ç©ºæ ¼+Shift: ä¸Šå‡ä¸‹é™</div>
                    <div>â€¢ é¼ æ ‡æŒ‰ä½: æŒç»­å‘å‰é£è¡Œ</div>
                    <div>â€¢ é¼ æ ‡æ‹–æ‹½: æ”¹å˜è§†è§’æ–¹å‘</div>
                    <div>â€¢ æ»šè½®: è°ƒæ•´é£è¡Œé€Ÿåº¦</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">ğŸ”„ è§†è§’æ—‹è½¬æ§åˆ¶</div>
                <div style="font-size: 10px; line-height: 1.3; margin-bottom: 8px;">
                    <div><strong style="color: #00ff00;">Ré”®: 180Â°ç¿»è½¬</strong> | <strong style="color: #00ffff;">Té”®: 15Â°æ—‹è½¬</strong></div>
                    <div><strong style="color: #ffaa00;">J/Lé”®: æ°´å¹³è½¬</strong> | <strong style="color: #ff88aa;">I/Ké”®: ç«–ç›´è½¬</strong></div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 0;">
                    <button onclick="rotateHorizontalLeft()" style="font-size: 9px; padding: 4px;">â¬…ï¸ å·¦(J)</button>
                    <button onclick="rotateHorizontalRight()" style="font-size: 9px; padding: 4px;">â¡ï¸ å³(L)</button>
                    <button onclick="rotateVerticalUp()" style="font-size: 9px; padding: 4px;">â¬†ï¸ ä¸Š(I)</button>
                    <button onclick="rotateVerticalDown()" style="font-size: 9px; padding: 4px;">â¬‡ï¸ ä¸‹(K)</button>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">ğŸ”’ é”å®šæ¨¡å¼</div>
                <div style="color: #ffaa00; font-size: 9px; margin: 2px 0;">ğŸ’¡ ç‚¹å‡»ä»»æ„å¤©ä½“è¿›å…¥é”å®šæ¨¡å¼</div>
                <div style="font-size: 10px; line-height: 1.3;">
                    <div>â€¢ WASD: ç¯ç»•ç›®æ ‡ â€¢ QE: è°ƒæ•´é«˜åº¦</div>
                    <div>â€¢ Ré”®: ç¿»è½¬è§’åº¦ â€¢ Té”®: é¡ºæ—¶é’ˆç¯ç»•</div>
                    <div>â€¢ J/Lé”®: å·¦å³ç¯ç»• â€¢ I/Ké”®: ä¸Šä¸‹è§†è§’</div>
                    <div>â€¢ ESC: å–æ¶ˆé”å®š</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">âš™ï¸ ç³»ç»Ÿæ§åˆ¶</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    <button onclick="resetView()" style="padding: 5px; font-size: 10px;">ğŸ  é‡ç½®</button>
                    <button onclick="flip180Degrees()" style="padding: 5px; font-size: 10px;">ğŸ”„ ç¿»è½¬</button>
                    <button onclick="rotateClockwise()" style="padding: 5px; font-size: 10px; background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 200, 255, 0.2) 100%); border-color: rgba(0, 255, 255, 0.4);"
                        onmouseover="this.style.background='linear-gradient(135deg, rgba(0, 255, 255, 0.4) 0%, rgba(0, 200, 255, 0.4) 100%)'; this.style.borderColor='rgba(0, 255, 255, 0.8)';"
                        onmouseout="this.style.background='linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 200, 255, 0.2) 100%)'; this.style.borderColor='rgba(0, 255, 255, 0.4)';">ğŸ” å¾®è°ƒ</button>
                    <button onclick="toggleAnimation()" style="padding: 5px; font-size: 10px;">â¯ï¸ æš‚åœ</button>
                </div>
                <button onclick="unlockCurrentConcept()" id="unlockBtn" style="display: none; background: linear-gradient(135deg, rgba(255, 0, 0, 0.2) 0%, rgba(255, 100, 100, 0.2) 100%); width: 100%; margin-top: 6px; padding: 5px; font-size: 10px;">ğŸ”“ å–æ¶ˆé”å®š</button>
            </div>

            <div class="control-section">
                <div class="control-title">ğŸ  å¯¼èˆªæ§åˆ¶</div>
                <button onclick="window.location.href='/'" style="width: 100%; padding: 8px; font-size: 11px; background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%); border-color: rgba(102, 126, 234, 0.5); color: var(--primary-color); font-weight: 600;"
                    onmouseover="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%)'; this.style.borderColor='rgba(102, 126, 234, 0.8)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.4)';"
                    onmouseout="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%)'; this.style.borderColor='rgba(102, 126, 234, 0.5)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                    ğŸ  è¿”å›é¦–é¡µ
                </button>
            </div>
        </div>

        <div class="cluster-info">
            <div><strong>è¯¾ç¨‹æ¦‚å¿µç»Ÿè®¡:</strong></div>
            <div id="clusterStats">æ­£åœ¨è®¡ç®—...</div>
        </div>

        <div id="fps">
            <div>FPS: <span id="fpsValue">60</span></div>
            <div style="font-size: 10px; opacity: 0.7;">æ€§èƒ½ç›‘è§†å™¨</div>
        </div>

        <div id="tooltip"></div>
    </div>

    <script>
        // åŠ è½½ç®¡ç†å™¨ç±»
        class LoadingManager {
            constructor() {
                this.totalTasks = 0;
                this.completedTasks = 0;
                this.currentStage = '';
                this.currentTask = '';
                this.stages = [
                    { name: 'åˆå§‹åŒ–å¼•æ“', weight: 10 },
                    { name: 'åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯', weight: 15 },
                    { name: 'æ„å»ºæ·±ç©ºæ•ˆæœ', weight: 20 },
                    { name: 'ç”Ÿæˆæ•°æ®ç»“æ„æ˜Ÿç³»', weight: 15 },
                    { name: 'ç”Ÿæˆç®—æ³•è®¾è®¡æ˜Ÿç³»', weight: 15 },
                    { name: 'ç”Ÿæˆè®¡ç®—æœºç½‘ç»œæ˜Ÿç³»', weight: 15 },
                    { name: 'ç”Ÿæˆæ“ä½œç³»ç»Ÿæ˜Ÿç³»', weight: 10 },
                    { name: 'ç”Ÿæˆæ•°æ®åº“ç³»ç»Ÿæ˜Ÿç³»', weight: 10 },
                    { name: 'ç”Ÿæˆè½¯ä»¶å·¥ç¨‹æ˜Ÿç³»', weight: 10 },
                    { name: 'è®¾ç½®äº¤äº’ç³»ç»Ÿ', weight: 5 },
                    { name: 'å¯åŠ¨å®‡å®™', weight: 5 }
                ];
                this.stageIndex = 0;
                this.setupElements();
            }

            setupElements() {
                this.progressFill = document.getElementById('progressFill');
                this.progressPercentage = document.getElementById('progressPercentage');
                this.loadingStage = document.getElementById('loadingStage');
                this.currentTaskElement = document.getElementById('currentTask');
                this.loadedCount = document.getElementById('loadedCount');
                this.totalCount = document.getElementById('totalCount');
                this.loadingScreen = document.getElementById('loadingScreen');

                // è®¡ç®—æ€»ä»»åŠ¡æ•°
                this.totalTasks = this.stages.reduce((sum, stage) => sum + stage.weight, 0);
                this.totalCount.textContent = this.totalTasks;
            }

            setStage(stageName) {
                this.currentStage = stageName;
                this.loadingStage.textContent = stageName;
                console.log(`ğŸ“ è¿›å…¥é˜¶æ®µ: ${stageName}`);
            }

            setTask(taskName) {
                this.currentTask = taskName;
                this.currentTaskElement.textContent = taskName;
            }

            updateProgress(increment = 1) {
                this.completedTasks += increment;
                const percentage = Math.min((this.completedTasks / this.totalTasks) * 100, 100);

                this.progressFill.style.width = percentage + '%';
                this.progressPercentage.textContent = Math.round(percentage) + '%';
                this.loadedCount.textContent = this.completedTasks;

                console.log(`âš¡ è¿›åº¦æ›´æ–°: ${Math.round(percentage)}% (${this.completedTasks}/${this.totalTasks})`);

                if (percentage >= 100) {
                    setTimeout(() => this.complete(), 500);
                }
            }

            complete() {
                this.setTask('å®‡å®™æ„å»ºå®Œæˆ! ğŸŒŸ');
                this.setStage('å‡†å¤‡è¿›å…¥...');

                // æ˜¾ç¤ºå®Œæˆä¿¡æ¯
                this.currentTaskElement.style.color = '#00ff00';
                this.loadingStage.style.color = '#00ff00';

                setTimeout(() => {
                    // æ·»åŠ æ·¡å‡ºåŠ¨ç”»
                    this.loadingScreen.style.transition = 'opacity 1.2s ease, transform 1.2s ease';
                    this.loadingScreen.style.transform = 'scale(0.95)';
                    this.loadingScreen.classList.add('hidden');

                    console.log('ğŸš€ åŠ è½½å®Œæˆï¼Œè¿›å…¥CSå®‡å®™!');

                    // åŠ è½½å®Œæˆåå¯åŠ¨åŠ¨ç”»
                    setTimeout(() => {
                        // æ˜¾ç¤ºä¸»ç•Œé¢
                        const infoPanel = document.getElementById('info');
                        if (infoPanel) {
                            infoPanel.innerHTML = `
                                <h1>CS Universe</h1>
                                <p><strong>è®¡ç®—æœºç§‘å­¦çŸ¥è¯†å®‡å®™</strong></p>
                                <p>â€¢ ç›¸åŒè¯¾ç¨‹èšé›†æˆçŸ¥è¯†æ˜Ÿç³»</p>
                                <p>â€¢ ğŸŒŸ <span style="color: #7dd3fc;">æ’æ˜Ÿ</span>ï¼šè¯¾ç¨‹ä¸­å¿ƒï¼Œå‘å‡ºå¼ºçƒˆå…‰èŠ’</p>
                                <p>â€¢ ğŸª <span style="color: #fbbf24;">è¡Œæ˜Ÿ</span>ï¼šç»•æ’æ˜Ÿæ—‹è½¬çš„ä¸»è¦åˆ†æ”¯</p>
                                <p>â€¢ ğŸŒ™ <span style="color: #86efac;">å«æ˜Ÿ</span>ï¼šç»•è¡Œæ˜Ÿæ—‹è½¬çš„å…·ä½“æ¦‚å¿µ</p>
                                <p>â€¢ ğŸ”¥ <span style="color: #f87171;">æ ¸å¿ƒæ¦‚å¿µ</span>ï¼šå¤šå±‚å…‰æ™•+ç²’å­æ•ˆæœ</p>
                                <p>â€¢ æ¦‚å¿µå…³è”å½¢æˆè¿çº¿ç½‘ç»œ</p>
                                <p>â€¢ ä¸åŒé¢œè‰²ä»£è¡¨ä¸åŒè¯¾ç¨‹é¢†åŸŸ</p>
                            `;
                        }

                        // æœ€ç»ˆç¡®ä¿ç»Ÿè®¡æ•°æ®æ­£ç¡®
                        console.log('ğŸ” æœ€ç»ˆæ£€æŸ¥ - papersæ•°ç»„é•¿åº¦:', papers.length);
                        if (papers.length > 0) {
                            updateClusterStats();
                            console.log('âœ… ç»Ÿè®¡æ•°æ®å·²æ›´æ–°');
                        } else {
                            console.error('âŒ papersæ•°ç»„ä»ä¸ºç©ºï¼Œå¯èƒ½å­˜åœ¨åˆ›å»ºé—®é¢˜');
                        }

                        animate();
                    }, 1200);
                }, 1000);
            }

            simulateProgress(min = 1, max = 3) {
                const increment = Math.floor(Math.random() * (max - min + 1)) + min;
                this.updateProgress(increment);

                // æ·»åŠ ä¸€äº›æ€§èƒ½æç¤º
                this.addPerformanceTips();
            }

            addPerformanceTips() {
                const tips = [
                    'ğŸ’¡ ä½¿ç”¨ç°ä»£æµè§ˆå™¨å¯è·å¾—æœ€ä½³ä½“éªŒ',
                    'ğŸš€ ç¡¬ä»¶åŠ é€Ÿå·²å¯ç”¨ä»¥æå‡æ€§èƒ½',
                    'ğŸ¯ è‡ªé€‚åº”æ¸²æŸ“ç¡®ä¿æµç•…è¿è¡Œ',
                    'âš¡ æ™ºèƒ½LODç³»ç»Ÿä¼˜åŒ–è¿œè·ç¦»å¯¹è±¡',
                    'ğŸ”§ ä½¿ç”¨WebGL 2.0è¿›è¡Œé«˜æ•ˆæ¸²æŸ“',
                    'ğŸ“Š åŠ¨æ€è°ƒæ•´æ¸²æŸ“è´¨é‡ä»¥ç»´æŒå¸§ç‡'
                ];

                if (Math.random() < 0.3 && this.completedTasks > 10) {
                    const tip = tips[Math.floor(Math.random() * tips.length)];
                    const tipElement = document.querySelector('.tip-content ul');
                    if (tipElement && tipElement.children.length > 0) {
                        const randomIndex = Math.floor(Math.random() * tipElement.children.length);
                        tipElement.children[randomIndex].textContent = tip;
                    }
                }
            }
        }

        // åˆ›å»ºå…¨å±€åŠ è½½ç®¡ç†å™¨
        const loadingManager = new LoadingManager();

        // å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—
        class TaskQueue {
            constructor() {
                this.tasks = [];
                this.isRunning = false;
            }

            add(task, priority = 0) {
                return new Promise((resolve) => {
                    this.tasks.push({ task, priority, resolve });
                    this.tasks.sort((a, b) => b.priority - a.priority);
                    if (!this.isRunning) {
                        this.process();
                    }
                });
            }

            async process() {
                this.isRunning = true;

                while (this.tasks.length > 0) {
                    const { task, resolve } = this.tasks.shift();

                    try {
                        await this.executeTask(task);
                        resolve(); // ä»»åŠ¡å®Œæˆï¼Œè§£å†³Promise
                    } catch (error) {
                        console.error('ä»»åŠ¡æ‰§è¡Œå¤±è´¥:', error);
                        resolve(); // å³ä½¿å‡ºé”™ä¹Ÿè¦è§£å†³Promise
                    }

                    // è®©æµè§ˆå™¨æœ‰æ—¶é—´å¤„ç†å…¶ä»–ä»»åŠ¡ï¼Œä½†ç¡®ä¿ä»»åŠ¡å®Œæˆ
                    await this.yield();
                }

                this.isRunning = false;
                console.log('ğŸ“‹ æ‰€æœ‰å¼‚æ­¥ä»»åŠ¡å·²å®Œæˆ');
            }

            executeTask(task) {
                return new Promise((resolve) => {
                    try {
                        if (typeof task === 'function') {
                            const result = task();
                            // å¦‚æœtaskè¿”å›Promiseï¼Œç­‰å¾…å®ƒå®Œæˆ
                            if (result && typeof result.then === 'function') {
                                result.then(resolve).catch(resolve);
                            } else {
                                resolve();
                            }
                        } else {
                            resolve();
                        }
                    } catch (error) {
                        console.error('ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸:', error);
                        resolve(); // å³ä½¿å‡ºé”™ä¹Ÿè¦ç»§ç»­
                    }
                });
            }

            yield() {
                return new Promise(resolve => {
                    if (window.requestIdleCallback) {
                        requestIdleCallback(resolve, { timeout: 50 });
                    } else {
                        setTimeout(resolve, 0);
                    }
                });
            }
        }

        const taskQueue = new TaskQueue();

        let scene, camera, renderer, papers = [], stars = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let isMouseDown = false;
        let mouseStart = new THREE.Vector2();
        let animationPaused = false;

        // æ·±ç©ºæ•ˆæœç›¸å…³å˜é‡
        let nebulaClouds = [];
        let meteors = [];
        let cosmicDust = [];
        let starTwinkles = [];
        let distantGalaxies = []; // è¿œæ™¯æ˜Ÿç³»æ•°ç»„

        // é£è¡Œæ§åˆ¶å˜é‡
        let keys = {};
        let flySpeed = 0.5;
        let rotateSpeed = 0.002;
        let cameraRotation = new THREE.Vector2(0, 0);
        let velocity = new THREE.Vector3();
        let flyMode = true;
        let isMousePressed = false;
        let mouseMoveForward = false;
        let dragThreshold = 10;
        let speedTrail = [];
        let maxTrailLength = 20;

        // æœç´¢é”å®šåŠŸèƒ½å˜é‡
        let lockedConcept = null;
        let lockMode = false;
        let lockDistance = 15;
        let lockAngle = 0;
        let lastLockMode = false;
        let preLockPosition = null;

        // FPSè®¡ç®—
        let fps = 60;
        let frameCount = 0;
        let lastTime = Date.now();

        // æ€§èƒ½ä¼˜åŒ–å˜é‡
        let LOD_DISTANCE_NEAR = 60;
        let LOD_DISTANCE_FAR = 300;  // å¤§å¹…å¢åŠ å¯è§è·ç¦»
        let FRUSTUM_CULLING_ENABLED = true;
        let lastCameraPosition = new THREE.Vector3();
        let cameraMovedThreshold = 3;
        let frameSkipCounter = 0;
        let animationUpdateFrequency = 2;

        // è®¡ç®—æœºç§‘å­¦æ˜Ÿç³»å’ŒçŸ¥è¯†ç‚¹ - æ’æ˜Ÿ-è¡Œæ˜Ÿ-å«æ˜Ÿç»“æ„
        const csCourses = [
            {
                name: 'æ•°æ®ç»“æ„',
                color: 0xff6b6b,
                center: new THREE.Vector3(120, 0, 0),
                planets: [
                    {
                        name: 'é“¾è¡¨',
                        color: 0xff4444,
                        satellites: ['å•é“¾è¡¨', 'åŒé“¾è¡¨', 'å¾ªç¯é“¾è¡¨', 'é™æ€é“¾è¡¨']
                    },
                    {
                        name: 'æ ˆ',
                        color: 0xff5555,
                        satellites: ['é¡ºåºæ ˆ', 'é“¾å¼æ ˆ', 'æ ˆâ€”â€”æ‹¬å·åŒ¹é…', 'æ ˆâ€”â€”è¡¨è¾¾å¼æ±‚å€¼', 'æ ˆâ€”â€”å¡ç‰¹å…°æ•°', 'æ ˆâ€”â€”å‡½æ•°è°ƒç”¨', 'æ ˆâ€”â€”é€’å½’']
                    },
                    {
                        name: 'é˜Ÿåˆ—',
                        color: 0xff7777,
                        satellites: ['é¡ºåºé˜Ÿåˆ—', 'å¾ªç¯é˜Ÿåˆ—', 'é“¾é˜Ÿåˆ—', 'åŒç«¯é˜Ÿåˆ—', 'é˜Ÿåˆ—â€”â€”ç¼“å†²åŒº', 'å¹¿åº¦ä¼˜å…ˆæœç´¢']
                    },
                    {
                        name: 'çŸ©é˜µ',
                        color: 0xffaaaa,
                        satellites: ['å¯¹ç§°çŸ©é˜µ', 'ä¸‰è§’çŸ©é˜µ', 'ç¨€ç–çŸ©é˜µâ€”â€”ä¸‰å…ƒç»„è¡¨ç¤ºæ³•', 'ç¨€ç–çŸ©é˜µâ€”â€”åå­—é“¾è¡¨æ³•', 'å¹¿ä¹‰è¡¨', 'KMPæ¨¡å¼åŒ¹é…']
                    },
                    {
                        name: 'æ ‘ä¸äºŒå‰æ ‘',
                        color: 0xff8888,
                        satellites: ['æ ‘ä¸äºŒå‰æ ‘çš„æ€§è´¨', 'BST', 'AVL', 'äºŒå‰æ ‘â€”â€”é¡ºåºå­˜å‚¨', 'äºŒå‰æ ‘â€”â€”é“¾å¼å­˜å‚¨', 'äºŒå‰æ ‘â€”â€”å››åºéå†', 'çº¿ç´¢äºŒå‰æ ‘', 'æ ‘ã€æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢', 'æ ‘å’Œæ£®æ—çš„éå†', 'å“ˆå¤«æ›¼æ ‘', 'å¹¶æŸ¥é›†']
                    },
                    {
                        name: 'å›¾',
                        color: 0xff6666,
                        satellites: ['å›¾çš„å­˜å‚¨ç»“æ„', 'å›¾çš„éå†â€”â€”DFS', 'å›¾çš„éå†â€”â€”BFS', 'æœ€å°ç”Ÿæˆæ ‘â€”â€”Primç®—æ³•', 'æœ€å°ç”Ÿæˆæ ‘â€”â€”Kruskalç®—æ³•', 'æœ€çŸ­è·¯å¾„â€”â€”Dijkstraç®—æ³•', 'æœ€çŸ­è·¯å¾„â€”â€”Floyd', 'æœ€çŸ­è·¯å¾„â€”â€”A*', 'å…³é”®è·¯å¾„']
                    },
                    {
                        name: 'æŸ¥æ‰¾',
                        color: 0xffbbbb,
                        satellites: ['äºŒåˆ†æŸ¥æ‰¾', 'åˆ†å—æŸ¥æ‰¾', 'BST', 'AVL', 'çº¢é»‘æ ‘', 'Bæ ‘', 'B+æ ‘', 'hashè¡¨']
                    },
                    {
                        name: 'æ’åº',
                        color: 0xffcccc,
                        satellites: ['å…«å¤§æ’åº', 'å¤–éƒ¨æ’åº']
                    }
                ]
            },
            {
                name: 'ç®—æ³•è®¾è®¡',
                color: 0x4ecdc4,
                center: new THREE.Vector3(-120, 60, 60),
                planets: [
                    {
                        name: 'åˆ†æ²»ç®—æ³•',
                        color: 0x2eb8b0,
                        satellites: ['äºŒåˆ†æœç´¢', 'å½’å¹¶æ’åº', 'å¿«é€Ÿæ’åº', 'æœ€å¤§å­æ•°ç»„']
                    },
                    {
                        name: 'åŠ¨æ€è§„åˆ’',
                        color: 0x4ecdc4,
                        satellites: ['èƒŒåŒ…é—®é¢˜', 'æœ€é•¿å…¬å…±å­åºåˆ—', 'æœ€é•¿é€’å¢å­åºåˆ—', 'ç¼–è¾‘è·ç¦»', 'çŠ¶æ€è½¬ç§»']
                    },
                    {
                        name: 'è´ªå¿ƒç®—æ³•',
                        color: 0x6ed9d1,
                        satellites: ['æ´»åŠ¨é€‰æ‹©', 'èƒŒåŒ…è´ªå¿ƒ', 'å“ˆå¤«æ›¼ç¼–ç ', 'æœ€å°ç”Ÿæˆæ ‘']
                    },
                    {
                        name: 'å›æº¯ç®—æ³•',
                        color: 0x8ee5de,
                        satellites: ['Nçš‡åé—®é¢˜', 'æ•°ç‹¬æ±‚è§£', 'å­é›†ç”Ÿæˆ', 'æ’åˆ—ç»„åˆ']
                    },
                    {
                        name: 'å›¾è®ºç®—æ³•',
                        color: 0x3ec2b7,
                        satellites: ['æ·±åº¦ä¼˜å…ˆæœç´¢', 'å¹¿åº¦ä¼˜å…ˆæœç´¢', 'Dijkstraç®—æ³•', 'Floydç®—æ³•', 'Kruskalç®—æ³•', 'Primç®—æ³•']
                    },
                    {
                        name: 'å­—ç¬¦ä¸²ç®—æ³•',
                        color: 0x5ed0c7,
                        satellites: ['KMPæ¨¡å¼åŒ¹é…', 'Rabin-Karpç®—æ³•', 'åç¼€æ•°ç»„', 'ACè‡ªåŠ¨æœº']
                    },
                    {
                        name: 'æ•°å€¼ç®—æ³•',
                        color: 0x7eddd4,
                        satellites: ['å¿«é€Ÿå¹‚', 'æ¬§å‡ é‡Œå¾—ç®—æ³•', 'æ‰©å±•æ¬§å‡ é‡Œå¾—', 'ç´ æ•°ç­›é€‰']
                    }
                ]
            },
            {
                name: 'è®¡ç®—æœºç½‘ç»œ',
                color: 0x45b7d1,
                center: new THREE.Vector3(0, -120, 0),
                planets: [
                    {
                        name: 'ç‰©ç†å±‚',
                        color: 0x2aa3c7,
                        satellites: ['æ•°æ®é€šä¿¡çš„åŸºç¡€çŸ¥è¯†', 'ä¼ è¾“ä»‹è´¨', 'ä¿¡é“å¤ç”¨', 'ç‰©ç†å±‚è®¾å¤‡']
                    },
                    {
                        name: 'æ•°æ®é“¾è·¯å±‚',
                        color: 0x45b7d1,
                        satellites: ['ç»„å¸§', 'å·®é”™æ§åˆ¶â€”â€”æ£€é”™ç ', 'å·®é”™æ§åˆ¶â€”â€”çº é”™ç¼–ç ', 'æµé‡æ§åˆ¶', 'å¯é ä¼ è¾“æœºåˆ¶', 'æ»‘åŠ¨çª—å£æœºåˆ¶', 'åœç­‰åè®®', 'GBNåè®®', 'SRåè®®', 'pppåè®®', 'MACå­å±‚', 'CSMA/CDåè®®', 'CSMA/CAåè®®', 'ç½‘æ¡¥', 'ç”Ÿæˆæ ‘åè®®', 'ä»¥å¤ªç½‘äº¤æ¢æœº', 'WLAN', 'ä»¤ç‰Œç¯ç½‘', 'è‡ªé€‚åº”æ ‘', 'ALOHA', 'ä½å›¾åè®®', 'äºŒè¿›åˆ¶å€’è®¡æ•°', 'VLAN', 'ç»å…¸ä»¥å¤ªç½‘']
                    },
                    {
                        name: 'ç½‘ç»œå±‚',
                        color: 0x60c5db,
                        satellites: ['è™šç”µè·¯å’Œæ•°æ®åŒ…æœåŠ¡', 'è·¯ç”±ä¸è½¬å‘', 'æ‹¥å¡æ§åˆ¶', 'DVè·¯ç”±ç®—æ³•', 'é“¾è·¯çŠ¶æ€è·¯ç”±ç®—æ³•', 'å±‚æ¬¡è·¯ç”±', 'IPv4â€”â€”åˆ†ç»„', 'IPv4â€”â€”åœ°å€', 'IPv4â€”â€”NAT', 'IPv4â€”â€”å­ç½‘åˆ’åˆ†ä¸å­ç½‘æ©ç ', 'CIDR', 'ARP', 'DHCP', 'ICMP', 'IPæ•°æ®åŒ…çš„æ ¼å¼', 'RIP', 'OSPF', 'BGP', 'IPv6', 'IPç»„æ’­', 'ç§»åŠ¨IP', 'VPN']
                    },
                    {
                        name: 'ä¼ è¾“å±‚',
                        color: 0x7bd3e5,
                        satellites: ['UDPæ•°æ®åŒ…', 'UDPæ ¡éªŒ', 'TCPæŠ¥æ–‡æ®µ', 'TCPçš„æµé‡æ§åˆ¶', 'TCPçš„å¯é ä¼ è¾“', 'TCPæ‹¥å¡æ§åˆ¶', 'TCPè¿æ¥çš„å»ºç«‹å’Œé‡Šæ”¾', 'å¥—æ¥å­—']
                    },
                    {
                        name: 'åº”ç”¨å±‚',
                        color: 0x96e1ef,
                        satellites: ['DNS', 'FTP', 'TELNET', 'WWW', 'HTTP', 'MIME', 'SMTP', 'POP3', 'DHCP', 'SNMP']
                    },
                    {
                        name: 'ç½‘ç»œå®‰å…¨',
                        color: 0x309bc1,
                        satellites: ['è®¡ç®—æœºç½‘ç»œé¢ä¸´çš„å®‰å…¨æ€§å¨èƒ', 'å®‰å…¨çš„è®¡ç®—æœºç½‘ç»œ', 'å¯¹ç§°å¯†é’¥å¯†ç ', 'DES', 'AES', 'å…¬é’¥å¯†ç ä½“åˆ¶', 'RSA', 'æ•°å­—ç­¾å', 'MD5', 'SHA-1', 'å¯†é’¥åˆ†é…']
                    }
                ]
            },
            {
                name: 'æ“ä½œç³»ç»Ÿ',
                color: 0x96ceb4,
                center: new THREE.Vector3(-60, 0, -120),
                planets: [
                    {
                        name: 'è¿›ç¨‹ç®¡ç†',
                        color: 0x7bc49a,
                        satellites: ['è¿›ç¨‹åˆ›å»º', 'è¿›ç¨‹è°ƒåº¦', 'è¿›ç¨‹åŒæ­¥', 'è¿›ç¨‹é€šä¿¡', 'æ­»é”å¤„ç†']
                    },
                    {
                        name: 'çº¿ç¨‹ç®¡ç†',
                        color: 0x96ceb4,
                        satellites: ['çº¿ç¨‹åˆ›å»º', 'çº¿ç¨‹åŒæ­¥', 'çº¿ç¨‹æ± ', 'å¤šçº¿ç¨‹ç¼–ç¨‹']
                    },
                    {
                        name: 'å†…å­˜ç®¡ç†',
                        color: 0xb1d8ce,
                        satellites: ['å†…å­˜åˆ†é…', 'è™šæ‹Ÿå†…å­˜', 'åˆ†é¡µæœºåˆ¶', 'åˆ†æ®µæœºåˆ¶', 'é¡µé¢ç½®æ¢', 'TLBç®¡ç†']
                    },
                    {
                        name: 'æ–‡ä»¶ç³»ç»Ÿ',
                        color: 0xcce2e8,
                        satellites: ['æ–‡ä»¶åˆ†é…', 'ç›®å½•ç»“æ„', 'ç£ç›˜è°ƒåº¦', 'RAIDæŠ€æœ¯', 'æ–‡ä»¶æƒé™', 'æ—¥å¿—æ–‡ä»¶']
                    },
                    {
                        name: 'è®¾å¤‡ç®¡ç†',
                        color: 0x81ba90,
                        satellites: ['I/Oç®¡ç†', 'ä¸­æ–­å¤„ç†', 'DMAæŠ€æœ¯', 'è®¾å¤‡é©±åŠ¨', 'ç¼“å†²æŠ€æœ¯']
                    },
                    {
                        name: 'ç³»ç»Ÿè°ƒç”¨',
                        color: 0xa6d0b8,
                        satellites: ['ç³»ç»Ÿè°ƒç”¨æ¥å£', 'å†…æ ¸æ€', 'ç”¨æˆ·æ€', 'æƒé™ç®¡ç†', 'ç³»ç»ŸæœåŠ¡']
                    }
                ]
            },
            {
                name: 'æ•°æ®åº“ç³»ç»Ÿ',
                color: 0xffeaa7,
                center: new THREE.Vector3(60, 120, -60),
                planets: [
                    {
                        name: 'å…³ç³»æ¨¡å‹',
                        color: 0xffe083,
                        satellites: ['å…³ç³»ä»£æ•°', 'å…ƒç»„æ¼”ç®—', 'ERæ¨¡å‹', 'å…³ç³»è§„èŒƒåŒ–', 'å‡½æ•°ä¾èµ–']
                    },
                    {
                        name: 'SQLè¯­è¨€',
                        color: 0xffeaa7,
                        satellites: ['DDLè¯­å¥', 'DMLè¯­å¥', 'DCLè¯­å¥', 'æŸ¥è¯¢ä¼˜åŒ–', 'è§†å›¾æ“ä½œ']
                    },
                    {
                        name: 'äº‹åŠ¡ç®¡ç†',
                        color: 0xfff4cb,
                        satellites: ['ACIDæ€§è´¨', 'å¹¶å‘æ§åˆ¶', 'é”æœºåˆ¶', 'æ­»é”å¤„ç†', 'æ¢å¤æŠ€æœ¯']
                    },
                    {
                        name: 'ç´¢å¼•æŠ€æœ¯',
                        color: 0xffecb3,
                        satellites: ['B+æ ‘ç´¢å¼•', 'å“ˆå¸Œç´¢å¼•', 'ä½å›¾ç´¢å¼•', 'å…¨æ–‡ç´¢å¼•', 'ç´¢å¼•ä¼˜åŒ–']
                    },
                    {
                        name: 'æŸ¥è¯¢å¤„ç†',
                        color: 0xffe699,
                        satellites: ['æŸ¥è¯¢ä¼˜åŒ–', 'æ‰§è¡Œè®¡åˆ’', 'è¿æ¥ç®—æ³•', 'é€‰æ‹©ç®—æ³•', 'ç»Ÿè®¡ä¿¡æ¯']
                    },
                    {
                        name: 'åˆ†å¸ƒå¼æ•°æ®åº“',
                        color: 0xffd666,
                        satellites: ['æ•°æ®åˆ†ç‰‡', 'åˆ†å¸ƒå¼äº‹åŠ¡', 'ä¸€è‡´æ€§åè®®', 'CAPç†è®º', 'NoSQLæ•°æ®åº“']
                    }
                ]
            },
            {
                name: 'è½¯ä»¶å·¥ç¨‹',
                color: 0xdda0dd,
                center: new THREE.Vector3(0, 0, 120),
                planets: [
                    {
                        name: 'éœ€æ±‚å·¥ç¨‹',
                        color: 0xd293d3,
                        satellites: ['éœ€æ±‚åˆ†æ', 'éœ€æ±‚å»ºæ¨¡', 'ç”¨ä¾‹åˆ†æ', 'éœ€æ±‚éªŒè¯', 'éœ€æ±‚ç®¡ç†']
                    },
                    {
                        name: 'ç³»ç»Ÿè®¾è®¡',
                        color: 0xdda0dd,
                        satellites: ['æ¶æ„è®¾è®¡', 'è¯¦ç»†è®¾è®¡', 'æ¥å£è®¾è®¡', 'æ•°æ®åº“è®¾è®¡', 'ç”¨æˆ·ç•Œé¢è®¾è®¡']
                    },
                    {
                        name: 'è½¯ä»¶æµ‹è¯•',
                        color: 0xe8ade7,
                        satellites: ['å•å…ƒæµ‹è¯•', 'é›†æˆæµ‹è¯•', 'ç³»ç»Ÿæµ‹è¯•', 'éªŒæ”¶æµ‹è¯•', 'æ€§èƒ½æµ‹è¯•', 'å®‰å…¨æµ‹è¯•']
                    },
                    {
                        name: 'é¡¹ç›®ç®¡ç†',
                        color: 0xf3baf1,
                        satellites: ['æ•æ·å¼€å‘', 'Scrumæ–¹æ³•', 'çœ‹æ¿æ–¹æ³•', 'é£é™©ç®¡ç†', 'è´¨é‡ç®¡ç†']
                    },
                    {
                        name: 'ç‰ˆæœ¬æ§åˆ¶',
                        color: 0xc986c7,
                        satellites: ['Gitç®¡ç†', 'åˆ†æ”¯ç­–ç•¥', 'åˆå¹¶å†²çª', 'ä»£ç å®¡æŸ¥', 'æŒç»­é›†æˆ']
                    },
                    {
                        name: 'è®¾è®¡æ¨¡å¼',
                        color: 0xde9cdb,
                        satellites: ['åˆ›å»ºå‹æ¨¡å¼', 'ç»“æ„å‹æ¨¡å¼', 'è¡Œä¸ºå‹æ¨¡å¼', 'æ¶æ„æ¨¡å¼', 'è®¾è®¡åŸåˆ™']
                    }
                ]
            }
        ];

        async function init() {
            try {
                // é˜¶æ®µ1: åˆå§‹åŒ–å¼•æ“
                loadingManager.setStage('åˆå§‹åŒ–å¼•æ“');
                loadingManager.setTask('åˆ›å»º3Dåœºæ™¯...');
                await initializeEngine();

                // é˜¶æ®µ2: åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
                loadingManager.setStage('åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯');
                loadingManager.setTask('ç”ŸæˆèƒŒæ™¯æ˜Ÿç©º...');
                await createStarFieldAsync();

                // é˜¶æ®µ3: æ„å»ºæ·±ç©ºæ•ˆæœ
                loadingManager.setStage('æ„å»ºæ·±ç©ºæ•ˆæœ');
                loadingManager.setTask('æ·»åŠ æ˜Ÿäº‘å’Œå®‡å®™å°˜åŸƒ...');
                await createDeepSpaceEffectsAsync();

                // é˜¶æ®µ4-9: åˆ›å»ºçŸ¥è¯†ç‚¹èšç±»
                await createConceptClustersAsync();

                // é˜¶æ®µ10: è®¾ç½®äº¤äº’ç³»ç»Ÿ
                loadingManager.setStage('è®¾ç½®äº¤äº’ç³»ç»Ÿ');
                loadingManager.setTask('é…ç½®æ§åˆ¶ç³»ç»Ÿ...');
                await setupInteractionAsync();

                // é˜¶æ®µ11: å®Œæˆåˆå§‹åŒ–
                loadingManager.setStage('å¯åŠ¨å®‡å®™');
                loadingManager.setTask('æœ€ç»ˆä¼˜åŒ–...');
                await finalizeAsync();

                loadingManager.complete();

            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                loadingManager.setTask('âŒ åˆå§‹åŒ–å¤±è´¥');
                loadingManager.setStage('è¯·åˆ·æ–°é¡µé¢é‡è¯•');

                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯å’Œé‡è¯•æŒ‰é’®
                const loadingDetails = document.querySelector('.loading-details');
                if (loadingDetails) {
                    loadingDetails.innerHTML = `
                        <div class="error-info">
                            <div style="color: #ff6b6b; font-size: 16px; margin-bottom: 10px;">âš ï¸ åŠ è½½å¤±è´¥</div>
                            <div style="font-size: 14px; margin-bottom: 15px; opacity: 0.8;">
                                åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–è®¾å¤‡å…¼å®¹æ€§é—®é¢˜ã€‚
                            </div>
                            <button onclick="location.reload()" style="
                                background: linear-gradient(135deg, rgba(255, 107, 107, 0.2) 0%, rgba(255, 107, 107, 0.4) 100%);
                                border: 1px solid #ff6b6b;
                                color: #ff6b6b;
                                padding: 10px 20px;
                                border-radius: var(--border-radius-sm);
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='rgba(255, 107, 107, 0.3)'"
                               onmouseout="this.style.background='linear-gradient(135deg, rgba(255, 107, 107, 0.2) 0%, rgba(255, 107, 107, 0.4) 100%)'">
                                ğŸ”„ é‡æ–°åŠ è½½
                            </button>
                        </div>
                    `;
                }
            }
        }

        async function initializeEngine() {
            // åˆ›å»ºåœºæ™¯
            loadingManager.setTask('åˆ›å»º3Dåœºæ™¯...');
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 50, 400);
            loadingManager.simulateProgress(1, 2);

            // åˆ›å»ºæ‘„åƒæœº
            loadingManager.setTask('è®¾ç½®æ‘„åƒæœº...');
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 150);
            camera.rotation.order = 'YXZ';
            loadingManager.simulateProgress(1, 2);

            // åˆ›å»ºæ¸²æŸ“å™¨
            loadingManager.setTask('åˆå§‹åŒ–æ¸²æŸ“å™¨...');
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setClearColor(0x000011, 0.8);
            renderer.shadowMap.enabled = false;
            renderer.outputEncoding = THREE.LinearEncoding;
            renderer.toneMapping = THREE.NoToneMapping;

            document.getElementById('container').appendChild(renderer.domElement);
            loadingManager.simulateProgress(2, 3);

            // æ·»åŠ å…‰ç…§ç³»ç»Ÿ
            loadingManager.setTask('é…ç½®å…‰ç…§ç³»ç»Ÿ...');
            setupLighting();
            loadingManager.simulateProgress(2, 4);
        }

        async function createStarFieldAsync() {
            const starLayers = [
                { count: 150, size: 0.8, opacity: 0.7, color: 0xffffff, twinkle: true, name: 'è¿‘æ™¯æ˜Ÿç©º' },
                { count: 75, size: 1.2, opacity: 0.5, color: 0x88aaff, twinkle: false, name: 'ä¸­æ™¯æ˜Ÿç©º' },
                { count: 300, size: 0.5, opacity: 0.35, color: 0xffffcc, twinkle: true, twinkeIntensity: 0.3, name: 'è¿œæ™¯æ˜Ÿç©º' }
            ];

            for (let layerIndex = 0; layerIndex < starLayers.length; layerIndex++) {
                const layer = starLayers[layerIndex];
                loadingManager.setTask(`ç”Ÿæˆ${layer.name} (${layer.count}é¢—æ˜Ÿ)...`);

                await taskQueue.add(() => {
                    createStarLayer(layer, layerIndex);
                }, 5);

                loadingManager.simulateProgress(3, 6);
                await new Promise(resolve => setTimeout(resolve, 100)); // çŸ­æš‚å»¶è¿Ÿä»¥æ˜¾ç¤ºè¿›åº¦
            }
        }

        function createStarLayer(layer, layerIndex) {
            const starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            const starOpacities = [];

            for (let i = 0; i < layer.count; i++) {
                const radius = 150 + layerIndex * 80; // å¢åŠ å±‚é—´è·ç¦»
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                starPositions.push(
                    Math.sin(phi) * Math.cos(theta) * radius,
                    Math.cos(phi) * radius,
                    Math.sin(phi) * Math.sin(theta) * radius
                );

                let color = new THREE.Color(layer.color);

                // ä¸ºä¸åŒå±‚æ¬¡æ·»åŠ é¢œè‰²å˜åŒ–
                if (layerIndex === 0) {
                    // è¿‘æ™¯æ˜Ÿç©º - ç™½è‰²ä¸ºä¸»ï¼Œå°‘é‡æš–è‰²
                    const hue = Math.random();
                    if (hue < 0.7) color.setHex(0xffffff);
                    else if (hue < 0.85) color.setHex(0xffddaa);
                    else color.setHex(0xaaddff);
                } else if (layerIndex === 1) {
                    // ä¸­æ™¯æ˜Ÿç©º - è“è‰²ä¸ºä¸»
                    const hue = Math.random();
                    if (hue < 0.6) color.setHex(0x88aaff);
                    else if (hue < 0.8) color.setHex(0xaaddff);
                    else color.setHex(0xddddff);
                } else if (layerIndex === 2) {
                    // è¿œæ™¯æ˜Ÿç©º - æ›´å¤šé¢œè‰²å˜åŒ–ï¼Œæ¨¡æ‹Ÿè¿œè·ç¦»æ˜Ÿç³»
                    const hue = Math.random();
                    if (hue < 0.3) color.setHex(0xffffcc); // æ·¡é»„
                    else if (hue < 0.5) color.setHex(0xffeeaa); // æš–ç™½
                    else if (hue < 0.7) color.setHex(0xeeffff); // å†·ç™½
                    else if (hue < 0.85) color.setHex(0xffcccc); // æ·¡çº¢
                    else color.setHex(0xccffcc); // æ·¡ç»¿
                }

                starColors.push(color.r, color.g, color.b);
                starSizes.push(layer.size * (0.5 + Math.random() * 0.8)); // å¢åŠ å¤§å°å˜åŒ–
                starOpacities.push(layer.opacity * (0.3 + Math.random() * 0.7)); // å¢åŠ é€æ˜åº¦å˜åŒ–
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            starsGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(starOpacities, 1));

            const starMaterial = new THREE.PointsMaterial({
                size: layer.size,
                transparent: true,
                opacity: layer.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const starField = new THREE.Points(starsGeometry, starMaterial);
            starField.userData = {
                rotationSpeed: (layerIndex + 1) * 0.00005, // è¿œæ™¯æ˜Ÿç©ºæ—‹è½¬æ›´æ…¢
                layer: layerIndex,
                twinkle: layer.twinkle,
                baseOpacity: layer.opacity,
                twinkleIntensity: layer.twinkeIntensity || 1.0 // è¿œæ™¯æ˜Ÿç©ºé—ªçƒæ›´å¾®å¼±
            };

            scene.add(starField);
            stars.push(starField);

            if (layer.twinkle) {
                starTwinkles.push({
                    starField: starField,
                    twinkleOffset: Math.random() * Math.PI * 2,
                    twinkleSpeed: (0.3 + Math.random() * 1.0) * (layerIndex === 2 ? 0.6 : 1.0), // è¿œæ™¯æ˜Ÿç©ºé—ªçƒæ›´æ…¢
                    intensity: starField.userData.twinkleIntensity
                });
            }
        }

        async function createDeepSpaceEffectsAsync() {
            loadingManager.setTask('ç”Ÿæˆæ˜Ÿäº‘...');
            await taskQueue.add(() => {
                createNebulaClouds();
            }, 4);
            loadingManager.simulateProgress(2, 5);

            loadingManager.setTask('æ·»åŠ å®‡å®™å°˜åŸƒ...');
            await taskQueue.add(() => {
                createCosmicDust();
            }, 4);
            loadingManager.simulateProgress(2, 5);

            loadingManager.setTask('åˆ›å»ºè¿œæ™¯æ˜Ÿç³»...');
            await taskQueue.add(() => {
                createDistantGalaxies();
            }, 3);
            loadingManager.simulateProgress(2, 4);

            loadingManager.setTask('åˆå§‹åŒ–æµæ˜Ÿç³»ç»Ÿ...');
            await taskQueue.add(() => {
                createMeteorSystem();
            }, 3);
            loadingManager.simulateProgress(2, 4);
        }

        async function createConceptClustersAsync() {
            for (let courseIndex = 0; courseIndex < csCourses.length; courseIndex++) {
                const course = csCourses[courseIndex];
                loadingManager.setStage(`ç”Ÿæˆ${course.name}æ˜Ÿç³»`);
                loadingManager.setTask(`åˆ›å»º${course.name}æ’æ˜Ÿ...`);

                await taskQueue.add(() => {
                    createStar(course, courseIndex);
                }, 3);
                loadingManager.simulateProgress(2, 4);

                // åˆ†æ‰¹åˆ›å»ºè¡Œæ˜Ÿç³»ç»Ÿ
                for (let planetIndex = 0; planetIndex < course.planets.length; planetIndex++) {
                    const planet = course.planets[planetIndex];
                    loadingManager.setTask(`æ„å»º${planet.name}è¡Œæ˜Ÿç³»ç»Ÿ...`);

                    await taskQueue.add(() => {
                        createPlanetSystem(course, planet, planetIndex, courseIndex);
                    }, 2);
                    loadingManager.simulateProgress(1, 2);
                }
            }

            // æ‰€æœ‰æ¦‚å¿µåˆ›å»ºå®Œæˆåï¼Œç«‹å³æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            console.log('ğŸ“Š æ‰€æœ‰æ¦‚å¿µåˆ›å»ºå®Œæˆï¼Œpapersæ•°ç»„é•¿åº¦:', papers.length);
            updateClusterStats();
        }

        async function setupInteractionAsync() {
            loadingManager.setTask('é…ç½®äº‹ä»¶ç›‘å¬å™¨...');
            await taskQueue.add(() => {
                setupEventListeners();
            }, 5);
            loadingManager.simulateProgress(2, 3);

            loadingManager.setTask('éªŒè¯ç»Ÿè®¡æ•°æ®...');
            // å†æ¬¡ç¡®è®¤ç»Ÿè®¡æ•°æ®æ­£ç¡®
            if (papers.length === 0) {
                console.warn('âš ï¸ papersæ•°ç»„ä¸ºç©ºï¼Œé‡æ–°ç»Ÿè®¡...');
                updateClusterStats();
            }
            loadingManager.simulateProgress(1, 2);
        }

        async function finalizeAsync() {
            loadingManager.setTask('æ£€æµ‹è®¾å¤‡æ€§èƒ½...');
            await performanceCheck();
            loadingManager.simulateProgress(1, 2);

            loadingManager.setTask('ä¼˜åŒ–æ¸²æŸ“é…ç½®...');
            await optimizeRenderSettings();
            loadingManager.simulateProgress(1, 2);

            loadingManager.setTask('å‡†å¤‡ç”¨æˆ·ç•Œé¢...');
            await new Promise(resolve => setTimeout(resolve, 200));
            loadingManager.simulateProgress(1, 1);

            loadingManager.setTask('æœ€ç»ˆæ£€æŸ¥å®Œæˆ! âœ¨');
            await new Promise(resolve => setTimeout(resolve, 100));
            loadingManager.simulateProgress(1, 1);
        }

        async function performanceCheck() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    console.log('ğŸ® GPU:', renderer);
                }

                // ç®€å•çš„æ€§èƒ½æµ‹è¯•
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

                console.log('ğŸ“Š æ€§èƒ½å‚æ•°:', {
                    maxTextureSize,
                    maxVertexAttribs,
                    devicePixelRatio: window.devicePixelRatio
                });
            }
        }

        async function optimizeRenderSettings() {
            // æ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´è®¾ç½®
            const devicePixelRatio = window.devicePixelRatio;
            const isHighDPI = devicePixelRatio > 1.5;
            const isMobile = window.innerWidth < 768;

            if (isMobile || isHighDPI) {
                // ç§»åŠ¨è®¾å¤‡æˆ–é«˜DPIè®¾å¤‡ä¼˜åŒ–
                LOD_DISTANCE_FAR = Math.min(LOD_DISTANCE_FAR, 200);
                animationUpdateFrequency = Math.max(animationUpdateFrequency, 3);
                console.log('ğŸ“± å·²åº”ç”¨ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–');
            }

            // å†…å­˜ä½¿ç”¨ä¼°ç®—
            const estimatedMemoryMB = (papers.length * 0.1 + stars.length * 0.05).toFixed(1);
            console.log(`ğŸ’¾ é¢„ä¼°æ˜¾å­˜ä½¿ç”¨: ${estimatedMemoryMB}MB`);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3); // é™ä½ç¯å¢ƒå…‰
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0x00f5ff, 0.5); // é™ä½ä¸»å…‰æº
            mainLight.position.set(50, 50, 50);
            scene.add(mainLight);

            const dynamicLight = new THREE.PointLight(0xffffff, 0.5, 50); // é™ä½åŠ¨æ€å…‰
            dynamicLight.position.set(0, 0, 0);
            scene.add(dynamicLight);

            scene.userData.dynamicLight = dynamicLight;
            scene.userData.mainLight = mainLight;
            scene.userData.starLights = []; // å­˜å‚¨æ’æ˜Ÿå…‰æº
        }

        function createStarField() {
            // è¿™ä¸ªå‡½æ•°ç°åœ¨ç”± createStarFieldAsync æ›¿ä»£
            // ä¿ç•™ä½œä¸ºå…¼å®¹æ€§å‡½æ•°
        }

        function createNebulaClouds() {
            const nebulaConfigs = [
                { color: 0x4400ff, opacity: 0.06, size: 80, position: new THREE.Vector3(-100, 50, -150) },
                { color: 0xff0066, opacity: 0.05, size: 90, position: new THREE.Vector3(120, -30, 100) },
                { color: 0x0066ff, opacity: 0.07, size: 70, position: new THREE.Vector3(-80, -80, 200) },
                { color: 0xff6600, opacity: 0.04, size: 100, position: new THREE.Vector3(50, 100, -100) }
            ];

            nebulaConfigs.forEach((config, index) => {
                const nebulaGeometry = new THREE.SphereGeometry(config.size, 16, 12);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: config.opacity,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });

                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.copy(config.position);
                nebula.userData = {
                    rotationSpeed: (index + 1) * 0.0002, // å¤§å¹…æé«˜æ˜Ÿäº‘åŸºç¡€æ—‹è½¬é€Ÿåº¦
                    pulseSpeed: 0.3 + Math.random() * 0.7,
                    baseOpacity: config.opacity
                };

                scene.add(nebula);
                nebulaClouds.push(nebula);
            });
        }

        function createCosmicDust() {
            const dustCount = 200;
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = [];
            const dustColors = [];
            const dustSizes = [];

            for (let i = 0; i < dustCount; i++) {
                const radius = 100 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                dustPositions.push(
                    Math.sin(phi) * Math.cos(theta) * radius + (Math.random() - 0.5) * 100,
                    Math.cos(phi) * radius + (Math.random() - 0.5) * 100,
                    Math.sin(phi) * Math.sin(theta) * radius + (Math.random() - 0.5) * 100
                );

                const dustColor = new THREE.Color();
                const colorVariant = Math.random();
                if (colorVariant < 0.4) dustColor.setHex(0xffddaa);
                else if (colorVariant < 0.7) dustColor.setHex(0xffaacc);
                else dustColor.setHex(0xaaccff);

                dustColors.push(dustColor.r, dustColor.g, dustColor.b);
                dustSizes.push(0.3 + Math.random() * 0.7);
            }

            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('color', new THREE.Float32BufferAttribute(dustColors, 3));
            dustGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dustSizes, 1));

            const dustMaterial = new THREE.PointsMaterial({
                size: 0.5,
                transparent: true,
                opacity: 0.4,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const dust = new THREE.Points(dustGeometry, dustMaterial);
            dust.userData = {
                rotationSpeed: 0.0001, // å¤§å¹…æé«˜å°˜åŸƒåŸºç¡€æ—‹è½¬é€Ÿåº¦
                driftSpeed: 0.002 // å¤§å¹…æé«˜å°˜åŸƒæ¼‚ç§»é€Ÿåº¦
            };

            scene.add(dust);
            cosmicDust.push(dust);
        }

        function createDistantGalaxies() {
            const galaxyConfigs = [
                {
                    position: new THREE.Vector3(-400, 150, -300),
                    color: 0x8888ff,
                    size: 40,
                    opacity: 0.15,
                    type: 'spiral',
                    rotation: { x: 0.3, y: 0, z: 0.2 }
                },
                {
                    position: new THREE.Vector3(350, -200, 400),
                    color: 0xffaa88,
                    size: 35,
                    opacity: 0.12,
                    type: 'spiral',
                    rotation: { x: -0.4, y: 0.5, z: 0 }
                },
                {
                    position: new THREE.Vector3(-250, -300, 200),
                    color: 0xaaffaa,
                    size: 30,
                    opacity: 0.18,
                    type: 'elliptical',
                    rotation: { x: 0.1, y: -0.3, z: 0.4 }
                },
                {
                    position: new THREE.Vector3(200, 300, -400),
                    color: 0xffccaa,
                    size: 45,
                    opacity: 0.1,
                    type: 'spiral',
                    rotation: { x: 0.6, y: 0.2, z: -0.1 }
                },
                {
                    position: new THREE.Vector3(-100, 0, -500),
                    color: 0xccaaff,
                    size: 25,
                    opacity: 0.2,
                    type: 'irregular',
                    rotation: { x: 0, y: 0.7, z: 0.3 }
                }
            ];

            galaxyConfigs.forEach((config, index) => {
                if (config.type === 'spiral') {
                    createSpiralGalaxy(config, index);
                } else if (config.type === 'elliptical') {
                    createEllipticalGalaxy(config, index);
                } else {
                    createIrregularGalaxy(config, index);
                }
            });
        }

        function createSpiralGalaxy(config, index) {
            const group = new THREE.Group();

            // åˆ›å»ºèºæ—‹è‡‚
            const spiralGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let arm = 0; arm < 2; arm++) {
                for (let i = 0; i < 100; i++) {
                    const t = i / 100;
                    const angle = t * Math.PI * 4 + arm * Math.PI; // ä¸¤æ¡èºæ—‹è‡‚
                    const radius = t * config.size * 0.8;

                    // æ·»åŠ ä¸€äº›éšæœºæ‰°åŠ¨è®©èºæ—‹è‡‚æ›´è‡ªç„¶
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * config.size * 0.1;
                    const y = (Math.random() - 0.5) * config.size * 0.15; // è®©æ˜Ÿç³»æœ‰ä¸€å®šåšåº¦
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * config.size * 0.1;

                    positions.push(x, y, z);

                    // é¢œè‰²ä»ä¸­å¿ƒåˆ°è¾¹ç¼˜æ¸å˜
                    const color = new THREE.Color(config.color);
                    const brightness = Math.max(0.3, 1 - t * 0.7); // ä¸­å¿ƒæ›´äº®
                    color.multiplyScalar(brightness);
                    colors.push(color.r, color.g, color.b);

                    // å¤§å°ä»ä¸­å¿ƒåˆ°è¾¹ç¼˜å˜å°
                    sizes.push((1 - t * 0.5) * 2);
                }
            }

            // æ·»åŠ æ˜Ÿç³»æ ¸å¿ƒ
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * config.size * 0.2;

                const x = Math.cos(angle) * radius;
                const y = (Math.random() - 0.5) * config.size * 0.05;
                const z = Math.sin(angle) * radius;

                positions.push(x, y, z);

                const coreColor = new THREE.Color(config.color);
                coreColor.multiplyScalar(1.5); // æ ¸å¿ƒæ›´äº®
                colors.push(coreColor.r, coreColor.g, coreColor.b);
                sizes.push(3 + Math.random() * 2);
            }

            spiralGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            spiralGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            spiralGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const spiralMaterial = new THREE.PointsMaterial({
                size: 1,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const spiral = new THREE.Points(spiralGeometry, spiralMaterial);
            group.add(spiral);

            // è®¾ç½®ä½ç½®å’Œæ—‹è½¬
            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0002 + 0.0001) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.2 + Math.random() * 0.3,
                type: 'spiral',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createEllipticalGalaxy(config, index) {
            const group = new THREE.Group();

            const ellipticalGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            // åˆ›å»ºæ¤­åœ†å½¢æ˜Ÿç³»
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.8); // ä¸­å¿ƒå¯†åº¦æ›´é«˜

                const a = config.size * 0.7; // é•¿è½´
                const b = config.size * 0.4; // çŸ­è½´

                const x = Math.cos(angle) * distance * a;
                const y = (Math.random() - 0.5) * config.size * 0.2;
                const z = Math.sin(angle) * distance * b;

                positions.push(x, y, z);

                const color = new THREE.Color(config.color);
                const brightness = Math.max(0.4, 1 - distance * 0.6);
                color.multiplyScalar(brightness);
                colors.push(color.r, color.g, color.b);

                sizes.push((1 - distance * 0.3) * 1.5);
            }

            ellipticalGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            ellipticalGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            ellipticalGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const ellipticalMaterial = new THREE.PointsMaterial({
                size: 0.8,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const elliptical = new THREE.Points(ellipticalGeometry, ellipticalMaterial);
            group.add(elliptical);

            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0001 + 0.00005) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.1 + Math.random() * 0.2,
                type: 'elliptical',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createIrregularGalaxy(config, index) {
            const group = new THREE.Group();

            const irregularGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            // åˆ›å»ºä¸è§„åˆ™æ˜Ÿç³»ï¼ˆæ›´éšæœºçš„åˆ†å¸ƒï¼‰
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random();
                const irregularity = Math.random() * 0.8 + 0.2; // ä¸è§„åˆ™å› å­

                const x = Math.cos(angle) * distance * config.size * irregularity;
                const y = (Math.random() - 0.5) * config.size * 0.3;
                const z = Math.sin(angle) * distance * config.size * irregularity;

                positions.push(x, y, z);

                const color = new THREE.Color(config.color);
                const brightness = Math.random() * 0.8 + 0.3; // æ›´éšæœºçš„äº®åº¦
                color.multiplyScalar(brightness);
                colors.push(color.r, color.g, color.b);

                sizes.push(Math.random() * 2 + 0.5);
            }

            irregularGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            irregularGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            irregularGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const irregularMaterial = new THREE.PointsMaterial({
                size: 1.2,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const irregular = new THREE.Points(irregularGeometry, irregularMaterial);
            group.add(irregular);

            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0003 + 0.0001) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.3 + Math.random() * 0.4,
                type: 'irregular',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createMeteorSystem() {
            const meteorCount = 3;

            for (let i = 0; i < meteorCount; i++) {
                const meteorData = {
                    active: false,
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    trail: [],
                    nextSpawn: Math.random() * 10000 + 5000,
                    mesh: null
                };

                meteors.push(meteorData);
            }
        }

        function createConceptClusters() {
            // è¿™ä¸ªå‡½æ•°ç°åœ¨ç”± createConceptClustersAsync æ›¿ä»£
            // ä¿ç•™ä½œä¸ºå…¼å®¹æ€§å‡½æ•°
        }

        function createStar(course, courseIndex) {
            const starSize = 3.0 + Math.random() * 1.0;
            const starGeometry = new THREE.SphereGeometry(starSize, 32, 24);

            // æ ¹æ®ä¸åŒè¯¾ç¨‹åˆ›å»ºä¸åŒç‰¹è‰²çš„æ’æ˜Ÿ
            let starMaterial, specialEffects = {};

            switch(courseIndex) {
                case 0: // æ•°æ®ç»“æ„ - è„‰å†²çº¢æ˜Ÿ
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    specialEffects.pulseType = 'strong';
                    specialEffects.energyRings = true;
                    break;

                case 1: // ç®—æ³•è®¾è®¡ - æ—‹è½¬é’æ˜Ÿ
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    specialEffects.pulseType = 'rhythmic';
                    specialEffects.spiralField = true;
                    break;

                case 2: // è®¡ç®—æœºç½‘ç»œ - ç½‘ç»œèŠ‚ç‚¹æ˜Ÿ
                    specialEffects.dataStreams = true;
                    break;

                case 3: // æ“ä½œç³»ç»Ÿ - ç¨³å®šç»¿æ˜Ÿ
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.95
                    });
                    specialEffects.pulseType = 'stable';
                    specialEffects.coreShield = true;
                    break;

                case 4: // æ•°æ®åº“ç³»ç»Ÿ - æ•°æ®çŸ©é˜µæ˜Ÿ
                    specialEffects.crystalline = true;
                    break;

                case 5: // è½¯ä»¶å·¥ç¨‹ - ä»£ç ä¹‹èŠ±
                    specialEffects.prismatic = true;
                    break;
            }

            if (!starMaterial) {
                starMaterial = new THREE.MeshBasicMaterial({
                    color: course.color,
                    transparent: true,
                    opacity: 0.9
                });
            }

            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.copy(course.center);

            // ä¸ºæ’æ˜Ÿåˆ›å»ºæ›´å¤§çš„ä¸å¯è§ç¢°æ’ä½“ä»¥æé«˜ç‚¹å‡»æ£€æµ‹
            const starClickGeometry = new THREE.SphereGeometry(starSize * 2, 16, 12);
            const starClickMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                visible: false
            });
            const starClickMesh = new THREE.Mesh(starClickGeometry, starClickMaterial);
            starClickMesh.position.copy(course.center);
            starClickMesh.userData = {
                type: 'star',
                name: course.name,
                course: courseIndex,
                animationOffset: Math.random() * Math.PI * 2,
                pulseSpeed: courseIndex === 1 ? 0.8 : courseIndex === 2 ? 1.2 : 0.5 + Math.random() * 0.5,
                baseColor: new THREE.Color(course.color),
                originalPosition: course.center.clone(),
                specialEffects: specialEffects,
                realMesh: star  // å¼•ç”¨åˆ°çœŸå®çš„æ˜Ÿçƒç½‘æ ¼
            };
            scene.add(starClickMesh);
            papers.push(starClickMesh);  // å°†ç¢°æ’ä½“åŠ å…¥æ£€æµ‹æ•°ç»„

            // åˆ›å»ºä¸åŒå¼ºåº¦çš„æ’æ˜Ÿå…‰æº
            const lightIntensity = courseIndex === 3 ? 2.5 : courseIndex === 4 ? 3.0 : 2.0;
            const starLight = new THREE.PointLight(course.color, lightIntensity, 100, 2);
            starLight.position.copy(course.center);
            scene.add(starLight);
            scene.userData.starLights.push({
                light: starLight,
                baseIntensity: lightIntensity,
                color: course.color,
                animationOffset: Math.random() * Math.PI * 2,
                courseIndex: courseIndex
            });

            star.userData = {
                type: 'star',
                name: course.name,
                course: courseIndex,
                animationOffset: Math.random() * Math.PI * 2,
                pulseSpeed: courseIndex === 1 ? 0.8 : courseIndex === 2 ? 1.2 : 0.5 + Math.random() * 0.5,
                baseColor: new THREE.Color(course.color),
                originalPosition: course.center.clone(),
                starLight: starLight,
                specialEffects: specialEffects,
                clickMesh: starClickMesh  // å¼•ç”¨åˆ°ç¢°æ’ä½“
            };

            // åˆ›å»ºç‰¹è‰²æ•ˆæœ
            createStarSpecialEffects(star, course, courseIndex, starSize);

            scene.add(star);
            // ä¸è¦å°†staråŠ å…¥papersæ•°ç»„ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»åŠ å…¥äº†clickMesh
        }

        // åˆ›å»ºæ’æ˜Ÿç‰¹è‰²æ•ˆæœ
        function createStarSpecialEffects(star, course, courseIndex, starSize) {
            const effects = star.userData.specialEffects;

            // åŸºç¡€å†…å±‚å‘å…‰
            const glowGeometry = new THREE.SphereGeometry(starSize * 1.2, 24, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(course.color).multiplyScalar(1.8),
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            star.add(glow);
            star.userData.innerGlow = glow;

            switch(courseIndex) {
                case 0: // æ•°æ®ç»“æ„ - èƒ½é‡ç¯
                    if (effects.energyRings) {
                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.RingGeometry(starSize * (2 + i), starSize * (2.2 + i), 32);
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: course.color,
                                transparent: true,
                                opacity: 0.3 - i * 0.1,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.rotation.x = Math.PI / 2;
                            star.add(ring);
                            star.userData[`energyRing${i}`] = ring;
                        }
                    }
                    break;

                case 1: // ç®—æ³•è®¾è®¡ - èºæ—‹åœº
                    if (effects.spiralField) {
                        const spiralGeometry = new THREE.BufferGeometry();
                        const positions = [];
                        const colors = [];

                        for (let i = 0; i < 100; i++) {
                            const t = i / 100 * Math.PI * 4;
                            const radius = starSize * (3 + t * 0.5);
                            positions.push(
                                Math.cos(t) * radius,
                                Math.sin(t * 0.5) * starSize * 2,
                                Math.sin(t) * radius
                            );

                            const spiralColor = new THREE.Color(course.color);
                            colors.push(spiralColor.r, spiralColor.g, spiralColor.b);
                        }

                        spiralGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        spiralGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                        const spiralMaterial = new THREE.PointsMaterial({
                            size: 3,
                            transparent: true,
                            opacity: 0.6,
                            vertexColors: true,
                            blending: THREE.AdditiveBlending
                        });

                        const spiral = new THREE.Points(spiralGeometry, spiralMaterial);
                        star.add(spiral);
                        star.userData.spiral = spiral;
                    }
                    break;

                case 2: // è®¡ç®—æœºç½‘ç»œ - ç½‘ç»œèŠ‚ç‚¹æ˜Ÿ
                    if (effects.dataStreams) {
                        // åˆ›å»ºç½‘ç»œèŠ‚ç‚¹è¿æ¥æ•ˆæœ
                        const nodePositions = [
                            new THREE.Vector3(starSize * 3, 0, 0),
                            new THREE.Vector3(-starSize * 3, 0, 0),
                            new THREE.Vector3(0, starSize * 3, 0),
                            new THREE.Vector3(0, -starSize * 3, 0),
                            new THREE.Vector3(0, 0, starSize * 3),
                            new THREE.Vector3(0, 0, -starSize * 3),
                            new THREE.Vector3(starSize * 2, starSize * 2, 0),
                            new THREE.Vector3(-starSize * 2, -starSize * 2, 0)
                        ];

                        // åˆ›å»ºç½‘ç»œèŠ‚ç‚¹
                        nodePositions.forEach((pos, i) => {
                            const nodeGeometry = new THREE.SphereGeometry(starSize * 0.3, 12, 8);
                            const nodeMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.2),
                                transparent: true,
                                opacity: 0.7,
                                blending: THREE.AdditiveBlending
                            });
                            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                            node.position.copy(pos);
                            star.add(node);
                            star.userData[`networkNode${i}`] = node;
                        });

                        // åˆ›å»ºè¿æ¥çº¿ - å…¨è¿æ¥ç½‘ç»œ
                        for (let i = 0; i < nodePositions.length; i++) {
                            for (let j = i + 1; j < nodePositions.length; j++) {
                                const points = [nodePositions[i], nodePositions[j]];
                                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                                const lineMaterial = new THREE.LineBasicMaterial({
                                    color: course.color,
                                    transparent: true,
                                    opacity: 0.15,
                                    blending: THREE.AdditiveBlending
                                });
                                const line = new THREE.Line(lineGeometry, lineMaterial);
                                star.add(line);
                                star.userData[`networkLine${i}_${j}`] = line;
                            }
                        }

                        // æ·»åŠ æ•°æ®åŒ…æµåŠ¨æ•ˆæœ
                        for (let i = 0; i < 5; i++) {
                            const packetGeometry = new THREE.SphereGeometry(starSize * 0.1, 8, 6);
                            const packetMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(2),
                                transparent: true,
                                opacity: 0.8,
                                blending: THREE.AdditiveBlending
                            });
                            const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                            packet.userData = {
                                pathProgress: Math.random(),
                                pathSpeed: 0.01 + Math.random() * 0.02,
                                pathIndex: Math.floor(Math.random() * nodePositions.length)
                            };
                            star.add(packet);
                            star.userData[`dataPacket${i}`] = packet;
                        }
                    }
                    break;

                case 3: // æ“ä½œç³»ç»Ÿ - æ ¸å¿ƒæŠ¤ç›¾
                    if (effects.coreShield) {
                        const shieldGeometry = new THREE.IcosahedronGeometry(starSize * 3, 1);
                        const shieldMaterial = new THREE.MeshBasicMaterial({
                            color: course.color,
                            transparent: true,
                            opacity: 0.15,
                            blending: THREE.AdditiveBlending,
                            wireframe: true
                        });
                        const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                        star.add(shield);
                        star.userData.shield = shield;
                    }
                    break;

                case 4: // æ•°æ®åº“ç³»ç»Ÿ - ä¼˜åŒ–æ•°æ®çŸ©é˜µæ˜Ÿ
                    if (effects.crystalline) {
                        // åˆ›å»ºåˆ†å±‚æ•°æ®ç»“æ„
                        const layers = [
                            { size: 3, spacing: starSize * 1.2, cubeSize: starSize * 0.3, name: 'ä¸»æ•°æ®å±‚' },
                            { size: 5, spacing: starSize * 0.8, cubeSize: starSize * 0.2, name: 'ç´¢å¼•å±‚' },
                            { size: 7, spacing: starSize * 0.6, cubeSize: starSize * 0.15, name: 'ç¼“å­˜å±‚' }
                        ];

                        layers.forEach((layer, layerIndex) => {
                            const offset = -(layer.size - 1) / 2;

                            for (let x = 0; x < layer.size; x++) {
                                for (let y = 0; y < layer.size; y++) {
                                    for (let z = 0; z < layer.size; z++) {
                                        // è·³è¿‡ä¸­å¿ƒä½ç½®ï¼ˆæ’æ˜Ÿä½ç½®ï¼‰
                                        if (layerIndex === 0 && x === 1 && y === 1 && z === 1) continue;

                                        // åœ¨å¤–å±‚åªåˆ›å»ºè¾¹ç¼˜ç«‹æ–¹ä½“
                                        if (layerIndex > 0) {
                                            const isEdge = x === 0 || x === layer.size - 1 ||
                                                         y === 0 || y === layer.size - 1 ||
                                                         z === 0 || z === layer.size - 1;
                                            if (!isEdge) continue;
                                        }

                                        const cubeGeometry = new THREE.BoxGeometry(layer.cubeSize, layer.cubeSize, layer.cubeSize);
                                        const brightness = 0.6 + Math.random() * 0.4;
                                        const cubeMaterial = new THREE.MeshBasicMaterial({
                                            color: new THREE.Color(course.color).multiplyScalar(brightness),
                                            transparent: true,
                                            opacity: 0.4 + layerIndex * 0.1,
                                            blending: THREE.AdditiveBlending
                                        });
                                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

                                        cube.position.set(
                                            (x + offset) * layer.spacing,
                                            (y + offset) * layer.spacing,
                                            (z + offset) * layer.spacing
                                        );

                                        cube.userData = {
                                            baseOpacity: cubeMaterial.opacity,
                                            flashDelay: Math.random() * 8,
                                            rotationSpeed: 0.002 + Math.random() * 0.008,
                                            layer: layerIndex,
                                            accessFrequency: layerIndex === 0 ? 0.01 : layerIndex === 1 ? 0.005 : 0.002
                                        };

                                        star.add(cube);
                                        star.userData[`matrixCube${layerIndex}_${x}_${y}_${z}`] = cube;
                                    }
                                }
                            }
                        });

                        // æ·»åŠ æ•°æ®æµè¿æ¥çº¿ - è¿æ¥ä¸åŒå±‚çº§
                        for (let i = 0; i < 20; i++) {
                            const layer1 = Math.floor(Math.random() * 3);
                            const layer2 = (layer1 + 1) % 3;

                            const radius1 = starSize * (1.2 - layer1 * 0.3);
                            const radius2 = starSize * (1.2 - layer2 * 0.3);

                            const angle1 = Math.random() * Math.PI * 2;
                            const angle2 = Math.random() * Math.PI * 2;

                            const startPos = new THREE.Vector3(
                                Math.cos(angle1) * radius1,
                                (Math.random() - 0.5) * starSize * 2,
                                Math.sin(angle1) * radius1
                            );
                            const endPos = new THREE.Vector3(
                                Math.cos(angle2) * radius2,
                                (Math.random() - 0.5) * starSize * 2,
                                Math.sin(angle2) * radius2
                            );

                            const points = [startPos, endPos];
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.2),
                                transparent: true,
                                opacity: 0.25,
                                blending: THREE.AdditiveBlending
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            star.add(line);
                            star.userData[`dataConnection${i}`] = line;
                        }

                        // æ·»åŠ ä¸»é”®ç´¢å¼•ç¯
                        const primaryRing = new THREE.RingGeometry(starSize * 2.8, starSize * 3.2, 32);
                        const primaryMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(course.color).multiplyScalar(1.5),
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide
                        });
                        const ring = new THREE.Mesh(primaryRing, primaryMaterial);
                        ring.rotation.x = Math.PI / 2;
                        star.add(ring);
                        star.userData.primaryKeyRing = ring;
                    }
                    break;

                case 5: // è½¯ä»¶å·¥ç¨‹ - è„‰å†²æ˜Ÿ
                    if (effects.prismatic) {
                        // åˆ›å»ºè„‰å†²æ˜Ÿæ ¸å¿ƒç¯
                        const coreRings = 4;
                        for (let i = 0; i < coreRings; i++) {
                            const ringRadius = starSize * (1.5 + i * 0.5);
                            const ringGeometry = new THREE.RingGeometry(ringRadius, ringRadius + starSize * 0.1, 32);
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.5 - i * 0.2),
                                transparent: true,
                                opacity: 0.6 - i * 0.1,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.rotation.x = Math.PI / 2;
                            ring.userData = {
                                baseRadius: ringRadius,
                                pulseOffset: i * Math.PI / 2,
                                ringIndex: i
                            };
                            star.add(ring);
                            star.userData[`pulseRing${i}`] = ring;
                        }

                        // åˆ›å»ºç£åœºçº¿
                        const fieldLines = 12;
                        for (let i = 0; i < fieldLines; i++) {
                            const points = [];
                            const segments = 20;

                            for (let j = 0; j <= segments; j++) {
                                const t = j / segments;
                                const radius = starSize * (2 + Math.sin(t * Math.PI * 2) * 1.5);
                                const height = (t - 0.5) * starSize * 6;
                                const angle = (i / fieldLines) * Math.PI * 2 + t * Math.PI * 0.5;

                                points.push(new THREE.Vector3(
                                    Math.cos(angle) * radius,
                                    height,
                                    Math.sin(angle) * radius
                                ));
                            }

                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(0.8),
                                transparent: true,
                                opacity: 0.3,
                                blending: THREE.AdditiveBlending
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            line.userData = {
                                fieldIndex: i,
                                rotationSpeed: 0.005 + Math.random() * 0.01
                            };
                            star.add(line);
                            star.userData[`magneticField${i}`] = line;
                        }
                    }
                    break;
            }

            // æ ‡å‡†å…‰æ™•å’Œè¾å°„æ•ˆæœ
            const coronaGeometry = new THREE.SphereGeometry(starSize * 2.5, 24, 16);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: course.color,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            star.add(corona);
            star.userData.corona = corona;

            const radiationGeometry = new THREE.SphereGeometry(starSize * 4, 16, 12);
            const radiationMaterial = new THREE.MeshBasicMaterial({
                color: course.color,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending
            });
            const radiation = new THREE.Mesh(radiationGeometry, radiationMaterial);
            star.add(radiation);
            star.userData.radiation = radiation;
        }

        function createPlanetSystem(course, planet, planetIndex, courseIndex) {
            const orbitRadius = 20 + planetIndex * 15;  // å¢åŠ åŸºç¡€è·ç¦»å’Œé—´éš”è·ç¦»
            const orbitSpeed = 0.012 / (1 + planetIndex * 0.2); // æé«˜è½¨é“é€Ÿåº¦ï¼Œå‡å°‘é€Ÿåº¦è¡°å‡
            const initialAngle = (planetIndex / course.planets.length) * Math.PI * 2;

            // åˆ›å»ºè¡Œæ˜Ÿè½¨é“çº¿ï¼ˆå›´ç»•æ’æ˜Ÿï¼‰
            const orbitPoints = [];
            const orbitSegments = 64; // è½¨é“åˆ†æ®µæ•°ï¼Œè¶Šå¤šè¶Šåœ†æ»‘
            for (let i = 0; i <= orbitSegments; i++) {
                const angle = (i / orbitSegments) * Math.PI * 2;
                orbitPoints.push(new THREE.Vector3(
                    course.center.x + Math.cos(angle) * orbitRadius,
                    course.center.y,
                    course.center.z + Math.sin(angle) * orbitRadius
                ));
            }

            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(course.color).multiplyScalar(0.6), // ä½¿ç”¨è¯¾ç¨‹é¢œè‰²ä½†è¾ƒæš—
                transparent: true,
                opacity: 0.15, // å¾ˆä½çš„é€æ˜åº¦ï¼Œä¸ä¼šå¤ªæ˜¾çœ¼
                blending: THREE.AdditiveBlending
            });

            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);

            const planetSize = 1.0 + Math.random() * 0.5;
            const planetGeometry = new THREE.SphereGeometry(planetSize, 24, 18);

            // è¡Œæ˜Ÿä½¿ç”¨å—å…‰ç…§å½±å“çš„æè´¨ï¼Œæé«˜äº®åº¦
            const planetMaterial = new THREE.MeshPhongMaterial({
                color: planet.color,
                emissive: new THREE.Color(planet.color).multiplyScalar(0.5), // ä»0.25æé«˜åˆ°0.5ï¼Œå¢åŠ å‘å…‰å¼ºåº¦
                transparent: true,
                opacity: 0.95, // ä»0.9æé«˜åˆ°0.95ï¼Œå¢åŠ ä¸é€æ˜åº¦
                shininess: 60  // ä»40æé«˜åˆ°60ï¼Œå¢åŠ é‡‘å±å…‰æ³½
            });

            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);

            planetMesh.position.set(
                course.center.x + Math.cos(initialAngle) * orbitRadius,
                course.center.y + Math.sin(initialAngle * 0.3) * 3,
                course.center.z + Math.sin(initialAngle) * orbitRadius
            );

            // ä¸ºè¡Œæ˜Ÿåˆ›å»ºæ›´å¤§çš„ä¸å¯è§ç¢°æ’ä½“
            const planetClickGeometry = new THREE.SphereGeometry(planetSize * 2, 16, 12);
            const planetClickMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                visible: false
            });
            const planetClickMesh = new THREE.Mesh(planetClickGeometry, planetClickMaterial);
            planetClickMesh.position.copy(planetMesh.position);
            planetClickMesh.userData = {
                type: 'planet',
                name: planet.name,
                course: courseIndex,
                planetIndex: planetIndex,
                orbitRadius: orbitRadius,
                orbitSpeed: orbitSpeed,
                orbitAngle: initialAngle,
                orbitCenter: course.center,
                animationOffset: Math.random() * Math.PI * 2,
                baseColor: new THREE.Color(planet.color),
                satellites: planet.satellites,
                realMesh: planetMesh
            };
            scene.add(planetClickMesh);
            papers.push(planetClickMesh);

            planetMesh.userData = {
                type: 'planet',
                name: planet.name,
                course: courseIndex,
                planetIndex: planetIndex,
                orbitRadius: orbitRadius,
                orbitSpeed: orbitSpeed,
                orbitAngle: initialAngle,
                orbitCenter: course.center,
                animationOffset: Math.random() * Math.PI * 2,
                baseColor: new THREE.Color(planet.color),
                satellites: planet.satellites,
                clickMesh: planetClickMesh
            };

            scene.add(planetMesh);
            // ä¸è¦å°†planetMeshåŠ å…¥papersï¼Œå› ä¸ºå·²ç»åŠ å…¥äº†clickMesh

            // ä¸ºè¡Œæ˜Ÿæ·»åŠ å‘å…‰æ•ˆæœï¼Œä½¿å…¶åœ¨æ—‹è½¬æ—¶æ›´åŠ æ˜æ˜¾
            const planetGlowGeometry = new THREE.SphereGeometry(planetSize * 1.5, 16, 12);
            const planetGlowMaterial = new THREE.MeshBasicMaterial({
                color: planet.color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const planetGlow = new THREE.Mesh(planetGlowGeometry, planetGlowMaterial);
            planetMesh.add(planetGlow);
            planetMesh.userData.planetGlow = planetGlow;

            createSatelliteSystem(planetMesh, planet);
        }

        function createSatelliteSystem(planetMesh, planetData) {
            const satelliteCount = Math.min(planetData.satellites.length, 8);

            for (let i = 0; i < satelliteCount; i++) {
                const satelliteName = planetData.satellites[i];

                const satelliteOrbitRadius = 4 + i * 2;  // å¢åŠ å«æ˜Ÿè½¨é“é—´è·
                const satelliteOrbitSpeed = 0.018 / (1 + i * 0.15); // æé«˜åŸºç¡€è½¨é“é€Ÿåº¦ï¼Œå‡å°‘é€Ÿåº¦è¡°å‡
                const satelliteInitialAngle = (i / satelliteCount) * Math.PI * 2;

                const satelliteSize = 0.3 + Math.random() * 0.2;
                const satelliteGeometry = new THREE.SphereGeometry(satelliteSize, 16, 12);

                // å«æ˜Ÿä¹Ÿä½¿ç”¨å—å…‰ç…§å½±å“çš„æè´¨ï¼Œå¹¶æé«˜äº®åº¦
                const satelliteMaterial = new THREE.MeshPhongMaterial({
                    color: planetData.color,
                    emissive: new THREE.Color(planetData.color).multiplyScalar(0.3), // ä»0.15æé«˜åˆ°0.3
                    transparent: true,
                    opacity: 0.9, // ä»0.85æé«˜åˆ°0.9
                    shininess: 45 // ä»30æé«˜åˆ°45
                });

                const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);

                satellite.position.set(
                    Math.cos(satelliteInitialAngle) * satelliteOrbitRadius,
                    Math.sin(satelliteInitialAngle * 0.5) * 1,
                    Math.sin(satelliteInitialAngle) * satelliteOrbitRadius
                );

                // ä¸ºå«æ˜Ÿåˆ›å»ºæ›´å¤§çš„ä¸å¯è§ç¢°æ’ä½“
                const satelliteClickGeometry = new THREE.SphereGeometry(satelliteSize * 3, 12, 8);
                const satelliteClickMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    visible: false
                });
                const satelliteClickMesh = new THREE.Mesh(satelliteClickGeometry, satelliteClickMaterial);
                satelliteClickMesh.position.copy(satellite.position);
                satelliteClickMesh.userData = {
                    type: 'satellite',
                    name: satelliteName,
                    course: planetMesh.userData.course,
                    planetIndex: planetMesh.userData.planetIndex,
                    satelliteIndex: i,
                    orbitRadius: satelliteOrbitRadius,
                    orbitSpeed: satelliteOrbitSpeed,
                    orbitAngle: satelliteInitialAngle,
                    animationOffset: Math.random() * Math.PI * 2,
                    baseColor: new THREE.Color(planetData.color),
                    parentPlanet: planetMesh,
                    realMesh: satellite
                };
                scene.add(satelliteClickMesh);
                papers.push(satelliteClickMesh);

                satellite.userData = {
                    type: 'satellite',
                    name: satelliteName,
                    course: planetMesh.userData.course,
                    planetIndex: planetMesh.userData.planetIndex,
                    satelliteIndex: i,
                    orbitRadius: satelliteOrbitRadius,
                    orbitSpeed: satelliteOrbitSpeed,
                    orbitAngle: satelliteInitialAngle,
                    animationOffset: Math.random() * Math.PI * 2,
                    baseColor: new THREE.Color(planetData.color),
                    parentPlanet: planetMesh,
                    clickMesh: satelliteClickMesh
                };

                if (Math.random() > 0.5) {
                    const glowGeometry = new THREE.SphereGeometry(satelliteSize * 2, 12, 8);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: planetData.color,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    satellite.add(glow);
                    satellite.userData.glow = glow;
                }

                scene.add(satellite);
                // ä¸è¦å°†satelliteåŠ å…¥papersï¼Œå› ä¸ºå·²ç»åŠ å…¥äº†clickMesh
            }
        }

        function setupEventListeners() {
            const canvas = renderer.domElement;
            const container = document.getElementById('container');

            // è®¾ç½®canvaså¯ä»¥è·å¾—ç„¦ç‚¹
            canvas.setAttribute('tabindex', '0');
            canvas.style.outline = 'none'; // ç§»é™¤ç„¦ç‚¹æ—¶çš„è½®å»“

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);

            // åŒæ—¶ç›‘å¬canvaså’Œdocumentçš„é”®ç›˜äº‹ä»¶
            canvas.addEventListener('keydown', onKeyDown);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // å½“ç‚¹å‡»canvasæ—¶ï¼Œç¡®ä¿å®ƒè·å¾—ç„¦ç‚¹
            canvas.addEventListener('click', () => {
                canvas.focus();
            });

            // ç„¦ç‚¹çŠ¶æ€è§†è§‰åé¦ˆ
            canvas.addEventListener('focus', () => {
                container.classList.add('focused');
            });

            canvas.addEventListener('blur', () => {
                container.classList.remove('focused');
            });

            // é¡µé¢åŠ è½½æ—¶è®©canvasè·å¾—ç„¦ç‚¹
            setTimeout(() => {
                canvas.focus();
            }, 1000);

            window.addEventListener('resize', onWindowResize);

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            isMouseDown = true;
            isMousePressed = true;
            mouseMoveForward = true;
            mouseStart.set(event.clientX, event.clientY);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isMouseDown && flyMode && !lockMode) {
                const deltaX = event.clientX - mouseStart.x;
                const deltaY = event.clientY - mouseStart.y;
                const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (dragDistance > dragThreshold) {
                    mouseMoveForward = false;

                    cameraRotation.x -= deltaY * rotateSpeed;
                    cameraRotation.y -= deltaX * rotateSpeed;

                    cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));

                    mouseStart.set(event.clientX, event.clientY);
                    document.body.style.cursor = 'grabbing';
                }
            } else if (!isMouseDown) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(papers);

                if (intersects.length > 0) {
                    const celestialBody = intersects[0].object;
                    if (celestialBody &&
                        celestialBody.userData &&
                        typeof celestialBody.userData.course === 'number' &&
                        celestialBody.userData.name &&
                        celestialBody.userData.type) {
                        showTooltip(event, celestialBody.userData);
                        document.body.style.cursor = 'pointer';
                    } else {
                        hideTooltip();
                        document.body.style.cursor = 'crosshair';
                    }
                } else {
                    hideTooltip();
                    document.body.style.cursor = 'crosshair';
                }
            }
        }

        function onMouseUp(event) {
            isMouseDown = false;
            isMousePressed = false;
            mouseMoveForward = false;
            document.body.style.cursor = 'crosshair';

            const deltaX = event.clientX - mouseStart.x;
            const deltaY = event.clientY - mouseStart.y;
            const clickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (clickDistance < dragThreshold) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(papers);

                if (intersects.length > 0) {
                    const clickedBody = intersects[0].object;
                    if (clickedBody &&
                        clickedBody.userData &&
                        typeof clickedBody.userData.course === 'number' &&
                        clickedBody.userData.name &&
                        clickedBody.userData.type) {
                        handleCelestialBodyClick(clickedBody);
                    }
                }
            }
        }

        function onMouseWheel(event) {
            if (event.deltaY > 0) {
                flySpeed = Math.max(0.1, flySpeed * 0.9);
            } else {
                flySpeed = Math.min(3, flySpeed * 1.1);
            }
        }

        function onKeyDown(event) {
            keys[event.code] = true;

            if (event.code === 'Escape' && lockMode && lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }

            if (event.code === 'KeyR') {
                flip180Degrees();
            }

            if (event.code === 'KeyT') {
                rotateClockwise();
            }

            // æ–°å¢çš„ç²¾ç»†æ—‹è½¬æ§åˆ¶
            if (event.code === 'KeyJ') {
                rotateHorizontalLeft();
            }
            if (event.code === 'KeyL') {
                rotateHorizontalRight();
            }
            if (event.code === 'KeyI') {
                rotateVerticalUp();
            }
            if (event.code === 'KeyK') {
                rotateVerticalDown();
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function updateFlyControls() {
            if (!flyMode) return;

            if (lastLockMode && !lockMode) {
                const currentDirection = new THREE.Vector3();
                camera.getWorldDirection(currentDirection);
                cameraRotation.y = Math.atan2(currentDirection.x, currentDirection.z);
                cameraRotation.x = -Math.asin(currentDirection.y);
            }
            lastLockMode = lockMode;

            velocity.set(0, 0, 0);

            if (keys['KeyW'] || keys['ArrowUp']) velocity.z -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) velocity.z += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) velocity.x -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) velocity.x += 1;
            if (keys['KeyQ'] || keys['Space']) velocity.y += 1;
            if (keys['KeyE'] || keys['ShiftLeft']) velocity.y -= 1;

            if (mouseMoveForward && isMousePressed) {
                velocity.z -= 1.2;
            }

            if (lockMode && lockedConcept) {
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    lockAngle -= 0.02;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    lockAngle += 0.02;
                }
                if (keys['KeyW'] || keys['ArrowUp']) {
                    lockDistance = Math.max(5, lockDistance - 0.5);
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    lockDistance = Math.min(50, lockDistance + 0.5);
                }

                let heightOffset = 0;
                if (keys['KeyQ'] || keys['Space']) {
                    heightOffset = 0.5;
                }
                if (keys['KeyE'] || keys['ShiftLeft']) {
                    heightOffset = -0.5;
                }

                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += 5 + heightOffset;

                camera.position.lerp(targetPosition, 0.1);
                camera.lookAt(lockedConcept.position);

                updateSpeedTrail(0.1);
                return;
            }

            if (velocity.length() > 0) {
                velocity.normalize();

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                const right = new THREE.Vector3();
                right.crossVectors(camera.up, direction).normalize();

                const up = new THREE.Vector3(0, 1, 0);

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(direction, -velocity.z * flySpeed);
                moveVector.addScaledVector(right, velocity.x * flySpeed);
                moveVector.addScaledVector(up, velocity.y * flySpeed);

                camera.position.add(moveVector);

                updateSpeedTrail(moveVector.length());
            } else {
                updateSpeedTrail(0);
            }

            if (!lockMode) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraRotation.y;
                camera.rotation.x = cameraRotation.x;
            }
        }

        function updateSpeedTrail(speed) {
            if (speed > 0.1) {
                speedTrail.push({
                    position: camera.position.clone(),
                    speed: speed,
                    time: Date.now()
                });

                if (speedTrail.length > maxTrailLength) {
                    speedTrail.shift();
                }
            } else {
                speedTrail = speedTrail.filter(point => Date.now() - point.time < 1000);
            }
        }

        function animate() {
            // å¦‚æœé¡µé¢ä¸å¯è§ï¼Œé™ä½æ¸²æŸ“é¢‘ç‡
            if (!isPageVisible) {
                setTimeout(() => requestAnimationFrame(animate), 100); // æ¯100msæ¸²æŸ“ä¸€æ¬¡
                return;
            }

            requestAnimationFrame(animate);

            frameSkipCounter++;

            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            if (scene.userData.dynamicLight) {
                scene.userData.dynamicLight.position.copy(camera.position);
            }

            updateFlyControls();

            if (!animationPaused) {
                const time = Date.now() * 0.001;

                updateDeepSpaceEffects(time);
                updateStarLights(time); // æ›´æ–°æ’æ˜ŸåŠ¨æ€å…‰æº

                if (frameSkipCounter % 8 === 0) { // è¿›ä¸€æ­¥å‡å°‘æ˜Ÿç©ºæ›´æ–°é—´éš”
                    stars.forEach(starField => {
                        starField.rotation.y += starField.userData.rotationSpeed * 0.8; // å¤§å¹…æé«˜æ˜Ÿç©ºæ—‹è½¬é€Ÿåº¦
                    });

                    starTwinkles.forEach(twinkle => {
                        const twinkleAmount = 0.5 + 0.5 * Math.sin(time * twinkle.twinkleSpeed + twinkle.twinkleOffset);
                        const finalOpacity = twinkle.starField.userData.baseOpacity *
                            (0.3 + 0.7 * twinkleAmount * twinkle.intensity);
                        twinkle.starField.material.opacity = finalOpacity;
                    });
                }

                papers.forEach((celestialBody, index) => {
                    const distanceToCamera = camera.position.distanceTo(celestialBody.position);

                    // è·å–çœŸå®ç½‘æ ¼è¿›è¡ŒåŠ¨ç”»æ›´æ–°
                    const realMesh = celestialBody.userData.realMesh || celestialBody;

                    // æ‰€æœ‰å¤©ä½“éƒ½ä¿æŒè¿åŠ¨ï¼Œä¸ç®¡è·ç¦»è¿œè¿‘
                    if (celestialBody.userData.type === 'star') {
                        updateStarAnimation(realMesh, time);  // æ’æ˜ŸåŠ¨ç”»å§‹ç»ˆæ›´æ–°
                    } else if (celestialBody.userData.type === 'planet') {
                        updatePlanetOrbit(celestialBody, time);  // è¡Œæ˜Ÿè½¨é“å§‹ç»ˆæ›´æ–°
                    } else if (celestialBody.userData.type === 'satellite') {
                        updateSatelliteOrbit(celestialBody, time);  // å«æ˜Ÿè½¨é“å§‹ç»ˆæ›´æ–°
                    }

                    // åŸºç¡€è‡ªè½¬åŠ¨ç”»å§‹ç»ˆè¿›è¡Œ
                    if (frameSkipCounter % animationUpdateFrequency === 0) {
                        realMesh.rotation.y += 0.0005;
                    }

                    // æ ¹æ®è·ç¦»å†³å®šæ˜¯å¦æ˜¾ç¤ºå’Œæ›´æ–°å¤æ‚æ•ˆæœ
                    if (distanceToCamera < LOD_DISTANCE_FAR) {
                        celestialBody.visible = true;

                        // è¿‘è·ç¦»æ—¶æ‰æ›´æ–°æè´¨å’Œå…‰ç…§æ•ˆæœ
                        if (realMesh.material && realMesh.material.emissive) {
                            if (realMesh.userData.isLocked) {
                                const lockPulse = Math.sin(time * 1.0) * 0.2 + 0.8;
                                // ä½¿ç”¨ç»¿è‰²é”å®šæ•ˆæœ
                                const lockColor = new THREE.Color(0x00ff00);
                                realMesh.material.emissive.copy(lockColor).multiplyScalar(lockPulse);
                            } else {
                                // æ­£å¸¸çš„åŸºç¡€é¢œè‰²åŠ¨ç”»ï¼Œä¸ºè¡Œæ˜Ÿå’Œå«æ˜Ÿæä¾›æ›´å¼ºçš„å‘å…‰æ•ˆæœ
                                const pulse = Math.sin(time * 1.5 + realMesh.userData.animationOffset) * 0.3 + 0.9;
                                let emissiveMultiplier = 0.3; // é»˜è®¤å€æ•°

                                // æ ¹æ®å¤©ä½“ç±»å‹è°ƒæ•´å‘å…‰å¼ºåº¦
                                if (celestialBody.userData.type === 'planet') {
                                    emissiveMultiplier = 0.5; // è¡Œæ˜Ÿä½¿ç”¨æ›´å¼ºçš„å‘å…‰
                                } else if (celestialBody.userData.type === 'satellite') {
                                    emissiveMultiplier = 0.4; // å«æ˜Ÿä½¿ç”¨ä¸­ç­‰å‘å…‰
                                }

                                realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(pulse * emissiveMultiplier);
                            }
                        }

                        updateCelestialBodyEffects(realMesh, time, frameSkipCounter);

                        if (realMesh.userData.isLocked) {
                            updateLockIndicators(celestialBody, time, frameSkipCounter);
                        }

                    } else if (distanceToCamera < LOD_DISTANCE_FAR * 2) {
                        // ä¸­ç­‰è·ç¦»ï¼šæ˜¾ç¤ºä½†å‡å°‘ç‰¹æ•ˆæ›´æ–°
                        celestialBody.visible = true;

                        // åªä¿ç•™åŸºæœ¬çš„æè´¨è„‰åŠ¨
                        if (realMesh.material && realMesh.material.emissive && !realMesh.userData.isLocked) {
                            const pulse = Math.sin(time * 1.5 + realMesh.userData.animationOffset) * 0.3 + 0.9;
                            let emissiveMultiplier = 0.2; // ä¸­ç­‰è·ç¦»é»˜è®¤å€æ•°

                            // æ ¹æ®å¤©ä½“ç±»å‹è°ƒæ•´å‘å…‰å¼ºåº¦
                            if (celestialBody.userData.type === 'planet') {
                                emissiveMultiplier = 0.35; // è¡Œæ˜Ÿåœ¨ä¸­ç­‰è·ç¦»ä¹Ÿä¿æŒè¾ƒé«˜äº®åº¦
                            } else if (celestialBody.userData.type === 'satellite') {
                                emissiveMultiplier = 0.25; // å«æ˜Ÿä¸­ç­‰äº®åº¦
                            }

                            realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(pulse * emissiveMultiplier);
                        } else if (realMesh.userData.isLocked) {
                            // å³ä½¿åœ¨ä¸­ç­‰è·ç¦»ä¹Ÿè¦æ˜¾ç¤ºé”å®šæ•ˆæœ
                            const lockPulse = Math.sin(time * 1.0) * 0.2 + 0.8;
                            const lockColor = new THREE.Color(0x00ff00);
                            realMesh.material.emissive.copy(lockColor).multiplyScalar(lockPulse);
                        }
                    } else {
                        // æè¿œè·ç¦»ï¼šæ˜¾ç¤ºä½†ä¸æ›´æ–°ç‰¹æ•ˆ
                        celestialBody.visible = true;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        function updateStarAnimation(star, time) {
            const courseIndex = star.userData.course;
            const effects = star.userData.specialEffects;

            // æ ¹æ®ä¸åŒè¯¾ç¨‹çš„è„‰å†²ç±»å‹æ›´æ–°
            let pulse;
            switch(effects.pulseType) {
                case 'strong': // æ•°æ®ç»“æ„ - å¼ºåŠ›è„‰å†²
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.3 + 0.7;
                    break;
                case 'rhythmic': // ç®—æ³•è®¾è®¡ - èŠ‚æ‹è„‰å†²
                    pulse = Math.abs(Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset)) * 0.4 + 0.6;
                    break;
                case 'wave': // è®¡ç®—æœºç½‘ç»œ - æ³¢æµªè„‰å†²
                    pulse = (Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) +
                             Math.sin(time * star.userData.pulseSpeed * 2 + star.userData.animationOffset)) * 0.15 + 0.7;
                    break;
                case 'stable': // æ“ä½œç³»ç»Ÿ - ç¨³å®šå…‰èŠ’
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.1 + 0.9;
                    break;
                case 'treasure': // æ•°æ®åº“ç³»ç»Ÿ - å®è—é—ªçƒ
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.2 + 0.8 +
                            Math.sin(time * star.userData.pulseSpeed * 3 + star.userData.animationOffset) * 0.1;
                    break;
                case 'shifting': // è½¯ä»¶å·¥ç¨‹ - å˜æ¢è„‰å†²
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.2 + 0.8;
                    // é¢œè‰²å˜æ¢ - åªåœ¨æœªé”å®šçŠ¶æ€ä¸‹è¿›è¡Œ
                    if (!star.userData.isLocked) {
                        const colorShift = Math.sin(time * 0.5 + star.userData.animationOffset) * 0.3 + 0.7;
                        star.material.color.copy(star.userData.baseColor).multiplyScalar(colorShift);
                    }
                    break;
                default:
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.1 + 0.9;
            }

            // å§‹ç»ˆæ›´æ–°æ’æ˜Ÿæœ¬ä½“çš„é€æ˜åº¦è„‰å†²
            if (star.material && star.material.opacity !== undefined) {
                // åªæœ‰åœ¨æœªé”å®šçŠ¶æ€ä¸‹æ‰åº”ç”¨è„‰å†²é€æ˜åº¦
                if (!star.userData.isLocked) {
                    star.material.opacity = pulse;
                }
            }

            // å§‹ç»ˆæ›´æ–°å†…å±‚å‘å…‰æ•ˆæœ
            if (star.userData.innerGlow) {
                const glowPulse = Math.sin(time * star.userData.pulseSpeed * 1.5 + star.userData.animationOffset) * 0.2 + 0.6;
                star.userData.innerGlow.material.opacity = 0.4 * glowPulse;
                star.userData.innerGlow.rotation.y += 0.008;
            }

            // å§‹ç»ˆæ›´æ–°ç‰¹è‰²æ•ˆæœï¼ˆè¿™å¾ˆé‡è¦ï¼ï¼‰
            updateStarSpecialEffects(star, time, courseIndex);

            // å§‹ç»ˆæ›´æ–°æ ‡å‡†æ•ˆæœ
            if (star.userData.corona) {
                star.userData.corona.rotation.y += 0.005;
                star.userData.corona.material.opacity = 0.15 * pulse;
            }

            if (star.userData.radiation) {
                star.userData.radiation.rotation.y -= 0.003;
                star.userData.radiation.rotation.x += 0.001;
                star.userData.radiation.material.opacity = 0.08 * pulse;
            }

            // å§‹ç»ˆæ›´æ–°æ’æ˜Ÿå…‰æºå¼ºåº¦
            if (star.userData.starLight) {
                const lightPulse = Math.sin(time * star.userData.pulseSpeed * 0.8 + star.userData.animationOffset) * 0.3 + 1.7;
                star.userData.starLight.intensity = lightPulse;
            }
        }

        // æ›´æ–°æ’æ˜Ÿç‰¹è‰²æ•ˆæœ
        function updateStarSpecialEffects(star, time, courseIndex) {
            switch(courseIndex) {
                case 0: // æ•°æ®ç»“æ„ - èƒ½é‡ç¯æ—‹è½¬
                    for (let i = 0; i < 3; i++) {
                        if (star.userData[`energyRing${i}`]) {
                            star.userData[`energyRing${i}`].rotation.z += 0.01 * (i + 1);
                            const ringPulse = Math.sin(time * 2 + i) * 0.1 + 0.3;
                            star.userData[`energyRing${i}`].material.opacity = ringPulse;
                        }
                    }
                    break;

                case 1: // ç®—æ³•è®¾è®¡ - èºæ—‹æ—‹è½¬
                    if (star.userData.spiral) {
                        star.userData.spiral.rotation.y += 0.02;
                        star.userData.spiral.rotation.x += 0.01;
                    }
                    break;

                case 2: // è®¡ç®—æœºç½‘ç»œ - ç½‘ç»œèŠ‚ç‚¹é—ªçƒå’Œæ•°æ®åŒ…æµåŠ¨
                    // ç½‘ç»œèŠ‚ç‚¹è„‰åŠ¨
                    for (let i = 0; i < 8; i++) {
                        if (star.userData[`networkNode${i}`]) {
                            const nodePulse = Math.sin(time * 3 + i * 0.5) * 0.3 + 0.7;
                            star.userData[`networkNode${i}`].material.opacity = nodePulse;
                            star.userData[`networkNode${i}`].scale.setScalar(0.8 + nodePulse * 0.4);
                        }
                    }

                    // è¿æ¥çº¿é—ªçƒ
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('networkLine')) {
                            const linePulse = Math.sin(time * 2 + Math.random() * 3) * 0.2 + 0.3;
                            star.userData[key].material.opacity = linePulse;
                        }
                    });

                    // æ•°æ®åŒ…æµåŠ¨
                    for (let i = 0; i < 5; i++) {
                        if (star.userData[`dataPacket${i}`]) {
                            const packet = star.userData[`dataPacket${i}`];
                            const nodePositions = [
                                new THREE.Vector3(star.geometry.parameters.radius * 3, 0, 0),
                                new THREE.Vector3(-star.geometry.parameters.radius * 3, 0, 0),
                                new THREE.Vector3(0, star.geometry.parameters.radius * 3, 0),
                                new THREE.Vector3(0, -star.geometry.parameters.radius * 3, 0),
                                new THREE.Vector3(0, 0, star.geometry.parameters.radius * 3),
                                new THREE.Vector3(0, 0, -star.geometry.parameters.radius * 3),
                                new THREE.Vector3(star.geometry.parameters.radius * 2, star.geometry.parameters.radius * 2, 0),
                                new THREE.Vector3(-star.geometry.parameters.radius * 2, -star.geometry.parameters.radius * 2, 0)
                            ];

                            packet.userData.pathProgress += packet.userData.pathSpeed;
                            if (packet.userData.pathProgress >= 1) {
                                packet.userData.pathProgress = 0;
                                packet.userData.pathIndex = (packet.userData.pathIndex + 1) % nodePositions.length;
                            }

                            const currentNode = nodePositions[packet.userData.pathIndex];
                            const nextNode = nodePositions[(packet.userData.pathIndex + 1) % nodePositions.length];
                            packet.position.lerpVectors(currentNode, nextNode, packet.userData.pathProgress);
                        }
                    }
                    break;

                case 3: // æ“ä½œç³»ç»Ÿ - æŠ¤ç›¾è„‰åŠ¨
                    if (star.userData.shield) {
                        star.userData.shield.rotation.x += 0.005;
                        star.userData.shield.rotation.y += 0.008;
                        const shieldPulse = Math.sin(time * 1.5) * 0.05 + 0.15;
                        star.userData.shield.material.opacity = shieldPulse;
                    }
                    break;

                case 4: // æ•°æ®åº“ç³»ç»Ÿ - æ•°æ®çŸ©é˜µé—ªçƒ
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('matrixCube')) {
                            const cube = star.userData[key];
                            const flashTime = time + cube.userData.flashDelay;
                            const flashPulse = Math.sin(flashTime * 2) * 0.3 + 0.7;
                            cube.material.opacity = cube.userData.baseOpacity * flashPulse;
                            cube.rotation.x += cube.userData.rotationSpeed;
                            cube.rotation.y += cube.userData.rotationSpeed * 0.7;

                            // éšæœºäº®åº¦çªå˜ï¼ˆæ•°æ®è®¿é—®æ•ˆæœï¼‰
                            if (Math.random() < 0.002) {
                                cube.material.opacity = 1.0;
                                setTimeout(() => {
                                    if (cube.material) cube.material.opacity = cube.userData.baseOpacity;
                                }, 100);
                            }
                        }

                        if (key.startsWith('dataConnection')) {
                            const connectionPulse = Math.sin(time * 1.5 + Math.random() * 2) * 0.1 + 0.2;
                            star.userData[key].material.opacity = connectionPulse;
                        }
                    });
                    break;

                case 5: // è½¯ä»¶å·¥ç¨‹ - è„‰å†²æ˜Ÿæ•ˆæœ
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('pulseRing')) {
                            const ring = star.userData[key];
                            ring.rotation.z += 0.005 * (ring.userData.ringIndex + 1);
                            const ringPulse = Math.sin(time * 2 + ring.userData.pulseOffset) * 0.2 + 0.6;
                            ring.material.opacity = ringPulse;
                        }

                        if (key.startsWith('magneticField')) {
                            const field = star.userData[key];
                            field.rotation.y += field.userData.rotationSpeed;
                        }
                    });
                    break;
            }
        }

        function updatePlanetOrbit(planet, time) {
            // è¡Œæ˜Ÿç»•ç€æ’æ˜Ÿæ—‹è½¬ - æé«˜è½¨é“é€Ÿåº¦ä½¿æ—‹è½¬æ›´æ˜æ˜¾
            planet.userData.orbitAngle += planet.userData.orbitSpeed * 0.3; // ä»15%æé«˜åˆ°30%

            // ç¡®ä¿è¡Œæ˜Ÿå›´ç»•æ’æ˜Ÿä¸­å¿ƒæ—‹è½¬
            const starCenter = planet.userData.orbitCenter; // æ’æ˜Ÿçš„ä½ç½®
            const x = starCenter.x + Math.cos(planet.userData.orbitAngle) * planet.userData.orbitRadius;
            const y = starCenter.y + Math.sin(planet.userData.orbitAngle * 0.3) * 3; // è½»å¾®çš„å‚ç›´æ³¢åŠ¨
            const z = starCenter.z + Math.sin(planet.userData.orbitAngle) * planet.userData.orbitRadius;

            planet.position.set(x, y, z);

            // å¦‚æœè¿™æ˜¯ç¢°æ’ä½“ï¼Œä¹Ÿè¦æ›´æ–°çœŸå®ç½‘æ ¼çš„ä½ç½®
            if (planet.userData.realMesh) {
                planet.userData.realMesh.position.set(x, y, z);
            }
            // å¦‚æœè¿™æ˜¯çœŸå®ç½‘æ ¼ï¼Œä¹Ÿè¦æ›´æ–°ç¢°æ’ä½“çš„ä½ç½®
            if (planet.userData.clickMesh) {
                planet.userData.clickMesh.position.set(x, y, z);
            }
        }

        function updateSatelliteOrbit(satellite, time) {
            // å«æ˜Ÿç»•ç€è¡Œæ˜Ÿæ—‹è½¬ - æé«˜è½¨é“é€Ÿåº¦ä½¿æ—‹è½¬æ›´æ˜æ˜¾
            satellite.userData.orbitAngle += satellite.userData.orbitSpeed * 0.4; // ä»25%æé«˜åˆ°40%

            // ç¡®ä¿å«æ˜Ÿå›´ç»•è¡Œæ˜Ÿçš„å®æ—¶ä½ç½®æ—‹è½¬
            const planetPos = satellite.userData.parentPlanet.position; // è·å–è¡Œæ˜Ÿçš„å½“å‰ä½ç½®

            const x = planetPos.x + Math.cos(satellite.userData.orbitAngle) * satellite.userData.orbitRadius;
            const y = planetPos.y + Math.sin(satellite.userData.orbitAngle * 0.5) * 1;
            const z = planetPos.z + Math.sin(satellite.userData.orbitAngle) * satellite.userData.orbitRadius;

            satellite.position.set(x, y, z);

            // å¦‚æœè¿™æ˜¯ç¢°æ’ä½“ï¼Œä¹Ÿè¦æ›´æ–°çœŸå®ç½‘æ ¼çš„ä½ç½®
            if (satellite.userData.realMesh) {
                satellite.userData.realMesh.position.set(x, y, z);
            }
            // å¦‚æœè¿™æ˜¯çœŸå®ç½‘æ ¼ï¼Œä¹Ÿè¦æ›´æ–°ç¢°æ’ä½“çš„ä½ç½®
            if (satellite.userData.clickMesh) {
                satellite.userData.clickMesh.position.set(x, y, z);
            }

            if (satellite.userData.glow) {
                satellite.userData.glow.rotation.y += 0.005; // æé«˜å‘å…‰æ•ˆæœæ—‹è½¬é€Ÿåº¦
                const glowPulse = Math.sin(time * 3 + satellite.userData.animationOffset) * 0.08 + 0.15;
                satellite.userData.glow.material.opacity = glowPulse;
            }
        }

        function updateCelestialBodyEffects(body, time, frameSkipCounter) {
            if (body.userData.starglow && frameSkipCounter % 3 === 0) {
                const starglowPulse = Math.sin(time * 2 + body.userData.starglowOffset) * 0.03 + 0.05;
                body.userData.starglow.material.opacity = starglowPulse;
                body.userData.starglow.rotation.y += 0.003; // è¿›ä¸€æ­¥æé«˜æ—‹è½¬
            }

            if (body.userData.glow && frameSkipCounter % 4 === 0) {
                body.userData.glow.rotation.y += 0.003; // è¿›ä¸€æ­¥æé«˜æ—‹è½¬
                const glowPulse = Math.sin(time * 2 + body.userData.animationOffset) * 0.08 + 0.2;
                body.userData.glow.material.opacity = glowPulse;
            }

            // æ›´æ–°è¡Œæ˜Ÿå‘å…‰æ•ˆæœ
            if (body.userData.planetGlow && frameSkipCounter % 2 === 0) {
                body.userData.planetGlow.rotation.y += 0.004; // è¡Œæ˜Ÿå‘å…‰æ•ˆæœæ—‹è½¬
                body.userData.planetGlow.rotation.x += 0.002;
                const planetGlowPulse = Math.sin(time * 1.5 + body.userData.animationOffset) * 0.1 + 0.3;
                body.userData.planetGlow.material.opacity = planetGlowPulse;
            }
        }

        function updateLockIndicators(body, time, frameSkipCounter) {
            if (body.userData.lockRing) {
                body.userData.lockRing.position.copy(body.position);
                body.userData.lockRing.lookAt(camera.position);
                body.userData.lockRing.rotation.z += 0.008; // å¤§å¹…æé«˜æ—‹è½¬é€Ÿåº¦

                const ringPulse = Math.sin(time * 1.5) * 0.15 + 0.75;
                body.userData.lockRing.material.opacity = ringPulse;
            }

            if (body.userData.lockGlow) {
                body.userData.lockGlow.position.copy(body.position);
                body.userData.lockGlow.rotation.y += 0.002; // å¤§å¹…æé«˜æ—‹è½¬é€Ÿåº¦

                const glowPulse = Math.sin(time * 1.2) * 0.02 + 0.12;
                body.userData.lockGlow.material.opacity = glowPulse;

                const scale = 1 + Math.sin(time * 0.8) * 0.05;
                body.userData.lockGlow.scale.setScalar(scale);
            }
        }

        function handleCelestialBodyClick(celestialBody) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ç¢°æ’ä½“ï¼Œè·å–çœŸå®çš„ç½‘æ ¼å¯¹è±¡
            const realMesh = celestialBody.userData.realMesh || celestialBody;
            const clickMesh = celestialBody.userData.realMesh ? celestialBody : celestialBody.userData.clickMesh;

            showDetailModal(celestialBody);

            if (lockedConcept !== clickMesh) {
                if (lockedConcept) {
                    unlockConcept(lockedConcept);
                }

                lockConcept(clickMesh);
                flyToConcept(clickMesh);
            }
        }

        function showDetailModal(celestialBody) {
            if (!celestialBody ||
                !celestialBody.userData ||
                typeof celestialBody.userData.course !== 'number' ||
                !celestialBody.userData.name ||
                !celestialBody.userData.type) {
                console.warn('Invalid celestial body data');
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'celestialModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                animation: fadeIn 0.3s ease;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
                border: 1px solid rgba(0, 245, 255, 0.3);
                border-radius: var(--border-radius-lg);
                padding: 30px;
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: var(--shadow-md);
                position: relative;
            `;

            const course = csCourses[celestialBody.userData.course];
            if (!course) {
                console.warn('Course not found for index:', celestialBody.userData.course);
                return;
            }

            let content = '';

            if (celestialBody.userData.type === 'star') {
                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">â­</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name} æ˜Ÿç³»</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">æ˜Ÿç³»ç±»å‹:</strong> çŸ¥è¯†æ’æ˜Ÿç³»ç»Ÿ</p>
                        <p><strong style="color: #ff00ff;">é¢†åŸŸ:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">è¡Œæ˜Ÿæ•°é‡:</strong> ${course.planets ? course.planets.length : 0} é¢—</p>
                        <p><strong style="color: #ff6b6b;">ä¸»è¦åˆ†æ”¯:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            ${course.planets ? course.planets.map(planet => `<li style="margin: 5px 0;">${planet.name}</li>`).join('') : ''}
                        </ul>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            è¿™æ˜¯${course.name}çŸ¥è¯†é¢†åŸŸçš„ä¸­å¿ƒæ’æ˜Ÿï¼Œå‘¨å›´ç¯ç»•ç€å„ä¸ªä¸“ä¸šåˆ†æ”¯è¡Œæ˜Ÿï¼Œæ¯é¢—è¡Œæ˜Ÿåˆæœ‰è‡ªå·±çš„çŸ¥è¯†å«æ˜Ÿç¾¤ã€‚
                        </p>
                    </div>
                `;
            } else if (celestialBody.userData.type === 'planet') {
                const satellites = celestialBody.userData.satellites || [];
                const planetIndex = typeof celestialBody.userData.planetIndex === 'number' ? celestialBody.userData.planetIndex : 0;

                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">ğŸª</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name}</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">å¤©ä½“ç±»å‹:</strong> çŸ¥è¯†è¡Œæ˜Ÿ</p>
                        <p><strong style="color: #ff00ff;">æ‰€å±æ˜Ÿç³»:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">è½¨é“ä½ç½®:</strong> ç¬¬ ${planetIndex + 1} è½¨é“</p>
                        <p><strong style="color: #ff6b6b;">å«æ˜Ÿæ•°é‡:</strong> ${satellites.length} é¢—</p>
                        <p><strong style="color: #45b7d1;">çŸ¥è¯†å«æ˜Ÿ:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            ${satellites.map(satellite => `<li style="margin: 5px 0;">${satellite}</li>`).join('')}
                        </ul>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            è¿™é¢—è¡Œæ˜Ÿä»£è¡¨${course.name}é¢†åŸŸä¸­çš„${celestialBody.userData.name}åˆ†æ”¯ï¼ŒåŒ…å«äº†è¯¥é¢†åŸŸçš„æ ¸å¿ƒæ¦‚å¿µå’ŒæŠ€æœ¯ã€‚
                        </p>
                    </div>
                `;
            } else if (celestialBody.userData.type === 'satellite') {
                const parentPlanet = celestialBody.userData.parentPlanet;
                const parentPlanetName = (parentPlanet && parentPlanet.userData && parentPlanet.userData.name)
                    ? parentPlanet.userData.name : 'æœªçŸ¥è¡Œæ˜Ÿ';
                const satelliteIndex = typeof celestialBody.userData.satelliteIndex === 'number' ? celestialBody.userData.satelliteIndex : 0;

                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">ğŸŒ™</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name}</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">å¤©ä½“ç±»å‹:</strong> çŸ¥è¯†å«æ˜Ÿ</p>
                        <p><strong style="color: #ff00ff;">æ‰€å±æ˜Ÿç³»:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">æ¯è¡Œæ˜Ÿ:</strong> ${parentPlanetName}</p>
                        <p><strong style="color: #45b7d1;">å«æ˜Ÿè½¨é“:</strong> ç¬¬ ${satelliteIndex + 1} è½¨é“</p>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            è¿™é¢—å«æ˜Ÿä»£è¡¨${parentPlanetName}é¢†åŸŸä¸­çš„å…·ä½“çŸ¥è¯†ç‚¹"${celestialBody.userData.name}"ï¼Œ
                            æ˜¯å­¦ä¹ è¯¥é¢†åŸŸæ—¶éœ€è¦æŒæ¡çš„é‡è¦æ¦‚å¿µã€‚
                        </p>
                        <div style="margin-top: 20px; padding: 15px; background: rgba(0, 245, 255, 0.1); border-radius: var(--border-radius); border-left: 3px solid #00f5ff;">
                            <p style="margin: 0; font-size: 14px;"><strong>å­¦ä¹ å»ºè®®:</strong></p>
                            <p style="margin: 10px 0 0 0; font-size: 14px;">
                                å»ºè®®å…ˆæŒæ¡${parentPlanetName}çš„åŸºç¡€æ¦‚å¿µï¼Œ
                                å†æ·±å…¥å­¦ä¹ ${celestialBody.userData.name}çš„å…·ä½“å®ç°å’Œåº”ç”¨ã€‚
                            </p>
                        </div>
                    </div>
                `;
            }

            modalContent.innerHTML = content + `
                <button id="closeModal" style="
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    background: none;
                    border: none;
                    color: #ff6b6b;
                    font-size: 24px;
                    cursor: pointer;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 50%;
                    transition: all 0.3s ease;
                " onmouseover="this.style.background='rgba(255, 107, 107, 0.2)'"
                   onmouseout="this.style.background='none'">Ã—</button>

                <div style="margin-top: 30px; text-align: center; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="closeDetailModal()" style="
                        background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
                        border: 1px solid rgba(0, 245, 255, 0.5);
                        color: #00f5ff;
                        padding: 12px 24px;
                        border-radius: var(--border-radius-sm);
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(0, 245, 255, 0.3)'"
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        ç»§ç»­æ¢ç´¢
                    </button>
                    <button onclick="learnMore('${celestialBody.userData.name}', '${celestialBody.userData.type}', ${celestialBody.userData.course})" style="
                        background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
                        border: 1px solid rgba(255, 193, 7, 0.5);
                        color: #ffc107;
                        padding: 12px 24px;
                        border-radius: var(--border-radius-sm);
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(255, 193, 7, 0.3)'"
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        ğŸ“š äº†è§£è¯¦æƒ…
                    </button>
                </div>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            document.getElementById('closeModal').onclick = closeDetailModal;
            modal.onclick = (e) => {
                if (e.target === modal) closeDetailModal();
            };

            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: scale(0.9); }
                    to { opacity: 1; transform: scale(1); }
                }
            `;
            document.head.appendChild(style);
        }

        function closeDetailModal() {
            const modal = document.getElementById('celestialModal');
            if (modal) {
                modal.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            }
        }

        function learnMore(name, type, courseIndex) {
            // å…³é—­å½“å‰å¼¹çª—
            closeDetailModal();

            // æ ¹æ®å¤©ä½“ç±»å‹å’Œåç§°è·³è½¬åˆ°å¯¹åº”é¡µé¢
            let targetUrl = '';

            if (type === 'star') {
                // æ’æ˜Ÿ - è·³è½¬åˆ°å¤§åˆ†ç±»é¡µé¢
                const categoryUrls = {
                    'æ•°æ®ç»“æ„': '/category/data-structures/',
                    'ç®—æ³•è®¾è®¡': '/category/algorithm-design/',
                    'è®¡ç®—æœºç½‘ç»œ': '/category/computer-networks/',
                    'æ“ä½œç³»ç»Ÿ': '/category/operating-systems/',
                    'æ•°æ®åº“ç³»ç»Ÿ': '/category/database-systems/',
                    'è½¯ä»¶å·¥ç¨‹': '/category/software-engineering/'
                };
                targetUrl = categoryUrls[name];
            } else if (type === 'planet') {
                // è¡Œæ˜Ÿ - è·³è½¬åˆ°å­åˆ†ç±»é¡µé¢
                const planetUrls = {
                    'é“¾è¡¨': '/planet/linked-list/',
                    'æ ˆ': '/planet/stack/',
                    'é˜Ÿåˆ—': '/planet/queue/',
                    'çŸ©é˜µ': '/planet/matrix/',
                    'æ ‘ä¸äºŒå‰æ ‘': '/planet/tree-binary-tree/',
                    'å›¾': '/planet/graph/',
                    'æŸ¥æ‰¾': '/planet/search/',
                    'æ’åº': '/planet/sorting/',
                    'åˆ†æ²»ç®—æ³•': '/planet/divide-conquer/',
                    'åŠ¨æ€è§„åˆ’': '/planet/dynamic-programming/',
                    'è´ªå¿ƒç®—æ³•': '/planet/greedy-algorithm/',
                    'å›æº¯ç®—æ³•': '/planet/backtracking/',
                    'å›¾è®ºç®—æ³•': '/planet/graph-algorithms/',
                    'å­—ç¬¦ä¸²ç®—æ³•': '/planet/string-algorithms/',
                    'æ•°å€¼ç®—æ³•': '/planet/numerical-algorithms/',
                    'ç‰©ç†å±‚': '/planet/physical-layer/',
                    'æ•°æ®é“¾è·¯å±‚': '/planet/data-link-layer/',
                    'ç½‘ç»œå±‚': '/planet/network-layer/',
                    'ä¼ è¾“å±‚': '/planet/transport-layer/',
                    'åº”ç”¨å±‚': '/planet/application-layer/',
                    'ç½‘ç»œå®‰å…¨': '/planet/network-security/',
                    'è¿›ç¨‹ç®¡ç†': '/planet/process-management/',
                    'çº¿ç¨‹ç®¡ç†': '/planet/thread-management/',
                    'å†…å­˜ç®¡ç†': '/planet/memory-management/',
                    'æ–‡ä»¶ç³»ç»Ÿ': '/planet/file-system/',
                    'è®¾å¤‡ç®¡ç†': '/planet/device-management/',
                    'ç³»ç»Ÿè°ƒç”¨': '/planet/system-calls/',
                    'å…³ç³»æ¨¡å‹': '/planet/relational-model/',
                    'SQLè¯­è¨€': '/planet/sql-language/',
                    'äº‹åŠ¡ç®¡ç†': '/planet/transaction-management/',
                    'ç´¢å¼•æŠ€æœ¯': '/planet/indexing/',
                    'æŸ¥è¯¢å¤„ç†': '/planet/query-processing/',
                    'åˆ†å¸ƒå¼æ•°æ®åº“': '/planet/distributed-database/',
                    'éœ€æ±‚å·¥ç¨‹': '/planet/requirements-engineering/',
                    'ç³»ç»Ÿè®¾è®¡': '/planet/system-design/',
                    'è½¯ä»¶æµ‹è¯•': '/planet/software-testing/',
                    'é¡¹ç›®ç®¡ç†': '/planet/project-management/',
                    'ç‰ˆæœ¬æ§åˆ¶': '/planet/version-control/',
                    'è®¾è®¡æ¨¡å¼': '/planet/design-patterns/'
                };
                targetUrl = planetUrls[name];
            } else if (type === 'satellite') {
                // å«æ˜Ÿ - è·³è½¬åˆ°å…·ä½“çŸ¥è¯†ç‚¹é¡µé¢
                // ä½¿ç”¨ç°æœ‰çš„slugç”Ÿæˆé€»è¾‘
                const implementedMapping = {
                    'å•é“¾è¡¨': '/learn/single-linklist/',
                    'å›¾çš„éå†â€”â€”DFS': '/learn/graph_dfs/',
                    'å·®é”™æ§åˆ¶â€”â€”æ£€é”™ç ': '/learn/crc-check/',
                    'å·®é”™æ§åˆ¶â€”â€”çº é”™ç¼–ç ': '/learn/hamming-code/'
                };

                if (implementedMapping[name]) {
                    targetUrl = implementedMapping[name];
                } else {
                    // ç”Ÿæˆé€šç”¨çš„çŸ¥è¯†ç‚¹é¡µé¢URL
                    const slug = generateSlugFromName(name);
                    targetUrl = `/learn/${slug}/`;
                }
            }

            if (targetUrl) {
                console.log(`è·³è½¬åˆ°: ${name} (${type}) -> ${targetUrl}`);
                window.location.href = targetUrl;
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„URLï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
                alert(`${name} çš„è¯¦ç»†å­¦ä¹ èµ„æºæ­£åœ¨å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…ï¼\n\nè¿™é‡Œå°†æä¾›ï¼š\nâ€¢ è¯¦ç»†çš„æ¦‚å¿µè§£é‡Š\nâ€¢ äº’åŠ¨å¼ç¤ºä¾‹æ¼”ç¤º\nâ€¢ ç›¸å…³ç»ƒä¹ é¢˜ç›®\nâ€¢ å®é™…åº”ç”¨æ¡ˆä¾‹`);
            }
        }

        function generateSlugFromName(name) {
            // å®Œæ•´çš„slugæ˜ å°„è¡¨ï¼Œä¸Pythonåç«¯å®Œå…¨ä¸€è‡´
            const completeSlugMapping = {
                'å•é“¾è¡¨': 'single-linklist',
                'åŒé“¾è¡¨': 'double-linked-list',
                'å¾ªç¯é“¾è¡¨': 'circular-linked-list',
                'é™æ€é“¾è¡¨': 'static-linked-list',
                'é¡ºåºæ ˆ': 'sequential-stack',
                'é“¾å¼æ ˆ': 'linked-stack',
                'æ ˆâ€”â€”æ‹¬å·åŒ¹é…': 'topic-9477183b',
                'æ ˆâ€”â€”è¡¨è¾¾å¼æ±‚å€¼': 'topic-84049d5b',
                'æ ˆâ€”â€”å¡ç‰¹å…°æ•°': 'topic-55106f00',
                'æ ˆâ€”â€”å‡½æ•°è°ƒç”¨': 'topic-43c1d7f8',
                'æ ˆâ€”â€”é€’å½’': 'topic-b6197b56',
                'é¡ºåºé˜Ÿåˆ—': 'sequential-queue',
                'å¾ªç¯é˜Ÿåˆ—': 'circular-queue',
                'é“¾é˜Ÿåˆ—': 'linked-queue',
                'åŒç«¯é˜Ÿåˆ—': 'deque',
                'é˜Ÿåˆ—â€”â€”ç¼“å†²åŒº': 'topic-0d962147',
                'å¹¿åº¦ä¼˜å…ˆæœç´¢': 'breadth-first-search',
                'å¯¹ç§°çŸ©é˜µ': 'symmetric-matrix',
                'ä¸‰è§’çŸ©é˜µ': 'triangular-matrix',
                'ç¨€ç–çŸ©é˜µâ€”â€”ä¸‰å…ƒç»„è¡¨ç¤ºæ³•': 'topic-808e0a45',
                'ç¨€ç–çŸ©é˜µâ€”â€”åå­—é“¾è¡¨æ³•': 'topic-b23a9ad8',
                'å¹¿ä¹‰è¡¨': 'generalized-list',
                'KMPæ¨¡å¼åŒ¹é…': 'kmp-dada3d14',
                'æ ‘ä¸äºŒå‰æ ‘çš„æ€§è´¨': 'tree-binary-tree-properties',
                'BST': 'bst-ae8200cb',
                'AVL': 'avl-0e3587fa',
                'äºŒå‰æ ‘â€”â€”é¡ºåºå­˜å‚¨': 'topic-98921b61',
                'äºŒå‰æ ‘â€”â€”é“¾å¼å­˜å‚¨': 'topic-96d8bc0a',
                'äºŒå‰æ ‘â€”â€”å››åºéå†': 'topic-677d774b',
                'çº¿ç´¢äºŒå‰æ ‘': 'threaded-binary-tree',
                'æ ‘ã€æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢': 'topic-5755c011',
                'æ ‘å’Œæ£®æ—çš„éå†': 'tree-forest-traversal',
                'å“ˆå¤«æ›¼æ ‘': 'huffman-tree',
                'å¹¶æŸ¥é›†': 'union-find',
                'å›¾çš„å­˜å‚¨ç»“æ„': 'graph-storage-structure',
                'å›¾çš„éå†â€”â€”DFS': 'graph_dfs',
                'å›¾çš„éå†â€”â€”BFS': 'bfs-0b162441',
                'æœ€å°ç”Ÿæˆæ ‘â€”â€”Primç®—æ³•': 'prim-c560c2ed',
                'æœ€å°ç”Ÿæˆæ ‘â€”â€”Kruskalç®—æ³•': 'kruskal-400979d2',
                'æœ€çŸ­è·¯å¾„â€”â€”Dijkstraç®—æ³•': 'dijkstra-4f1a04fe',
                'æœ€çŸ­è·¯å¾„â€”â€”Floyd': 'floyd-9498fc4f',
                'æœ€çŸ­è·¯å¾„â€”â€”A*': 'topic-54ef0780',
                'å…³é”®è·¯å¾„': 'critical-path',
                'äºŒåˆ†æŸ¥æ‰¾': 'binary-search',
                'åˆ†å—æŸ¥æ‰¾': 'block-search',
                'çº¢é»‘æ ‘': 'red-black-tree',
                'Bæ ‘': 'topic-bc4a04d3',
                'B+æ ‘': 'topic-19dd3d1e',
                'hashè¡¨': 'hash-d2be4a35',
                'å…«å¤§æ’åº': 'eight-sorting-algorithms',
                'å¤–éƒ¨æ’åº': 'external-sorting',
                'äºŒåˆ†æœç´¢': 'topic-31d15901',
                'å½’å¹¶æ’åº': 'topic-95566613',
                'å¿«é€Ÿæ’åº': 'topic-5ee213ee',
                'æœ€å¤§å­æ•°ç»„': 'topic-e22ba13f',
                'èƒŒåŒ…é—®é¢˜': 'topic-d39a003f',
                'æœ€é•¿å…¬å…±å­åºåˆ—': 'topic-9032049e',
                'æœ€é•¿é€’å¢å­åºåˆ—': 'topic-9a1f60ae',
                'ç¼–è¾‘è·ç¦»': 'topic-5192e297',
                'çŠ¶æ€è½¬ç§»': 'topic-06e65263',
                'æ´»åŠ¨é€‰æ‹©': 'topic-7dbfb5c7',
                'èƒŒåŒ…è´ªå¿ƒ': 'topic-2bb8cbe2',
                'å“ˆå¤«æ›¼ç¼–ç ': 'topic-49959872',
                'æœ€å°ç”Ÿæˆæ ‘': 'minimum-spanning-tree',
                'Nçš‡åé—®é¢˜': 'topic-bde78f30',
                'æ•°ç‹¬æ±‚è§£': 'topic-3a15946a',
                'å­é›†ç”Ÿæˆ': 'topic-afbc23bb',
                'æ’åˆ—ç»„åˆ': 'topic-c177570e',
                'æ·±åº¦ä¼˜å…ˆæœç´¢': 'topic-75d2ecdf',
                'Dijkstraç®—æ³•': 'dijkstra-fcff225e',
                'Floydç®—æ³•': 'floyd-55aee254',
                'Kruskalç®—æ³•': 'kruskal-469314f5',
                'Primç®—æ³•': 'prim-c2c37590',
                'Rabin-Karpç®—æ³•': 'rabinkarp-8e2b5d4b',
                'åç¼€æ•°ç»„': 'topic-4d20081f',
                'ACè‡ªåŠ¨æœº': 'ac-34fba25a',
                'å¿«é€Ÿå¹‚': 'topic-35888d4c',
                'æ¬§å‡ é‡Œå¾—ç®—æ³•': 'topic-fb38c805',
                'æ‰©å±•æ¬§å‡ é‡Œå¾—': 'topic-c2106cde',
                'ç´ æ•°ç­›é€‰': 'topic-c5253730',
                'æ•°æ®é€šä¿¡çš„åŸºç¡€çŸ¥è¯†': 'topic-49436551',
                'ä¼ è¾“ä»‹è´¨': 'topic-792728c9',
                'ä¿¡é“å¤ç”¨': 'topic-22a05c42',
                'ç‰©ç†å±‚è®¾å¤‡': 'topic-fe62a26c',
                'ç»„å¸§': 'topic-64dbbedd',
                'å·®é”™æ§åˆ¶â€”â€”æ£€é”™ç ': 'crc-check',
                'å·®é”™æ§åˆ¶â€”â€”çº é”™ç¼–ç ': 'hamming-code',
                'æµé‡æ§åˆ¶': 'topic-e73722b3',
                'å¯é ä¼ è¾“æœºåˆ¶': 'topic-90b4d246',
                'æ»‘åŠ¨çª—å£æœºåˆ¶': 'topic-21aaa736',
                'åœç­‰åè®®': 'topic-189bc34f',
                'GBNåè®®': 'gbn-6c028dfe',
                'SRåè®®': 'sr-1f7f6cf6',
                'pppåè®®': 'ppp-c146f0f8',
                'MACå­å±‚': 'mac-97eab93f',
                'CSMA/CDåè®®': 'csmacd-ce8073ee',
                'CSMA/CAåè®®': 'csmaca-9f95262d',
                'ç½‘æ¡¥': 'topic-a65126a7',
                'ç”Ÿæˆæ ‘åè®®': 'topic-490e474b',
                'ä»¥å¤ªç½‘äº¤æ¢æœº': 'topic-66688d44',
                'WLAN': 'wlan-8e76902b',
                'ä»¤ç‰Œç¯ç½‘': 'topic-c554d64f',
                'è‡ªé€‚åº”æ ‘': 'topic-ec668b50',
                'ALOHA': 'aloha-419b6322',
                'ä½å›¾åè®®': 'topic-e6ae9603',
                'äºŒè¿›åˆ¶å€’è®¡æ•°': 'topic-324bf6b3',
                'VLAN': 'vlan-9881f82f',
                'ç»å…¸ä»¥å¤ªç½‘': 'topic-d9d14c56',
                'è™šç”µè·¯å’Œæ•°æ®åŒ…æœåŠ¡': 'topic-781e9c6b',
                'è·¯ç”±ä¸è½¬å‘': 'topic-4c764b65',
                'æ‹¥å¡æ§åˆ¶': 'topic-cd31ab3a',
                'DVè·¯ç”±ç®—æ³•': 'dv-b86c1681',
                'é“¾è·¯çŠ¶æ€è·¯ç”±ç®—æ³•': 'topic-763671ff',
                'å±‚æ¬¡è·¯ç”±': 'topic-cd6d1eb4',
                'IPv4â€”â€”åˆ†ç»„': 'ipv4-9fc15f27',
                'IPv4â€”â€”åœ°å€': 'ipv4-9759f481',
                'IPv4â€”â€”NAT': 'ipv4nat-dc739220',
                'IPv4â€”â€”å­ç½‘åˆ’åˆ†ä¸å­ç½‘æ©ç ': 'ipv4-4b24f7e0',
                'CIDR': 'cidr-fb34bfeb',
                'ARP': 'arp-e18712a7',
                'DHCP': 'dhcp-54201c55',
                'ICMP': 'icmp-7d6fe0dd',
                'IPæ•°æ®åŒ…çš„æ ¼å¼': 'ip-3f2f6f56',
                'RIP': 'rip-a195b7c9',
                'OSPF': 'ospf-0ad08eb2',
                'BGP': 'bgp-fb5acc03',
                'IPv6': 'ipv6-fdb7cb8f',
                'IPç»„æ’­': 'ip-3f23f4d5',
                'ç§»åŠ¨IP': 'ip-d2473636',
                'VPN': 'vpn-eaef8590',
                'UDPæ•°æ®åŒ…': 'udp-3d6af637',
                'UDPæ ¡éªŒ': 'udp-c2537e3e',
                'TCPæŠ¥æ–‡æ®µ': 'tcp-ea2e5009',
                'TCPçš„æµé‡æ§åˆ¶': 'tcp-29a0cd26',
                'TCPçš„å¯é ä¼ è¾“': 'tcp-3b941421',
                'TCPæ‹¥å¡æ§åˆ¶': 'tcp-fa8383dd',
                'TCPè¿æ¥çš„å»ºç«‹å’Œé‡Šæ”¾': 'tcp-5d664357',
                'å¥—æ¥å­—': 'topic-e4499afd',
                'DNS': 'dns-ed5f2bde',
                'FTP': 'ftp-c728a493',
                'TELNET': 'telnet-1360d178',
                'WWW': 'www-793b899a',
                'HTTP': 'http-293c9ea2',
                'MIME': 'mime-1903a344',
                'SMTP': 'smtp-c2239a92',
                'POP3': 'pop3-0e82c505',
                'SNMP': 'snmp-305af652',
                'è®¡ç®—æœºç½‘ç»œé¢ä¸´çš„å®‰å…¨æ€§å¨èƒ': 'topic-616f79f7',
                'å®‰å…¨çš„è®¡ç®—æœºç½‘ç»œ': 'topic-c33a1c3b',
                'å¯¹ç§°å¯†é’¥å¯†ç ': 'topic-70fbbcaa',
                'DES': 'des-80ac4ad5',
                'AES': 'aes-76b75934',
                'å…¬é’¥å¯†ç ä½“åˆ¶': 'topic-1d189374',
                'RSA': 'rsa-445d0434',
                'æ•°å­—ç­¾å': 'topic-95da6a4c',
                'MD5': 'md5-7f138a09',
                'SHA-1': 'sha1-c7df38de',
                'å¯†é’¥åˆ†é…': 'topic-2dd4c7e3',
                'è¿›ç¨‹åˆ›å»º': 'topic-f2cc1fcd',
                'è¿›ç¨‹è°ƒåº¦': 'topic-8dd1b7f3',
                'è¿›ç¨‹åŒæ­¥': 'topic-c120f910',
                'è¿›ç¨‹é€šä¿¡': 'topic-24da6400',
                'æ­»é”å¤„ç†': 'topic-01dda544',
                'çº¿ç¨‹åˆ›å»º': 'topic-d6065366',
                'çº¿ç¨‹åŒæ­¥': 'topic-283a81a9',
                'çº¿ç¨‹æ± ': 'topic-46dc5c2e',
                'å¤šçº¿ç¨‹ç¼–ç¨‹': 'topic-4e8c9a97',
                'å†…å­˜åˆ†é…': 'topic-c2083682',
                'è™šæ‹Ÿå†…å­˜': 'topic-84429675',
                'åˆ†é¡µæœºåˆ¶': 'topic-36ecd165',
                'åˆ†æ®µæœºåˆ¶': 'topic-f8896228',
                'é¡µé¢ç½®æ¢': 'topic-495eff4a',
                'TLBç®¡ç†': 'tlb-a34d1b95',
                'æ–‡ä»¶åˆ†é…': 'topic-29c6be28',
                'ç›®å½•ç»“æ„': 'topic-c222403a',
                'ç£ç›˜è°ƒåº¦': 'topic-a56767df',
                'RAIDæŠ€æœ¯': 'raid-fee9a073',
                'æ–‡ä»¶æƒé™': 'topic-bc417e55',
                'æ—¥å¿—æ–‡ä»¶': 'topic-59eb0644',
                'I/Oç®¡ç†': 'io-30e1a2bd',
                'ä¸­æ–­å¤„ç†': 'topic-f07a04b5',
                'DMAæŠ€æœ¯': 'dma-3e09abe4',
                'è®¾å¤‡é©±åŠ¨': 'topic-37bd6ae6',
                'ç¼“å†²æŠ€æœ¯': 'topic-0e4724fb',
                'ç³»ç»Ÿè°ƒç”¨æ¥å£': 'topic-a0a850a1',
                'å†…æ ¸æ€': 'topic-fb5911da',
                'ç”¨æˆ·æ€': 'topic-5627064b',
                'æƒé™ç®¡ç†': 'topic-23bbdd59',
                'ç³»ç»ŸæœåŠ¡': 'topic-46a614a2',
                'å…³ç³»ä»£æ•°': 'topic-4c64eb6a',
                'å…ƒç»„æ¼”ç®—': 'topic-5370732c',
                'ERæ¨¡å‹': 'er-c2193d80',
                'å…³ç³»è§„èŒƒåŒ–': 'topic-ba5a2c6f',
                'å‡½æ•°ä¾èµ–': 'topic-2ab55c60',
                'DDLè¯­å¥': 'ddl-80b7485e',
                'DMLè¯­å¥': 'dml-310f52ad',
                'DCLè¯­å¥': 'dcl-d5faebc7',
                'æŸ¥è¯¢ä¼˜åŒ–': 'topic-5eb083bd',
                'è§†å›¾æ“ä½œ': 'topic-089de5bf',
                'ACIDæ€§è´¨': 'acid-1e40c1c9',
                'å¹¶å‘æ§åˆ¶': 'topic-5a9d7500',
                'é”æœºåˆ¶': 'topic-c812c111',
                'æ¢å¤æŠ€æœ¯': 'topic-3aa3b470',
                'B+æ ‘ç´¢å¼•': 'topic-8f5369f8',
                'å“ˆå¸Œç´¢å¼•': 'topic-a0b6a51c',
                'ä½å›¾ç´¢å¼•': 'topic-77f4592f',
                'å…¨æ–‡ç´¢å¼•': 'topic-be13841f',
                'ç´¢å¼•ä¼˜åŒ–': 'topic-d3f457a3',
                'æ‰§è¡Œè®¡åˆ’': 'topic-355c882c',
                'è¿æ¥ç®—æ³•': 'topic-3ae45546',
                'é€‰æ‹©ç®—æ³•': 'topic-1ae77997',
                'ç»Ÿè®¡ä¿¡æ¯': 'topic-f56ae67a',
                'æ•°æ®åˆ†ç‰‡': 'topic-92d7276f',
                'åˆ†å¸ƒå¼äº‹åŠ¡': 'topic-a19fed56',
                'ä¸€è‡´æ€§åè®®': 'topic-86a15c3e',
                'CAPç†è®º': 'cap-832c15eb',
                'NoSQLæ•°æ®åº“': 'nosql-8d04f5ec',
                'éœ€æ±‚åˆ†æ': 'topic-195af93f',
                'éœ€æ±‚å»ºæ¨¡': 'topic-a983d6c6',
                'ç”¨ä¾‹åˆ†æ': 'topic-849334c6',
                'éœ€æ±‚éªŒè¯': 'topic-319436cf',
                'éœ€æ±‚ç®¡ç†': 'topic-a6675782',
                'æ¶æ„è®¾è®¡': 'topic-9890f816',
                'è¯¦ç»†è®¾è®¡': 'topic-9ef96c66',
                'æ¥å£è®¾è®¡': 'topic-0bd4753c',
                'æ•°æ®åº“è®¾è®¡': 'topic-31ac2cd2',
                'ç”¨æˆ·ç•Œé¢è®¾è®¡': 'topic-1c4fb742',
                'å•å…ƒæµ‹è¯•': 'topic-93b824b5',
                'é›†æˆæµ‹è¯•': 'topic-9691fa05',
                'ç³»ç»Ÿæµ‹è¯•': 'topic-3476a036',
                'éªŒæ”¶æµ‹è¯•': 'topic-4882dac1',
                'æ€§èƒ½æµ‹è¯•': 'topic-ddd22119',
                'å®‰å…¨æµ‹è¯•': 'topic-aabf5035',
                'æ•æ·å¼€å‘': 'topic-889270ca',
                'Scrumæ–¹æ³•': 'scrum-85032ed8',
                'çœ‹æ¿æ–¹æ³•': 'topic-39fd11df',
                'é£é™©ç®¡ç†': 'topic-e4d60b5b',
                'è´¨é‡ç®¡ç†': 'topic-054f5e77',
                'Gitç®¡ç†': 'git-51617d4b',
                'åˆ†æ”¯ç­–ç•¥': 'topic-40eb5270',
                'åˆå¹¶å†²çª': 'topic-dfbabb98',
                'ä»£ç å®¡æŸ¥': 'topic-89d9f581',
                'æŒç»­é›†æˆ': 'topic-ba50ec6f',
                'åˆ›å»ºå‹æ¨¡å¼': 'topic-d7b229c4',
                'ç»“æ„å‹æ¨¡å¼': 'topic-f203704d',
                'è¡Œä¸ºå‹æ¨¡å¼': 'topic-0df886f3',
                'æ¶æ„æ¨¡å¼': 'topic-3b64cdeb',
                'è®¾è®¡åŸåˆ™': 'topic-7cc9f6e9'
            };

            // ç›´æ¥ä»æ˜ å°„è¡¨ä¸­æŸ¥æ‰¾
            if (completeSlugMapping[name]) {
                return completeSlugMapping[name];
            }

            // å¦‚æœæ˜ å°„è¡¨ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤å€¼
            console.warn('æœªæ‰¾åˆ°çŸ¥è¯†ç‚¹çš„slugæ˜ å°„:', name);
            return 'topic-unknown';
        }

        function updateDeepSpaceEffects(time) {
            nebulaClouds.forEach((nebula, index) => {
                nebula.rotation.x += nebula.userData.rotationSpeed * 0.8; // å¤§å¹…æé«˜æ˜Ÿäº‘æ—‹è½¬
                nebula.rotation.y += nebula.userData.rotationSpeed * 0.8 * 0.7;
                nebula.rotation.z += nebula.userData.rotationSpeed * 0.8 * 0.3;

                const pulse = Math.sin(time * nebula.userData.pulseSpeed) * 0.05 + 0.95;
                nebula.material.opacity = nebula.userData.baseOpacity * pulse;
            });

            // æ›´æ–°è¿œæ™¯æ˜Ÿç³»
            distantGalaxies.forEach((galaxy) => {
                // ç¼“æ…¢æ—‹è½¬
                galaxy.rotation.y += galaxy.userData.rotationSpeed;

                // è½»å¾®çš„è„‰åŠ¨æ•ˆæœ
                const pulse = Math.sin(time * galaxy.userData.pulseSpeed) * 0.1 + 0.9;
                galaxy.children.forEach(child => {
                    if (child.material && child.material.opacity !== undefined) {
                        child.material.opacity = galaxy.userData.baseOpacity * pulse;
                    }
                });

                // æ ¹æ®æ˜Ÿç³»ç±»å‹æ·»åŠ ç‰¹æ®Šæ•ˆæœ
                if (galaxy.userData.type === 'spiral') {
                    // èºæ—‹æ˜Ÿç³»é¢å¤–çš„èºæ—‹è‡‚æ—‹è½¬
                    galaxy.rotation.z += galaxy.userData.rotationSpeed * 0.5;
                } else if (galaxy.userData.type === 'irregular') {
                    // ä¸è§„åˆ™æ˜Ÿç³»çš„è½»å¾®æ‘†åŠ¨
                    galaxy.rotation.x += Math.sin(time * 0.1 + galaxy.userData.index) * 0.0001;
                    galaxy.rotation.z += Math.cos(time * 0.1 + galaxy.userData.index) * 0.0001;
                }
            });

            cosmicDust.forEach(dust => {
                dust.rotation.y += dust.userData.rotationSpeed * 0.8; // å¤§å¹…æé«˜å°˜åŸƒæ—‹è½¬
                dust.rotation.x += dust.userData.rotationSpeed * 0.8 * 0.5;

                dust.position.x += Math.sin(time * 0.1) * dust.userData.driftSpeed * 1.2; // å¤§å¹…æé«˜æ¼‚ç§»
                dust.position.z += Math.cos(time * 0.1) * dust.userData.driftSpeed * 1.2;
            });

            meteors.forEach((meteor, index) => {
                if (!meteor.active) {
                    if (Date.now() > meteor.nextSpawn) {
                        spawnMeteor(meteor);
                    }
                } else {
                    meteor.position.add(meteor.velocity);

                    if (meteor.mesh) {
                        meteor.mesh.position.copy(meteor.position);

                        if (meteor.position.length() > 400) {
                            scene.remove(meteor.mesh);
                            meteor.mesh = null;
                            meteor.active = false;
                            meteor.nextSpawn = Date.now() + Math.random() * 15000 + 10000;
                        }
                    }
                }
            });
        }

        function spawnMeteor(meteorData) {
            const distance = 300 + Math.random() * 100;
            const angle1 = Math.random() * Math.PI * 2;
            const angle2 = Math.random() * Math.PI * 0.5 + Math.PI * 0.25;

            meteorData.position.set(
                Math.sin(angle2) * Math.cos(angle1) * distance,
                Math.cos(angle2) * distance,
                Math.sin(angle2) * Math.sin(angle1) * distance
            );

            const targetDirection = new THREE.Vector3()
                .subVectors(camera.position, meteorData.position)
                .normalize()
                .multiplyScalar(2 + Math.random() * 3);

            meteorData.velocity.copy(targetDirection);
            meteorData.active = true;

            const meteorGeometry = new THREE.SphereGeometry(0.3, 6, 4);
            const meteorMaterial = new THREE.MeshBasicMaterial({
                color: 0xffddaa,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            meteorData.mesh = new THREE.Mesh(meteorGeometry, meteorMaterial);
            meteorData.mesh.position.copy(meteorData.position);
            scene.add(meteorData.mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetView() {
            if (lockMode && lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }

            camera.position.set(0, 0, 150);
            cameraRotation.set(0, 0);
            camera.rotation.set(0, 0, 0);
            flySpeed = 0.5;
            lockAngle = 0;
            lockDistance = 15;
        }

        function toggleAnimation() {
            animationPaused = !animationPaused;
        }

        function animateCameraToTarget(targetPosition, lookAtPosition, isLockMode = false) {
            const startPosition = camera.position.clone();
            const startRotation = cameraRotation.clone();

            const direction = new THREE.Vector3().subVectors(lookAtPosition, targetPosition).normalize();
            const targetRotationY = Math.atan2(direction.x, direction.z);
            const targetRotationX = -Math.asin(direction.y);

            const duration = 2000;
            const startTime = Date.now();

            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                camera.position.lerpVectors(startPosition, targetPosition, eased);

                if (isLockMode) {
                    camera.lookAt(lookAtPosition);
                } else {
                    cameraRotation.x = THREE.MathUtils.lerp(startRotation.x, targetRotationX, eased);
                    cameraRotation.y = THREE.MathUtils.lerp(startRotation.y, targetRotationY, eased);

                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            updateCamera();
        }

        function updateClusterStats() {
            console.log('ğŸ“Š å¼€å§‹æ›´æ–°é›†ç¾¤ç»Ÿè®¡...');
            console.log('papersæ•°ç»„é•¿åº¦:', papers.length);

            // è°ƒè¯•ï¼šæ˜¾ç¤ºpapersæ•°ç»„ä¸­æ¯ä¸ªå¯¹è±¡çš„è¯¾ç¨‹ä¿¡æ¯
            if (papers.length > 0) {
                const debugInfo = papers.slice(0, 5).map(p => ({
                    type: p.userData.type,
                    course: p.userData.course,
                    name: p.userData.name
                }));
                console.log('å‰5ä¸ªpaperså¯¹è±¡:', debugInfo);
            }

            const stats = csCourses.map((course, index) => {
                const count = papers.filter(p => {
                    return p.userData && typeof p.userData.course === 'number' && p.userData.course === index;
                }).length;
                console.log(`${course.name} (index ${index}): ${count}ä¸ªæ¦‚å¿µ`);
                return `${course.name}: ${count}ä¸ªæ¦‚å¿µ`;
            }).join('<br>');

            const statsElement = document.getElementById('clusterStats');
            if (statsElement) {
                statsElement.innerHTML = stats;
                console.log('âœ… ç»Ÿè®¡ä¿¡æ¯å·²æ›´æ–°åˆ°DOM');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°clusterStatså…ƒç´ ');
            }
        }

        function showTooltip(event, userData) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = event.clientX + 15 + 'px';
            tooltip.style.top = event.clientY - 10 + 'px';

            if (!userData || typeof userData.course !== 'number' || !userData.name || !userData.type) {
                hideTooltip();
                return;
            }

            const course = csCourses[userData.course];
            if (!course) {
                hideTooltip();
                return;
            }

            let content = '';

            if (userData.type === 'star') {
                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 16px;">
                            â­ ${userData.name} æ˜Ÿç³»
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">ğŸŒŒ</span> <strong>ç±»å‹:</strong> çŸ¥è¯†æ’æ˜Ÿ
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">ğŸª</span> <strong>è¡Œæ˜Ÿæ•°é‡:</strong> ${course.planets ? course.planets.length : 0} ä¸ª
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">ğŸ“š</span> <strong>é¢†åŸŸ:</strong> ${course.name}
                        </div>
                    </div>
                `;
            } else if (userData.type === 'planet') {
                const satelliteCount = userData.satellites ? userData.satellites.length : 0;
                const planetIndex = typeof userData.planetIndex === 'number' ? userData.planetIndex : 0;

                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ğŸª ${userData.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">ğŸŒŒ</span> <strong>æ‰€å±æ˜Ÿç³»:</strong> ${course.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">ğŸ›¸</span> <strong>ç±»å‹:</strong> çŸ¥è¯†è¡Œæ˜Ÿ
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">ğŸŒ™</span> <strong>å«æ˜Ÿæ•°é‡:</strong> ${satelliteCount} ä¸ª
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #45b7d1;">ğŸ“</span> <strong>è½¨é“ä½ç½®:</strong> ç¬¬ ${planetIndex + 1} è½¨é“
                        </div>
                    </div>
                `;
            } else if (userData.type === 'satellite') {
                const parentPlanetName = (userData.parentPlanet && userData.parentPlanet.userData && userData.parentPlanet.userData.name)
                    ? userData.parentPlanet.userData.name : 'æœªçŸ¥è¡Œæ˜Ÿ';
                const satelliteIndex = typeof userData.satelliteIndex === 'number' ? userData.satelliteIndex : 0;

                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ğŸŒ™ ${userData.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">ğŸŒŒ</span> <strong>æ‰€å±æ˜Ÿç³»:</strong> ${course.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">ğŸ›¸</span> <strong>ç±»å‹:</strong> çŸ¥è¯†å«æ˜Ÿ
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">ğŸª</span> <strong>æ¯è¡Œæ˜Ÿ:</strong> ${parentPlanetName}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #45b7d1;">ğŸ“</span> <strong>å«æ˜Ÿè½¨é“:</strong> ç¬¬ ${satelliteIndex + 1} è½¨é“
                        </div>
                    </div>
                `;
            }

            tooltip.innerHTML = content;
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        function searchConcept() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            if (!searchTerm) {
                return;
            }

            const foundConcepts = papers.filter(paper =>
                paper.userData.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            if (foundConcepts.length > 0) {
                const exactMatch = foundConcepts.find(paper =>
                    paper.userData.name.toLowerCase() === searchTerm.toLowerCase()
                );

                const targetConcept = exactMatch || foundConcepts[0];

                if (lockedConcept) {
                    unlockConcept(lockedConcept);
                }

                lockConcept(targetConcept);
                flyToConcept(targetConcept);
                showSearchResult(foundConcepts.length, targetConcept);
            } else {
                showSearchResult(0, null);
            }
        }

        function lockConcept(concept) {
            preLockPosition = camera.position.clone();

            lockedConcept = concept;
            lockMode = true;

            document.getElementById('unlockBtn').style.display = 'inline-block';

            // è·å–çœŸå®ç½‘æ ¼è¿›è¡Œæè´¨æ“ä½œ
            const realMesh = concept.userData.realMesh || concept;

            // åŒæ—¶åœ¨ç¢°æ’ä½“å’ŒçœŸå®ç½‘æ ¼ä¸­è®¾ç½®é”å®šçŠ¶æ€
            concept.userData.isLocked = true;
            realMesh.userData.isLocked = true;

            // åœ¨çœŸå®ç½‘æ ¼ä¸­ä¿å­˜åŸå§‹æè´¨å±æ€§
            realMesh.userData.originalEmissive = realMesh.material.emissive.clone();
            realMesh.userData.originalColor = realMesh.material.color.clone();
            realMesh.userData.originalOpacity = realMesh.material.opacity;

            // åˆ›å»ºé”å®šæŒ‡ç¤ºå™¨ï¼ˆç¯å½¢ï¼‰
            const ringGeometry = new THREE.RingGeometry(
                realMesh.geometry.parameters.radius * 2,
                realMesh.geometry.parameters.radius * 2.2,
                32
            );
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(concept.position);
            ring.lookAt(camera.position);

            concept.userData.lockRing = ring;
            scene.add(ring);

            // æ·»åŠ è„‰å†²å…‰æ™•
            const glowGeometry = new THREE.SphereGeometry(realMesh.geometry.parameters.radius * 3, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(concept.position);

            concept.userData.lockGlow = glow;
            scene.add(glow);
        }

        function unlockConcept(concept) {
            if (concept && (concept.userData.isLocked || (concept.userData.realMesh && concept.userData.realMesh.userData.isLocked))) {
                // è·å–çœŸå®ç½‘æ ¼è¿›è¡Œæè´¨æ“ä½œ
                const realMesh = concept.userData.realMesh || concept;

                // åŒæ—¶æ¸…é™¤ç¢°æ’ä½“å’ŒçœŸå®ç½‘æ ¼çš„é”å®šçŠ¶æ€
                concept.userData.isLocked = false;
                realMesh.userData.isLocked = false;

                // å¼ºåˆ¶æ¢å¤åˆ°åŸºç¡€é¢œè‰²çŠ¶æ€
                if (realMesh.material && realMesh.userData.baseColor) {
                    // æ¢å¤åŸºç¡€é¢œè‰²
                    realMesh.material.color.copy(realMesh.userData.baseColor);

                    // æ¢å¤åŸºç¡€å‘å…‰æ•ˆæœ
                    realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(0.15);

                    // æ¢å¤åŸºç¡€é€æ˜åº¦
                    realMesh.material.opacity = 0.9;
                }

                // æ¸…ç†ä¿å­˜çš„åŸå§‹å±æ€§
                delete realMesh.userData.originalEmissive;
                delete realMesh.userData.originalColor;
                delete realMesh.userData.originalOpacity;
                delete realMesh.userData.justUnlocked;

                // ç§»é™¤é”å®šæŒ‡ç¤ºå™¨
                if (concept.userData.lockRing) {
                    scene.remove(concept.userData.lockRing);
                    concept.userData.lockRing = null;
                }

                if (concept.userData.lockGlow) {
                    scene.remove(concept.userData.lockGlow);
                    concept.userData.lockGlow = null;
                }
            }

            // éšè—å–æ¶ˆé”å®šæŒ‰é’®
            document.getElementById('unlockBtn').style.display = 'none';

            // é‡ç½®é”å®šçŠ¶æ€
            lockedConcept = null;
            lockMode = false;

            // å¦‚æœæœ‰ä¿å­˜çš„é”å®šå‰ä½ç½®ï¼Œæœå‘é‚£ä¸ªä½ç½®
            if (preLockPosition) {
                // ä½¿ç”¨é”å®šé€»è¾‘çš„åå‘æ“ä½œï¼šè®©ç›¸æœºæœå‘é”å®šå‰çš„ä½ç½®
                camera.lookAt(preLockPosition);

                // åŒæ­¥cameraRotationå˜é‡ä»¥ä¿æŒä¸€è‡´æ€§
                const direction = new THREE.Vector3().subVectors(preLockPosition, camera.position).normalize();
                cameraRotation.y = Math.atan2(direction.x, direction.z);
                cameraRotation.x = -Math.asin(direction.y);

                // æ¸…é™¤ä¿å­˜çš„ä½ç½®
                preLockPosition = null;
            }
        }

        function unlockCurrentConcept() {
            if (lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }
        }

        function showSearchResult(count, concept) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.position = 'fixed';
            tooltip.style.top = '50%';
            tooltip.style.left = '50%';
            tooltip.style.transform = 'translate(-50%, -50%)';
            tooltip.style.zIndex = '1000';

            if (count === 0) {
                tooltip.innerHTML = `
                    <div style="text-align: center; color: #ff6b6b;">
                        <div style="font-size: 16px; margin-bottom: 10px;">ğŸ” æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>
                        <div style="font-size: 12px; opacity: 0.8;">è¯·å°è¯•å…¶ä»–å…³é”®è¯</div>
                    </div>
                `;
            } else {
                const course = csCourses[concept.userData.course];
                tooltip.innerHTML = `
                    <div style="text-align: center; color: #00ff00;">
                        <div style="font-size: 16px; margin-bottom: 10px;">ğŸ¯ å·²é”å®šç›®æ ‡</div>
                        <div style="font-size: 14px; color: #00f5ff; margin-bottom: 5px;">${concept.userData.name}</div>
                        <div style="font-size: 12px; opacity: 0.8;">æ‰€å±è¯¾ç¨‹: ${course.name}</div>
                        <div style="font-size: 12px; opacity: 0.8;">æ‰¾åˆ° ${count} ä¸ªç›¸å…³ç»“æœ</div>
                        <div style="font-size: 10px; margin-top: 10px; opacity: 0.6;">
                            <div>ğŸ® WASD: ç¯ç»•è§‚å¯Ÿ | QE: è°ƒæ•´é«˜åº¦</div>
                            <div>âŒ¨ï¸ ESCé”®æˆ–ç‚¹å‡»"å–æ¶ˆé”å®š"æŒ‰é’®è§£é™¤é”å®š</div>
                        </div>
                    </div>
                `;
            }

            tooltip.classList.add('show');

            // 5ç§’åè‡ªåŠ¨éšè—æœç´¢ç»“æœæç¤º
            setTimeout(() => {
                if (tooltip.innerHTML.includes('å·²é”å®šç›®æ ‡') || tooltip.innerHTML.includes('æœªæ‰¾åˆ°åŒ¹é…ç»“æœ')) {
                    tooltip.classList.remove('show');
                }
            }, 5000);
        }

        function flyToConcept(concept) {
            // åœ¨æ¦‚å¿µå‘¨å›´è®¾ç½®ç›¸æœºä½ç½®ï¼Œå½¢æˆç¯ç»•æ•ˆæœ
            const distance = lockDistance;
            const height = 5;

            const targetPosition = concept.position.clone();
            targetPosition.x += distance * Math.cos(lockAngle);
            targetPosition.z += distance * Math.sin(lockAngle);
            targetPosition.y += height;

            // æ‰§è¡Œç›¸æœºåŠ¨ç”»ï¼Œç¡®ä¿çœ‹å‘æ¦‚å¿µ
            animateCameraToTarget(targetPosition, concept.position, true);
        }

        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchConcept();
            }
        }

        function rotateClockwise() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šé¡ºæ—¶é’ˆç¯ç»•ç›®æ ‡15åº¦
                lockAngle += Math.PI / 12; // 15åº¦å°è§’åº¦æ—‹è½¬
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šé¡ºæ—¶é’ˆæ—‹è½¬è§†è§’15åº¦
            const targetRotationY = cameraRotation.y + Math.PI / 12; // 15åº¦å°è§’åº¦

            // æ‰§è¡Œå¹³æ»‘æ—‹è½¬åŠ¨ç”»
            const startRotationY = cameraRotation.y;
            const duration = 200; // 200æ¯«ç§’å¿«é€Ÿæ—‹è½¬
            const startTime = Date.now();

            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©æ—‹è½¬æ›´è‡ªç„¶
                const eased = 1 - Math.pow(1 - progress, 3);

                // æ›´æ–°Yè½´æ—‹è½¬
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetRotationY, eased);

                // åº”ç”¨æ—‹è½¬åˆ°ç›¸æœº
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }

            updateRotation();
        }

        function flip180Degrees() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šç›´æ¥ç¿»è½¬ç¯ç»•è§’åº¦
                lockAngle += Math.PI;
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šç¿»è½¬Yè½´æ—‹è½¬180åº¦
            const targetRotationY = cameraRotation.y + Math.PI;

            // æ‰§è¡Œå¹³æ»‘ç¿»è½¬åŠ¨ç”»
            const startRotationY = cameraRotation.y;
            const duration = 300; // 300æ¯«ç§’å¿«é€Ÿç¿»è½¬
            const startTime = Date.now();

            function updateFlip() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©ç¿»è½¬æ›´è‡ªç„¶
                const eased = 1 - Math.pow(1 - progress, 3);

                // æ›´æ–°Yè½´æ—‹è½¬
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetRotationY, eased);

                // åº”ç”¨æ—‹è½¬åˆ°ç›¸æœº
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateFlip);
                }
            }

            updateFlip();
        }

        // æ›´æ–°æ’æ˜ŸåŠ¨æ€å…‰æº
        function updateStarLights(time) {
            scene.userData.starLights.forEach(starLightData => {
                let pulseIntensity;

                // æ ¹æ®è¯¾ç¨‹ç±»å‹è°ƒæ•´å…‰æºè¡Œä¸º
                switch(starLightData.courseIndex) {
                    case 0: // æ•°æ®ç»“æ„ - å¼ºåŠ›è„‰å†²å…‰
                        pulseIntensity = Math.sin(time * 1.2 + starLightData.animationOffset) * 0.8 + 1.5;
                        break;
                    case 1: // ç®—æ³•è®¾è®¡ - èŠ‚å¥å…‰
                        pulseIntensity = Math.abs(Math.sin(time * 1.5 + starLightData.animationOffset)) * 0.6 + 1.4;
                        break;
                    case 2: // è®¡ç®—æœºç½‘ç»œ - æ³¢åŠ¨å…‰
                        pulseIntensity = (Math.sin(time * 0.8 + starLightData.animationOffset) +
                                        Math.sin(time * 1.6 + starLightData.animationOffset)) * 0.3 + 1.6;
                        break;
                    case 3: // æ“ä½œç³»ç»Ÿ - ç¨³å®šå…‰
                        pulseIntensity = Math.sin(time * 0.5 + starLightData.animationOffset) * 0.2 + 2.0;
                        break;
                    case 4: // æ•°æ®åº“ç³»ç»Ÿ - å®è—å…‰
                        pulseIntensity = Math.sin(time * 0.7 + starLightData.animationOffset) * 0.5 + 2.2 +
                                       Math.sin(time * 2.1 + starLightData.animationOffset) * 0.3;
                        break;
                    case 5: // è½¯ä»¶å·¥ç¨‹ - å˜å¹»å…‰
                        pulseIntensity = Math.sin(time * 1.0 + starLightData.animationOffset) * 0.4 + 1.8;
                        break;
                    default:
                        pulseIntensity = Math.sin(time * 0.8 + starLightData.animationOffset) * 0.5 + 1.5;
                }

                starLightData.light.intensity = starLightData.baseIntensity * pulseIntensity;

                // è½»å¾®çš„è‰²å½©å˜åŒ–
                const colorShift = Math.sin(time * 0.3 + starLightData.animationOffset) * 0.1 + 0.9;
                const color = new THREE.Color(starLightData.color);
                color.multiplyScalar(colorShift);
                starLightData.light.color.copy(color);
            });
        }

        // æ§åˆ¶é¢æ¿åˆ‡æ¢åŠŸèƒ½
        function toggleControlsPanel() {
            const controls = document.getElementById('controls');
            const toggle = document.getElementById('controlsToggle');

            controls.classList.toggle('open');
            toggle.classList.toggle('open');

            // æ›´æ–°æŒ‰é’®æ–‡å­—
            if (controls.classList.contains('open')) {
                toggle.innerHTML = 'âœ• å…³é—­é¢æ¿';
            } else {
                toggle.innerHTML = 'ğŸ® æ§åˆ¶é¢æ¿';
            }
        }

        // æ–°å¢çš„4ä¸ªç²¾ç»†æ—‹è½¬æ§åˆ¶å‡½æ•°
        function rotateHorizontalLeft() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šé€†æ—¶é’ˆç¯ç»•ç›®æ ‡10åº¦
                lockAngle -= Math.PI / 18; // 10åº¦å°è§’åº¦æ—‹è½¬
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šæ°´å¹³å‘å·¦æ—‹è½¬10åº¦
            const targetRotationY = cameraRotation.y - Math.PI / 18; // 10åº¦å°è§’åº¦
            smoothRotateCamera(targetRotationY, cameraRotation.x, 150);
        }

        function rotateHorizontalRight() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šé¡ºæ—¶é’ˆç¯ç»•ç›®æ ‡10åº¦
                lockAngle += Math.PI / 18; // 10åº¦å°è§’åº¦æ—‹è½¬
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šæ°´å¹³å‘å³æ—‹è½¬10åº¦
            const targetRotationY = cameraRotation.y + Math.PI / 18; // 10åº¦å°è§’åº¦
            smoothRotateCamera(targetRotationY, cameraRotation.x, 150);
        }

        function rotateVerticalUp() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šè°ƒæ•´è§‚å¯Ÿé«˜åº¦ï¼ˆå‘ä¸Šï¼‰
                const currentHeight = camera.position.y - lockedConcept.position.y;
                const newHeight = Math.min(currentHeight + 2, 30); // é™åˆ¶æœ€å¤§é«˜åº¦
                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += newHeight;
                camera.position.lerp(targetPosition, 0.2);
                camera.lookAt(lockedConcept.position);
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šç«–ç›´å‘ä¸Šæ—‹è½¬10åº¦
            const targetRotationX = Math.max(cameraRotation.x - Math.PI / 18, -Math.PI/2); // é™åˆ¶ä¸èƒ½è¶…è¿‡å‚ç›´å‘ä¸Š
            smoothRotateCamera(cameraRotation.y, targetRotationX, 150);
        }

        function rotateVerticalDown() {
            if (lockMode && lockedConcept) {
                // é”å®šæ¨¡å¼ä¸‹ï¼šè°ƒæ•´è§‚å¯Ÿé«˜åº¦ï¼ˆå‘ä¸‹ï¼‰
                const currentHeight = camera.position.y - lockedConcept.position.y;
                const newHeight = Math.max(currentHeight - 2, -10); // é™åˆ¶æœ€å°é«˜åº¦
                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += newHeight;
                camera.position.lerp(targetPosition, 0.2);
                camera.lookAt(lockedConcept.position);
                return;
            }

            // è‡ªç”±é£è¡Œæ¨¡å¼ä¸‹ï¼šç«–ç›´å‘ä¸‹æ—‹è½¬10åº¦
            const targetRotationX = Math.min(cameraRotation.x + Math.PI / 18, Math.PI/2); // é™åˆ¶ä¸èƒ½è¶…è¿‡å‚ç›´å‘ä¸‹
            smoothRotateCamera(cameraRotation.y, targetRotationX, 150);
        }

        // é€šç”¨çš„å¹³æ»‘æ—‹è½¬å‡½æ•°
        function smoothRotateCamera(targetY, targetX, duration = 150) {
            const startRotationY = cameraRotation.y;
            const startRotationX = cameraRotation.x;
            const startTime = Date.now();

            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©æ—‹è½¬æ›´è‡ªç„¶
                const eased = 1 - Math.pow(1 - progress, 3);

                // æ›´æ–°æ—‹è½¬
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetY, eased);
                cameraRotation.x = THREE.MathUtils.lerp(startRotationX, targetX, eased);

                // åº”ç”¨æ—‹è½¬åˆ°ç›¸æœº
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }

            updateRotation();
        }

        console.log('CS Courses loaded:', csCourses.length);

        // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹åˆå§‹åŒ–
        window.addEventListener('load', () => {
            setTimeout(() => {
                init();
            }, 500); // çŸ­æš‚å»¶è¿Ÿä»¥ç¡®ä¿åŠ è½½å±å¹•æ­£ç¡®æ˜¾ç¤º
        });

        // å¦‚æœé¡µé¢å·²ç»åŠ è½½å®Œæˆï¼Œç«‹å³å¼€å§‹
        if (document.readyState === 'complete') {
            setTimeout(() => {
                init();
            }, 500);
        }

        // é¡µé¢å¯è§æ€§ä¼˜åŒ–
        let isPageVisible = true;
        document.addEventListener('visibilitychange', () => {
            isPageVisible = !document.hidden;
            if (isPageVisible) {
                console.log('ğŸ‘ï¸ é¡µé¢å¯è§ï¼Œæ¢å¤å…¨é€Ÿæ¸²æŸ“');
            } else {
                console.log('ğŸ™ˆ é¡µé¢éšè—ï¼Œé™ä½æ¸²æŸ“é¢‘ç‡');
            }
        });

        // ç›‘å¬çª—å£å¤±ç„¦ä¼˜åŒ–æ€§èƒ½
        window.addEventListener('blur', () => {
            animationPaused = true;
            console.log('â¸ï¸ çª—å£å¤±ç„¦ï¼Œæš‚åœåŠ¨ç”»');
        });

        window.addEventListener('focus', () => {
            animationPaused = false;
            console.log('â–¶ï¸ çª—å£è·ç„¦ï¼Œæ¢å¤åŠ¨ç”»');
        });
    </script>
</body>
</html>