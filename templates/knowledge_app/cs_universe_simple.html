<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS Universe - 计算机科学知识宇宙</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            overflow: hidden;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e8f4fd;
            cursor: crosshair;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 40% 80%, rgba(119, 198, 255, 0.1) 0%, transparent 50%);
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        #container.focused {
            border-color: rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 25px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 320px;
            transition: all 0.3s ease;
            color: #a8d8ea;
        }

        #info:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        #info h1 {
            font-size: 28px;
            margin-bottom: 12px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #00f5ff);
            background-size: 200% 200%;
            animation: gradientFlow 3s ease-in-out infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        #info p {
            font-size: 13px;
            line-height: 1.6;
            opacity: 0.9;
            margin: 8px 0;
            color: #b8e6ff;
        }

        #info p strong {
            color: #7dd3fc;
            font-weight: 600;
        }

        #controls {
            position: fixed;
            left: -320px; /* 默认隐藏 */
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 20, 40, 0.9) 100%);
            padding: 20px;
            border-radius: 0 15px 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: none;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 320px;
            height: auto;
            max-height: 85vh;
            overflow: hidden; /* 移除滚动条 */
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            color: #a8d8ea;
        }

        #controls.open {
            left: 0;
        }

        #controls:hover {
            box-shadow: var(--shadow-md);
        }

        #controlsToggle {
            position: fixed;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 101;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border: 1px solid rgba(0, 245, 255, 0.4);
            color: #00f5ff;
            padding: 15px 8px;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.2);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        #controlsToggle:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.4) 0%, rgba(255, 0, 255, 0.4) 100%);
            border-color: rgba(0, 245, 255, 0.8);
            transform: translateY(-50%) translateX(3px);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.4);
        }

        #controlsToggle.open {
            left: 330px;
            border-radius: 10px 0 0 10px;
            border-right: none;
            border-left: 1px solid rgba(0, 245, 255, 0.4);
        }

        .control-section {
            margin-bottom: 12px;
            font-size: 12px;
        }

        .control-title {
            font-weight: 600;
            margin-bottom: 6px;
            color: #00f5ff;
            font-size: 13px;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .legend:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            transform: translateX(5px);
            color: #00f5ff;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

        .legend-item:hover .legend-color {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-inverse);
            padding: 10px 16px;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            margin: 6px 6px 6px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border-color: rgba(0, 245, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.3);
            color: #00f5ff;
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.2);
        }

        #searchInput {
            transition: all 0.3s ease;
        }

        #searchInput:focus {
            outline: none;
            border-color: rgba(0, 245, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #tooltip {
            position: absolute;
            z-index: 200;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            color: #b8e6ff;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 280px;
            transform: translateY(10px);
        }

        #tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .cluster-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.8) 100%);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            font-size: 12px;
            transition: all 0.3s ease;
            color: #b8e6ff;
        }

        .cluster-info:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .cluster-info strong {
            color: #7dd3fc;
            text-shadow: 0 0 10px rgba(125, 211, 252, 0.3);
        }

        #fps {
            position: absolute;
            top: 20px;
            right: 50%;
            transform: translateX(50%);
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(20, 20, 40, 0.7) 100%);
            padding: 10px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            font-size: 12px;
            color: #7dd3fc;
            text-align: center;
            min-width: 80px;
        }

        /* 加载屏幕样式 */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-inverse);
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #loadingScreen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-container {
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .loading-logo {
            margin-bottom: 40px;
        }

        .rotating-galaxy {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 30px;
        }

        .galaxy-ring {
            position: absolute;
            border: 2px solid transparent;
            border-radius: 50%;
            animation: rotateGalaxy 8s linear infinite;
        }

        .ring-1 {
            width: 120px;
            height: 120px;
            border-top-color: #00f5ff;
            border-right-color: #00f5ff;
            animation-duration: 8s;
        }

        .ring-2 {
            width: 90px;
            height: 90px;
            top: 15px;
            left: 15px;
            border-top-color: #ff00ff;
            border-left-color: #ff00ff;
            animation-duration: 6s;
            animation-direction: reverse;
        }

        .ring-3 {
            width: 60px;
            height: 60px;
            top: 30px;
            left: 30px;
            border-bottom-color: #ffeaa7;
            border-right-color: #ffeaa7;
            animation-duration: 4s;
        }

        .galaxy-core {
            position: absolute;
            width: 30px;
            height: 30px;
            top: 45px;
            left: 45px;
            background: radial-gradient(circle, #ffffff 0%, #00f5ff 50%, transparent 100%);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes rotateGalaxy {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .loading-title {
            font-size: 32px;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #7dd3fc, #a78bfa, #7dd3fc);
            background-size: 200% 200%;
            animation: gradientFlow 3s ease-in-out infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .loading-subtitle {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 0;
            color: #b8e6ff;
        }

        .loading-progress {
            margin: 30px 0;
        }

        .progress-bar {
            position: relative;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(0, 245, 255, 0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff 0%, #ff00ff 50%, #00f5ff 100%);
            background-size: 200% 100%;
            animation: progressShimmer 2s ease-in-out infinite;
            border-radius: var(--border-radius);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-glow {
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.5), transparent);
            border-radius: 12px;
            opacity: 0;
            animation: progressGlow 3s ease-in-out infinite;
        }

        @keyframes progressShimmer {
            0%, 100% { background-position: 0% 0%; }
            50% { background-position: 100% 0%; }
        }

        @keyframes progressGlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #b8e6ff;
        }

        #progressPercentage {
            font-weight: 600;
            color: #7dd3fc;
            font-size: 16px;
        }

        #loadingStage {
            opacity: 0.9;
            font-style: italic;
            color: #a8d8ea;
        }

        .loading-details {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(20, 20, 40, 0.4) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }

        .current-task {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .task-icon {
            margin-right: 8px;
            font-size: 16px;
            animation: taskPulse 1.5s ease-in-out infinite;
        }

        @keyframes taskPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .loading-stats {
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
        }

        .loading-tips {
            position: fixed;
            bottom: 30px;
            left: 30px;
            right: 30px;
            max-width: 400px;
            margin: 0 auto;
        }

        .tip-content {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(20, 20, 40, 0.6) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .tip-content h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #00f5ff;
        }

        .tip-content ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .tip-content li {
            padding: 5px 0;
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.4;
            position: relative;
            padding-left: 15px;
        }

        .tip-content li::before {
            content: '✨';
            position: absolute;
            left: 0;
            top: 5px;
        }
    </style>
</head>
<body>
    <!-- 加载屏幕 -->
    <div id="loadingScreen">
        <div class="loading-container">
            <div class="loading-logo">
                <div class="rotating-galaxy">
                    <div class="galaxy-ring ring-1"></div>
                    <div class="galaxy-ring ring-2"></div>
                    <div class="galaxy-ring ring-3"></div>
                    <div class="galaxy-core"></div>
                </div>
                <h1 class="loading-title">CS Universe</h1>
                <p class="loading-subtitle">计算机科学知识宇宙正在构建中...</p>
            </div>

            <div class="loading-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-glow"></div>
                </div>
                <div class="progress-text">
                    <span id="progressPercentage">0%</span>
                    <span id="loadingStage">初始化...</span>
                </div>
            </div>

            <div class="loading-details">
                <div class="current-task">
                    <span class="task-icon">⚡</span>
                    <span id="currentTask">准备启动...</span>
                </div>
                <div class="loading-stats">
                    <span id="loadedCount">0</span> / <span id="totalCount">0</span> 项已完成
                </div>
            </div>
        </div>

        <div class="loading-tips">
            <div class="tip-content">
                <h3>💡 探索提示</h3>
                <ul id="tipsList">
                    <li>使用 WASD 键在宇宙中自由飞行</li>
                    <li>观察行星绕恒星、卫星绕行星的轨道运动</li>
                    <li>点击任意天体进入环绕观察模式</li>
                    <li>搜索功能可以快速定位知识概念</li>
                    <li>每个恒星都有独特的视觉特效</li>
                    <li>按 R 键快速翻转 180 度视角</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="info">
            <h1>CS Universe</h1>
            <p><strong>计算机科学知识宇宙</strong></p>
            <p>• 相同课程聚集成知识星系</p>
            <p>• 🌟 <span style="color: #7dd3fc;">恒星</span>：课程中心，发出强烈光芒</p>
            <p>• 🪐 <span style="color: #fbbf24;">行星</span>：绕恒星旋转的主要分支</p>
            <p>• 🌙 <span style="color: #86efac;">卫星</span>：绕行星旋转的具体概念</p>
            <p>• 🔥 <span style="color: #f87171;">核心概念</span>：多层光晕+粒子效果</p>
            <p>• 概念关联形成连线网络</p>
            <p>• 不同颜色代表不同课程领域</p>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>数据结构 (Data Structure)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: var(--accent-color);"></div>
                <span>算法设计 (Algorithm)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45b7d1;"></div>
                <span>计算机网络 (Network)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #96ceb4;"></div>
                <span>操作系统 (OS)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffeaa7;"></div>
                <span>数据库系统 (Database)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #dda0dd;"></div>
                <span>软件工程 (SE)</span>
            </div>
        </div>

        <div id="controlsToggle" onclick="toggleControlsPanel()">
            🎮 控制面板
        </div>

        <div id="controls">
            <div class="control-section">
                <div class="control-title">🌌 宇宙运行规律</div>
                <div style="font-size: 10px; line-height: 1.3; margin-bottom: 8px;">
                    <div>• 🪐 行星绕恒星轨道运行</div>
                    <div>• 🌙 卫星绕行星轨道运行</div>
                    <div>• 距离越远轨道速度越慢</div>
                    <div>• 所有天体都有自转效果</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">🔍 搜索概念</div>
                <input type="text" id="searchInput" placeholder="搜索知识点 (如: 栈, 队列, TCP/IP...)"
                       style="width: 100%; padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);
                              background: rgba(0,0,0,0.5); color: var(--text-inverse); font-size: 11px; margin-bottom: 8px;"
                       onkeypress="handleSearchKeyPress(event)">
                <button onclick="searchConcept()" style="width: 100%; margin-bottom: 0; padding: 6px 12px; font-size: 11px;">🎯 搜索并跳转</button>
            </div>

            <div class="control-section">
                <div class="control-title">🚀 基础飞行控制</div>
                <div style="color: #ffaa00; font-size: 10px; margin-bottom: 6px; padding: 4px; background: rgba(255, 170, 0, 0.1); border-radius: 4px;">💡 点击3D场景获得键盘焦点</div>
                <div style="font-size: 10px; line-height: 1.3;">
                    <div>• WASD / 方向键: 前后左右移动</div>
                    <div>• QE / 空格+Shift: 上升下降</div>
                    <div>• 鼠标按住: 持续向前飞行</div>
                    <div>• 鼠标拖拽: 改变视角方向</div>
                    <div>• 滚轮: 调整飞行速度</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">🔄 视角旋转控制</div>
                <div style="font-size: 10px; line-height: 1.3; margin-bottom: 8px;">
                    <div><strong style="color: #00ff00;">R键: 180°翻转</strong> | <strong style="color: #00ffff;">T键: 15°旋转</strong></div>
                    <div><strong style="color: #ffaa00;">J/L键: 水平转</strong> | <strong style="color: #ff88aa;">I/K键: 竖直转</strong></div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 0;">
                    <button onclick="rotateHorizontalLeft()" style="font-size: 9px; padding: 4px;">⬅️ 左(J)</button>
                    <button onclick="rotateHorizontalRight()" style="font-size: 9px; padding: 4px;">➡️ 右(L)</button>
                    <button onclick="rotateVerticalUp()" style="font-size: 9px; padding: 4px;">⬆️ 上(I)</button>
                    <button onclick="rotateVerticalDown()" style="font-size: 9px; padding: 4px;">⬇️ 下(K)</button>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">🔒 锁定模式</div>
                <div style="color: #ffaa00; font-size: 9px; margin: 2px 0;">💡 点击任意天体进入锁定模式</div>
                <div style="font-size: 10px; line-height: 1.3;">
                    <div>• WASD: 环绕目标 • QE: 调整高度</div>
                    <div>• R键: 翻转角度 • T键: 顺时针环绕</div>
                    <div>• J/L键: 左右环绕 • I/K键: 上下视角</div>
                    <div>• ESC: 取消锁定</div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-title">⚙️ 系统控制</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    <button onclick="resetView()" style="padding: 5px; font-size: 10px;">🏠 重置</button>
                    <button onclick="flip180Degrees()" style="padding: 5px; font-size: 10px;">🔄 翻转</button>
                    <button onclick="rotateClockwise()" style="padding: 5px; font-size: 10px; background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 200, 255, 0.2) 100%); border-color: rgba(0, 255, 255, 0.4);"
                        onmouseover="this.style.background='linear-gradient(135deg, rgba(0, 255, 255, 0.4) 0%, rgba(0, 200, 255, 0.4) 100%)'; this.style.borderColor='rgba(0, 255, 255, 0.8)';"
                        onmouseout="this.style.background='linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 200, 255, 0.2) 100%)'; this.style.borderColor='rgba(0, 255, 255, 0.4)';">🔁 微调</button>
                    <button onclick="toggleAnimation()" style="padding: 5px; font-size: 10px;">⏯️ 暂停</button>
                </div>
                <button onclick="unlockCurrentConcept()" id="unlockBtn" style="display: none; background: linear-gradient(135deg, rgba(255, 0, 0, 0.2) 0%, rgba(255, 100, 100, 0.2) 100%); width: 100%; margin-top: 6px; padding: 5px; font-size: 10px;">🔓 取消锁定</button>
            </div>

            <div class="control-section">
                <div class="control-title">🏠 导航控制</div>
                <button onclick="window.location.href='/'" style="width: 100%; padding: 8px; font-size: 11px; background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%); border-color: rgba(102, 126, 234, 0.5); color: var(--primary-color); font-weight: 600;"
                    onmouseover="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%)'; this.style.borderColor='rgba(102, 126, 234, 0.8)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.4)';"
                    onmouseout="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%)'; this.style.borderColor='rgba(102, 126, 234, 0.5)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                    🏠 返回首页
                </button>
            </div>
        </div>

        <div class="cluster-info">
            <div><strong>课程概念统计:</strong></div>
            <div id="clusterStats">正在计算...</div>
        </div>

        <div id="fps">
            <div>FPS: <span id="fpsValue">60</span></div>
            <div style="font-size: 10px; opacity: 0.7;">性能监视器</div>
        </div>

        <div id="tooltip"></div>
    </div>

    <script>
        // 加载管理器类
        class LoadingManager {
            constructor() {
                this.totalTasks = 0;
                this.completedTasks = 0;
                this.currentStage = '';
                this.currentTask = '';
                this.stages = [
                    { name: '初始化引擎', weight: 10 },
                    { name: '创建星空背景', weight: 15 },
                    { name: '构建深空效果', weight: 20 },
                    { name: '生成数据结构星系', weight: 15 },
                    { name: '生成算法设计星系', weight: 15 },
                    { name: '生成计算机网络星系', weight: 15 },
                    { name: '生成操作系统星系', weight: 10 },
                    { name: '生成数据库系统星系', weight: 10 },
                    { name: '生成软件工程星系', weight: 10 },
                    { name: '设置交互系统', weight: 5 },
                    { name: '启动宇宙', weight: 5 }
                ];
                this.stageIndex = 0;
                this.setupElements();
            }

            setupElements() {
                this.progressFill = document.getElementById('progressFill');
                this.progressPercentage = document.getElementById('progressPercentage');
                this.loadingStage = document.getElementById('loadingStage');
                this.currentTaskElement = document.getElementById('currentTask');
                this.loadedCount = document.getElementById('loadedCount');
                this.totalCount = document.getElementById('totalCount');
                this.loadingScreen = document.getElementById('loadingScreen');

                // 计算总任务数
                this.totalTasks = this.stages.reduce((sum, stage) => sum + stage.weight, 0);
                this.totalCount.textContent = this.totalTasks;
            }

            setStage(stageName) {
                this.currentStage = stageName;
                this.loadingStage.textContent = stageName;
                console.log(`📍 进入阶段: ${stageName}`);
            }

            setTask(taskName) {
                this.currentTask = taskName;
                this.currentTaskElement.textContent = taskName;
            }

            updateProgress(increment = 1) {
                this.completedTasks += increment;
                const percentage = Math.min((this.completedTasks / this.totalTasks) * 100, 100);

                this.progressFill.style.width = percentage + '%';
                this.progressPercentage.textContent = Math.round(percentage) + '%';
                this.loadedCount.textContent = this.completedTasks;

                console.log(`⚡ 进度更新: ${Math.round(percentage)}% (${this.completedTasks}/${this.totalTasks})`);

                if (percentage >= 100) {
                    setTimeout(() => this.complete(), 500);
                }
            }

            complete() {
                this.setTask('宇宙构建完成! 🌟');
                this.setStage('准备进入...');

                // 显示完成信息
                this.currentTaskElement.style.color = '#00ff00';
                this.loadingStage.style.color = '#00ff00';

                setTimeout(() => {
                    // 添加淡出动画
                    this.loadingScreen.style.transition = 'opacity 1.2s ease, transform 1.2s ease';
                    this.loadingScreen.style.transform = 'scale(0.95)';
                    this.loadingScreen.classList.add('hidden');

                    console.log('🚀 加载完成，进入CS宇宙!');

                    // 加载完成后启动动画
                    setTimeout(() => {
                        // 显示主界面
                        const infoPanel = document.getElementById('info');
                        if (infoPanel) {
                            infoPanel.innerHTML = `
                                <h1>CS Universe</h1>
                                <p><strong>计算机科学知识宇宙</strong></p>
                                <p>• 相同课程聚集成知识星系</p>
                                <p>• 🌟 <span style="color: #7dd3fc;">恒星</span>：课程中心，发出强烈光芒</p>
                                <p>• 🪐 <span style="color: #fbbf24;">行星</span>：绕恒星旋转的主要分支</p>
                                <p>• 🌙 <span style="color: #86efac;">卫星</span>：绕行星旋转的具体概念</p>
                                <p>• 🔥 <span style="color: #f87171;">核心概念</span>：多层光晕+粒子效果</p>
                                <p>• 概念关联形成连线网络</p>
                                <p>• 不同颜色代表不同课程领域</p>
                            `;
                        }

                        // 最终确保统计数据正确
                        console.log('🔍 最终检查 - papers数组长度:', papers.length);
                        if (papers.length > 0) {
                            updateClusterStats();
                            console.log('✅ 统计数据已更新');
                        } else {
                            console.error('❌ papers数组仍为空，可能存在创建问题');
                        }

                        animate();
                    }, 1200);
                }, 1000);
            }

            simulateProgress(min = 1, max = 3) {
                const increment = Math.floor(Math.random() * (max - min + 1)) + min;
                this.updateProgress(increment);

                // 添加一些性能提示
                this.addPerformanceTips();
            }

            addPerformanceTips() {
                const tips = [
                    '💡 使用现代浏览器可获得最佳体验',
                    '🚀 硬件加速已启用以提升性能',
                    '🎯 自适应渲染确保流畅运行',
                    '⚡ 智能LOD系统优化远距离对象',
                    '🔧 使用WebGL 2.0进行高效渲染',
                    '📊 动态调整渲染质量以维持帧率'
                ];

                if (Math.random() < 0.3 && this.completedTasks > 10) {
                    const tip = tips[Math.floor(Math.random() * tips.length)];
                    const tipElement = document.querySelector('.tip-content ul');
                    if (tipElement && tipElement.children.length > 0) {
                        const randomIndex = Math.floor(Math.random() * tipElement.children.length);
                        tipElement.children[randomIndex].textContent = tip;
                    }
                }
            }
        }

        // 创建全局加载管理器
        const loadingManager = new LoadingManager();

        // 异步任务队列
        class TaskQueue {
            constructor() {
                this.tasks = [];
                this.isRunning = false;
            }

            add(task, priority = 0) {
                return new Promise((resolve) => {
                    this.tasks.push({ task, priority, resolve });
                    this.tasks.sort((a, b) => b.priority - a.priority);
                    if (!this.isRunning) {
                        this.process();
                    }
                });
            }

            async process() {
                this.isRunning = true;

                while (this.tasks.length > 0) {
                    const { task, resolve } = this.tasks.shift();

                    try {
                        await this.executeTask(task);
                        resolve(); // 任务完成，解决Promise
                    } catch (error) {
                        console.error('任务执行失败:', error);
                        resolve(); // 即使出错也要解决Promise
                    }

                    // 让浏览器有时间处理其他任务，但确保任务完成
                    await this.yield();
                }

                this.isRunning = false;
                console.log('📋 所有异步任务已完成');
            }

            executeTask(task) {
                return new Promise((resolve) => {
                    try {
                        if (typeof task === 'function') {
                            const result = task();
                            // 如果task返回Promise，等待它完成
                            if (result && typeof result.then === 'function') {
                                result.then(resolve).catch(resolve);
                            } else {
                                resolve();
                            }
                        } else {
                            resolve();
                        }
                    } catch (error) {
                        console.error('任务执行异常:', error);
                        resolve(); // 即使出错也要继续
                    }
                });
            }

            yield() {
                return new Promise(resolve => {
                    if (window.requestIdleCallback) {
                        requestIdleCallback(resolve, { timeout: 50 });
                    } else {
                        setTimeout(resolve, 0);
                    }
                });
            }
        }

        const taskQueue = new TaskQueue();

        let scene, camera, renderer, papers = [], stars = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let isMouseDown = false;
        let mouseStart = new THREE.Vector2();
        let animationPaused = false;

        // 深空效果相关变量
        let nebulaClouds = [];
        let meteors = [];
        let cosmicDust = [];
        let starTwinkles = [];
        let distantGalaxies = []; // 远景星系数组

        // 飞行控制变量
        let keys = {};
        let flySpeed = 0.5;
        let rotateSpeed = 0.002;
        let cameraRotation = new THREE.Vector2(0, 0);
        let velocity = new THREE.Vector3();
        let flyMode = true;
        let isMousePressed = false;
        let mouseMoveForward = false;
        let dragThreshold = 10;
        let speedTrail = [];
        let maxTrailLength = 20;

        // 搜索锁定功能变量
        let lockedConcept = null;
        let lockMode = false;
        let lockDistance = 15;
        let lockAngle = 0;
        let lastLockMode = false;
        let preLockPosition = null;

        // FPS计算
        let fps = 60;
        let frameCount = 0;
        let lastTime = Date.now();

        // 性能优化变量
        let LOD_DISTANCE_NEAR = 60;
        let LOD_DISTANCE_FAR = 300;  // 大幅增加可见距离
        let FRUSTUM_CULLING_ENABLED = true;
        let lastCameraPosition = new THREE.Vector3();
        let cameraMovedThreshold = 3;
        let frameSkipCounter = 0;
        let animationUpdateFrequency = 2;

        // 计算机科学星系和知识点 - 恒星-行星-卫星结构
        const csCourses = [
            {
                name: '数据结构',
                color: 0xff6b6b,
                center: new THREE.Vector3(120, 0, 0),
                planets: [
                    {
                        name: '链表',
                        color: 0xff4444,
                        satellites: ['单链表', '双链表', '循环链表', '静态链表']
                    },
                    {
                        name: '栈',
                        color: 0xff5555,
                        satellites: ['顺序栈', '链式栈', '栈——括号匹配', '栈——表达式求值', '栈——卡特兰数', '栈——函数调用', '栈——递归']
                    },
                    {
                        name: '队列',
                        color: 0xff7777,
                        satellites: ['顺序队列', '循环队列', '链队列', '双端队列', '队列——缓冲区', '广度优先搜索']
                    },
                    {
                        name: '矩阵',
                        color: 0xffaaaa,
                        satellites: ['对称矩阵', '三角矩阵', '稀疏矩阵——三元组表示法', '稀疏矩阵——十字链表法', '广义表', 'KMP模式匹配']
                    },
                    {
                        name: '树与二叉树',
                        color: 0xff8888,
                        satellites: ['树与二叉树的性质', 'BST', 'AVL', '二叉树——顺序存储', '二叉树——链式存储', '二叉树——四序遍历', '线索二叉树', '树、森林与二叉树的转换', '树和森林的遍历', '哈夫曼树', '并查集']
                    },
                    {
                        name: '图',
                        color: 0xff6666,
                        satellites: ['图的存储结构', '图的遍历——DFS', '图的遍历——BFS', '最小生成树——Prim算法', '最小生成树——Kruskal算法', '最短路径——Dijkstra算法', '最短路径——Floyd', '最短路径——A*', '关键路径']
                    },
                    {
                        name: '查找',
                        color: 0xffbbbb,
                        satellites: ['二分查找', '分块查找', 'BST', 'AVL', '红黑树', 'B树', 'B+树', 'hash表']
                    },
                    {
                        name: '排序',
                        color: 0xffcccc,
                        satellites: ['八大排序', '外部排序']
                    }
                ]
            },
            {
                name: '算法设计',
                color: 0x4ecdc4,
                center: new THREE.Vector3(-120, 60, 60),
                planets: [
                    {
                        name: '分治算法',
                        color: 0x2eb8b0,
                        satellites: ['二分搜索', '归并排序', '快速排序', '最大子数组']
                    },
                    {
                        name: '动态规划',
                        color: 0x4ecdc4,
                        satellites: ['背包问题', '最长公共子序列', '最长递增子序列', '编辑距离', '状态转移']
                    },
                    {
                        name: '贪心算法',
                        color: 0x6ed9d1,
                        satellites: ['活动选择', '背包贪心', '哈夫曼编码', '最小生成树']
                    },
                    {
                        name: '回溯算法',
                        color: 0x8ee5de,
                        satellites: ['N皇后问题', '数独求解', '子集生成', '排列组合']
                    },
                    {
                        name: '图论算法',
                        color: 0x3ec2b7,
                        satellites: ['深度优先搜索', '广度优先搜索', 'Dijkstra算法', 'Floyd算法', 'Kruskal算法', 'Prim算法']
                    },
                    {
                        name: '字符串算法',
                        color: 0x5ed0c7,
                        satellites: ['KMP模式匹配', 'Rabin-Karp算法', '后缀数组', 'AC自动机']
                    },
                    {
                        name: '数值算法',
                        color: 0x7eddd4,
                        satellites: ['快速幂', '欧几里得算法', '扩展欧几里得', '素数筛选']
                    }
                ]
            },
            {
                name: '计算机网络',
                color: 0x45b7d1,
                center: new THREE.Vector3(0, -120, 0),
                planets: [
                    {
                        name: '物理层',
                        color: 0x2aa3c7,
                        satellites: ['数据通信的基础知识', '传输介质', '信道复用', '物理层设备']
                    },
                    {
                        name: '数据链路层',
                        color: 0x45b7d1,
                        satellites: ['组帧', '差错控制——检错码', '差错控制——纠错编码', '流量控制', '可靠传输机制', '滑动窗口机制', '停等协议', 'GBN协议', 'SR协议', 'ppp协议', 'MAC子层', 'CSMA/CD协议', 'CSMA/CA协议', '网桥', '生成树协议', '以太网交换机', 'WLAN', '令牌环网', '自适应树', 'ALOHA', '位图协议', '二进制倒计数', 'VLAN', '经典以太网']
                    },
                    {
                        name: '网络层',
                        color: 0x60c5db,
                        satellites: ['虚电路和数据包服务', '路由与转发', '拥塞控制', 'DV路由算法', '链路状态路由算法', '层次路由', 'IPv4——分组', 'IPv4——地址', 'IPv4——NAT', 'IPv4——子网划分与子网掩码', 'CIDR', 'ARP', 'DHCP', 'ICMP', 'IP数据包的格式', 'RIP', 'OSPF', 'BGP', 'IPv6', 'IP组播', '移动IP', 'VPN']
                    },
                    {
                        name: '传输层',
                        color: 0x7bd3e5,
                        satellites: ['UDP数据包', 'UDP校验', 'TCP报文段', 'TCP的流量控制', 'TCP的可靠传输', 'TCP拥塞控制', 'TCP连接的建立和释放', '套接字']
                    },
                    {
                        name: '应用层',
                        color: 0x96e1ef,
                        satellites: ['DNS', 'FTP', 'TELNET', 'WWW', 'HTTP', 'MIME', 'SMTP', 'POP3', 'DHCP', 'SNMP']
                    },
                    {
                        name: '网络安全',
                        color: 0x309bc1,
                        satellites: ['计算机网络面临的安全性威胁', '安全的计算机网络', '对称密钥密码', 'DES', 'AES', '公钥密码体制', 'RSA', '数字签名', 'MD5', 'SHA-1', '密钥分配']
                    }
                ]
            },
            {
                name: '操作系统',
                color: 0x96ceb4,
                center: new THREE.Vector3(-60, 0, -120),
                planets: [
                    {
                        name: '进程管理',
                        color: 0x7bc49a,
                        satellites: ['进程创建', '进程调度', '进程同步', '进程通信', '死锁处理']
                    },
                    {
                        name: '线程管理',
                        color: 0x96ceb4,
                        satellites: ['线程创建', '线程同步', '线程池', '多线程编程']
                    },
                    {
                        name: '内存管理',
                        color: 0xb1d8ce,
                        satellites: ['内存分配', '虚拟内存', '分页机制', '分段机制', '页面置换', 'TLB管理']
                    },
                    {
                        name: '文件系统',
                        color: 0xcce2e8,
                        satellites: ['文件分配', '目录结构', '磁盘调度', 'RAID技术', '文件权限', '日志文件']
                    },
                    {
                        name: '设备管理',
                        color: 0x81ba90,
                        satellites: ['I/O管理', '中断处理', 'DMA技术', '设备驱动', '缓冲技术']
                    },
                    {
                        name: '系统调用',
                        color: 0xa6d0b8,
                        satellites: ['系统调用接口', '内核态', '用户态', '权限管理', '系统服务']
                    }
                ]
            },
            {
                name: '数据库系统',
                color: 0xffeaa7,
                center: new THREE.Vector3(60, 120, -60),
                planets: [
                    {
                        name: '关系模型',
                        color: 0xffe083,
                        satellites: ['关系代数', '元组演算', 'ER模型', '关系规范化', '函数依赖']
                    },
                    {
                        name: 'SQL语言',
                        color: 0xffeaa7,
                        satellites: ['DDL语句', 'DML语句', 'DCL语句', '查询优化', '视图操作']
                    },
                    {
                        name: '事务管理',
                        color: 0xfff4cb,
                        satellites: ['ACID性质', '并发控制', '锁机制', '死锁处理', '恢复技术']
                    },
                    {
                        name: '索引技术',
                        color: 0xffecb3,
                        satellites: ['B+树索引', '哈希索引', '位图索引', '全文索引', '索引优化']
                    },
                    {
                        name: '查询处理',
                        color: 0xffe699,
                        satellites: ['查询优化', '执行计划', '连接算法', '选择算法', '统计信息']
                    },
                    {
                        name: '分布式数据库',
                        color: 0xffd666,
                        satellites: ['数据分片', '分布式事务', '一致性协议', 'CAP理论', 'NoSQL数据库']
                    }
                ]
            },
            {
                name: '软件工程',
                color: 0xdda0dd,
                center: new THREE.Vector3(0, 0, 120),
                planets: [
                    {
                        name: '需求工程',
                        color: 0xd293d3,
                        satellites: ['需求分析', '需求建模', '用例分析', '需求验证', '需求管理']
                    },
                    {
                        name: '系统设计',
                        color: 0xdda0dd,
                        satellites: ['架构设计', '详细设计', '接口设计', '数据库设计', '用户界面设计']
                    },
                    {
                        name: '软件测试',
                        color: 0xe8ade7,
                        satellites: ['单元测试', '集成测试', '系统测试', '验收测试', '性能测试', '安全测试']
                    },
                    {
                        name: '项目管理',
                        color: 0xf3baf1,
                        satellites: ['敏捷开发', 'Scrum方法', '看板方法', '风险管理', '质量管理']
                    },
                    {
                        name: '版本控制',
                        color: 0xc986c7,
                        satellites: ['Git管理', '分支策略', '合并冲突', '代码审查', '持续集成']
                    },
                    {
                        name: '设计模式',
                        color: 0xde9cdb,
                        satellites: ['创建型模式', '结构型模式', '行为型模式', '架构模式', '设计原则']
                    }
                ]
            }
        ];

        async function init() {
            try {
                // 阶段1: 初始化引擎
                loadingManager.setStage('初始化引擎');
                loadingManager.setTask('创建3D场景...');
                await initializeEngine();

                // 阶段2: 创建星空背景
                loadingManager.setStage('创建星空背景');
                loadingManager.setTask('生成背景星空...');
                await createStarFieldAsync();

                // 阶段3: 构建深空效果
                loadingManager.setStage('构建深空效果');
                loadingManager.setTask('添加星云和宇宙尘埃...');
                await createDeepSpaceEffectsAsync();

                // 阶段4-9: 创建知识点聚类
                await createConceptClustersAsync();

                // 阶段10: 设置交互系统
                loadingManager.setStage('设置交互系统');
                loadingManager.setTask('配置控制系统...');
                await setupInteractionAsync();

                // 阶段11: 完成初始化
                loadingManager.setStage('启动宇宙');
                loadingManager.setTask('最终优化...');
                await finalizeAsync();

                loadingManager.complete();

            } catch (error) {
                console.error('初始化失败:', error);
                loadingManager.setTask('❌ 初始化失败');
                loadingManager.setStage('请刷新页面重试');

                // 显示错误信息和重试按钮
                const loadingDetails = document.querySelector('.loading-details');
                if (loadingDetails) {
                    loadingDetails.innerHTML = `
                        <div class="error-info">
                            <div style="color: #ff6b6b; font-size: 16px; margin-bottom: 10px;">⚠️ 加载失败</div>
                            <div style="font-size: 14px; margin-bottom: 15px; opacity: 0.8;">
                                初始化过程中出现错误，可能是网络问题或设备兼容性问题。
                            </div>
                            <button onclick="location.reload()" style="
                                background: linear-gradient(135deg, rgba(255, 107, 107, 0.2) 0%, rgba(255, 107, 107, 0.4) 100%);
                                border: 1px solid #ff6b6b;
                                color: #ff6b6b;
                                padding: 10px 20px;
                                border-radius: var(--border-radius-sm);
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='rgba(255, 107, 107, 0.3)'"
                               onmouseout="this.style.background='linear-gradient(135deg, rgba(255, 107, 107, 0.2) 0%, rgba(255, 107, 107, 0.4) 100%)'">
                                🔄 重新加载
                            </button>
                        </div>
                    `;
                }
            }
        }

        async function initializeEngine() {
            // 创建场景
            loadingManager.setTask('创建3D场景...');
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 50, 400);
            loadingManager.simulateProgress(1, 2);

            // 创建摄像机
            loadingManager.setTask('设置摄像机...');
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 150);
            camera.rotation.order = 'YXZ';
            loadingManager.simulateProgress(1, 2);

            // 创建渲染器
            loadingManager.setTask('初始化渲染器...');
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setClearColor(0x000011, 0.8);
            renderer.shadowMap.enabled = false;
            renderer.outputEncoding = THREE.LinearEncoding;
            renderer.toneMapping = THREE.NoToneMapping;

            document.getElementById('container').appendChild(renderer.domElement);
            loadingManager.simulateProgress(2, 3);

            // 添加光照系统
            loadingManager.setTask('配置光照系统...');
            setupLighting();
            loadingManager.simulateProgress(2, 4);
        }

        async function createStarFieldAsync() {
            const starLayers = [
                { count: 150, size: 0.8, opacity: 0.7, color: 0xffffff, twinkle: true, name: '近景星空' },
                { count: 75, size: 1.2, opacity: 0.5, color: 0x88aaff, twinkle: false, name: '中景星空' },
                { count: 300, size: 0.5, opacity: 0.35, color: 0xffffcc, twinkle: true, twinkeIntensity: 0.3, name: '远景星空' }
            ];

            for (let layerIndex = 0; layerIndex < starLayers.length; layerIndex++) {
                const layer = starLayers[layerIndex];
                loadingManager.setTask(`生成${layer.name} (${layer.count}颗星)...`);

                await taskQueue.add(() => {
                    createStarLayer(layer, layerIndex);
                }, 5);

                loadingManager.simulateProgress(3, 6);
                await new Promise(resolve => setTimeout(resolve, 100)); // 短暂延迟以显示进度
            }
        }

        function createStarLayer(layer, layerIndex) {
            const starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            const starOpacities = [];

            for (let i = 0; i < layer.count; i++) {
                const radius = 150 + layerIndex * 80; // 增加层间距离
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                starPositions.push(
                    Math.sin(phi) * Math.cos(theta) * radius,
                    Math.cos(phi) * radius,
                    Math.sin(phi) * Math.sin(theta) * radius
                );

                let color = new THREE.Color(layer.color);

                // 为不同层次添加颜色变化
                if (layerIndex === 0) {
                    // 近景星空 - 白色为主，少量暖色
                    const hue = Math.random();
                    if (hue < 0.7) color.setHex(0xffffff);
                    else if (hue < 0.85) color.setHex(0xffddaa);
                    else color.setHex(0xaaddff);
                } else if (layerIndex === 1) {
                    // 中景星空 - 蓝色为主
                    const hue = Math.random();
                    if (hue < 0.6) color.setHex(0x88aaff);
                    else if (hue < 0.8) color.setHex(0xaaddff);
                    else color.setHex(0xddddff);
                } else if (layerIndex === 2) {
                    // 远景星空 - 更多颜色变化，模拟远距离星系
                    const hue = Math.random();
                    if (hue < 0.3) color.setHex(0xffffcc); // 淡黄
                    else if (hue < 0.5) color.setHex(0xffeeaa); // 暖白
                    else if (hue < 0.7) color.setHex(0xeeffff); // 冷白
                    else if (hue < 0.85) color.setHex(0xffcccc); // 淡红
                    else color.setHex(0xccffcc); // 淡绿
                }

                starColors.push(color.r, color.g, color.b);
                starSizes.push(layer.size * (0.5 + Math.random() * 0.8)); // 增加大小变化
                starOpacities.push(layer.opacity * (0.3 + Math.random() * 0.7)); // 增加透明度变化
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            starsGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(starOpacities, 1));

            const starMaterial = new THREE.PointsMaterial({
                size: layer.size,
                transparent: true,
                opacity: layer.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const starField = new THREE.Points(starsGeometry, starMaterial);
            starField.userData = {
                rotationSpeed: (layerIndex + 1) * 0.00005, // 远景星空旋转更慢
                layer: layerIndex,
                twinkle: layer.twinkle,
                baseOpacity: layer.opacity,
                twinkleIntensity: layer.twinkeIntensity || 1.0 // 远景星空闪烁更微弱
            };

            scene.add(starField);
            stars.push(starField);

            if (layer.twinkle) {
                starTwinkles.push({
                    starField: starField,
                    twinkleOffset: Math.random() * Math.PI * 2,
                    twinkleSpeed: (0.3 + Math.random() * 1.0) * (layerIndex === 2 ? 0.6 : 1.0), // 远景星空闪烁更慢
                    intensity: starField.userData.twinkleIntensity
                });
            }
        }

        async function createDeepSpaceEffectsAsync() {
            loadingManager.setTask('生成星云...');
            await taskQueue.add(() => {
                createNebulaClouds();
            }, 4);
            loadingManager.simulateProgress(2, 5);

            loadingManager.setTask('添加宇宙尘埃...');
            await taskQueue.add(() => {
                createCosmicDust();
            }, 4);
            loadingManager.simulateProgress(2, 5);

            loadingManager.setTask('创建远景星系...');
            await taskQueue.add(() => {
                createDistantGalaxies();
            }, 3);
            loadingManager.simulateProgress(2, 4);

            loadingManager.setTask('初始化流星系统...');
            await taskQueue.add(() => {
                createMeteorSystem();
            }, 3);
            loadingManager.simulateProgress(2, 4);
        }

        async function createConceptClustersAsync() {
            for (let courseIndex = 0; courseIndex < csCourses.length; courseIndex++) {
                const course = csCourses[courseIndex];
                loadingManager.setStage(`生成${course.name}星系`);
                loadingManager.setTask(`创建${course.name}恒星...`);

                await taskQueue.add(() => {
                    createStar(course, courseIndex);
                }, 3);
                loadingManager.simulateProgress(2, 4);

                // 分批创建行星系统
                for (let planetIndex = 0; planetIndex < course.planets.length; planetIndex++) {
                    const planet = course.planets[planetIndex];
                    loadingManager.setTask(`构建${planet.name}行星系统...`);

                    await taskQueue.add(() => {
                        createPlanetSystem(course, planet, planetIndex, courseIndex);
                    }, 2);
                    loadingManager.simulateProgress(1, 2);
                }
            }

            // 所有概念创建完成后，立即更新统计信息
            console.log('📊 所有概念创建完成，papers数组长度:', papers.length);
            updateClusterStats();
        }

        async function setupInteractionAsync() {
            loadingManager.setTask('配置事件监听器...');
            await taskQueue.add(() => {
                setupEventListeners();
            }, 5);
            loadingManager.simulateProgress(2, 3);

            loadingManager.setTask('验证统计数据...');
            // 再次确认统计数据正确
            if (papers.length === 0) {
                console.warn('⚠️ papers数组为空，重新统计...');
                updateClusterStats();
            }
            loadingManager.simulateProgress(1, 2);
        }

        async function finalizeAsync() {
            loadingManager.setTask('检测设备性能...');
            await performanceCheck();
            loadingManager.simulateProgress(1, 2);

            loadingManager.setTask('优化渲染配置...');
            await optimizeRenderSettings();
            loadingManager.simulateProgress(1, 2);

            loadingManager.setTask('准备用户界面...');
            await new Promise(resolve => setTimeout(resolve, 200));
            loadingManager.simulateProgress(1, 1);

            loadingManager.setTask('最终检查完成! ✨');
            await new Promise(resolve => setTimeout(resolve, 100));
            loadingManager.simulateProgress(1, 1);
        }

        async function performanceCheck() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    console.log('🎮 GPU:', renderer);
                }

                // 简单的性能测试
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

                console.log('📊 性能参数:', {
                    maxTextureSize,
                    maxVertexAttribs,
                    devicePixelRatio: window.devicePixelRatio
                });
            }
        }

        async function optimizeRenderSettings() {
            // 根据设备性能调整设置
            const devicePixelRatio = window.devicePixelRatio;
            const isHighDPI = devicePixelRatio > 1.5;
            const isMobile = window.innerWidth < 768;

            if (isMobile || isHighDPI) {
                // 移动设备或高DPI设备优化
                LOD_DISTANCE_FAR = Math.min(LOD_DISTANCE_FAR, 200);
                animationUpdateFrequency = Math.max(animationUpdateFrequency, 3);
                console.log('📱 已应用移动设备优化');
            }

            // 内存使用估算
            const estimatedMemoryMB = (papers.length * 0.1 + stars.length * 0.05).toFixed(1);
            console.log(`💾 预估显存使用: ${estimatedMemoryMB}MB`);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3); // 降低环境光
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0x00f5ff, 0.5); // 降低主光源
            mainLight.position.set(50, 50, 50);
            scene.add(mainLight);

            const dynamicLight = new THREE.PointLight(0xffffff, 0.5, 50); // 降低动态光
            dynamicLight.position.set(0, 0, 0);
            scene.add(dynamicLight);

            scene.userData.dynamicLight = dynamicLight;
            scene.userData.mainLight = mainLight;
            scene.userData.starLights = []; // 存储恒星光源
        }

        function createStarField() {
            // 这个函数现在由 createStarFieldAsync 替代
            // 保留作为兼容性函数
        }

        function createNebulaClouds() {
            const nebulaConfigs = [
                { color: 0x4400ff, opacity: 0.06, size: 80, position: new THREE.Vector3(-100, 50, -150) },
                { color: 0xff0066, opacity: 0.05, size: 90, position: new THREE.Vector3(120, -30, 100) },
                { color: 0x0066ff, opacity: 0.07, size: 70, position: new THREE.Vector3(-80, -80, 200) },
                { color: 0xff6600, opacity: 0.04, size: 100, position: new THREE.Vector3(50, 100, -100) }
            ];

            nebulaConfigs.forEach((config, index) => {
                const nebulaGeometry = new THREE.SphereGeometry(config.size, 16, 12);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: config.opacity,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });

                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.copy(config.position);
                nebula.userData = {
                    rotationSpeed: (index + 1) * 0.0002, // 大幅提高星云基础旋转速度
                    pulseSpeed: 0.3 + Math.random() * 0.7,
                    baseOpacity: config.opacity
                };

                scene.add(nebula);
                nebulaClouds.push(nebula);
            });
        }

        function createCosmicDust() {
            const dustCount = 200;
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = [];
            const dustColors = [];
            const dustSizes = [];

            for (let i = 0; i < dustCount; i++) {
                const radius = 100 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                dustPositions.push(
                    Math.sin(phi) * Math.cos(theta) * radius + (Math.random() - 0.5) * 100,
                    Math.cos(phi) * radius + (Math.random() - 0.5) * 100,
                    Math.sin(phi) * Math.sin(theta) * radius + (Math.random() - 0.5) * 100
                );

                const dustColor = new THREE.Color();
                const colorVariant = Math.random();
                if (colorVariant < 0.4) dustColor.setHex(0xffddaa);
                else if (colorVariant < 0.7) dustColor.setHex(0xffaacc);
                else dustColor.setHex(0xaaccff);

                dustColors.push(dustColor.r, dustColor.g, dustColor.b);
                dustSizes.push(0.3 + Math.random() * 0.7);
            }

            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('color', new THREE.Float32BufferAttribute(dustColors, 3));
            dustGeometry.setAttribute('size', new THREE.Float32BufferAttribute(dustSizes, 1));

            const dustMaterial = new THREE.PointsMaterial({
                size: 0.5,
                transparent: true,
                opacity: 0.4,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const dust = new THREE.Points(dustGeometry, dustMaterial);
            dust.userData = {
                rotationSpeed: 0.0001, // 大幅提高尘埃基础旋转速度
                driftSpeed: 0.002 // 大幅提高尘埃漂移速度
            };

            scene.add(dust);
            cosmicDust.push(dust);
        }

        function createDistantGalaxies() {
            const galaxyConfigs = [
                {
                    position: new THREE.Vector3(-400, 150, -300),
                    color: 0x8888ff,
                    size: 40,
                    opacity: 0.15,
                    type: 'spiral',
                    rotation: { x: 0.3, y: 0, z: 0.2 }
                },
                {
                    position: new THREE.Vector3(350, -200, 400),
                    color: 0xffaa88,
                    size: 35,
                    opacity: 0.12,
                    type: 'spiral',
                    rotation: { x: -0.4, y: 0.5, z: 0 }
                },
                {
                    position: new THREE.Vector3(-250, -300, 200),
                    color: 0xaaffaa,
                    size: 30,
                    opacity: 0.18,
                    type: 'elliptical',
                    rotation: { x: 0.1, y: -0.3, z: 0.4 }
                },
                {
                    position: new THREE.Vector3(200, 300, -400),
                    color: 0xffccaa,
                    size: 45,
                    opacity: 0.1,
                    type: 'spiral',
                    rotation: { x: 0.6, y: 0.2, z: -0.1 }
                },
                {
                    position: new THREE.Vector3(-100, 0, -500),
                    color: 0xccaaff,
                    size: 25,
                    opacity: 0.2,
                    type: 'irregular',
                    rotation: { x: 0, y: 0.7, z: 0.3 }
                }
            ];

            galaxyConfigs.forEach((config, index) => {
                if (config.type === 'spiral') {
                    createSpiralGalaxy(config, index);
                } else if (config.type === 'elliptical') {
                    createEllipticalGalaxy(config, index);
                } else {
                    createIrregularGalaxy(config, index);
                }
            });
        }

        function createSpiralGalaxy(config, index) {
            const group = new THREE.Group();

            // 创建螺旋臂
            const spiralGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let arm = 0; arm < 2; arm++) {
                for (let i = 0; i < 100; i++) {
                    const t = i / 100;
                    const angle = t * Math.PI * 4 + arm * Math.PI; // 两条螺旋臂
                    const radius = t * config.size * 0.8;

                    // 添加一些随机扰动让螺旋臂更自然
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * config.size * 0.1;
                    const y = (Math.random() - 0.5) * config.size * 0.15; // 让星系有一定厚度
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * config.size * 0.1;

                    positions.push(x, y, z);

                    // 颜色从中心到边缘渐变
                    const color = new THREE.Color(config.color);
                    const brightness = Math.max(0.3, 1 - t * 0.7); // 中心更亮
                    color.multiplyScalar(brightness);
                    colors.push(color.r, color.g, color.b);

                    // 大小从中心到边缘变小
                    sizes.push((1 - t * 0.5) * 2);
                }
            }

            // 添加星系核心
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * config.size * 0.2;

                const x = Math.cos(angle) * radius;
                const y = (Math.random() - 0.5) * config.size * 0.05;
                const z = Math.sin(angle) * radius;

                positions.push(x, y, z);

                const coreColor = new THREE.Color(config.color);
                coreColor.multiplyScalar(1.5); // 核心更亮
                colors.push(coreColor.r, coreColor.g, coreColor.b);
                sizes.push(3 + Math.random() * 2);
            }

            spiralGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            spiralGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            spiralGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const spiralMaterial = new THREE.PointsMaterial({
                size: 1,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const spiral = new THREE.Points(spiralGeometry, spiralMaterial);
            group.add(spiral);

            // 设置位置和旋转
            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0002 + 0.0001) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.2 + Math.random() * 0.3,
                type: 'spiral',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createEllipticalGalaxy(config, index) {
            const group = new THREE.Group();

            const ellipticalGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            // 创建椭圆形星系
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.8); // 中心密度更高

                const a = config.size * 0.7; // 长轴
                const b = config.size * 0.4; // 短轴

                const x = Math.cos(angle) * distance * a;
                const y = (Math.random() - 0.5) * config.size * 0.2;
                const z = Math.sin(angle) * distance * b;

                positions.push(x, y, z);

                const color = new THREE.Color(config.color);
                const brightness = Math.max(0.4, 1 - distance * 0.6);
                color.multiplyScalar(brightness);
                colors.push(color.r, color.g, color.b);

                sizes.push((1 - distance * 0.3) * 1.5);
            }

            ellipticalGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            ellipticalGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            ellipticalGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const ellipticalMaterial = new THREE.PointsMaterial({
                size: 0.8,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const elliptical = new THREE.Points(ellipticalGeometry, ellipticalMaterial);
            group.add(elliptical);

            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0001 + 0.00005) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.1 + Math.random() * 0.2,
                type: 'elliptical',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createIrregularGalaxy(config, index) {
            const group = new THREE.Group();

            const irregularGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            // 创建不规则星系（更随机的分布）
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random();
                const irregularity = Math.random() * 0.8 + 0.2; // 不规则因子

                const x = Math.cos(angle) * distance * config.size * irregularity;
                const y = (Math.random() - 0.5) * config.size * 0.3;
                const z = Math.sin(angle) * distance * config.size * irregularity;

                positions.push(x, y, z);

                const color = new THREE.Color(config.color);
                const brightness = Math.random() * 0.8 + 0.3; // 更随机的亮度
                color.multiplyScalar(brightness);
                colors.push(color.r, color.g, color.b);

                sizes.push(Math.random() * 2 + 0.5);
            }

            irregularGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            irregularGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            irregularGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const irregularMaterial = new THREE.PointsMaterial({
                size: 1.2,
                transparent: true,
                opacity: config.opacity,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const irregular = new THREE.Points(irregularGeometry, irregularMaterial);
            group.add(irregular);

            group.position.copy(config.position);
            group.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);

            group.userData = {
                rotationSpeed: (Math.random() * 0.0003 + 0.0001) * (index % 2 === 0 ? 1 : -1),
                baseOpacity: config.opacity,
                pulseSpeed: 0.3 + Math.random() * 0.4,
                type: 'irregular',
                index: index
            };

            scene.add(group);
            distantGalaxies.push(group);
        }

        function createMeteorSystem() {
            const meteorCount = 3;

            for (let i = 0; i < meteorCount; i++) {
                const meteorData = {
                    active: false,
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    trail: [],
                    nextSpawn: Math.random() * 10000 + 5000,
                    mesh: null
                };

                meteors.push(meteorData);
            }
        }

        function createConceptClusters() {
            // 这个函数现在由 createConceptClustersAsync 替代
            // 保留作为兼容性函数
        }

        function createStar(course, courseIndex) {
            const starSize = 3.0 + Math.random() * 1.0;
            const starGeometry = new THREE.SphereGeometry(starSize, 32, 24);

            // 根据不同课程创建不同特色的恒星
            let starMaterial, specialEffects = {};

            switch(courseIndex) {
                case 0: // 数据结构 - 脉冲红星
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    specialEffects.pulseType = 'strong';
                    specialEffects.energyRings = true;
                    break;

                case 1: // 算法设计 - 旋转青星
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    specialEffects.pulseType = 'rhythmic';
                    specialEffects.spiralField = true;
                    break;

                case 2: // 计算机网络 - 网络节点星
                    specialEffects.dataStreams = true;
                    break;

                case 3: // 操作系统 - 稳定绿星
                    starMaterial = new THREE.MeshBasicMaterial({
                        color: course.color,
                        transparent: true,
                        opacity: 0.95
                    });
                    specialEffects.pulseType = 'stable';
                    specialEffects.coreShield = true;
                    break;

                case 4: // 数据库系统 - 数据矩阵星
                    specialEffects.crystalline = true;
                    break;

                case 5: // 软件工程 - 代码之花
                    specialEffects.prismatic = true;
                    break;
            }

            if (!starMaterial) {
                starMaterial = new THREE.MeshBasicMaterial({
                    color: course.color,
                    transparent: true,
                    opacity: 0.9
                });
            }

            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.copy(course.center);

            // 为恒星创建更大的不可见碰撞体以提高点击检测
            const starClickGeometry = new THREE.SphereGeometry(starSize * 2, 16, 12);
            const starClickMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                visible: false
            });
            const starClickMesh = new THREE.Mesh(starClickGeometry, starClickMaterial);
            starClickMesh.position.copy(course.center);
            starClickMesh.userData = {
                type: 'star',
                name: course.name,
                course: courseIndex,
                animationOffset: Math.random() * Math.PI * 2,
                pulseSpeed: courseIndex === 1 ? 0.8 : courseIndex === 2 ? 1.2 : 0.5 + Math.random() * 0.5,
                baseColor: new THREE.Color(course.color),
                originalPosition: course.center.clone(),
                specialEffects: specialEffects,
                realMesh: star  // 引用到真实的星球网格
            };
            scene.add(starClickMesh);
            papers.push(starClickMesh);  // 将碰撞体加入检测数组

            // 创建不同强度的恒星光源
            const lightIntensity = courseIndex === 3 ? 2.5 : courseIndex === 4 ? 3.0 : 2.0;
            const starLight = new THREE.PointLight(course.color, lightIntensity, 100, 2);
            starLight.position.copy(course.center);
            scene.add(starLight);
            scene.userData.starLights.push({
                light: starLight,
                baseIntensity: lightIntensity,
                color: course.color,
                animationOffset: Math.random() * Math.PI * 2,
                courseIndex: courseIndex
            });

            star.userData = {
                type: 'star',
                name: course.name,
                course: courseIndex,
                animationOffset: Math.random() * Math.PI * 2,
                pulseSpeed: courseIndex === 1 ? 0.8 : courseIndex === 2 ? 1.2 : 0.5 + Math.random() * 0.5,
                baseColor: new THREE.Color(course.color),
                originalPosition: course.center.clone(),
                starLight: starLight,
                specialEffects: specialEffects,
                clickMesh: starClickMesh  // 引用到碰撞体
            };

            // 创建特色效果
            createStarSpecialEffects(star, course, courseIndex, starSize);

            scene.add(star);
            // 不要将star加入papers数组，因为我们已经加入了clickMesh
        }

        // 创建恒星特色效果
        function createStarSpecialEffects(star, course, courseIndex, starSize) {
            const effects = star.userData.specialEffects;

            // 基础内层发光
            const glowGeometry = new THREE.SphereGeometry(starSize * 1.2, 24, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(course.color).multiplyScalar(1.8),
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            star.add(glow);
            star.userData.innerGlow = glow;

            switch(courseIndex) {
                case 0: // 数据结构 - 能量环
                    if (effects.energyRings) {
                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.RingGeometry(starSize * (2 + i), starSize * (2.2 + i), 32);
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: course.color,
                                transparent: true,
                                opacity: 0.3 - i * 0.1,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.rotation.x = Math.PI / 2;
                            star.add(ring);
                            star.userData[`energyRing${i}`] = ring;
                        }
                    }
                    break;

                case 1: // 算法设计 - 螺旋场
                    if (effects.spiralField) {
                        const spiralGeometry = new THREE.BufferGeometry();
                        const positions = [];
                        const colors = [];

                        for (let i = 0; i < 100; i++) {
                            const t = i / 100 * Math.PI * 4;
                            const radius = starSize * (3 + t * 0.5);
                            positions.push(
                                Math.cos(t) * radius,
                                Math.sin(t * 0.5) * starSize * 2,
                                Math.sin(t) * radius
                            );

                            const spiralColor = new THREE.Color(course.color);
                            colors.push(spiralColor.r, spiralColor.g, spiralColor.b);
                        }

                        spiralGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        spiralGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                        const spiralMaterial = new THREE.PointsMaterial({
                            size: 3,
                            transparent: true,
                            opacity: 0.6,
                            vertexColors: true,
                            blending: THREE.AdditiveBlending
                        });

                        const spiral = new THREE.Points(spiralGeometry, spiralMaterial);
                        star.add(spiral);
                        star.userData.spiral = spiral;
                    }
                    break;

                case 2: // 计算机网络 - 网络节点星
                    if (effects.dataStreams) {
                        // 创建网络节点连接效果
                        const nodePositions = [
                            new THREE.Vector3(starSize * 3, 0, 0),
                            new THREE.Vector3(-starSize * 3, 0, 0),
                            new THREE.Vector3(0, starSize * 3, 0),
                            new THREE.Vector3(0, -starSize * 3, 0),
                            new THREE.Vector3(0, 0, starSize * 3),
                            new THREE.Vector3(0, 0, -starSize * 3),
                            new THREE.Vector3(starSize * 2, starSize * 2, 0),
                            new THREE.Vector3(-starSize * 2, -starSize * 2, 0)
                        ];

                        // 创建网络节点
                        nodePositions.forEach((pos, i) => {
                            const nodeGeometry = new THREE.SphereGeometry(starSize * 0.3, 12, 8);
                            const nodeMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.2),
                                transparent: true,
                                opacity: 0.7,
                                blending: THREE.AdditiveBlending
                            });
                            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                            node.position.copy(pos);
                            star.add(node);
                            star.userData[`networkNode${i}`] = node;
                        });

                        // 创建连接线 - 全连接网络
                        for (let i = 0; i < nodePositions.length; i++) {
                            for (let j = i + 1; j < nodePositions.length; j++) {
                                const points = [nodePositions[i], nodePositions[j]];
                                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                                const lineMaterial = new THREE.LineBasicMaterial({
                                    color: course.color,
                                    transparent: true,
                                    opacity: 0.15,
                                    blending: THREE.AdditiveBlending
                                });
                                const line = new THREE.Line(lineGeometry, lineMaterial);
                                star.add(line);
                                star.userData[`networkLine${i}_${j}`] = line;
                            }
                        }

                        // 添加数据包流动效果
                        for (let i = 0; i < 5; i++) {
                            const packetGeometry = new THREE.SphereGeometry(starSize * 0.1, 8, 6);
                            const packetMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(2),
                                transparent: true,
                                opacity: 0.8,
                                blending: THREE.AdditiveBlending
                            });
                            const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                            packet.userData = {
                                pathProgress: Math.random(),
                                pathSpeed: 0.01 + Math.random() * 0.02,
                                pathIndex: Math.floor(Math.random() * nodePositions.length)
                            };
                            star.add(packet);
                            star.userData[`dataPacket${i}`] = packet;
                        }
                    }
                    break;

                case 3: // 操作系统 - 核心护盾
                    if (effects.coreShield) {
                        const shieldGeometry = new THREE.IcosahedronGeometry(starSize * 3, 1);
                        const shieldMaterial = new THREE.MeshBasicMaterial({
                            color: course.color,
                            transparent: true,
                            opacity: 0.15,
                            blending: THREE.AdditiveBlending,
                            wireframe: true
                        });
                        const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                        star.add(shield);
                        star.userData.shield = shield;
                    }
                    break;

                case 4: // 数据库系统 - 优化数据矩阵星
                    if (effects.crystalline) {
                        // 创建分层数据结构
                        const layers = [
                            { size: 3, spacing: starSize * 1.2, cubeSize: starSize * 0.3, name: '主数据层' },
                            { size: 5, spacing: starSize * 0.8, cubeSize: starSize * 0.2, name: '索引层' },
                            { size: 7, spacing: starSize * 0.6, cubeSize: starSize * 0.15, name: '缓存层' }
                        ];

                        layers.forEach((layer, layerIndex) => {
                            const offset = -(layer.size - 1) / 2;

                            for (let x = 0; x < layer.size; x++) {
                                for (let y = 0; y < layer.size; y++) {
                                    for (let z = 0; z < layer.size; z++) {
                                        // 跳过中心位置（恒星位置）
                                        if (layerIndex === 0 && x === 1 && y === 1 && z === 1) continue;

                                        // 在外层只创建边缘立方体
                                        if (layerIndex > 0) {
                                            const isEdge = x === 0 || x === layer.size - 1 ||
                                                         y === 0 || y === layer.size - 1 ||
                                                         z === 0 || z === layer.size - 1;
                                            if (!isEdge) continue;
                                        }

                                        const cubeGeometry = new THREE.BoxGeometry(layer.cubeSize, layer.cubeSize, layer.cubeSize);
                                        const brightness = 0.6 + Math.random() * 0.4;
                                        const cubeMaterial = new THREE.MeshBasicMaterial({
                                            color: new THREE.Color(course.color).multiplyScalar(brightness),
                                            transparent: true,
                                            opacity: 0.4 + layerIndex * 0.1,
                                            blending: THREE.AdditiveBlending
                                        });
                                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

                                        cube.position.set(
                                            (x + offset) * layer.spacing,
                                            (y + offset) * layer.spacing,
                                            (z + offset) * layer.spacing
                                        );

                                        cube.userData = {
                                            baseOpacity: cubeMaterial.opacity,
                                            flashDelay: Math.random() * 8,
                                            rotationSpeed: 0.002 + Math.random() * 0.008,
                                            layer: layerIndex,
                                            accessFrequency: layerIndex === 0 ? 0.01 : layerIndex === 1 ? 0.005 : 0.002
                                        };

                                        star.add(cube);
                                        star.userData[`matrixCube${layerIndex}_${x}_${y}_${z}`] = cube;
                                    }
                                }
                            }
                        });

                        // 添加数据流连接线 - 连接不同层级
                        for (let i = 0; i < 20; i++) {
                            const layer1 = Math.floor(Math.random() * 3);
                            const layer2 = (layer1 + 1) % 3;

                            const radius1 = starSize * (1.2 - layer1 * 0.3);
                            const radius2 = starSize * (1.2 - layer2 * 0.3);

                            const angle1 = Math.random() * Math.PI * 2;
                            const angle2 = Math.random() * Math.PI * 2;

                            const startPos = new THREE.Vector3(
                                Math.cos(angle1) * radius1,
                                (Math.random() - 0.5) * starSize * 2,
                                Math.sin(angle1) * radius1
                            );
                            const endPos = new THREE.Vector3(
                                Math.cos(angle2) * radius2,
                                (Math.random() - 0.5) * starSize * 2,
                                Math.sin(angle2) * radius2
                            );

                            const points = [startPos, endPos];
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.2),
                                transparent: true,
                                opacity: 0.25,
                                blending: THREE.AdditiveBlending
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            star.add(line);
                            star.userData[`dataConnection${i}`] = line;
                        }

                        // 添加主键索引环
                        const primaryRing = new THREE.RingGeometry(starSize * 2.8, starSize * 3.2, 32);
                        const primaryMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(course.color).multiplyScalar(1.5),
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide
                        });
                        const ring = new THREE.Mesh(primaryRing, primaryMaterial);
                        ring.rotation.x = Math.PI / 2;
                        star.add(ring);
                        star.userData.primaryKeyRing = ring;
                    }
                    break;

                case 5: // 软件工程 - 脉冲星
                    if (effects.prismatic) {
                        // 创建脉冲星核心环
                        const coreRings = 4;
                        for (let i = 0; i < coreRings; i++) {
                            const ringRadius = starSize * (1.5 + i * 0.5);
                            const ringGeometry = new THREE.RingGeometry(ringRadius, ringRadius + starSize * 0.1, 32);
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(1.5 - i * 0.2),
                                transparent: true,
                                opacity: 0.6 - i * 0.1,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.rotation.x = Math.PI / 2;
                            ring.userData = {
                                baseRadius: ringRadius,
                                pulseOffset: i * Math.PI / 2,
                                ringIndex: i
                            };
                            star.add(ring);
                            star.userData[`pulseRing${i}`] = ring;
                        }

                        // 创建磁场线
                        const fieldLines = 12;
                        for (let i = 0; i < fieldLines; i++) {
                            const points = [];
                            const segments = 20;

                            for (let j = 0; j <= segments; j++) {
                                const t = j / segments;
                                const radius = starSize * (2 + Math.sin(t * Math.PI * 2) * 1.5);
                                const height = (t - 0.5) * starSize * 6;
                                const angle = (i / fieldLines) * Math.PI * 2 + t * Math.PI * 0.5;

                                points.push(new THREE.Vector3(
                                    Math.cos(angle) * radius,
                                    height,
                                    Math.sin(angle) * radius
                                ));
                            }

                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: new THREE.Color(course.color).multiplyScalar(0.8),
                                transparent: true,
                                opacity: 0.3,
                                blending: THREE.AdditiveBlending
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            line.userData = {
                                fieldIndex: i,
                                rotationSpeed: 0.005 + Math.random() * 0.01
                            };
                            star.add(line);
                            star.userData[`magneticField${i}`] = line;
                        }
                    }
                    break;
            }

            // 标准光晕和辐射效果
            const coronaGeometry = new THREE.SphereGeometry(starSize * 2.5, 24, 16);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: course.color,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            star.add(corona);
            star.userData.corona = corona;

            const radiationGeometry = new THREE.SphereGeometry(starSize * 4, 16, 12);
            const radiationMaterial = new THREE.MeshBasicMaterial({
                color: course.color,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending
            });
            const radiation = new THREE.Mesh(radiationGeometry, radiationMaterial);
            star.add(radiation);
            star.userData.radiation = radiation;
        }

        function createPlanetSystem(course, planet, planetIndex, courseIndex) {
            const orbitRadius = 20 + planetIndex * 15;  // 增加基础距离和间隔距离
            const orbitSpeed = 0.012 / (1 + planetIndex * 0.2); // 提高轨道速度，减少速度衰减
            const initialAngle = (planetIndex / course.planets.length) * Math.PI * 2;

            // 创建行星轨道线（围绕恒星）
            const orbitPoints = [];
            const orbitSegments = 64; // 轨道分段数，越多越圆滑
            for (let i = 0; i <= orbitSegments; i++) {
                const angle = (i / orbitSegments) * Math.PI * 2;
                orbitPoints.push(new THREE.Vector3(
                    course.center.x + Math.cos(angle) * orbitRadius,
                    course.center.y,
                    course.center.z + Math.sin(angle) * orbitRadius
                ));
            }

            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(course.color).multiplyScalar(0.6), // 使用课程颜色但较暗
                transparent: true,
                opacity: 0.15, // 很低的透明度，不会太显眼
                blending: THREE.AdditiveBlending
            });

            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);

            const planetSize = 1.0 + Math.random() * 0.5;
            const planetGeometry = new THREE.SphereGeometry(planetSize, 24, 18);

            // 行星使用受光照影响的材质，提高亮度
            const planetMaterial = new THREE.MeshPhongMaterial({
                color: planet.color,
                emissive: new THREE.Color(planet.color).multiplyScalar(0.5), // 从0.25提高到0.5，增加发光强度
                transparent: true,
                opacity: 0.95, // 从0.9提高到0.95，增加不透明度
                shininess: 60  // 从40提高到60，增加金属光泽
            });

            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);

            planetMesh.position.set(
                course.center.x + Math.cos(initialAngle) * orbitRadius,
                course.center.y + Math.sin(initialAngle * 0.3) * 3,
                course.center.z + Math.sin(initialAngle) * orbitRadius
            );

            // 为行星创建更大的不可见碰撞体
            const planetClickGeometry = new THREE.SphereGeometry(planetSize * 2, 16, 12);
            const planetClickMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                visible: false
            });
            const planetClickMesh = new THREE.Mesh(planetClickGeometry, planetClickMaterial);
            planetClickMesh.position.copy(planetMesh.position);
            planetClickMesh.userData = {
                type: 'planet',
                name: planet.name,
                course: courseIndex,
                planetIndex: planetIndex,
                orbitRadius: orbitRadius,
                orbitSpeed: orbitSpeed,
                orbitAngle: initialAngle,
                orbitCenter: course.center,
                animationOffset: Math.random() * Math.PI * 2,
                baseColor: new THREE.Color(planet.color),
                satellites: planet.satellites,
                realMesh: planetMesh
            };
            scene.add(planetClickMesh);
            papers.push(planetClickMesh);

            planetMesh.userData = {
                type: 'planet',
                name: planet.name,
                course: courseIndex,
                planetIndex: planetIndex,
                orbitRadius: orbitRadius,
                orbitSpeed: orbitSpeed,
                orbitAngle: initialAngle,
                orbitCenter: course.center,
                animationOffset: Math.random() * Math.PI * 2,
                baseColor: new THREE.Color(planet.color),
                satellites: planet.satellites,
                clickMesh: planetClickMesh
            };

            scene.add(planetMesh);
            // 不要将planetMesh加入papers，因为已经加入了clickMesh

            // 为行星添加发光效果，使其在旋转时更加明显
            const planetGlowGeometry = new THREE.SphereGeometry(planetSize * 1.5, 16, 12);
            const planetGlowMaterial = new THREE.MeshBasicMaterial({
                color: planet.color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const planetGlow = new THREE.Mesh(planetGlowGeometry, planetGlowMaterial);
            planetMesh.add(planetGlow);
            planetMesh.userData.planetGlow = planetGlow;

            createSatelliteSystem(planetMesh, planet);
        }

        function createSatelliteSystem(planetMesh, planetData) {
            const satelliteCount = Math.min(planetData.satellites.length, 8);

            for (let i = 0; i < satelliteCount; i++) {
                const satelliteName = planetData.satellites[i];

                const satelliteOrbitRadius = 4 + i * 2;  // 增加卫星轨道间距
                const satelliteOrbitSpeed = 0.018 / (1 + i * 0.15); // 提高基础轨道速度，减少速度衰减
                const satelliteInitialAngle = (i / satelliteCount) * Math.PI * 2;

                const satelliteSize = 0.3 + Math.random() * 0.2;
                const satelliteGeometry = new THREE.SphereGeometry(satelliteSize, 16, 12);

                // 卫星也使用受光照影响的材质，并提高亮度
                const satelliteMaterial = new THREE.MeshPhongMaterial({
                    color: planetData.color,
                    emissive: new THREE.Color(planetData.color).multiplyScalar(0.3), // 从0.15提高到0.3
                    transparent: true,
                    opacity: 0.9, // 从0.85提高到0.9
                    shininess: 45 // 从30提高到45
                });

                const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);

                satellite.position.set(
                    Math.cos(satelliteInitialAngle) * satelliteOrbitRadius,
                    Math.sin(satelliteInitialAngle * 0.5) * 1,
                    Math.sin(satelliteInitialAngle) * satelliteOrbitRadius
                );

                // 为卫星创建更大的不可见碰撞体
                const satelliteClickGeometry = new THREE.SphereGeometry(satelliteSize * 3, 12, 8);
                const satelliteClickMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    visible: false
                });
                const satelliteClickMesh = new THREE.Mesh(satelliteClickGeometry, satelliteClickMaterial);
                satelliteClickMesh.position.copy(satellite.position);
                satelliteClickMesh.userData = {
                    type: 'satellite',
                    name: satelliteName,
                    course: planetMesh.userData.course,
                    planetIndex: planetMesh.userData.planetIndex,
                    satelliteIndex: i,
                    orbitRadius: satelliteOrbitRadius,
                    orbitSpeed: satelliteOrbitSpeed,
                    orbitAngle: satelliteInitialAngle,
                    animationOffset: Math.random() * Math.PI * 2,
                    baseColor: new THREE.Color(planetData.color),
                    parentPlanet: planetMesh,
                    realMesh: satellite
                };
                scene.add(satelliteClickMesh);
                papers.push(satelliteClickMesh);

                satellite.userData = {
                    type: 'satellite',
                    name: satelliteName,
                    course: planetMesh.userData.course,
                    planetIndex: planetMesh.userData.planetIndex,
                    satelliteIndex: i,
                    orbitRadius: satelliteOrbitRadius,
                    orbitSpeed: satelliteOrbitSpeed,
                    orbitAngle: satelliteInitialAngle,
                    animationOffset: Math.random() * Math.PI * 2,
                    baseColor: new THREE.Color(planetData.color),
                    parentPlanet: planetMesh,
                    clickMesh: satelliteClickMesh
                };

                if (Math.random() > 0.5) {
                    const glowGeometry = new THREE.SphereGeometry(satelliteSize * 2, 12, 8);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: planetData.color,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    satellite.add(glow);
                    satellite.userData.glow = glow;
                }

                scene.add(satellite);
                // 不要将satellite加入papers，因为已经加入了clickMesh
            }
        }

        function setupEventListeners() {
            const canvas = renderer.domElement;
            const container = document.getElementById('container');

            // 设置canvas可以获得焦点
            canvas.setAttribute('tabindex', '0');
            canvas.style.outline = 'none'; // 移除焦点时的轮廓

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);

            // 同时监听canvas和document的键盘事件
            canvas.addEventListener('keydown', onKeyDown);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 当点击canvas时，确保它获得焦点
            canvas.addEventListener('click', () => {
                canvas.focus();
            });

            // 焦点状态视觉反馈
            canvas.addEventListener('focus', () => {
                container.classList.add('focused');
            });

            canvas.addEventListener('blur', () => {
                container.classList.remove('focused');
            });

            // 页面加载时让canvas获得焦点
            setTimeout(() => {
                canvas.focus();
            }, 1000);

            window.addEventListener('resize', onWindowResize);

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            isMouseDown = true;
            isMousePressed = true;
            mouseMoveForward = true;
            mouseStart.set(event.clientX, event.clientY);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isMouseDown && flyMode && !lockMode) {
                const deltaX = event.clientX - mouseStart.x;
                const deltaY = event.clientY - mouseStart.y;
                const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (dragDistance > dragThreshold) {
                    mouseMoveForward = false;

                    cameraRotation.x -= deltaY * rotateSpeed;
                    cameraRotation.y -= deltaX * rotateSpeed;

                    cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));

                    mouseStart.set(event.clientX, event.clientY);
                    document.body.style.cursor = 'grabbing';
                }
            } else if (!isMouseDown) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(papers);

                if (intersects.length > 0) {
                    const celestialBody = intersects[0].object;
                    if (celestialBody &&
                        celestialBody.userData &&
                        typeof celestialBody.userData.course === 'number' &&
                        celestialBody.userData.name &&
                        celestialBody.userData.type) {
                        showTooltip(event, celestialBody.userData);
                        document.body.style.cursor = 'pointer';
                    } else {
                        hideTooltip();
                        document.body.style.cursor = 'crosshair';
                    }
                } else {
                    hideTooltip();
                    document.body.style.cursor = 'crosshair';
                }
            }
        }

        function onMouseUp(event) {
            isMouseDown = false;
            isMousePressed = false;
            mouseMoveForward = false;
            document.body.style.cursor = 'crosshair';

            const deltaX = event.clientX - mouseStart.x;
            const deltaY = event.clientY - mouseStart.y;
            const clickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (clickDistance < dragThreshold) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(papers);

                if (intersects.length > 0) {
                    const clickedBody = intersects[0].object;
                    if (clickedBody &&
                        clickedBody.userData &&
                        typeof clickedBody.userData.course === 'number' &&
                        clickedBody.userData.name &&
                        clickedBody.userData.type) {
                        handleCelestialBodyClick(clickedBody);
                    }
                }
            }
        }

        function onMouseWheel(event) {
            if (event.deltaY > 0) {
                flySpeed = Math.max(0.1, flySpeed * 0.9);
            } else {
                flySpeed = Math.min(3, flySpeed * 1.1);
            }
        }

        function onKeyDown(event) {
            keys[event.code] = true;

            if (event.code === 'Escape' && lockMode && lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }

            if (event.code === 'KeyR') {
                flip180Degrees();
            }

            if (event.code === 'KeyT') {
                rotateClockwise();
            }

            // 新增的精细旋转控制
            if (event.code === 'KeyJ') {
                rotateHorizontalLeft();
            }
            if (event.code === 'KeyL') {
                rotateHorizontalRight();
            }
            if (event.code === 'KeyI') {
                rotateVerticalUp();
            }
            if (event.code === 'KeyK') {
                rotateVerticalDown();
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function updateFlyControls() {
            if (!flyMode) return;

            if (lastLockMode && !lockMode) {
                const currentDirection = new THREE.Vector3();
                camera.getWorldDirection(currentDirection);
                cameraRotation.y = Math.atan2(currentDirection.x, currentDirection.z);
                cameraRotation.x = -Math.asin(currentDirection.y);
            }
            lastLockMode = lockMode;

            velocity.set(0, 0, 0);

            if (keys['KeyW'] || keys['ArrowUp']) velocity.z -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) velocity.z += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) velocity.x -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) velocity.x += 1;
            if (keys['KeyQ'] || keys['Space']) velocity.y += 1;
            if (keys['KeyE'] || keys['ShiftLeft']) velocity.y -= 1;

            if (mouseMoveForward && isMousePressed) {
                velocity.z -= 1.2;
            }

            if (lockMode && lockedConcept) {
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    lockAngle -= 0.02;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    lockAngle += 0.02;
                }
                if (keys['KeyW'] || keys['ArrowUp']) {
                    lockDistance = Math.max(5, lockDistance - 0.5);
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    lockDistance = Math.min(50, lockDistance + 0.5);
                }

                let heightOffset = 0;
                if (keys['KeyQ'] || keys['Space']) {
                    heightOffset = 0.5;
                }
                if (keys['KeyE'] || keys['ShiftLeft']) {
                    heightOffset = -0.5;
                }

                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += 5 + heightOffset;

                camera.position.lerp(targetPosition, 0.1);
                camera.lookAt(lockedConcept.position);

                updateSpeedTrail(0.1);
                return;
            }

            if (velocity.length() > 0) {
                velocity.normalize();

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                const right = new THREE.Vector3();
                right.crossVectors(camera.up, direction).normalize();

                const up = new THREE.Vector3(0, 1, 0);

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(direction, -velocity.z * flySpeed);
                moveVector.addScaledVector(right, velocity.x * flySpeed);
                moveVector.addScaledVector(up, velocity.y * flySpeed);

                camera.position.add(moveVector);

                updateSpeedTrail(moveVector.length());
            } else {
                updateSpeedTrail(0);
            }

            if (!lockMode) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraRotation.y;
                camera.rotation.x = cameraRotation.x;
            }
        }

        function updateSpeedTrail(speed) {
            if (speed > 0.1) {
                speedTrail.push({
                    position: camera.position.clone(),
                    speed: speed,
                    time: Date.now()
                });

                if (speedTrail.length > maxTrailLength) {
                    speedTrail.shift();
                }
            } else {
                speedTrail = speedTrail.filter(point => Date.now() - point.time < 1000);
            }
        }

        function animate() {
            // 如果页面不可见，降低渲染频率
            if (!isPageVisible) {
                setTimeout(() => requestAnimationFrame(animate), 100); // 每100ms渲染一次
                return;
            }

            requestAnimationFrame(animate);

            frameSkipCounter++;

            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            if (scene.userData.dynamicLight) {
                scene.userData.dynamicLight.position.copy(camera.position);
            }

            updateFlyControls();

            if (!animationPaused) {
                const time = Date.now() * 0.001;

                updateDeepSpaceEffects(time);
                updateStarLights(time); // 更新恒星动态光源

                if (frameSkipCounter % 8 === 0) { // 进一步减少星空更新间隔
                    stars.forEach(starField => {
                        starField.rotation.y += starField.userData.rotationSpeed * 0.8; // 大幅提高星空旋转速度
                    });

                    starTwinkles.forEach(twinkle => {
                        const twinkleAmount = 0.5 + 0.5 * Math.sin(time * twinkle.twinkleSpeed + twinkle.twinkleOffset);
                        const finalOpacity = twinkle.starField.userData.baseOpacity *
                            (0.3 + 0.7 * twinkleAmount * twinkle.intensity);
                        twinkle.starField.material.opacity = finalOpacity;
                    });
                }

                papers.forEach((celestialBody, index) => {
                    const distanceToCamera = camera.position.distanceTo(celestialBody.position);

                    // 获取真实网格进行动画更新
                    const realMesh = celestialBody.userData.realMesh || celestialBody;

                    // 所有天体都保持运动，不管距离远近
                    if (celestialBody.userData.type === 'star') {
                        updateStarAnimation(realMesh, time);  // 恒星动画始终更新
                    } else if (celestialBody.userData.type === 'planet') {
                        updatePlanetOrbit(celestialBody, time);  // 行星轨道始终更新
                    } else if (celestialBody.userData.type === 'satellite') {
                        updateSatelliteOrbit(celestialBody, time);  // 卫星轨道始终更新
                    }

                    // 基础自转动画始终进行
                    if (frameSkipCounter % animationUpdateFrequency === 0) {
                        realMesh.rotation.y += 0.0005;
                    }

                    // 根据距离决定是否显示和更新复杂效果
                    if (distanceToCamera < LOD_DISTANCE_FAR) {
                        celestialBody.visible = true;

                        // 近距离时才更新材质和光照效果
                        if (realMesh.material && realMesh.material.emissive) {
                            if (realMesh.userData.isLocked) {
                                const lockPulse = Math.sin(time * 1.0) * 0.2 + 0.8;
                                // 使用绿色锁定效果
                                const lockColor = new THREE.Color(0x00ff00);
                                realMesh.material.emissive.copy(lockColor).multiplyScalar(lockPulse);
                            } else {
                                // 正常的基础颜色动画，为行星和卫星提供更强的发光效果
                                const pulse = Math.sin(time * 1.5 + realMesh.userData.animationOffset) * 0.3 + 0.9;
                                let emissiveMultiplier = 0.3; // 默认倍数

                                // 根据天体类型调整发光强度
                                if (celestialBody.userData.type === 'planet') {
                                    emissiveMultiplier = 0.5; // 行星使用更强的发光
                                } else if (celestialBody.userData.type === 'satellite') {
                                    emissiveMultiplier = 0.4; // 卫星使用中等发光
                                }

                                realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(pulse * emissiveMultiplier);
                            }
                        }

                        updateCelestialBodyEffects(realMesh, time, frameSkipCounter);

                        if (realMesh.userData.isLocked) {
                            updateLockIndicators(celestialBody, time, frameSkipCounter);
                        }

                    } else if (distanceToCamera < LOD_DISTANCE_FAR * 2) {
                        // 中等距离：显示但减少特效更新
                        celestialBody.visible = true;

                        // 只保留基本的材质脉动
                        if (realMesh.material && realMesh.material.emissive && !realMesh.userData.isLocked) {
                            const pulse = Math.sin(time * 1.5 + realMesh.userData.animationOffset) * 0.3 + 0.9;
                            let emissiveMultiplier = 0.2; // 中等距离默认倍数

                            // 根据天体类型调整发光强度
                            if (celestialBody.userData.type === 'planet') {
                                emissiveMultiplier = 0.35; // 行星在中等距离也保持较高亮度
                            } else if (celestialBody.userData.type === 'satellite') {
                                emissiveMultiplier = 0.25; // 卫星中等亮度
                            }

                            realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(pulse * emissiveMultiplier);
                        } else if (realMesh.userData.isLocked) {
                            // 即使在中等距离也要显示锁定效果
                            const lockPulse = Math.sin(time * 1.0) * 0.2 + 0.8;
                            const lockColor = new THREE.Color(0x00ff00);
                            realMesh.material.emissive.copy(lockColor).multiplyScalar(lockPulse);
                        }
                    } else {
                        // 极远距离：显示但不更新特效
                        celestialBody.visible = true;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        function updateStarAnimation(star, time) {
            const courseIndex = star.userData.course;
            const effects = star.userData.specialEffects;

            // 根据不同课程的脉冲类型更新
            let pulse;
            switch(effects.pulseType) {
                case 'strong': // 数据结构 - 强力脉冲
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.3 + 0.7;
                    break;
                case 'rhythmic': // 算法设计 - 节拍脉冲
                    pulse = Math.abs(Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset)) * 0.4 + 0.6;
                    break;
                case 'wave': // 计算机网络 - 波浪脉冲
                    pulse = (Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) +
                             Math.sin(time * star.userData.pulseSpeed * 2 + star.userData.animationOffset)) * 0.15 + 0.7;
                    break;
                case 'stable': // 操作系统 - 稳定光芒
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.1 + 0.9;
                    break;
                case 'treasure': // 数据库系统 - 宝藏闪烁
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.2 + 0.8 +
                            Math.sin(time * star.userData.pulseSpeed * 3 + star.userData.animationOffset) * 0.1;
                    break;
                case 'shifting': // 软件工程 - 变换脉冲
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.2 + 0.8;
                    // 颜色变换 - 只在未锁定状态下进行
                    if (!star.userData.isLocked) {
                        const colorShift = Math.sin(time * 0.5 + star.userData.animationOffset) * 0.3 + 0.7;
                        star.material.color.copy(star.userData.baseColor).multiplyScalar(colorShift);
                    }
                    break;
                default:
                    pulse = Math.sin(time * star.userData.pulseSpeed + star.userData.animationOffset) * 0.1 + 0.9;
            }

            // 始终更新恒星本体的透明度脉冲
            if (star.material && star.material.opacity !== undefined) {
                // 只有在未锁定状态下才应用脉冲透明度
                if (!star.userData.isLocked) {
                    star.material.opacity = pulse;
                }
            }

            // 始终更新内层发光效果
            if (star.userData.innerGlow) {
                const glowPulse = Math.sin(time * star.userData.pulseSpeed * 1.5 + star.userData.animationOffset) * 0.2 + 0.6;
                star.userData.innerGlow.material.opacity = 0.4 * glowPulse;
                star.userData.innerGlow.rotation.y += 0.008;
            }

            // 始终更新特色效果（这很重要！）
            updateStarSpecialEffects(star, time, courseIndex);

            // 始终更新标准效果
            if (star.userData.corona) {
                star.userData.corona.rotation.y += 0.005;
                star.userData.corona.material.opacity = 0.15 * pulse;
            }

            if (star.userData.radiation) {
                star.userData.radiation.rotation.y -= 0.003;
                star.userData.radiation.rotation.x += 0.001;
                star.userData.radiation.material.opacity = 0.08 * pulse;
            }

            // 始终更新恒星光源强度
            if (star.userData.starLight) {
                const lightPulse = Math.sin(time * star.userData.pulseSpeed * 0.8 + star.userData.animationOffset) * 0.3 + 1.7;
                star.userData.starLight.intensity = lightPulse;
            }
        }

        // 更新恒星特色效果
        function updateStarSpecialEffects(star, time, courseIndex) {
            switch(courseIndex) {
                case 0: // 数据结构 - 能量环旋转
                    for (let i = 0; i < 3; i++) {
                        if (star.userData[`energyRing${i}`]) {
                            star.userData[`energyRing${i}`].rotation.z += 0.01 * (i + 1);
                            const ringPulse = Math.sin(time * 2 + i) * 0.1 + 0.3;
                            star.userData[`energyRing${i}`].material.opacity = ringPulse;
                        }
                    }
                    break;

                case 1: // 算法设计 - 螺旋旋转
                    if (star.userData.spiral) {
                        star.userData.spiral.rotation.y += 0.02;
                        star.userData.spiral.rotation.x += 0.01;
                    }
                    break;

                case 2: // 计算机网络 - 网络节点闪烁和数据包流动
                    // 网络节点脉动
                    for (let i = 0; i < 8; i++) {
                        if (star.userData[`networkNode${i}`]) {
                            const nodePulse = Math.sin(time * 3 + i * 0.5) * 0.3 + 0.7;
                            star.userData[`networkNode${i}`].material.opacity = nodePulse;
                            star.userData[`networkNode${i}`].scale.setScalar(0.8 + nodePulse * 0.4);
                        }
                    }

                    // 连接线闪烁
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('networkLine')) {
                            const linePulse = Math.sin(time * 2 + Math.random() * 3) * 0.2 + 0.3;
                            star.userData[key].material.opacity = linePulse;
                        }
                    });

                    // 数据包流动
                    for (let i = 0; i < 5; i++) {
                        if (star.userData[`dataPacket${i}`]) {
                            const packet = star.userData[`dataPacket${i}`];
                            const nodePositions = [
                                new THREE.Vector3(star.geometry.parameters.radius * 3, 0, 0),
                                new THREE.Vector3(-star.geometry.parameters.radius * 3, 0, 0),
                                new THREE.Vector3(0, star.geometry.parameters.radius * 3, 0),
                                new THREE.Vector3(0, -star.geometry.parameters.radius * 3, 0),
                                new THREE.Vector3(0, 0, star.geometry.parameters.radius * 3),
                                new THREE.Vector3(0, 0, -star.geometry.parameters.radius * 3),
                                new THREE.Vector3(star.geometry.parameters.radius * 2, star.geometry.parameters.radius * 2, 0),
                                new THREE.Vector3(-star.geometry.parameters.radius * 2, -star.geometry.parameters.radius * 2, 0)
                            ];

                            packet.userData.pathProgress += packet.userData.pathSpeed;
                            if (packet.userData.pathProgress >= 1) {
                                packet.userData.pathProgress = 0;
                                packet.userData.pathIndex = (packet.userData.pathIndex + 1) % nodePositions.length;
                            }

                            const currentNode = nodePositions[packet.userData.pathIndex];
                            const nextNode = nodePositions[(packet.userData.pathIndex + 1) % nodePositions.length];
                            packet.position.lerpVectors(currentNode, nextNode, packet.userData.pathProgress);
                        }
                    }
                    break;

                case 3: // 操作系统 - 护盾脉动
                    if (star.userData.shield) {
                        star.userData.shield.rotation.x += 0.005;
                        star.userData.shield.rotation.y += 0.008;
                        const shieldPulse = Math.sin(time * 1.5) * 0.05 + 0.15;
                        star.userData.shield.material.opacity = shieldPulse;
                    }
                    break;

                case 4: // 数据库系统 - 数据矩阵闪烁
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('matrixCube')) {
                            const cube = star.userData[key];
                            const flashTime = time + cube.userData.flashDelay;
                            const flashPulse = Math.sin(flashTime * 2) * 0.3 + 0.7;
                            cube.material.opacity = cube.userData.baseOpacity * flashPulse;
                            cube.rotation.x += cube.userData.rotationSpeed;
                            cube.rotation.y += cube.userData.rotationSpeed * 0.7;

                            // 随机亮度突变（数据访问效果）
                            if (Math.random() < 0.002) {
                                cube.material.opacity = 1.0;
                                setTimeout(() => {
                                    if (cube.material) cube.material.opacity = cube.userData.baseOpacity;
                                }, 100);
                            }
                        }

                        if (key.startsWith('dataConnection')) {
                            const connectionPulse = Math.sin(time * 1.5 + Math.random() * 2) * 0.1 + 0.2;
                            star.userData[key].material.opacity = connectionPulse;
                        }
                    });
                    break;

                case 5: // 软件工程 - 脉冲星效果
                    Object.keys(star.userData).forEach(key => {
                        if (key.startsWith('pulseRing')) {
                            const ring = star.userData[key];
                            ring.rotation.z += 0.005 * (ring.userData.ringIndex + 1);
                            const ringPulse = Math.sin(time * 2 + ring.userData.pulseOffset) * 0.2 + 0.6;
                            ring.material.opacity = ringPulse;
                        }

                        if (key.startsWith('magneticField')) {
                            const field = star.userData[key];
                            field.rotation.y += field.userData.rotationSpeed;
                        }
                    });
                    break;
            }
        }

        function updatePlanetOrbit(planet, time) {
            // 行星绕着恒星旋转 - 提高轨道速度使旋转更明显
            planet.userData.orbitAngle += planet.userData.orbitSpeed * 0.3; // 从15%提高到30%

            // 确保行星围绕恒星中心旋转
            const starCenter = planet.userData.orbitCenter; // 恒星的位置
            const x = starCenter.x + Math.cos(planet.userData.orbitAngle) * planet.userData.orbitRadius;
            const y = starCenter.y + Math.sin(planet.userData.orbitAngle * 0.3) * 3; // 轻微的垂直波动
            const z = starCenter.z + Math.sin(planet.userData.orbitAngle) * planet.userData.orbitRadius;

            planet.position.set(x, y, z);

            // 如果这是碰撞体，也要更新真实网格的位置
            if (planet.userData.realMesh) {
                planet.userData.realMesh.position.set(x, y, z);
            }
            // 如果这是真实网格，也要更新碰撞体的位置
            if (planet.userData.clickMesh) {
                planet.userData.clickMesh.position.set(x, y, z);
            }
        }

        function updateSatelliteOrbit(satellite, time) {
            // 卫星绕着行星旋转 - 提高轨道速度使旋转更明显
            satellite.userData.orbitAngle += satellite.userData.orbitSpeed * 0.4; // 从25%提高到40%

            // 确保卫星围绕行星的实时位置旋转
            const planetPos = satellite.userData.parentPlanet.position; // 获取行星的当前位置

            const x = planetPos.x + Math.cos(satellite.userData.orbitAngle) * satellite.userData.orbitRadius;
            const y = planetPos.y + Math.sin(satellite.userData.orbitAngle * 0.5) * 1;
            const z = planetPos.z + Math.sin(satellite.userData.orbitAngle) * satellite.userData.orbitRadius;

            satellite.position.set(x, y, z);

            // 如果这是碰撞体，也要更新真实网格的位置
            if (satellite.userData.realMesh) {
                satellite.userData.realMesh.position.set(x, y, z);
            }
            // 如果这是真实网格，也要更新碰撞体的位置
            if (satellite.userData.clickMesh) {
                satellite.userData.clickMesh.position.set(x, y, z);
            }

            if (satellite.userData.glow) {
                satellite.userData.glow.rotation.y += 0.005; // 提高发光效果旋转速度
                const glowPulse = Math.sin(time * 3 + satellite.userData.animationOffset) * 0.08 + 0.15;
                satellite.userData.glow.material.opacity = glowPulse;
            }
        }

        function updateCelestialBodyEffects(body, time, frameSkipCounter) {
            if (body.userData.starglow && frameSkipCounter % 3 === 0) {
                const starglowPulse = Math.sin(time * 2 + body.userData.starglowOffset) * 0.03 + 0.05;
                body.userData.starglow.material.opacity = starglowPulse;
                body.userData.starglow.rotation.y += 0.003; // 进一步提高旋转
            }

            if (body.userData.glow && frameSkipCounter % 4 === 0) {
                body.userData.glow.rotation.y += 0.003; // 进一步提高旋转
                const glowPulse = Math.sin(time * 2 + body.userData.animationOffset) * 0.08 + 0.2;
                body.userData.glow.material.opacity = glowPulse;
            }

            // 更新行星发光效果
            if (body.userData.planetGlow && frameSkipCounter % 2 === 0) {
                body.userData.planetGlow.rotation.y += 0.004; // 行星发光效果旋转
                body.userData.planetGlow.rotation.x += 0.002;
                const planetGlowPulse = Math.sin(time * 1.5 + body.userData.animationOffset) * 0.1 + 0.3;
                body.userData.planetGlow.material.opacity = planetGlowPulse;
            }
        }

        function updateLockIndicators(body, time, frameSkipCounter) {
            if (body.userData.lockRing) {
                body.userData.lockRing.position.copy(body.position);
                body.userData.lockRing.lookAt(camera.position);
                body.userData.lockRing.rotation.z += 0.008; // 大幅提高旋转速度

                const ringPulse = Math.sin(time * 1.5) * 0.15 + 0.75;
                body.userData.lockRing.material.opacity = ringPulse;
            }

            if (body.userData.lockGlow) {
                body.userData.lockGlow.position.copy(body.position);
                body.userData.lockGlow.rotation.y += 0.002; // 大幅提高旋转速度

                const glowPulse = Math.sin(time * 1.2) * 0.02 + 0.12;
                body.userData.lockGlow.material.opacity = glowPulse;

                const scale = 1 + Math.sin(time * 0.8) * 0.05;
                body.userData.lockGlow.scale.setScalar(scale);
            }
        }

        function handleCelestialBodyClick(celestialBody) {
            // 如果点击的是碰撞体，获取真实的网格对象
            const realMesh = celestialBody.userData.realMesh || celestialBody;
            const clickMesh = celestialBody.userData.realMesh ? celestialBody : celestialBody.userData.clickMesh;

            showDetailModal(celestialBody);

            if (lockedConcept !== clickMesh) {
                if (lockedConcept) {
                    unlockConcept(lockedConcept);
                }

                lockConcept(clickMesh);
                flyToConcept(clickMesh);
            }
        }

        function showDetailModal(celestialBody) {
            if (!celestialBody ||
                !celestialBody.userData ||
                typeof celestialBody.userData.course !== 'number' ||
                !celestialBody.userData.name ||
                !celestialBody.userData.type) {
                console.warn('Invalid celestial body data');
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'celestialModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                animation: fadeIn 0.3s ease;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
                border: 1px solid rgba(0, 245, 255, 0.3);
                border-radius: var(--border-radius-lg);
                padding: 30px;
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: var(--shadow-md);
                position: relative;
            `;

            const course = csCourses[celestialBody.userData.course];
            if (!course) {
                console.warn('Course not found for index:', celestialBody.userData.course);
                return;
            }

            let content = '';

            if (celestialBody.userData.type === 'star') {
                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">⭐</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name} 星系</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">星系类型:</strong> 知识恒星系统</p>
                        <p><strong style="color: #ff00ff;">领域:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">行星数量:</strong> ${course.planets ? course.planets.length : 0} 颗</p>
                        <p><strong style="color: #ff6b6b;">主要分支:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            ${course.planets ? course.planets.map(planet => `<li style="margin: 5px 0;">${planet.name}</li>`).join('') : ''}
                        </ul>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            这是${course.name}知识领域的中心恒星，周围环绕着各个专业分支行星，每颗行星又有自己的知识卫星群。
                        </p>
                    </div>
                `;
            } else if (celestialBody.userData.type === 'planet') {
                const satellites = celestialBody.userData.satellites || [];
                const planetIndex = typeof celestialBody.userData.planetIndex === 'number' ? celestialBody.userData.planetIndex : 0;

                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">🪐</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name}</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">天体类型:</strong> 知识行星</p>
                        <p><strong style="color: #ff00ff;">所属星系:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">轨道位置:</strong> 第 ${planetIndex + 1} 轨道</p>
                        <p><strong style="color: #ff6b6b;">卫星数量:</strong> ${satellites.length} 颗</p>
                        <p><strong style="color: #45b7d1;">知识卫星:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            ${satellites.map(satellite => `<li style="margin: 5px 0;">${satellite}</li>`).join('')}
                        </ul>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            这颗行星代表${course.name}领域中的${celestialBody.userData.name}分支，包含了该领域的核心概念和技术。
                        </p>
                    </div>
                `;
            } else if (celestialBody.userData.type === 'satellite') {
                const parentPlanet = celestialBody.userData.parentPlanet;
                const parentPlanetName = (parentPlanet && parentPlanet.userData && parentPlanet.userData.name)
                    ? parentPlanet.userData.name : '未知行星';
                const satelliteIndex = typeof celestialBody.userData.satelliteIndex === 'number' ? celestialBody.userData.satelliteIndex : 0;

                content = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">🌙</div>
                        <h2 style="color: #00f5ff; margin: 0; font-size: 24px;">${celestialBody.userData.name}</h2>
                    </div>
                    <div style="color: var(--text-inverse); line-height: 1.6;">
                        <p><strong style="color: #00ff88;">天体类型:</strong> 知识卫星</p>
                        <p><strong style="color: #ff00ff;">所属星系:</strong> ${course.name}</p>
                        <p><strong style="color: #ffeaa7;">母行星:</strong> ${parentPlanetName}</p>
                        <p><strong style="color: #45b7d1;">卫星轨道:</strong> 第 ${satelliteIndex + 1} 轨道</p>
                        <p style="margin-top: 20px; font-style: italic; opacity: 0.8;">
                            这颗卫星代表${parentPlanetName}领域中的具体知识点"${celestialBody.userData.name}"，
                            是学习该领域时需要掌握的重要概念。
                        </p>
                        <div style="margin-top: 20px; padding: 15px; background: rgba(0, 245, 255, 0.1); border-radius: var(--border-radius); border-left: 3px solid #00f5ff;">
                            <p style="margin: 0; font-size: 14px;"><strong>学习建议:</strong></p>
                            <p style="margin: 10px 0 0 0; font-size: 14px;">
                                建议先掌握${parentPlanetName}的基础概念，
                                再深入学习${celestialBody.userData.name}的具体实现和应用。
                            </p>
                        </div>
                    </div>
                `;
            }

            modalContent.innerHTML = content + `
                <button id="closeModal" style="
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    background: none;
                    border: none;
                    color: #ff6b6b;
                    font-size: 24px;
                    cursor: pointer;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 50%;
                    transition: all 0.3s ease;
                " onmouseover="this.style.background='rgba(255, 107, 107, 0.2)'"
                   onmouseout="this.style.background='none'">×</button>

                <div style="margin-top: 30px; text-align: center; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="closeDetailModal()" style="
                        background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
                        border: 1px solid rgba(0, 245, 255, 0.5);
                        color: #00f5ff;
                        padding: 12px 24px;
                        border-radius: var(--border-radius-sm);
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(0, 245, 255, 0.3)'"
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        继续探索
                    </button>
                    <button onclick="learnMore('${celestialBody.userData.name}', '${celestialBody.userData.type}', ${celestialBody.userData.course})" style="
                        background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
                        border: 1px solid rgba(255, 193, 7, 0.5);
                        color: #ffc107;
                        padding: 12px 24px;
                        border-radius: var(--border-radius-sm);
                        cursor: pointer;
                        font-size: 14px;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(255, 193, 7, 0.3)'"
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        📚 了解详情
                    </button>
                </div>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            document.getElementById('closeModal').onclick = closeDetailModal;
            modal.onclick = (e) => {
                if (e.target === modal) closeDetailModal();
            };

            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: scale(0.9); }
                    to { opacity: 1; transform: scale(1); }
                }
            `;
            document.head.appendChild(style);
        }

        function closeDetailModal() {
            const modal = document.getElementById('celestialModal');
            if (modal) {
                modal.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            }
        }

        function learnMore(name, type, courseIndex) {
            // 关闭当前弹窗
            closeDetailModal();

            // 根据天体类型和名称跳转到对应页面
            let targetUrl = '';

            if (type === 'star') {
                // 恒星 - 跳转到大分类页面
                const categoryUrls = {
                    '数据结构': '/category/data-structures/',
                    '算法设计': '/category/algorithm-design/',
                    '计算机网络': '/category/computer-networks/',
                    '操作系统': '/category/operating-systems/',
                    '数据库系统': '/category/database-systems/',
                    '软件工程': '/category/software-engineering/'
                };
                targetUrl = categoryUrls[name];
            } else if (type === 'planet') {
                // 行星 - 跳转到子分类页面
                const planetUrls = {
                    '链表': '/planet/linked-list/',
                    '栈': '/planet/stack/',
                    '队列': '/planet/queue/',
                    '矩阵': '/planet/matrix/',
                    '树与二叉树': '/planet/tree-binary-tree/',
                    '图': '/planet/graph/',
                    '查找': '/planet/search/',
                    '排序': '/planet/sorting/',
                    '分治算法': '/planet/divide-conquer/',
                    '动态规划': '/planet/dynamic-programming/',
                    '贪心算法': '/planet/greedy-algorithm/',
                    '回溯算法': '/planet/backtracking/',
                    '图论算法': '/planet/graph-algorithms/',
                    '字符串算法': '/planet/string-algorithms/',
                    '数值算法': '/planet/numerical-algorithms/',
                    '物理层': '/planet/physical-layer/',
                    '数据链路层': '/planet/data-link-layer/',
                    '网络层': '/planet/network-layer/',
                    '传输层': '/planet/transport-layer/',
                    '应用层': '/planet/application-layer/',
                    '网络安全': '/planet/network-security/',
                    '进程管理': '/planet/process-management/',
                    '线程管理': '/planet/thread-management/',
                    '内存管理': '/planet/memory-management/',
                    '文件系统': '/planet/file-system/',
                    '设备管理': '/planet/device-management/',
                    '系统调用': '/planet/system-calls/',
                    '关系模型': '/planet/relational-model/',
                    'SQL语言': '/planet/sql-language/',
                    '事务管理': '/planet/transaction-management/',
                    '索引技术': '/planet/indexing/',
                    '查询处理': '/planet/query-processing/',
                    '分布式数据库': '/planet/distributed-database/',
                    '需求工程': '/planet/requirements-engineering/',
                    '系统设计': '/planet/system-design/',
                    '软件测试': '/planet/software-testing/',
                    '项目管理': '/planet/project-management/',
                    '版本控制': '/planet/version-control/',
                    '设计模式': '/planet/design-patterns/'
                };
                targetUrl = planetUrls[name];
            } else if (type === 'satellite') {
                // 卫星 - 跳转到具体知识点页面
                // 使用现有的slug生成逻辑
                const implementedMapping = {
                    '单链表': '/learn/single-linklist/',
                    '图的遍历——DFS': '/learn/graph_dfs/',
                    '差错控制——检错码': '/learn/crc-check/',
                    '差错控制——纠错编码': '/learn/hamming-code/'
                };

                if (implementedMapping[name]) {
                    targetUrl = implementedMapping[name];
                } else {
                    // 生成通用的知识点页面URL
                    const slug = generateSlugFromName(name);
                    targetUrl = `/learn/${slug}/`;
                }
            }

            if (targetUrl) {
                console.log(`跳转到: ${name} (${type}) -> ${targetUrl}`);
                window.location.href = targetUrl;
            } else {
                // 如果没有找到对应的URL，显示提示信息
                alert(`${name} 的详细学习资源正在开发中，敬请期待！\n\n这里将提供：\n• 详细的概念解释\n• 互动式示例演示\n• 相关练习题目\n• 实际应用案例`);
            }
        }

        function generateSlugFromName(name) {
            // 完整的slug映射表，与Python后端完全一致
            const completeSlugMapping = {
                '单链表': 'single-linklist',
                '双链表': 'double-linked-list',
                '循环链表': 'circular-linked-list',
                '静态链表': 'static-linked-list',
                '顺序栈': 'sequential-stack',
                '链式栈': 'linked-stack',
                '栈——括号匹配': 'topic-9477183b',
                '栈——表达式求值': 'topic-84049d5b',
                '栈——卡特兰数': 'topic-55106f00',
                '栈——函数调用': 'topic-43c1d7f8',
                '栈——递归': 'topic-b6197b56',
                '顺序队列': 'sequential-queue',
                '循环队列': 'circular-queue',
                '链队列': 'linked-queue',
                '双端队列': 'deque',
                '队列——缓冲区': 'topic-0d962147',
                '广度优先搜索': 'breadth-first-search',
                '对称矩阵': 'symmetric-matrix',
                '三角矩阵': 'triangular-matrix',
                '稀疏矩阵——三元组表示法': 'topic-808e0a45',
                '稀疏矩阵——十字链表法': 'topic-b23a9ad8',
                '广义表': 'generalized-list',
                'KMP模式匹配': 'kmp-dada3d14',
                '树与二叉树的性质': 'tree-binary-tree-properties',
                'BST': 'bst-ae8200cb',
                'AVL': 'avl-0e3587fa',
                '二叉树——顺序存储': 'topic-98921b61',
                '二叉树——链式存储': 'topic-96d8bc0a',
                '二叉树——四序遍历': 'topic-677d774b',
                '线索二叉树': 'threaded-binary-tree',
                '树、森林与二叉树的转换': 'topic-5755c011',
                '树和森林的遍历': 'tree-forest-traversal',
                '哈夫曼树': 'huffman-tree',
                '并查集': 'union-find',
                '图的存储结构': 'graph-storage-structure',
                '图的遍历——DFS': 'graph_dfs',
                '图的遍历——BFS': 'bfs-0b162441',
                '最小生成树——Prim算法': 'prim-c560c2ed',
                '最小生成树——Kruskal算法': 'kruskal-400979d2',
                '最短路径——Dijkstra算法': 'dijkstra-4f1a04fe',
                '最短路径——Floyd': 'floyd-9498fc4f',
                '最短路径——A*': 'topic-54ef0780',
                '关键路径': 'critical-path',
                '二分查找': 'binary-search',
                '分块查找': 'block-search',
                '红黑树': 'red-black-tree',
                'B树': 'topic-bc4a04d3',
                'B+树': 'topic-19dd3d1e',
                'hash表': 'hash-d2be4a35',
                '八大排序': 'eight-sorting-algorithms',
                '外部排序': 'external-sorting',
                '二分搜索': 'topic-31d15901',
                '归并排序': 'topic-95566613',
                '快速排序': 'topic-5ee213ee',
                '最大子数组': 'topic-e22ba13f',
                '背包问题': 'topic-d39a003f',
                '最长公共子序列': 'topic-9032049e',
                '最长递增子序列': 'topic-9a1f60ae',
                '编辑距离': 'topic-5192e297',
                '状态转移': 'topic-06e65263',
                '活动选择': 'topic-7dbfb5c7',
                '背包贪心': 'topic-2bb8cbe2',
                '哈夫曼编码': 'topic-49959872',
                '最小生成树': 'minimum-spanning-tree',
                'N皇后问题': 'topic-bde78f30',
                '数独求解': 'topic-3a15946a',
                '子集生成': 'topic-afbc23bb',
                '排列组合': 'topic-c177570e',
                '深度优先搜索': 'topic-75d2ecdf',
                'Dijkstra算法': 'dijkstra-fcff225e',
                'Floyd算法': 'floyd-55aee254',
                'Kruskal算法': 'kruskal-469314f5',
                'Prim算法': 'prim-c2c37590',
                'Rabin-Karp算法': 'rabinkarp-8e2b5d4b',
                '后缀数组': 'topic-4d20081f',
                'AC自动机': 'ac-34fba25a',
                '快速幂': 'topic-35888d4c',
                '欧几里得算法': 'topic-fb38c805',
                '扩展欧几里得': 'topic-c2106cde',
                '素数筛选': 'topic-c5253730',
                '数据通信的基础知识': 'topic-49436551',
                '传输介质': 'topic-792728c9',
                '信道复用': 'topic-22a05c42',
                '物理层设备': 'topic-fe62a26c',
                '组帧': 'topic-64dbbedd',
                '差错控制——检错码': 'crc-check',
                '差错控制——纠错编码': 'hamming-code',
                '流量控制': 'topic-e73722b3',
                '可靠传输机制': 'topic-90b4d246',
                '滑动窗口机制': 'topic-21aaa736',
                '停等协议': 'topic-189bc34f',
                'GBN协议': 'gbn-6c028dfe',
                'SR协议': 'sr-1f7f6cf6',
                'ppp协议': 'ppp-c146f0f8',
                'MAC子层': 'mac-97eab93f',
                'CSMA/CD协议': 'csmacd-ce8073ee',
                'CSMA/CA协议': 'csmaca-9f95262d',
                '网桥': 'topic-a65126a7',
                '生成树协议': 'topic-490e474b',
                '以太网交换机': 'topic-66688d44',
                'WLAN': 'wlan-8e76902b',
                '令牌环网': 'topic-c554d64f',
                '自适应树': 'topic-ec668b50',
                'ALOHA': 'aloha-419b6322',
                '位图协议': 'topic-e6ae9603',
                '二进制倒计数': 'topic-324bf6b3',
                'VLAN': 'vlan-9881f82f',
                '经典以太网': 'topic-d9d14c56',
                '虚电路和数据包服务': 'topic-781e9c6b',
                '路由与转发': 'topic-4c764b65',
                '拥塞控制': 'topic-cd31ab3a',
                'DV路由算法': 'dv-b86c1681',
                '链路状态路由算法': 'topic-763671ff',
                '层次路由': 'topic-cd6d1eb4',
                'IPv4——分组': 'ipv4-9fc15f27',
                'IPv4——地址': 'ipv4-9759f481',
                'IPv4——NAT': 'ipv4nat-dc739220',
                'IPv4——子网划分与子网掩码': 'ipv4-4b24f7e0',
                'CIDR': 'cidr-fb34bfeb',
                'ARP': 'arp-e18712a7',
                'DHCP': 'dhcp-54201c55',
                'ICMP': 'icmp-7d6fe0dd',
                'IP数据包的格式': 'ip-3f2f6f56',
                'RIP': 'rip-a195b7c9',
                'OSPF': 'ospf-0ad08eb2',
                'BGP': 'bgp-fb5acc03',
                'IPv6': 'ipv6-fdb7cb8f',
                'IP组播': 'ip-3f23f4d5',
                '移动IP': 'ip-d2473636',
                'VPN': 'vpn-eaef8590',
                'UDP数据包': 'udp-3d6af637',
                'UDP校验': 'udp-c2537e3e',
                'TCP报文段': 'tcp-ea2e5009',
                'TCP的流量控制': 'tcp-29a0cd26',
                'TCP的可靠传输': 'tcp-3b941421',
                'TCP拥塞控制': 'tcp-fa8383dd',
                'TCP连接的建立和释放': 'tcp-5d664357',
                '套接字': 'topic-e4499afd',
                'DNS': 'dns-ed5f2bde',
                'FTP': 'ftp-c728a493',
                'TELNET': 'telnet-1360d178',
                'WWW': 'www-793b899a',
                'HTTP': 'http-293c9ea2',
                'MIME': 'mime-1903a344',
                'SMTP': 'smtp-c2239a92',
                'POP3': 'pop3-0e82c505',
                'SNMP': 'snmp-305af652',
                '计算机网络面临的安全性威胁': 'topic-616f79f7',
                '安全的计算机网络': 'topic-c33a1c3b',
                '对称密钥密码': 'topic-70fbbcaa',
                'DES': 'des-80ac4ad5',
                'AES': 'aes-76b75934',
                '公钥密码体制': 'topic-1d189374',
                'RSA': 'rsa-445d0434',
                '数字签名': 'topic-95da6a4c',
                'MD5': 'md5-7f138a09',
                'SHA-1': 'sha1-c7df38de',
                '密钥分配': 'topic-2dd4c7e3',
                '进程创建': 'topic-f2cc1fcd',
                '进程调度': 'topic-8dd1b7f3',
                '进程同步': 'topic-c120f910',
                '进程通信': 'topic-24da6400',
                '死锁处理': 'topic-01dda544',
                '线程创建': 'topic-d6065366',
                '线程同步': 'topic-283a81a9',
                '线程池': 'topic-46dc5c2e',
                '多线程编程': 'topic-4e8c9a97',
                '内存分配': 'topic-c2083682',
                '虚拟内存': 'topic-84429675',
                '分页机制': 'topic-36ecd165',
                '分段机制': 'topic-f8896228',
                '页面置换': 'topic-495eff4a',
                'TLB管理': 'tlb-a34d1b95',
                '文件分配': 'topic-29c6be28',
                '目录结构': 'topic-c222403a',
                '磁盘调度': 'topic-a56767df',
                'RAID技术': 'raid-fee9a073',
                '文件权限': 'topic-bc417e55',
                '日志文件': 'topic-59eb0644',
                'I/O管理': 'io-30e1a2bd',
                '中断处理': 'topic-f07a04b5',
                'DMA技术': 'dma-3e09abe4',
                '设备驱动': 'topic-37bd6ae6',
                '缓冲技术': 'topic-0e4724fb',
                '系统调用接口': 'topic-a0a850a1',
                '内核态': 'topic-fb5911da',
                '用户态': 'topic-5627064b',
                '权限管理': 'topic-23bbdd59',
                '系统服务': 'topic-46a614a2',
                '关系代数': 'topic-4c64eb6a',
                '元组演算': 'topic-5370732c',
                'ER模型': 'er-c2193d80',
                '关系规范化': 'topic-ba5a2c6f',
                '函数依赖': 'topic-2ab55c60',
                'DDL语句': 'ddl-80b7485e',
                'DML语句': 'dml-310f52ad',
                'DCL语句': 'dcl-d5faebc7',
                '查询优化': 'topic-5eb083bd',
                '视图操作': 'topic-089de5bf',
                'ACID性质': 'acid-1e40c1c9',
                '并发控制': 'topic-5a9d7500',
                '锁机制': 'topic-c812c111',
                '恢复技术': 'topic-3aa3b470',
                'B+树索引': 'topic-8f5369f8',
                '哈希索引': 'topic-a0b6a51c',
                '位图索引': 'topic-77f4592f',
                '全文索引': 'topic-be13841f',
                '索引优化': 'topic-d3f457a3',
                '执行计划': 'topic-355c882c',
                '连接算法': 'topic-3ae45546',
                '选择算法': 'topic-1ae77997',
                '统计信息': 'topic-f56ae67a',
                '数据分片': 'topic-92d7276f',
                '分布式事务': 'topic-a19fed56',
                '一致性协议': 'topic-86a15c3e',
                'CAP理论': 'cap-832c15eb',
                'NoSQL数据库': 'nosql-8d04f5ec',
                '需求分析': 'topic-195af93f',
                '需求建模': 'topic-a983d6c6',
                '用例分析': 'topic-849334c6',
                '需求验证': 'topic-319436cf',
                '需求管理': 'topic-a6675782',
                '架构设计': 'topic-9890f816',
                '详细设计': 'topic-9ef96c66',
                '接口设计': 'topic-0bd4753c',
                '数据库设计': 'topic-31ac2cd2',
                '用户界面设计': 'topic-1c4fb742',
                '单元测试': 'topic-93b824b5',
                '集成测试': 'topic-9691fa05',
                '系统测试': 'topic-3476a036',
                '验收测试': 'topic-4882dac1',
                '性能测试': 'topic-ddd22119',
                '安全测试': 'topic-aabf5035',
                '敏捷开发': 'topic-889270ca',
                'Scrum方法': 'scrum-85032ed8',
                '看板方法': 'topic-39fd11df',
                '风险管理': 'topic-e4d60b5b',
                '质量管理': 'topic-054f5e77',
                'Git管理': 'git-51617d4b',
                '分支策略': 'topic-40eb5270',
                '合并冲突': 'topic-dfbabb98',
                '代码审查': 'topic-89d9f581',
                '持续集成': 'topic-ba50ec6f',
                '创建型模式': 'topic-d7b229c4',
                '结构型模式': 'topic-f203704d',
                '行为型模式': 'topic-0df886f3',
                '架构模式': 'topic-3b64cdeb',
                '设计原则': 'topic-7cc9f6e9'
            };

            // 直接从映射表中查找
            if (completeSlugMapping[name]) {
                return completeSlugMapping[name];
            }

            // 如果映射表中没有找到，返回一个默认值
            console.warn('未找到知识点的slug映射:', name);
            return 'topic-unknown';
        }

        function updateDeepSpaceEffects(time) {
            nebulaClouds.forEach((nebula, index) => {
                nebula.rotation.x += nebula.userData.rotationSpeed * 0.8; // 大幅提高星云旋转
                nebula.rotation.y += nebula.userData.rotationSpeed * 0.8 * 0.7;
                nebula.rotation.z += nebula.userData.rotationSpeed * 0.8 * 0.3;

                const pulse = Math.sin(time * nebula.userData.pulseSpeed) * 0.05 + 0.95;
                nebula.material.opacity = nebula.userData.baseOpacity * pulse;
            });

            // 更新远景星系
            distantGalaxies.forEach((galaxy) => {
                // 缓慢旋转
                galaxy.rotation.y += galaxy.userData.rotationSpeed;

                // 轻微的脉动效果
                const pulse = Math.sin(time * galaxy.userData.pulseSpeed) * 0.1 + 0.9;
                galaxy.children.forEach(child => {
                    if (child.material && child.material.opacity !== undefined) {
                        child.material.opacity = galaxy.userData.baseOpacity * pulse;
                    }
                });

                // 根据星系类型添加特殊效果
                if (galaxy.userData.type === 'spiral') {
                    // 螺旋星系额外的螺旋臂旋转
                    galaxy.rotation.z += galaxy.userData.rotationSpeed * 0.5;
                } else if (galaxy.userData.type === 'irregular') {
                    // 不规则星系的轻微摆动
                    galaxy.rotation.x += Math.sin(time * 0.1 + galaxy.userData.index) * 0.0001;
                    galaxy.rotation.z += Math.cos(time * 0.1 + galaxy.userData.index) * 0.0001;
                }
            });

            cosmicDust.forEach(dust => {
                dust.rotation.y += dust.userData.rotationSpeed * 0.8; // 大幅提高尘埃旋转
                dust.rotation.x += dust.userData.rotationSpeed * 0.8 * 0.5;

                dust.position.x += Math.sin(time * 0.1) * dust.userData.driftSpeed * 1.2; // 大幅提高漂移
                dust.position.z += Math.cos(time * 0.1) * dust.userData.driftSpeed * 1.2;
            });

            meteors.forEach((meteor, index) => {
                if (!meteor.active) {
                    if (Date.now() > meteor.nextSpawn) {
                        spawnMeteor(meteor);
                    }
                } else {
                    meteor.position.add(meteor.velocity);

                    if (meteor.mesh) {
                        meteor.mesh.position.copy(meteor.position);

                        if (meteor.position.length() > 400) {
                            scene.remove(meteor.mesh);
                            meteor.mesh = null;
                            meteor.active = false;
                            meteor.nextSpawn = Date.now() + Math.random() * 15000 + 10000;
                        }
                    }
                }
            });
        }

        function spawnMeteor(meteorData) {
            const distance = 300 + Math.random() * 100;
            const angle1 = Math.random() * Math.PI * 2;
            const angle2 = Math.random() * Math.PI * 0.5 + Math.PI * 0.25;

            meteorData.position.set(
                Math.sin(angle2) * Math.cos(angle1) * distance,
                Math.cos(angle2) * distance,
                Math.sin(angle2) * Math.sin(angle1) * distance
            );

            const targetDirection = new THREE.Vector3()
                .subVectors(camera.position, meteorData.position)
                .normalize()
                .multiplyScalar(2 + Math.random() * 3);

            meteorData.velocity.copy(targetDirection);
            meteorData.active = true;

            const meteorGeometry = new THREE.SphereGeometry(0.3, 6, 4);
            const meteorMaterial = new THREE.MeshBasicMaterial({
                color: 0xffddaa,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            meteorData.mesh = new THREE.Mesh(meteorGeometry, meteorMaterial);
            meteorData.mesh.position.copy(meteorData.position);
            scene.add(meteorData.mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetView() {
            if (lockMode && lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }

            camera.position.set(0, 0, 150);
            cameraRotation.set(0, 0);
            camera.rotation.set(0, 0, 0);
            flySpeed = 0.5;
            lockAngle = 0;
            lockDistance = 15;
        }

        function toggleAnimation() {
            animationPaused = !animationPaused;
        }

        function animateCameraToTarget(targetPosition, lookAtPosition, isLockMode = false) {
            const startPosition = camera.position.clone();
            const startRotation = cameraRotation.clone();

            const direction = new THREE.Vector3().subVectors(lookAtPosition, targetPosition).normalize();
            const targetRotationY = Math.atan2(direction.x, direction.z);
            const targetRotationX = -Math.asin(direction.y);

            const duration = 2000;
            const startTime = Date.now();

            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                camera.position.lerpVectors(startPosition, targetPosition, eased);

                if (isLockMode) {
                    camera.lookAt(lookAtPosition);
                } else {
                    cameraRotation.x = THREE.MathUtils.lerp(startRotation.x, targetRotationX, eased);
                    cameraRotation.y = THREE.MathUtils.lerp(startRotation.y, targetRotationY, eased);

                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            updateCamera();
        }

        function updateClusterStats() {
            console.log('📊 开始更新集群统计...');
            console.log('papers数组长度:', papers.length);

            // 调试：显示papers数组中每个对象的课程信息
            if (papers.length > 0) {
                const debugInfo = papers.slice(0, 5).map(p => ({
                    type: p.userData.type,
                    course: p.userData.course,
                    name: p.userData.name
                }));
                console.log('前5个papers对象:', debugInfo);
            }

            const stats = csCourses.map((course, index) => {
                const count = papers.filter(p => {
                    return p.userData && typeof p.userData.course === 'number' && p.userData.course === index;
                }).length;
                console.log(`${course.name} (index ${index}): ${count}个概念`);
                return `${course.name}: ${count}个概念`;
            }).join('<br>');

            const statsElement = document.getElementById('clusterStats');
            if (statsElement) {
                statsElement.innerHTML = stats;
                console.log('✅ 统计信息已更新到DOM');
            } else {
                console.error('❌ 找不到clusterStats元素');
            }
        }

        function showTooltip(event, userData) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = event.clientX + 15 + 'px';
            tooltip.style.top = event.clientY - 10 + 'px';

            if (!userData || typeof userData.course !== 'number' || !userData.name || !userData.type) {
                hideTooltip();
                return;
            }

            const course = csCourses[userData.course];
            if (!course) {
                hideTooltip();
                return;
            }

            let content = '';

            if (userData.type === 'star') {
                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 16px;">
                            ⭐ ${userData.name} 星系
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">🌌</span> <strong>类型:</strong> 知识恒星
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">🪐</span> <strong>行星数量:</strong> ${course.planets ? course.planets.length : 0} 个
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">📚</span> <strong>领域:</strong> ${course.name}
                        </div>
                    </div>
                `;
            } else if (userData.type === 'planet') {
                const satelliteCount = userData.satellites ? userData.satellites.length : 0;
                const planetIndex = typeof userData.planetIndex === 'number' ? userData.planetIndex : 0;

                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            🪐 ${userData.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">🌌</span> <strong>所属星系:</strong> ${course.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">🛸</span> <strong>类型:</strong> 知识行星
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">🌙</span> <strong>卫星数量:</strong> ${satelliteCount} 个
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #45b7d1;">📍</span> <strong>轨道位置:</strong> 第 ${planetIndex + 1} 轨道
                        </div>
                    </div>
                `;
            } else if (userData.type === 'satellite') {
                const parentPlanetName = (userData.parentPlanet && userData.parentPlanet.userData && userData.parentPlanet.userData.name)
                    ? userData.parentPlanet.userData.name : '未知行星';
                const satelliteIndex = typeof userData.satelliteIndex === 'number' ? userData.satelliteIndex : 0;

                content = `
                    <div style="border-left: 3px solid #${course.color.toString(16).padStart(6, '0')}; padding-left: 10px;">
                        <div style="color: #00f5ff; font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            🌙 ${userData.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ff00ff;">🌌</span> <strong>所属星系:</strong> ${course.name}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #00ff88;">🛸</span> <strong>类型:</strong> 知识卫星
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #ffeaa7;">🪐</span> <strong>母行星:</strong> ${parentPlanetName}
                        </div>
                        <div style="margin: 4px 0; opacity: 0.9;">
                            <span style="color: #45b7d1;">📍</span> <strong>卫星轨道:</strong> 第 ${satelliteIndex + 1} 轨道
                        </div>
                    </div>
                `;
            }

            tooltip.innerHTML = content;
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        function searchConcept() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            if (!searchTerm) {
                return;
            }

            const foundConcepts = papers.filter(paper =>
                paper.userData.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            if (foundConcepts.length > 0) {
                const exactMatch = foundConcepts.find(paper =>
                    paper.userData.name.toLowerCase() === searchTerm.toLowerCase()
                );

                const targetConcept = exactMatch || foundConcepts[0];

                if (lockedConcept) {
                    unlockConcept(lockedConcept);
                }

                lockConcept(targetConcept);
                flyToConcept(targetConcept);
                showSearchResult(foundConcepts.length, targetConcept);
            } else {
                showSearchResult(0, null);
            }
        }

        function lockConcept(concept) {
            preLockPosition = camera.position.clone();

            lockedConcept = concept;
            lockMode = true;

            document.getElementById('unlockBtn').style.display = 'inline-block';

            // 获取真实网格进行材质操作
            const realMesh = concept.userData.realMesh || concept;

            // 同时在碰撞体和真实网格中设置锁定状态
            concept.userData.isLocked = true;
            realMesh.userData.isLocked = true;

            // 在真实网格中保存原始材质属性
            realMesh.userData.originalEmissive = realMesh.material.emissive.clone();
            realMesh.userData.originalColor = realMesh.material.color.clone();
            realMesh.userData.originalOpacity = realMesh.material.opacity;

            // 创建锁定指示器（环形）
            const ringGeometry = new THREE.RingGeometry(
                realMesh.geometry.parameters.radius * 2,
                realMesh.geometry.parameters.radius * 2.2,
                32
            );
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(concept.position);
            ring.lookAt(camera.position);

            concept.userData.lockRing = ring;
            scene.add(ring);

            // 添加脉冲光晕
            const glowGeometry = new THREE.SphereGeometry(realMesh.geometry.parameters.radius * 3, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(concept.position);

            concept.userData.lockGlow = glow;
            scene.add(glow);
        }

        function unlockConcept(concept) {
            if (concept && (concept.userData.isLocked || (concept.userData.realMesh && concept.userData.realMesh.userData.isLocked))) {
                // 获取真实网格进行材质操作
                const realMesh = concept.userData.realMesh || concept;

                // 同时清除碰撞体和真实网格的锁定状态
                concept.userData.isLocked = false;
                realMesh.userData.isLocked = false;

                // 强制恢复到基础颜色状态
                if (realMesh.material && realMesh.userData.baseColor) {
                    // 恢复基础颜色
                    realMesh.material.color.copy(realMesh.userData.baseColor);

                    // 恢复基础发光效果
                    realMesh.material.emissive.copy(realMesh.userData.baseColor).multiplyScalar(0.15);

                    // 恢复基础透明度
                    realMesh.material.opacity = 0.9;
                }

                // 清理保存的原始属性
                delete realMesh.userData.originalEmissive;
                delete realMesh.userData.originalColor;
                delete realMesh.userData.originalOpacity;
                delete realMesh.userData.justUnlocked;

                // 移除锁定指示器
                if (concept.userData.lockRing) {
                    scene.remove(concept.userData.lockRing);
                    concept.userData.lockRing = null;
                }

                if (concept.userData.lockGlow) {
                    scene.remove(concept.userData.lockGlow);
                    concept.userData.lockGlow = null;
                }
            }

            // 隐藏取消锁定按钮
            document.getElementById('unlockBtn').style.display = 'none';

            // 重置锁定状态
            lockedConcept = null;
            lockMode = false;

            // 如果有保存的锁定前位置，朝向那个位置
            if (preLockPosition) {
                // 使用锁定逻辑的反向操作：让相机朝向锁定前的位置
                camera.lookAt(preLockPosition);

                // 同步cameraRotation变量以保持一致性
                const direction = new THREE.Vector3().subVectors(preLockPosition, camera.position).normalize();
                cameraRotation.y = Math.atan2(direction.x, direction.z);
                cameraRotation.x = -Math.asin(direction.y);

                // 清除保存的位置
                preLockPosition = null;
            }
        }

        function unlockCurrentConcept() {
            if (lockedConcept) {
                unlockConcept(lockedConcept);
                hideTooltip();
            }
        }

        function showSearchResult(count, concept) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.position = 'fixed';
            tooltip.style.top = '50%';
            tooltip.style.left = '50%';
            tooltip.style.transform = 'translate(-50%, -50%)';
            tooltip.style.zIndex = '1000';

            if (count === 0) {
                tooltip.innerHTML = `
                    <div style="text-align: center; color: #ff6b6b;">
                        <div style="font-size: 16px; margin-bottom: 10px;">🔍 未找到匹配结果</div>
                        <div style="font-size: 12px; opacity: 0.8;">请尝试其他关键词</div>
                    </div>
                `;
            } else {
                const course = csCourses[concept.userData.course];
                tooltip.innerHTML = `
                    <div style="text-align: center; color: #00ff00;">
                        <div style="font-size: 16px; margin-bottom: 10px;">🎯 已锁定目标</div>
                        <div style="font-size: 14px; color: #00f5ff; margin-bottom: 5px;">${concept.userData.name}</div>
                        <div style="font-size: 12px; opacity: 0.8;">所属课程: ${course.name}</div>
                        <div style="font-size: 12px; opacity: 0.8;">找到 ${count} 个相关结果</div>
                        <div style="font-size: 10px; margin-top: 10px; opacity: 0.6;">
                            <div>🎮 WASD: 环绕观察 | QE: 调整高度</div>
                            <div>⌨️ ESC键或点击"取消锁定"按钮解除锁定</div>
                        </div>
                    </div>
                `;
            }

            tooltip.classList.add('show');

            // 5秒后自动隐藏搜索结果提示
            setTimeout(() => {
                if (tooltip.innerHTML.includes('已锁定目标') || tooltip.innerHTML.includes('未找到匹配结果')) {
                    tooltip.classList.remove('show');
                }
            }, 5000);
        }

        function flyToConcept(concept) {
            // 在概念周围设置相机位置，形成环绕效果
            const distance = lockDistance;
            const height = 5;

            const targetPosition = concept.position.clone();
            targetPosition.x += distance * Math.cos(lockAngle);
            targetPosition.z += distance * Math.sin(lockAngle);
            targetPosition.y += height;

            // 执行相机动画，确保看向概念
            animateCameraToTarget(targetPosition, concept.position, true);
        }

        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchConcept();
            }
        }

        function rotateClockwise() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：顺时针环绕目标15度
                lockAngle += Math.PI / 12; // 15度小角度旋转
                return;
            }

            // 自由飞行模式下：顺时针旋转视角15度
            const targetRotationY = cameraRotation.y + Math.PI / 12; // 15度小角度

            // 执行平滑旋转动画
            const startRotationY = cameraRotation.y;
            const duration = 200; // 200毫秒快速旋转
            const startTime = Date.now();

            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // 使用缓动函数让旋转更自然
                const eased = 1 - Math.pow(1 - progress, 3);

                // 更新Y轴旋转
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetRotationY, eased);

                // 应用旋转到相机
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }

            updateRotation();
        }

        function flip180Degrees() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：直接翻转环绕角度
                lockAngle += Math.PI;
                return;
            }

            // 自由飞行模式下：翻转Y轴旋转180度
            const targetRotationY = cameraRotation.y + Math.PI;

            // 执行平滑翻转动画
            const startRotationY = cameraRotation.y;
            const duration = 300; // 300毫秒快速翻转
            const startTime = Date.now();

            function updateFlip() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // 使用缓动函数让翻转更自然
                const eased = 1 - Math.pow(1 - progress, 3);

                // 更新Y轴旋转
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetRotationY, eased);

                // 应用旋转到相机
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateFlip);
                }
            }

            updateFlip();
        }

        // 更新恒星动态光源
        function updateStarLights(time) {
            scene.userData.starLights.forEach(starLightData => {
                let pulseIntensity;

                // 根据课程类型调整光源行为
                switch(starLightData.courseIndex) {
                    case 0: // 数据结构 - 强力脉冲光
                        pulseIntensity = Math.sin(time * 1.2 + starLightData.animationOffset) * 0.8 + 1.5;
                        break;
                    case 1: // 算法设计 - 节奏光
                        pulseIntensity = Math.abs(Math.sin(time * 1.5 + starLightData.animationOffset)) * 0.6 + 1.4;
                        break;
                    case 2: // 计算机网络 - 波动光
                        pulseIntensity = (Math.sin(time * 0.8 + starLightData.animationOffset) +
                                        Math.sin(time * 1.6 + starLightData.animationOffset)) * 0.3 + 1.6;
                        break;
                    case 3: // 操作系统 - 稳定光
                        pulseIntensity = Math.sin(time * 0.5 + starLightData.animationOffset) * 0.2 + 2.0;
                        break;
                    case 4: // 数据库系统 - 宝藏光
                        pulseIntensity = Math.sin(time * 0.7 + starLightData.animationOffset) * 0.5 + 2.2 +
                                       Math.sin(time * 2.1 + starLightData.animationOffset) * 0.3;
                        break;
                    case 5: // 软件工程 - 变幻光
                        pulseIntensity = Math.sin(time * 1.0 + starLightData.animationOffset) * 0.4 + 1.8;
                        break;
                    default:
                        pulseIntensity = Math.sin(time * 0.8 + starLightData.animationOffset) * 0.5 + 1.5;
                }

                starLightData.light.intensity = starLightData.baseIntensity * pulseIntensity;

                // 轻微的色彩变化
                const colorShift = Math.sin(time * 0.3 + starLightData.animationOffset) * 0.1 + 0.9;
                const color = new THREE.Color(starLightData.color);
                color.multiplyScalar(colorShift);
                starLightData.light.color.copy(color);
            });
        }

        // 控制面板切换功能
        function toggleControlsPanel() {
            const controls = document.getElementById('controls');
            const toggle = document.getElementById('controlsToggle');

            controls.classList.toggle('open');
            toggle.classList.toggle('open');

            // 更新按钮文字
            if (controls.classList.contains('open')) {
                toggle.innerHTML = '✕ 关闭面板';
            } else {
                toggle.innerHTML = '🎮 控制面板';
            }
        }

        // 新增的4个精细旋转控制函数
        function rotateHorizontalLeft() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：逆时针环绕目标10度
                lockAngle -= Math.PI / 18; // 10度小角度旋转
                return;
            }

            // 自由飞行模式下：水平向左旋转10度
            const targetRotationY = cameraRotation.y - Math.PI / 18; // 10度小角度
            smoothRotateCamera(targetRotationY, cameraRotation.x, 150);
        }

        function rotateHorizontalRight() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：顺时针环绕目标10度
                lockAngle += Math.PI / 18; // 10度小角度旋转
                return;
            }

            // 自由飞行模式下：水平向右旋转10度
            const targetRotationY = cameraRotation.y + Math.PI / 18; // 10度小角度
            smoothRotateCamera(targetRotationY, cameraRotation.x, 150);
        }

        function rotateVerticalUp() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：调整观察高度（向上）
                const currentHeight = camera.position.y - lockedConcept.position.y;
                const newHeight = Math.min(currentHeight + 2, 30); // 限制最大高度
                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += newHeight;
                camera.position.lerp(targetPosition, 0.2);
                camera.lookAt(lockedConcept.position);
                return;
            }

            // 自由飞行模式下：竖直向上旋转10度
            const targetRotationX = Math.max(cameraRotation.x - Math.PI / 18, -Math.PI/2); // 限制不能超过垂直向上
            smoothRotateCamera(cameraRotation.y, targetRotationX, 150);
        }

        function rotateVerticalDown() {
            if (lockMode && lockedConcept) {
                // 锁定模式下：调整观察高度（向下）
                const currentHeight = camera.position.y - lockedConcept.position.y;
                const newHeight = Math.max(currentHeight - 2, -10); // 限制最小高度
                const targetPosition = lockedConcept.position.clone();
                targetPosition.x += lockDistance * Math.cos(lockAngle);
                targetPosition.z += lockDistance * Math.sin(lockAngle);
                targetPosition.y += newHeight;
                camera.position.lerp(targetPosition, 0.2);
                camera.lookAt(lockedConcept.position);
                return;
            }

            // 自由飞行模式下：竖直向下旋转10度
            const targetRotationX = Math.min(cameraRotation.x + Math.PI / 18, Math.PI/2); // 限制不能超过垂直向下
            smoothRotateCamera(cameraRotation.y, targetRotationX, 150);
        }

        // 通用的平滑旋转函数
        function smoothRotateCamera(targetY, targetX, duration = 150) {
            const startRotationY = cameraRotation.y;
            const startRotationX = cameraRotation.x;
            const startTime = Date.now();

            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // 使用缓动函数让旋转更自然
                const eased = 1 - Math.pow(1 - progress, 3);

                // 更新旋转
                cameraRotation.y = THREE.MathUtils.lerp(startRotationY, targetY, eased);
                cameraRotation.x = THREE.MathUtils.lerp(startRotationX, targetX, eased);

                // 应用旋转到相机
                if (!lockMode) {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;
                }

                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }

            updateRotation();
        }

        console.log('CS Courses loaded:', csCourses.length);

        // 等待页面加载完成后开始初始化
        window.addEventListener('load', () => {
            setTimeout(() => {
                init();
            }, 500); // 短暂延迟以确保加载屏幕正确显示
        });

        // 如果页面已经加载完成，立即开始
        if (document.readyState === 'complete') {
            setTimeout(() => {
                init();
            }, 500);
        }

        // 页面可见性优化
        let isPageVisible = true;
        document.addEventListener('visibilitychange', () => {
            isPageVisible = !document.hidden;
            if (isPageVisible) {
                console.log('👁️ 页面可见，恢复全速渲染');
            } else {
                console.log('🙈 页面隐藏，降低渲染频率');
            }
        });

        // 监听窗口失焦优化性能
        window.addEventListener('blur', () => {
            animationPaused = true;
            console.log('⏸️ 窗口失焦，暂停动画');
        });

        window.addEventListener('focus', () => {
            animationPaused = false;
            console.log('▶️ 窗口获焦，恢复动画');
        });
    </script>
</body>
</html>