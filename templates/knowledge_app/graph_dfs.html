=
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾çš„æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 350px 300px;
            height: 100vh;
            gap: 15px;
            padding: 15px;
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
            overflow-y: auto;
        }

        h1 {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .section h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #4ecdc4;
        }

        .algorithm-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }

        .stack-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            min-height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }

        .stack-item {
            display: inline-block;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 15px;
            font-size: 0.8em;
            animation: stackPop 0.3s ease;
        }

        @keyframes stackPop {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .visited-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .visited-node {
            background: rgba(78, 205, 196, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            animation: fadeInScale 0.5s ease;
        }

        @keyframes fadeInScale {
            from { transform: scale(0) rotate(180deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .graph-examples {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .example-btn {
            padding: 8px;
            font-size: 0.8em;
            background: rgba(255, 255, 255, 0.2);
        }

        .status-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .status-ready { background: rgba(78, 205, 196, 0.8); }
        .status-running { background: rgba(255, 193, 7, 0.8); }
        .status-completed { background: rgba(40, 167, 69, 0.8); }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
        }

        /* å­˜å‚¨ç»“æ„é¢æ¿æ ·å¼ */
        .storage-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
            overflow-y: auto;
        }

        .storage-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* é‚»æ¥è¡¨æ ·å¼ */
        .adjacency-list {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .list-item {
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .list-item.highlight {
            background: rgba(243, 156, 18, 0.3);
            border-left-color: #f39c12;
            transform: translateX(5px);
        }

        .list-item.visited {
            background: rgba(46, 204, 113, 0.2);
            border-left-color: #2ecc71;
        }

        .node-label {
            color: #4ecdc4;
            font-weight: bold;
        }

        .neighbors {
            color: #ecf0f1;
        }

        .neighbor-node {
            display: inline-block;
            margin: 0 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .neighbor-node.active {
            background: #f39c12;
            color: white;
            transform: scale(1.1);
        }

        .neighbor-node.visited {
            background: #2ecc71;
            color: white;
        }

        /* é‚»æ¥çŸ©é˜µæ ·å¼ */
        .adjacency-matrix {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .matrix-table th,
        .matrix-table td {
            padding: 6px 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .matrix-table th {
            background: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            font-weight: bold;
        }

        .matrix-table td {
            color: #ecf0f1;
        }

        .matrix-table td.highlight {
            background: rgba(243, 156, 18, 0.5);
            color: white;
            transform: scale(1.1);
        }

        .matrix-table td.visited {
            background: rgba(46, 204, 113, 0.3);
        }

        .matrix-explanation {
            margin-top: 10px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 6px;
            font-size: 0.8em;
            border-left: 4px solid #3498db;
        }

        /* ä»£ç è¯­è¨€åˆ‡æ¢æ ·å¼ */
        .language-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .lang-btn {
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
            text-align: center;
        }

        .lang-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border-color: #4ecdc4;
        }

        .lang-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .code-container {
            position: relative;
        }

        .code-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .code-display .keyword { color: #ff79c6; }
        .code-display .string { color: #f1fa8c; }
        .code-display .comment { color: #6272a4; font-style: italic; }
        .code-display .function { color: #50fa7b; }
        .code-display .type { color: #8be9fd; }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(78, 205, 196, 0.8);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .copy-btn:hover {
            background: rgba(78, 205, 196, 1);
            transform: translateY(-1px);
        }

        .copy-btn.copied {
            background: rgba(46, 204, 113, 0.9);
        }

        /* ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡†æ ·å¼ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            width: 90%;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }

        .modal-title {
            font-size: 1.8em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .instruction-section {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4ecdc4;
        }

        .instruction-section h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instruction-section p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .instruction-list {
            list-style: none;
            padding: 0;
        }

        .instruction-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
            color: rgba(255,255,255,0.9);
        }

        .instruction-list li::before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #4ecdc4;
            font-weight: bold;
        }

        .highlight-text {
            color: #f39c12;
            font-weight: bold;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .feature-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .feature-item h4 {
            color: #ff6b6b;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .feature-item p {
            font-size: 0.9em;
            margin: 0;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto auto;
            }

            .control-panel, .storage-panel {
                max-height: 300px;
            }

            .language-selector {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                width: 95%;
                padding: 20px;
                max-height: 90vh;
            }

            .modal-title {
                font-size: 1.4em;
            }

            .feature-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .instruction-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-panel">
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>

        <div class="control-panel">
            <h1>ğŸ” DFS ç®—æ³•å¯è§†åŒ–</h1>

            <div class="section">
                <div id="status" class="status-indicator status-ready">
                    å‡†å¤‡å¼€å§‹ - é€‰æ‹©èµ·å§‹èŠ‚ç‚¹
                </div>
            </div>

            <div class="section">
                <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
                <div class="controls">
                    <button id="startBtn" onclick="startDFS()">å¼€å§‹ DFS</button>
                    <button id="pauseBtn" onclick="togglePause()" disabled>æš‚åœ</button>
                    <button id="resetBtn" onclick="resetVisualization()">é‡ç½®</button>
                    <button id="stepBtn" onclick="stepDFS()" disabled>å•æ­¥æ‰§è¡Œ</button>
                </div>

                <div class="speed-control">
                    <span>é€Ÿåº¦:</span>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <button class="full-width" onclick="showInstructions()" style="background: linear-gradient(45deg, #9b59b6, #3498db); margin-top: 10px;">
                    ğŸ“– ä½¿ç”¨è¯´æ˜
                </button>
            </div>

            <div class="section">
                <h3>ğŸ“Š é¢„è®¾å›¾ä¾‹</h3>
                <div class="graph-examples">
                    <button class="example-btn" onclick="loadExample('simple')">ç®€å•å›¾</button>
                    <button class="example-btn" onclick="loadExample('tree')">æ ‘ç»“æ„</button>
                    <button class="example-btn" onclick="loadExample('cycle')">ç¯å½¢å›¾</button>
                    <button class="example-btn" onclick="loadExample('complex')">å¤æ‚å›¾</button>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š é€’å½’æ ˆ</h3>
                <div id="stackDisplay" class="stack-display">
                    æ ˆä¸ºç©º
                </div>
            </div>

            <div class="section">
                <h3>âœ… è®¿é—®é¡ºåº</h3>
                <div id="visitedList" class="visited-list">
                    å°šæœªå¼€å§‹
                </div>
            </div>

            <div class="section">
                <h3>ğŸ¨ å›¾ä¾‹</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>æœªè®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>æ­£åœ¨è®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>å·²è®¿é—®</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>èµ·å§‹èŠ‚ç‚¹</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ’» DFS ç®—æ³•ä»£ç </h3>
                <div class="language-selector">
                    <button class="lang-btn active" data-lang="javascript" onclick="changeCodeLanguage('javascript')">JavaScript</button>
                    <button class="lang-btn" data-lang="python" onclick="changeCodeLanguage('python')">Python</button>
                    <button class="lang-btn" data-lang="cpp" onclick="changeCodeLanguage('cpp')">C++</button>
                    <button class="lang-btn" data-lang="java" onclick="changeCodeLanguage('java')">Java</button>
                </div>
                <div class="code-container">
                    <button class="copy-btn" onclick="copyCode()" id="copyBtn">ğŸ“‹ å¤åˆ¶</button>
                    <div id="codeDisplay" class="code-display"></div>
                </div>
            </div>
        </div>

        <div class="storage-panel">
            <h1>ğŸ—ƒï¸ å›¾çš„å­˜å‚¨ç»“æ„</h1>

            <div class="storage-toggle">
                <button class="toggle-btn active" id="listToggle" onclick="showAdjacencyList()">é‚»æ¥è¡¨</button>
                <button class="toggle-btn" id="matrixToggle" onclick="showAdjacencyMatrix()">é‚»æ¥çŸ©é˜µ</button>
            </div>

            <div id="adjacencyListView" class="section">
                <h3>ğŸ“‹ é‚»æ¥è¡¨ (Adjacency List)</h3>
                <div class="adjacency-list" id="adjacencyListContent">
                    é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥è¡¨
                </div>
                <div class="matrix-explanation">
                    ğŸ’¡ é‚»æ¥è¡¨ç”¨é“¾è¡¨å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…ï¼Œç©ºé—´æ•ˆç‡é«˜ï¼Œé€‚åˆç¨€ç–å›¾ã€‚
                </div>
            </div>

            <div id="adjacencyMatrixView" class="section" style="display: none;">
                <h3>ğŸ“Š é‚»æ¥çŸ©é˜µ (Adjacency Matrix)</h3>
                <div class="adjacency-matrix" id="adjacencyMatrixContent">
                    é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥çŸ©é˜µ
                </div>
                <div class="matrix-explanation">
                    ğŸ’¡ é‚»æ¥çŸ©é˜µç”¨äºŒç»´æ•°ç»„å­˜å‚¨ï¼ŒæŸ¥è¯¢è¾¹çš„å­˜åœ¨æ€§ä¸ºO(1)ï¼Œé€‚åˆç¨ å¯†å›¾ã€‚
                </div>
            </div>

            <div class="section">
                <h3>ğŸ” å½“å‰æ“ä½œ</h3>
                <div id="currentOperation" class="algorithm-info">
                    ç­‰å¾…å¼€å§‹DFS...
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š å­˜å‚¨ç»“æ„å¯¹æ¯”</h3>
                <div class="algorithm-info" style="font-size: 0.75em;">
<strong>é‚»æ¥è¡¨:</strong><br>
â€¢ ç©ºé—´å¤æ‚åº¦: O(V + E)<br>
â€¢ æ·»åŠ è¾¹: O(1)<br>
â€¢ æŸ¥è¯¢è¾¹: O(degree(v))<br>
â€¢ é€‚åˆ: ç¨€ç–å›¾<br><br>
<strong>é‚»æ¥çŸ©é˜µ:</strong><br>
â€¢ ç©ºé—´å¤æ‚åº¦: O(VÂ²)<br>
â€¢ æ·»åŠ è¾¹: O(1)<br>
â€¢ æŸ¥è¯¢è¾¹: O(1)<br>
â€¢ é€‚åˆ: ç¨ å¯†å›¾
                </div>
            </div>
        </div>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡† -->
    <div id="instructionModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ğŸ“– DFS å¯è§†åŒ–å·¥å…·ä½¿ç”¨è¯´æ˜</h2>
                <button class="close-btn" onclick="hideInstructions()">Ã—</button>
            </div>

            <div class="instruction-section">
                <h3>ğŸš€ å¿«é€Ÿå¼€å§‹</h3>
                <ul class="instruction-list">
                    <li>é€‰æ‹©ä¸€ä¸ªé¢„è®¾å›¾ä¾‹æˆ–ä¿æŒé»˜è®¤çš„ç®€å•å›¾</li>
                    <li><span class="highlight-text">ç‚¹å‡»ä»»æ„èŠ‚ç‚¹</span>é€‰æ‹©ä¸ºèµ·å§‹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹ä¼šå˜æˆè“è‰²ï¼‰</li>
                    <li>ç‚¹å‡»<span class="highlight-text">"å¼€å§‹ DFS"</span>æŒ‰é’®è§‚çœ‹ç®—æ³•æ‰§è¡Œ</li>
                    <li>ä½¿ç”¨é€Ÿåº¦æ»‘å—è°ƒèŠ‚åŠ¨ç”»é€Ÿåº¦ï¼ˆ1-10çº§ï¼‰</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ® æ§åˆ¶åŠŸèƒ½</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>â–¶ï¸ å¼€å§‹ DFS</h4>
                        <p>å¯åŠ¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•çš„è‡ªåŠ¨æ‰§è¡Œ</p>
                    </div>
                    <div class="feature-item">
                        <h4>â¸ï¸ æš‚åœ/ç»§ç»­</h4>
                        <p>æš‚åœæˆ–æ¢å¤æ­£åœ¨æ‰§è¡Œçš„ç®—æ³•åŠ¨ç”»</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ”„ é‡ç½®</h4>
                        <p>æ¸…é™¤æ‰€æœ‰çŠ¶æ€ï¼Œé‡æ–°å¼€å§‹æ¼”ç¤º</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ‘† å•æ­¥æ‰§è¡Œ</h4>
                        <p>é€æ­¥æ‰§è¡Œç®—æ³•ï¼Œæ·±å…¥ç†è§£æ¯ä¸€æ­¥</p>
                    </div>
                </div>
            </div>

            <div class="instruction-section">
                <h3>ğŸ“Š å›¾ä¾‹è¯´æ˜</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>ç®€å•å›¾</h4>
                        <p>4ä¸ªèŠ‚ç‚¹çš„åŸºç¡€å›¾ç»“æ„ï¼Œé€‚åˆåˆå­¦è€…</p>
                    </div>
                    <div class="feature-item">
                        <h4>æ ‘ç»“æ„</h4>
                        <p>åˆ†å±‚æ ‘å½¢ç»“æ„ï¼Œå±•ç¤ºDFSçš„é€’å½’ç‰¹æ€§</p>
                    </div>
                    <div class="feature-item">
                        <h4>ç¯å½¢å›¾</h4>
                        <p>åŒ…å«ç¯è·¯çš„å›¾ï¼Œæ¼”ç¤ºç¯æ£€æµ‹</p>
                    </div>
                    <div class="feature-item">
                        <h4>å¤æ‚å›¾</h4>
                        <p>å¤šèŠ‚ç‚¹å¤æ‚è¿æ¥ï¼ŒæŒ‘æˆ˜ç†è§£èƒ½åŠ›</p>
                    </div>
                </div>
            </div>

            <div class="instruction-section">
                <h3>ğŸ¨ å¯è§†åŒ–å…ƒç´ </h3>
                <ul class="instruction-list">
                    <li><span style="color: #e74c3c;">â—</span> <span class="highlight-text">çº¢è‰²èŠ‚ç‚¹</span>ï¼šæœªè®¿é—®çš„èŠ‚ç‚¹</li>
                    <li><span style="color: #3498db;">â—</span> <span class="highlight-text">è“è‰²èŠ‚ç‚¹</span>ï¼šé€‰ä¸­çš„èµ·å§‹èŠ‚ç‚¹</li>
                    <li><span style="color: #f39c12;">â—</span> <span class="highlight-text">æ©™è‰²èŠ‚ç‚¹</span>ï¼šæ­£åœ¨è®¿é—®çš„èŠ‚ç‚¹ï¼ˆå¸¦è„‰å†²æ•ˆæœï¼‰</li>
                    <li><span style="color: #2ecc71;">â—</span> <span class="highlight-text">ç»¿è‰²èŠ‚ç‚¹</span>ï¼šå·²è®¿é—®å®Œæˆçš„èŠ‚ç‚¹</li>
                    <li><span style="color: #f39c12;">â¤</span> <span class="highlight-text">æ©™è‰²è¾¹</span>ï¼šå½“å‰æ­£åœ¨éå†çš„è¾¹</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ“š æ ˆå¯è§†åŒ–</h3>
                <p>å³ä¾§çš„DFSæ ˆå®æ—¶æ˜¾ç¤ºç®—æ³•çš„æ‰§è¡ŒçŠ¶æ€ï¼š</p>
                <ul class="instruction-list">
                    <li><span class="highlight-text">æ ˆé¡¶</span>ï¼šä¸‹ä¸€ä¸ªè¦å¤„ç†çš„èŠ‚ç‚¹</li>
                    <li><span class="highlight-text">å…¥æ ˆåŠ¨ç”»</span>ï¼šæ–°èŠ‚ç‚¹å‹å…¥æ—¶çš„ç¼©æ”¾æ•ˆæœ</li>
                    <li><span class="highlight-text">å‡ºæ ˆåŠ¨ç”»</span>ï¼šèŠ‚ç‚¹å¼¹å‡ºæ—¶çš„ä¸Šç§»æ¶ˆå¤±æ•ˆæœ</li>
                    <li>æ ˆçš„<span class="highlight-text">åè¿›å…ˆå‡º</span>ç‰¹æ€§ç›´è§‚å±•ç¤º</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ—ƒï¸ å­˜å‚¨ç»“æ„</h3>
                <p>åœ¨å³ä¾§é¢æ¿å¯ä»¥åˆ‡æ¢æŸ¥çœ‹ä¸¤ç§å›¾çš„å­˜å‚¨æ–¹å¼ï¼š</p>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>ğŸ“‹ é‚»æ¥è¡¨</h4>
                        <p>æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶é‚»å±…åˆ—è¡¨ï¼Œç©ºé—´æ•ˆç‡é«˜ï¼Œé€‚åˆç¨€ç–å›¾</p>
                    </div>
                    <div class="feature-item">
                        <h4>ğŸ“Š é‚»æ¥çŸ©é˜µ</h4>
                        <p>äºŒç»´è¡¨æ ¼å­˜å‚¨ï¼ŒæŸ¥è¯¢æ•ˆç‡O(1)ï¼Œé€‚åˆç¨ å¯†å›¾</p>
                    </div>
                </div>
                <p><span class="highlight-text">å®æ—¶é«˜äº®</span>ï¼šç®—æ³•æ‰§è¡Œæ—¶ä¼šé«˜äº®æ˜¾ç¤ºå½“å‰å¤„ç†çš„èŠ‚ç‚¹è¡Œ</p>
            </div>

            <div class="instruction-section">
                <h3>ğŸ’» ä»£ç å­¦ä¹ </h3>
                <p>åº•éƒ¨æä¾›å››ç§ç¼–ç¨‹è¯­è¨€çš„DFSå®ç°ï¼š</p>
                <ul class="instruction-list">
                    <li><span class="highlight-text">JavaScript</span>ï¼šç°ä»£Webå¼€å‘ï¼Œé€‚åˆå‰ç«¯å­¦ä¹ </li>
                    <li><span class="highlight-text">Python</span>ï¼šè¯­æ³•ç®€æ´ï¼Œåˆå­¦è€…å‹å¥½</li>
                    <li><span class="highlight-text">C++</span>ï¼šé«˜æ€§èƒ½å®ç°ï¼Œç®—æ³•ç«èµ›å¸¸ç”¨</li>
                    <li><span class="highlight-text">Java</span>ï¼šä¼ä¸šçº§å¼€å‘ï¼Œé¢å‘å¯¹è±¡</li>
                </ul>
                <p>ç‚¹å‡»<span class="highlight-text">"ğŸ“‹ å¤åˆ¶"</span>æŒ‰é’®å¯ä»¥ä¸€é”®å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿ï¼</p>
            </div>

            <div class="instruction-section">
                <h3>ğŸ’¡ å­¦ä¹ å»ºè®®</h3>
                <ul class="instruction-list">
                    <li><span class="highlight-text">å…ˆè§‚çœ‹è‡ªåŠ¨æ¼”ç¤º</span>ï¼Œç†è§£æ•´ä½“æµç¨‹</li>
                    <li><span class="highlight-text">ä½¿ç”¨å•æ­¥æ¨¡å¼</span>ï¼Œä»”ç»†è§‚å¯Ÿæ¯ä¸€æ­¥</li>
                    <li><span class="highlight-text">å¯¹æ¯”ä¸åŒå›¾ç»“æ„</span>ï¼Œç†è§£ç®—æ³•çš„é€šç”¨æ€§</li>
                    <li><span class="highlight-text">è§‚å¯Ÿæ ˆçš„å˜åŒ–</span>ï¼Œç†è§£é€’å½’çš„æœ¬è´¨</li>
                    <li><span class="highlight-text">æ¯”è¾ƒå­˜å‚¨ç»“æ„</span>ï¼Œé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„</li>
                    <li><span class="highlight-text">é˜…è¯»å¤šè¯­è¨€ä»£ç </span>ï¼Œæé«˜ç¼–ç¨‹èƒ½åŠ›</li>
                </ul>
            </div>

            <div class="instruction-section">
                <h3>ğŸ¯ å¸¸è§é—®é¢˜</h3>
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>Q: ä¸ºä»€ä¹ˆè¦é€†åºæ·»åŠ é‚»å±…ï¼Ÿ</h4>
                        <p>A: æ ˆæ˜¯åè¿›å…ˆå‡ºï¼Œé€†åºæ·»åŠ ç¡®ä¿æŒ‰å­—å…¸åºè®¿é—®èŠ‚ç‚¹</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: è®¿é—®é¡ºåºä¸ºä»€ä¹ˆä¸åŒï¼Ÿ</h4>
                        <p>A: DFSè®¿é—®é¡ºåºå–å†³äºé‚»æ¥è¡¨çš„å­˜å‚¨é¡ºåº</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: é€’å½’å’Œè¿­ä»£æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ</h4>
                        <p>A: é€’å½’ä½¿ç”¨ç³»ç»Ÿæ ˆï¼Œè¿­ä»£ä½¿ç”¨æ‰‹åŠ¨æ ˆï¼Œæœ¬è´¨ç›¸åŒ</p>
                    </div>
                    <div class="feature-item">
                        <h4>Q: å¦‚ä½•å¤„ç†ç¯è·¯ï¼Ÿ</h4>
                        <p>A: ä½¿ç”¨visitedé›†åˆé¿å…é‡å¤è®¿é—®åŒä¸€èŠ‚ç‚¹</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        let graph = {};
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let isRunning = false;
        let isPaused = false;
        let dfsState = {
            visited: new Set(),
            stack: [],
            currentNode: null,
            visitOrder: [],
            step: 0
        };

        let animationSpeed = 1000; // æ¯«ç§’
        let storageView = 'list'; // 'list' or 'matrix'
        let currentLanguage = 'javascript'; // å½“å‰é€‰æ‹©çš„ç¼–ç¨‹è¯­è¨€

        // æ ˆå¯è§†åŒ–ç›¸å…³
        let stackVisualization = {
            x: 0, // å°†åœ¨resizeCanvasä¸­è®¾ç½®
            y: 50,
            width: 120,
            itemHeight: 40,
            items: [], // {value, y, animating, action} action: 'push' | 'pop'
            animations: []
        };

        // å¤šè¯­è¨€DFSä»£ç å®ç°
        const dfsCodeImplementations = {
            javascript: `<span class="comment">// JavaScript å®ç° - è¿­ä»£ç‰ˆæœ¬</span>
<span class="keyword">function</span> <span class="function">DFS</span>(graph, start) {
    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="type">Set</span>();
    <span class="keyword">let</span> stack = [start];
    <span class="keyword">let</span> result = [];

    <span class="keyword">while</span> (stack.length > <span class="string">0</span>) {
        <span class="keyword">let</span> node = stack.<span class="function">pop</span>();

        <span class="keyword">if</span> (!visited.<span class="function">has</span>(node)) {
            visited.<span class="function">add</span>(node);
            result.<span class="function">push</span>(node);

            <span class="comment">// é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº</span>
            <span class="keyword">for</span> (<span class="keyword">let</span> i = graph[node].length - <span class="string">1</span>; i >= <span class="string">0</span>; i--) {
                <span class="keyword">let</span> neighbor = graph[node][i];
                <span class="keyword">if</span> (!visited.<span class="function">has</span>(neighbor)) {
                    stack.<span class="function">push</span>(neighbor);
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}

<span class="comment">// é€’å½’ç‰ˆæœ¬</span>
<span class="keyword">function</span> <span class="function">DFS_recursive</span>(graph, node, visited = <span class="keyword">new</span> <span class="type">Set</span>()) {
    visited.<span class="function">add</span>(node);
    console.<span class="function">log</span>(node); <span class="comment">// å¤„ç†å½“å‰èŠ‚ç‚¹</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> graph[node]) {
        <span class="keyword">if</span> (!visited.<span class="function">has</span>(neighbor)) {
            <span class="function">DFS_recursive</span>(graph, neighbor, visited);
        }
    }
}`,

            python: `<span class="comment"># Python å®ç° - è¿­ä»£ç‰ˆæœ¬</span>
<span class="keyword">def</span> <span class="function">dfs</span>(graph, start):
    visited = <span class="function">set</span>()
    stack = [start]
    result = []

    <span class="keyword">while</span> stack:
        node = stack.<span class="function">pop</span>()

        <span class="keyword">if</span> node <span class="keyword">not in</span> visited:
            visited.<span class="function">add</span>(node)
            result.<span class="function">append</span>(node)

            <span class="comment"># é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº</span>
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> <span class="function">reversed</span>(graph[node]):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    stack.<span class="function">append</span>(neighbor)

    <span class="keyword">return</span> result

<span class="comment"># é€’å½’ç‰ˆæœ¬</span>
<span class="keyword">def</span> <span class="function">dfs_recursive</span>(graph, node, visited=<span class="keyword">None</span>):
    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="keyword">None</span>:
        visited = <span class="function">set</span>()

    visited.<span class="function">add</span>(node)
    <span class="function">print</span>(node)  <span class="comment"># å¤„ç†å½“å‰èŠ‚ç‚¹</span>

    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:
        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
            <span class="function">dfs_recursive</span>(graph, neighbor, visited)

<span class="comment"># ä½¿ç”¨ç¤ºä¾‹</span>
graph = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],
    <span class="string">'B'</span>: [<span class="string">'D'</span>, <span class="string">'E'</span>],
    <span class="string">'C'</span>: [<span class="string">'F'</span>],
    <span class="string">'D'</span>: [],
    <span class="string">'E'</span>: [],
    <span class="string">'F'</span>: []
}
result = <span class="function">dfs</span>(graph, <span class="string">'A'</span>)`,

            cpp: `<span class="comment">// C++ å®ç°</span>
<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stack&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_set&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;unordered_map&gt;</span>

<span class="keyword">using namespace</span> std;

<span class="comment">// è¿­ä»£ç‰ˆæœ¬</span>
<span class="type">vector</span>&lt;<span class="type">int</span>&gt; <span class="function">DFS</span>(<span class="type">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt;& graph, <span class="type">int</span> start) {
    <span class="type">unordered_set</span>&lt;<span class="type">int</span>&gt; visited;
    <span class="type">stack</span>&lt;<span class="type">int</span>&gt; stk;
    <span class="type">vector</span>&lt;<span class="type">int</span>&gt; result;

    stk.<span class="function">push</span>(start);

    <span class="keyword">while</span> (!stk.<span class="function">empty</span>()) {
        <span class="type">int</span> node = stk.<span class="function">top</span>();
        stk.<span class="function">pop</span>();

        <span class="keyword">if</span> (visited.<span class="function">find</span>(node) == visited.<span class="function">end</span>()) {
            visited.<span class="function">insert</span>(node);
            result.<span class="function">push_back</span>(node);

            <span class="comment">// é€†åºæ·»åŠ é‚»å±…</span>
            <span class="keyword">for</span> (<span class="type">int</span> i = graph[node].<span class="function">size</span>() - <span class="string">1</span>; i >= <span class="string">0</span>; i--) {
                <span class="type">int</span> neighbor = graph[node][i];
                <span class="keyword">if</span> (visited.<span class="function">find</span>(neighbor) == visited.<span class="function">end</span>()) {
                    stk.<span class="function">push</span>(neighbor);
                }
            }
        }
    }

    <span class="keyword">return</span> result;
}

<span class="comment">// é€’å½’ç‰ˆæœ¬</span>
<span class="keyword">void</span> <span class="function">DFS_recursive</span>(<span class="type">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">vector</span>&lt;<span class="type">int</span>&gt;&gt;& graph,
                      <span class="type">int</span> node, <span class="type">unordered_set</span>&lt;<span class="type">int</span>&gt;& visited) {
    visited.<span class="function">insert</span>(node);
    cout &lt;&lt; node &lt;&lt; <span class="string">" "</span>;  <span class="comment">// å¤„ç†å½“å‰èŠ‚ç‚¹</span>

    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) {
        <span class="keyword">if</span> (visited.<span class="function">find</span>(neighbor) == visited.<span class="function">end</span>()) {
            <span class="function">DFS_recursive</span>(graph, neighbor, visited);
        }
    }
}`,

            java: `<span class="comment">// Java å®ç°</span>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="type">DFSImplementation</span> {

    <span class="comment">// è¿­ä»£ç‰ˆæœ¬</span>
    <span class="keyword">public static</span> <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="function">DFS</span>(<span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; graph, <span class="type">int</span> start) {
        <span class="type">Set</span>&lt;<span class="type">Integer</span>&gt; visited = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;&gt;();
        <span class="type">Stack</span>&lt;<span class="type">Integer</span>&gt; stack = <span class="keyword">new</span> <span class="type">Stack</span>&lt;&gt;();
        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();

        stack.<span class="function">push</span>(start);

        <span class="keyword">while</span> (!stack.<span class="function">isEmpty</span>()) {
            <span class="type">int</span> node = stack.<span class="function">pop</span>();

            <span class="keyword">if</span> (!visited.<span class="function">contains</span>(node)) {
                visited.<span class="function">add</span>(node);
                result.<span class="function">add</span>(node);

                <span class="comment">// é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº</span>
                <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; neighbors = graph.<span class="function">get</span>(node);
                <span class="keyword">if</span> (neighbors != <span class="keyword">null</span>) {
                    <span class="keyword">for</span> (<span class="type">int</span> i = neighbors.<span class="function">size</span>() - <span class="string">1</span>; i >= <span class="string">0</span>; i--) {
                        <span class="type">int</span> neighbor = neighbors.<span class="function">get</span>(i);
                        <span class="keyword">if</span> (!visited.<span class="function">contains</span>(neighbor)) {
                            stack.<span class="function">push</span>(neighbor);
                        }
                    }
                }
            }
        }

        <span class="keyword">return</span> result;
    }

    <span class="comment">// é€’å½’ç‰ˆæœ¬</span>
    <span class="keyword">public static</span> <span class="keyword">void</span> <span class="function">DFS_recursive</span>(<span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; graph,
                                       <span class="type">int</span> node, <span class="type">Set</span>&lt;<span class="type">Integer</span>&gt; visited) {
        visited.<span class="function">add</span>(node);
        <span class="type">System</span>.out.<span class="function">print</span>(node + <span class="string">" "</span>);  <span class="comment">// å¤„ç†å½“å‰èŠ‚ç‚¹</span>

        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; neighbors = graph.<span class="function">get</span>(node);
        <span class="keyword">if</span> (neighbors != <span class="keyword">null</span>) {
            <span class="keyword">for</span> (<span class="type">int</span> neighbor : neighbors) {
                <span class="keyword">if</span> (!visited.<span class="function">contains</span>(neighbor)) {
                    <span class="function">DFS_recursive</span>(graph, neighbor, visited);
                }
            }
        }
    }
}`
        };

        // è·å–çº¯æ–‡æœ¬ä»£ç ï¼ˆç”¨äºå¤åˆ¶ï¼‰
        const dfsCodePlainText = {
            javascript: `// JavaScript å®ç° - è¿­ä»£ç‰ˆæœ¬
function DFS(graph, start) {
    let visited = new Set();
    let stack = [start];
    let result = [];

    while (stack.length > 0) {
        let node = stack.pop();

        if (!visited.has(node)) {
            visited.add(node);
            result.push(node);

            // é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº
            for (let i = graph[node].length - 1; i >= 0; i--) {
                let neighbor = graph[node][i];
                if (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }

    return result;
}

// é€’å½’ç‰ˆæœ¬
function DFS_recursive(graph, node, visited = new Set()) {
    visited.add(node);
    console.log(node); // å¤„ç†å½“å‰èŠ‚ç‚¹

    for (let neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
            DFS_recursive(graph, neighbor, visited);
        }
    }
}`,

            python: `# Python å®ç° - è¿­ä»£ç‰ˆæœ¬
def dfs(graph, start):
    visited = set()
    stack = [start]
    result = []

    while stack:
        node = stack.pop()

        if node not in visited:
            visited.add(node)
            result.append(node)

            # é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result

# é€’å½’ç‰ˆæœ¬
def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()

    visited.add(node)
    print(node)  # å¤„ç†å½“å‰èŠ‚ç‚¹

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# ä½¿ç”¨ç¤ºä¾‹
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}
result = dfs(graph, 'A')`,

            cpp: `// C++ å®ç°
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_set>
#include <unordered_map>

using namespace std;

// è¿­ä»£ç‰ˆæœ¬
vector<int> DFS(unordered_map<int, vector<int>>& graph, int start) {
    unordered_set<int> visited;
    stack<int> stk;
    vector<int> result;

    stk.push(start);

    while (!stk.empty()) {
        int node = stk.top();
        stk.pop();

        if (visited.find(node) == visited.end()) {
            visited.insert(node);
            result.push_back(node);

            // é€†åºæ·»åŠ é‚»å±…
            for (int i = graph[node].size() - 1; i >= 0; i--) {
                int neighbor = graph[node][i];
                if (visited.find(neighbor) == visited.end()) {
                    stk.push(neighbor);
                }
            }
        }
    }

    return result;
}

// é€’å½’ç‰ˆæœ¬
void DFS_recursive(unordered_map<int, vector<int>>& graph,
                  int node, unordered_set<int>& visited) {
    visited.insert(node);
    cout << node << " ";  // å¤„ç†å½“å‰èŠ‚ç‚¹

    for (int neighbor : graph[node]) {
        if (visited.find(neighbor) == visited.end()) {
            DFS_recursive(graph, neighbor, visited);
        }
    }
}`,

            java: `// Java å®ç°
import java.util.*;

public class DFSImplementation {

    // è¿­ä»£ç‰ˆæœ¬
    public static List<Integer> DFS(Map<Integer, List<Integer>> graph, int start) {
        Set<Integer> visited = new HashSet<>();
        Stack<Integer> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();

        stack.push(start);

        while (!stack.isEmpty()) {
            int node = stack.pop();

            if (!visited.contains(node)) {
                visited.add(node);
                result.add(node);

                // é€†åºæ·»åŠ é‚»å±…ä»¥ä¿æŒæ­£ç¡®è®¿é—®é¡ºåº
                List<Integer> neighbors = graph.get(node);
                if (neighbors != null) {
                    for (int i = neighbors.size() - 1; i >= 0; i--) {
                        int neighbor = neighbors.get(i);
                        if (!visited.contains(neighbor)) {
                            stack.push(neighbor);
                        }
                    }
                }
            }
        }

        return result;
    }

    // é€’å½’ç‰ˆæœ¬
    public static void DFS_recursive(Map<Integer, List<Integer>> graph,
                                   int node, Set<Integer> visited) {
        visited.add(node);
        System.out.print(node + " ");  // å¤„ç†å½“å‰èŠ‚ç‚¹

        List<Integer> neighbors = graph.get(node);
        if (neighbors != null) {
            for (int neighbor : neighbors) {
                if (!visited.contains(neighbor)) {
                    DFS_recursive(graph, neighbor, visited);
                }
            }
        }
    }
}`
        };

        // ç”»å¸ƒè®¾ç½®
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            // è®¾ç½®æ ˆå¯è§†åŒ–ä½ç½®ï¼ˆå³ä¾§ï¼‰
            stackVisualization.x = rect.width - 150;
            stackVisualization.maxHeight = rect.height - 100;
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.state = 'unvisited'; // unvisited, visiting, visited
                this.visitOrder = -1;
            }

            draw() {
                ctx.save();

                // ç»˜åˆ¶èŠ‚ç‚¹
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // æ ¹æ®çŠ¶æ€è®¾ç½®é¢œè‰²
                let color;
                switch(this.state) {
                    case 'unvisited': color = '#e74c3c'; break;
                    case 'visiting': color = '#f39c12'; break;
                    case 'visited': color = '#2ecc71'; break;
                    case 'start': color = '#3498db'; break;
                }

                if (this.state === 'visiting') {
                    // è„‰å†²æ•ˆæœ
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                }

                ctx.fillStyle = color;
                ctx.fill();

                // è¾¹æ¡†
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();

                // å‘å…‰æ•ˆæœ
                if (this.state === 'visiting' || this.state === 'start') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = color;
                    ctx.fill();
                }

                ctx.restore();

                // ç»˜åˆ¶èŠ‚ç‚¹æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                // ç»˜åˆ¶è®¿é—®é¡ºåº
                if (this.visitOrder >= 0) {
                    ctx.fillStyle = '#ffdc00';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(this.visitOrder + 1, this.x + 20, this.y - 20);
                }
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        // è¾¹ç±»
        class Edge {
            constructor(from, to) {
                this.from = from;
                this.to = to;
                this.isActive = false;
            }

            draw() {
                const fromNode = nodes.find(n => n.id === this.from);
                const toNode = nodes.find(n => n.id === this.to);

                if (!fromNode || !toNode) return;

                ctx.save();

                // è®¡ç®—è¾¹çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆé¿å…ä¸èŠ‚ç‚¹é‡å ï¼‰
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;

                const startX = fromNode.x + unitX * fromNode.radius;
                const startY = fromNode.y + unitY * fromNode.radius;
                const endX = toNode.x - unitX * toNode.radius;
                const endY = toNode.y - unitY * toNode.radius;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);

                if (this.isActive) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#f39c12';
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                }

                ctx.stroke();
                ctx.restore();

                // ç»˜åˆ¶ç®­å¤´
                this.drawArrow(endX, endY, Math.atan2(dy, dx));
            }

            drawArrow(x, y, angle) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-15, -8);
                ctx.lineTo(-15, 8);
                ctx.closePath();

                if (this.isActive) {
                    ctx.fillStyle = '#f39c12';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                }
                ctx.fill();

                ctx.restore();
            }
        }

        // ç»˜åˆ¶å‡½æ•°
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            drawGrid();

            // ç»˜åˆ¶è¾¹
            edges.forEach(edge => edge.draw());

            // ç»˜åˆ¶èŠ‚ç‚¹
            nodes.forEach(node => node.draw());

            // ç»˜åˆ¶æ ˆå¯è§†åŒ–
            drawStackVisualization();

            requestAnimationFrame(draw);
        }

        function drawGrid() {
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            const gridSize = 30;
            const rect = canvas.getBoundingClientRect();
            const maxX = rect.width - 180; // ç»™æ ˆç•™å‡ºç©ºé—´

            for (let x = 0; x < maxX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, rect.height);
                ctx.stroke();
            }

            for (let y = 0; y < rect.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // æ ˆå¯è§†åŒ–ç»˜åˆ¶å‡½æ•°
        function drawStackVisualization() {
            const stack = stackVisualization;

            // ç»˜åˆ¶æ ˆå®¹å™¨èƒŒæ™¯
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.fillRect(stack.x - 10, stack.y - 10, stack.width + 20, stack.maxHeight + 20);
            ctx.strokeRect(stack.x - 10, stack.y - 10, stack.width + 20, stack.maxHeight + 20);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('DFS æ ˆ', stack.x + stack.width / 2, stack.y - 20);

            // ç»˜åˆ¶æ ˆåº•æŒ‡ç¤º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '12px Arial';
            ctx.fillText('æ ˆåº•', stack.x + stack.width / 2, stack.y + stack.maxHeight + 35);

            // ç»˜åˆ¶æ ˆé¡¶æŒ‡ç¤ºç®­å¤´ï¼ˆå¦‚æœæ ˆä¸ä¸ºç©ºï¼‰
            if (stack.items.length > 0) {
                const topY = stack.y + stack.maxHeight - stack.items.length * stack.itemHeight;
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.moveTo(stack.x - 25, topY + stack.itemHeight / 2);
                ctx.lineTo(stack.x - 10, topY + stack.itemHeight / 2 - 8);
                ctx.lineTo(stack.x - 10, topY + stack.itemHeight / 2 + 8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#f39c12';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('æ ˆé¡¶', stack.x - 30, topY + stack.itemHeight / 2 + 4);
            }

            ctx.restore();

            // ç»˜åˆ¶æ ˆä¸­çš„å…ƒç´ 
            stack.items.forEach((item, index) => {
                drawStackItem(item, index);
            });
        }

        function drawStackItem(item, index) {
            const stack = stackVisualization;
            let y = item.y || (stack.y + stack.maxHeight - (index + 1) * stack.itemHeight);

            ctx.save();

            // æ ¹æ®åŠ¨ç”»çŠ¶æ€è®¾ç½®é€æ˜åº¦å’Œç¼©æ”¾
            let alpha = 1;
            let scale = 1;

            if (item.animating) {
                if (item.action === 'push') {
                    alpha = Math.min(1, (Date.now() - item.animationStart) / 300);
                    scale = 0.5 + alpha * 0.5;
                } else if (item.action === 'pop') {
                    const progress = (Date.now() - item.animationStart) / 500;
                    alpha = Math.max(0, 1 - progress);
                    scale = 1 + progress * 0.5;
                    y = y - progress * 30; // å‘ä¸Šç§»åŠ¨
                }
            }

            ctx.globalAlpha = alpha;

            // ç»˜åˆ¶æ ˆå…ƒç´ èƒŒæ™¯
            const centerX = stack.x + stack.width / 2;
            const centerY = y + stack.itemHeight / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);

            // å…ƒç´ èƒŒæ™¯
            let gradient = ctx.createLinearGradient(-50, -15, 50, 15);
            if (item.action === 'push') {
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(1, '#4ecdc4');
            } else if (item.action === 'pop') {
                gradient.addColorStop(0, '#f39c12');
                gradient.addColorStop(1, '#e74c3c');
            } else {
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(-50, -15, 100, 30);

            // è¾¹æ¡†
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(-50, -15, 100, 30);

            // å‘å…‰æ•ˆæœ
            if (item.animating) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = item.action === 'push' ? '#4ecdc4' : '#f39c12';
                ctx.fillRect(-50, -15, 100, 30);
            }

            ctx.restore();

            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(item.value, centerX, centerY);

            ctx.restore();
        }

        // æ ˆåŠ¨ç”»å‡½æ•°
        function pushToStackVisualization(value) {
            const newItem = {
                value: value,
                animating: true,
                action: 'push',
                animationStart: Date.now()
            };

            stackVisualization.items.push(newItem);

            // åŠ¨ç”»ç»“æŸåç§»é™¤åŠ¨ç”»çŠ¶æ€
            setTimeout(() => {
                newItem.animating = false;
                newItem.action = null;
            }, 300);
        }

        function popFromStackVisualization() {
            if (stackVisualization.items.length === 0) return null;

            const item = stackVisualization.items[stackVisualization.items.length - 1];
            item.animating = true;
            item.action = 'pop';
            item.animationStart = Date.now();

            // åŠ¨ç”»ç»“æŸåç§»é™¤å…ƒç´ 
            setTimeout(() => {
                stackVisualization.items.pop();
            }, 500);

            return item;
        }

        function clearStackVisualization() {
            stackVisualization.items = [];
        }

        // é¢„è®¾å›¾ä¾‹
        function loadExample(type) {
            resetVisualization();

            switch(type) {
                case 'simple':
                    loadSimpleGraph();
                    break;
                case 'tree':
                    loadTreeGraph();
                    break;
                case 'cycle':
                    loadCycleGraph();
                    break;
                case 'complex':
                    loadComplexGraph();
                    break;
            }
        }

        function loadSimpleGraph() {
            nodes = [
                new Node('A', 100, 100),
                new Node('B', 250, 100),
                new Node('C', 100, 250),
                new Node('D', 250, 250)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'C'),
                new Edge('B', 'D'),
                new Edge('C', 'D')
            ];

            buildGraph();
        }

        function loadTreeGraph() {
            nodes = [
                new Node('A', 200, 80),
                new Node('B', 120, 180),
                new Node('C', 280, 180),
                new Node('D', 70, 280),
                new Node('E', 170, 280),
                new Node('F', 230, 280),
                new Node('G', 330, 280)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'C'),
                new Edge('B', 'D'),
                new Edge('B', 'E'),
                new Edge('C', 'F'),
                new Edge('C', 'G')
            ];

            buildGraph();
        }

        function loadCycleGraph() {
            const centerX = 180;
            const centerY = 180;
            const radius = 80;
            const nodeCount = 6;

            nodes = [];
            edges = [];

            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push(new Node(String.fromCharCode(65 + i), x, y));
            }

            for (let i = 0; i < nodeCount; i++) {
                const from = String.fromCharCode(65 + i);
                const to = String.fromCharCode(65 + (i + 1) % nodeCount);
                edges.push(new Edge(from, to));
            }

            buildGraph();
        }

        function loadComplexGraph() {
            nodes = [
                new Node('A', 100, 100),
                new Node('B', 250, 80),
                new Node('C', 400, 100),
                new Node('D', 150, 200),
                new Node('E', 300, 180),
                new Node('F', 350, 280),
                new Node('G', 200, 300),
                new Node('H', 450, 250)
            ];

            edges = [
                new Edge('A', 'B'),
                new Edge('A', 'D'),
                new Edge('B', 'C'),
                new Edge('B', 'E'),
                new Edge('C', 'E'),
                new Edge('C', 'H'),
                new Edge('D', 'G'),
                new Edge('E', 'F'),
                new Edge('F', 'G'),
                new Edge('F', 'H')
            ];

            buildGraph();
        }

        function buildGraph() {
            graph = {};
            nodes.forEach(node => {
                graph[node.id] = [];
            });

            edges.forEach(edge => {
                if (graph[edge.from]) {
                    graph[edge.from].push(edge.to);
                }
            });

            // æ›´æ–°å­˜å‚¨ç»“æ„æ˜¾ç¤º
            updateStorageStructure();
        }

        // å­˜å‚¨ç»“æ„ç›¸å…³å‡½æ•°
        function showAdjacencyList() {
            storageView = 'list';
            document.getElementById('listToggle').classList.add('active');
            document.getElementById('matrixToggle').classList.remove('active');
            document.getElementById('adjacencyListView').style.display = 'block';
            document.getElementById('adjacencyMatrixView').style.display = 'none';
            updateStorageStructure();
        }

        function showAdjacencyMatrix() {
            storageView = 'matrix';
            document.getElementById('matrixToggle').classList.add('active');
            document.getElementById('listToggle').classList.remove('active');
            document.getElementById('adjacencyListView').style.display = 'none';
            document.getElementById('adjacencyMatrixView').style.display = 'block';
            updateStorageStructure();
        }

        function updateStorageStructure() {
            if (storageView === 'list') {
                updateAdjacencyList();
            } else {
                updateAdjacencyMatrix();
            }
        }

        function updateAdjacencyList() {
            const container = document.getElementById('adjacencyListContent');
            if (nodes.length === 0) {
                container.innerHTML = 'é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥è¡¨';
                return;
            }

            let html = '';
            const sortedNodes = nodes.map(n => n.id).sort();

            sortedNodes.forEach(nodeId => {
                const neighbors = graph[nodeId] || [];
                const isHighlight = dfsState.currentNode === nodeId;
                const isVisited = dfsState.visited.has(nodeId);

                let listItemClass = 'list-item';
                if (isHighlight) listItemClass += ' highlight';
                else if (isVisited) listItemClass += ' visited';

                html += `<div class="${listItemClass}">`;
                html += `<span class="node-label">${nodeId}</span> â†’ `;

                if (neighbors.length === 0) {
                    html += `<span class="neighbors">[ ]</span>`;
                } else {
                    html += `<span class="neighbors">[ `;
                    neighbors.forEach((neighbor, index) => {
                        let neighborClass = 'neighbor-node';
                        if (dfsState.stack.includes(neighbor) && isHighlight) {
                            neighborClass += ' active';
                        } else if (dfsState.visited.has(neighbor)) {
                            neighborClass += ' visited';
                        }

                        html += `<span class="${neighborClass}">${neighbor}</span>`;
                        if (index < neighbors.length - 1) html += ', ';
                    });
                    html += ` ]</span>`;
                }
                html += '</div>';
            });

            container.innerHTML = html;
        }

        function updateAdjacencyMatrix() {
            const container = document.getElementById('adjacencyMatrixContent');
            if (nodes.length === 0) {
                container.innerHTML = 'é€‰æ‹©å›¾ä¾‹åæ˜¾ç¤ºé‚»æ¥çŸ©é˜µ';
                return;
            }

            const sortedNodes = nodes.map(n => n.id).sort();
            const size = sortedNodes.length;

            // æ„å»ºé‚»æ¥çŸ©é˜µ
            const matrix = {};
            sortedNodes.forEach(from => {
                matrix[from] = {};
                sortedNodes.forEach(to => {
                    matrix[from][to] = 0;
                });
            });

            edges.forEach(edge => {
                if (matrix[edge.from] && matrix[edge.from][edge.to] !== undefined) {
                    matrix[edge.from][edge.to] = 1;
                }
            });

            // ç”ŸæˆHTMLè¡¨æ ¼
            let html = '<table class="matrix-table">';

            // è¡¨å¤´
            html += '<tr><th></th>';
            sortedNodes.forEach(nodeId => {
                html += `<th>${nodeId}</th>`;
            });
            html += '</tr>';

            // è¡¨æ ¼å†…å®¹
            sortedNodes.forEach(fromNode => {
                html += `<tr><th>${fromNode}</th>`;
                sortedNodes.forEach(toNode => {
                    const value = matrix[fromNode][toNode];
                    let cellClass = '';

                    if (dfsState.currentNode === fromNode) {
                        cellClass = 'highlight';
                    } else if (dfsState.visited.has(fromNode)) {
                        cellClass = 'visited';
                    }

                    html += `<td class="${cellClass}">${value}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';

            container.innerHTML = html;
        }

        function updateCurrentOperation(operation) {
            document.getElementById('currentOperation').innerHTML = operation;
        }

        // ä»£ç è¯­è¨€åˆ‡æ¢åŠŸèƒ½
        function changeCodeLanguage(language) {
            currentLanguage = language;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === language) {
                    btn.classList.add('active');
                }
            });

            // æ›´æ–°ä»£ç æ˜¾ç¤º
            updateCodeDisplay();
        }

        function updateCodeDisplay() {
            const codeDisplay = document.getElementById('codeDisplay');
            codeDisplay.innerHTML = dfsCodeImplementations[currentLanguage];
        }

        // å¤åˆ¶ä»£ç åŠŸèƒ½
        async function copyCode() {
            const copyBtn = document.getElementById('copyBtn');
            const codeText = dfsCodePlainText[currentLanguage];

            try {
                await navigator.clipboard.writeText(codeText);

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                copyBtn.classList.add('copied');

                // 2ç§’åæ¢å¤åŸçŠ¶
                setTimeout(() => {
                    copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶';
                    copyBtn.classList.remove('copied');
                }, 2000);

            } catch (err) {
                // å¦‚æœclipboard APIä¸å¯ç”¨ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
                fallbackCopyTextToClipboard(codeText);
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                copyBtn.classList.add('copied');

                setTimeout(() => {
                    copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶';
                    copyBtn.classList.remove('copied');
                }, 2000);
            }
        }

        // å¤‡ç”¨å¤åˆ¶æ–¹æ³•
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;

            // é¿å…æ»šåŠ¨åˆ°åº•éƒ¨
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('æ— æ³•å¤åˆ¶ä»£ç ', err);
            }

            document.body.removeChild(textArea);
        }

        // ä½¿ç”¨è¯´æ˜æ¨¡æ€æ¡†æ§åˆ¶
        function showInstructions() {
            document.getElementById('instructionModal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
        }

        function hideInstructions() {
            document.getElementById('instructionModal').style.display = 'none';
            document.body.style.overflow = 'auto'; // æ¢å¤æ»šåŠ¨
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('instructionModal');
            if (e.target === modal) {
                hideInstructions();
            }
        });

        // æŒ‰ESCé”®å…³é—­æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideInstructions();
            }
        });

        // DFSç®—æ³•å®ç°
        async function startDFS() {
            if (!selectedNode) {
                updateStatus('è¯·å…ˆç‚¹å‡»é€‰æ‹©èµ·å§‹èŠ‚ç‚¹ï¼', 'ready');
                return;
            }

            isRunning = true;
            isPaused = false;
            updateControls();
            updateStatus('DFS æ‰§è¡Œä¸­...', 'running');

            // åˆå§‹åŒ–çŠ¶æ€
            dfsState = {
                visited: new Set(),
                stack: [selectedNode.id],
                currentNode: null,
                visitOrder: [],
                step: 0
            };

            selectedNode.state = 'start';

            // åˆå§‹åŒ–æ ˆå¯è§†åŒ–
            clearStackVisualization();
            pushToStackVisualization(selectedNode.id);

            updateStackDisplay();
            updateCurrentOperation(`ğŸš€ DFSå¼€å§‹ï¼èµ·å§‹èŠ‚ç‚¹: <strong>${selectedNode.id}</strong><br>ğŸ“¥ å°†èµ·å§‹èŠ‚ç‚¹å‹å…¥æ ˆ`);
            updateStorageStructure();

            await sleep(500); // ç»™ä¸€ç‚¹æ—¶é—´æ˜¾ç¤ºåˆå§‹çŠ¶æ€

            // æ‰§è¡ŒDFS
            await executeDFS();
        }

        async function executeDFS() {
            while (dfsState.stack.length > 0 && isRunning) {
                if (isPaused) {
                    await new Promise(resolve => {
                        const checkPause = () => {
                            if (!isPaused || !isRunning) {
                                resolve();
                            } else {
                                setTimeout(checkPause, 100);
                            }
                        };
                        checkPause();
                    });
                }

                if (!isRunning) break;

                await stepDFSInternal();
                await sleep(animationSpeed);
            }

            if (isRunning) {
                updateStatus('DFS å®Œæˆï¼', 'completed');
                updateCurrentOperation('ğŸ‰ DFSéå†å®Œæˆï¼æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹éƒ½å·²è®¿é—®ã€‚');
                isRunning = false;
                updateControls();
            }
        }

        async function stepDFSInternal() {
            if (dfsState.stack.length === 0) return false;

            const nodeId = dfsState.stack.pop();
            const node = nodes.find(n => n.id === nodeId);

            // æ ˆå¯è§†åŒ–å‡ºæ ˆåŠ¨ç”»
            popFromStackVisualization();

            updateCurrentOperation(`ğŸ” ä»æ ˆä¸­å¼¹å‡ºèŠ‚ç‚¹: <strong>${nodeId}</strong>`);
            updateStorageStructure();

            await sleep(animationSpeed / 3);

            if (!dfsState.visited.has(nodeId)) {
                updateCurrentOperation(`âœ… è®¿é—®èŠ‚ç‚¹ <strong>${nodeId}</strong> (é¦–æ¬¡è®¿é—®)`);

                // è®¿é—®èŠ‚ç‚¹
                dfsState.visited.add(nodeId);
                dfsState.visitOrder.push(nodeId);
                dfsState.currentNode = nodeId;

                if (node.state !== 'start') {
                    node.state = 'visiting';
                }
                node.visitOrder = dfsState.visitOrder.length - 1;

                // æ›´æ–°æ˜¾ç¤º
                updateStackDisplay();
                updateVisitedList();
                updateStorageStructure();

                await sleep(animationSpeed / 3);

                // æ·»åŠ é‚»å±…åˆ°æ ˆä¸­ï¼ˆé€†åºæ·»åŠ ä»¥ä¿æŒæ­£ç¡®çš„è®¿é—®é¡ºåºï¼‰
                const neighbors = graph[nodeId] || [];
                if (neighbors.length > 0) {
                    updateCurrentOperation(`ğŸ“‹ æ£€æŸ¥èŠ‚ç‚¹ <strong>${nodeId}</strong> çš„é‚»å±…: [${neighbors.join(', ')}]`);
                } else {
                    updateCurrentOperation(`ğŸ“‹ èŠ‚ç‚¹ <strong>${nodeId}</strong> æ²¡æœ‰é‚»å±…`);
                }

                await sleep(animationSpeed / 4);

                const unvisitedNeighbors = [];
                for (let i = neighbors.length - 1; i >= 0; i--) {
                    const neighbor = neighbors[i];
                    if (!dfsState.visited.has(neighbor)) {
                        unvisitedNeighbors.push(neighbor);
                        dfsState.stack.push(neighbor);

                        // æ ˆå¯è§†åŒ–å…¥æ ˆåŠ¨ç”»
                        pushToStackVisualization(neighbor);

                        updateCurrentOperation(`â¬†ï¸ å°†æœªè®¿é—®é‚»å±… <strong>${neighbor}</strong> å‹å…¥æ ˆ`);

                        // é«˜äº®è¾¹
                        const edge = edges.find(e => e.from === nodeId && e.to === neighbor);
                        if (edge) {
                            edge.isActive = true;
                            setTimeout(() => {
                                edge.isActive = false;
                            }, animationSpeed);
                        }

                        await sleep(animationSpeed / 4);
                    }
                }

                if (unvisitedNeighbors.length === 0) {
                    updateCurrentOperation(`âš ï¸ èŠ‚ç‚¹ <strong>${nodeId}</strong> çš„æ‰€æœ‰é‚»å±…éƒ½å·²è®¿é—®`);
                }

                await sleep(animationSpeed / 3);

                if (node.state !== 'start') {
                    node.state = 'visited';
                }

                updateCurrentOperation(`âœ¨ èŠ‚ç‚¹ <strong>${nodeId}</strong> å¤„ç†å®Œæˆ`);
            } else {
                updateCurrentOperation(`âš ï¸ èŠ‚ç‚¹ <strong>${nodeId}</strong> å·²è®¿é—®ï¼Œè·³è¿‡`);
            }

            updateStackDisplay();
            updateStorageStructure();
            return true;
        }

        function stepDFS() {
            if (isRunning && !isPaused) return;

            if (!selectedNode) {
                updateStatus('è¯·å…ˆé€‰æ‹©èµ·å§‹èŠ‚ç‚¹ï¼', 'ready');
                return;
            }

            if (dfsState.stack.length === 0 && dfsState.visitOrder.length === 0) {
                // åˆå§‹åŒ–
                dfsState = {
                    visited: new Set(),
                    stack: [selectedNode.id],
                    currentNode: null,
                    visitOrder: [],
                    step: 0
                };
                selectedNode.state = 'start';

                // åˆå§‹åŒ–æ ˆå¯è§†åŒ–
                clearStackVisualization();
                pushToStackVisualization(selectedNode.id);

                updateStackDisplay();
                updateCurrentOperation(`ğŸš€ å•æ­¥æ¨¡å¼å¼€å§‹ï¼èµ·å§‹èŠ‚ç‚¹: <strong>${selectedNode.id}</strong><br>ğŸ“¥ å°†èµ·å§‹èŠ‚ç‚¹å‹å…¥æ ˆ`);
                updateStorageStructure();
                updateStatus('å•æ­¥æ¨¡å¼ - æŒ‰ä¸‹"å•æ­¥æ‰§è¡Œ"ç»§ç»­', 'running');
            } else {
                stepDFSInternal();
                if (dfsState.stack.length === 0) {
                    updateStatus('DFS å®Œæˆï¼', 'completed');
                    updateCurrentOperation('ğŸ‰ DFSéå†å®Œæˆï¼æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹éƒ½å·²è®¿é—®ã€‚');
                }
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';

            if (!isPaused && isRunning) {
                executeDFS();
            }
        }

        function resetVisualization() {
            isRunning = false;
            isPaused = false;
            selectedNode = null;

            // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
            nodes.forEach(node => {
                node.state = 'unvisited';
                node.visitOrder = -1;
            });

            // é‡ç½®æ‰€æœ‰è¾¹çŠ¶æ€
            edges.forEach(edge => {
                edge.isActive = false;
            });

            // é‡ç½®DFSçŠ¶æ€
            dfsState = {
                visited: new Set(),
                stack: [],
                currentNode: null,
                visitOrder: [],
                step: 0
            };

            // æ¸…ç©ºæ ˆå¯è§†åŒ–
            clearStackVisualization();

            updateControls();
            updateStackDisplay();
            updateVisitedList();
            updateStorageStructure();
            updateCurrentOperation('ç­‰å¾…å¼€å§‹DFS...');
            updateStatus('å‡†å¤‡å¼€å§‹ - é€‰æ‹©èµ·å§‹èŠ‚ç‚¹', 'ready');
        }

        // UIæ›´æ–°å‡½æ•°
        function updateControls() {
            document.getElementById('startBtn').disabled = isRunning || !selectedNode;
            document.getElementById('pauseBtn').disabled = !isRunning;
            document.getElementById('stepBtn').disabled = isRunning && !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-indicator status-${type}`;
        }

        function updateStackDisplay() {
            const stackEl = document.getElementById('stackDisplay');
            if (dfsState.stack.length === 0) {
                stackEl.innerHTML = 'æ ˆä¸ºç©º';
            } else {
                stackEl.innerHTML = dfsState.stack
                    .slice()
                    .reverse()
                    .map(nodeId => `<span class="stack-item">${nodeId}</span>`)
                    .join('');
            }
        }

        function updateVisitedList() {
            const visitedEl = document.getElementById('visitedList');
            if (dfsState.visitOrder.length === 0) {
                visitedEl.innerHTML = 'å°šæœªå¼€å§‹';
            } else {
                visitedEl.innerHTML = dfsState.visitOrder
                    .map((nodeId, index) => `<span class="visited-node">${index + 1}. ${nodeId}</span>`)
                    .join('');
            }
        }

        // å·¥å…·å‡½æ•°
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // äº‹ä»¶ç›‘å¬
        canvas.addEventListener('click', (e) => {
            if (isRunning) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹
            const clickedNode = nodes.find(node => node.contains(x, y));

            if (clickedNode) {
                // é‡ç½®ä¹‹å‰é€‰æ‹©çš„èŠ‚ç‚¹
                if (selectedNode) {
                    selectedNode.state = 'unvisited';
                }

                selectedNode = clickedNode;
                selectedNode.state = 'start';
                updateStatus(`å·²é€‰æ‹©èµ·å§‹èŠ‚ç‚¹: ${selectedNode.id}`, 'ready');
                updateControls();
            }
        });

        // é€Ÿåº¦æ§åˆ¶
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            animationSpeed = 2000 - (speed - 1) * 180; // 200ms to 1800ms
            document.getElementById('speedValue').textContent = speed;
        });

        // åˆå§‹åŒ–
        window.addEventListener('load', () => {
            resizeCanvas();
            loadExample('simple');
            updateCodeDisplay(); // åˆå§‹åŒ–ä»£ç æ˜¾ç¤º
            draw();
        });

        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>