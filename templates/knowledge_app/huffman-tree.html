{% extends 'knowledge_app/base.html' %}

{% block title %}{{ page_title|default:"哈夫曼树" }} - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>{{ breadcrumb_category|default:"数据结构" }}</span><span>></span><span>{{ page_title|default:"哈夫曼树" }}</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">{{ page_icon|default:"🌳" }}</span>
            {{ page_title|default:"哈夫曼树" }}
        </h1><p>{{ page_description|default:"数据压缩的艺术 - 可视化学习最优编码算法" }}</p></div><!-- 知识点概述 --><div class="content-card slide-in-right"><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                知识点概述
            </h2><div class="info-box info-box-info" style="margin: 20px 0;"><span class="info-icon">💡</span><strong>核心概念：</strong>哈夫曼树是一种用于数据压缩的特殊二叉树，通过给出现频率高的字符分配短编码，频率低的字符分配长编码，从而实现最优的压缩效果。
            </div><div class="unified-grid unified-grid-2"><div class="grid-card"><span class="card-icon">🏷️</span><h4 class="card-title">哈夫曼编码</h4><p class="card-description">基于字符出现频率的可变长度编码方式</p></div><div class="grid-card"><span class="card-icon">📊</span><h4 class="card-title">优先队列</h4><p class="card-description">按频率从小到大排序的数据结构</p></div><div class="grid-card"><span class="card-icon">🌿</span><h4 class="card-title">叶子节点</h4><p class="card-description">存储原始字符和频率的终端节点</p></div><div class="grid-card"><span class="card-icon">⚖️</span><h4 class="card-title">最优性</h4><p class="card-description">保证编码总长度最短的贪心算法</p></div></div><div class="unified-grid unified-grid-3" style="margin-top: 20px;"><div class="info-box info-box-success"><span class="info-icon">⭐</span><strong>学习难度：</strong>进阶级别
                </div><div class="info-box info-box-warning"><span class="info-icon">📚</span><strong>前置知识：</strong>二叉树、优先队列、贪心算法
                </div><div class="info-box info-box-info"><span class="info-icon">⏱️</span><strong>学习时长：</strong>约2-3小时
                </div></div></div></div><!-- 概念详解 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🔍</span>
                概念详解
            </h2><h3 style="color: #4a5568; margin: 25px 0 15px 0;">1. 💡 基本思想</h3><div class="info-box info-box-success"><span class="info-icon">🏠</span><strong>生活类比：</strong>想象你在整理书架，经常看的书放在容易拿到的地方（短路径），偶尔看的书放在高处（长路径）。哈夫曼树也是这样，常用字符用短编码，少用字符用长编码。
            </div><h3 style="color: #4a5568; margin: 25px 0 15px 0;">2. 🏗️ 构建过程</h3><ol style="padding-left: 20px; line-height: 1.8;"><li><strong>统计频率：</strong>计算每个字符出现的次数</li><li><strong>建立队列：</strong>将所有字符按频率从小到大排序</li><li><strong>合并操作：</strong>重复取出频率最小的两个节点，合并成新节点</li><li><strong>构成树形：</strong>直到只剩一个节点，即为根节点</li><li><strong>布局优化：</strong>调整为标准二叉树形状</li></ol><h3 style="color: #4a5568; margin: 25px 0 15px 0;">3. 🆚 与其他编码的对比</h3><div class="unified-grid unified-grid-2"><div class="info-box info-box-warning"><span class="info-icon">🔤</span><strong>ASCII编码：</strong>固定8位长度，适用于标准文本，效率一般
                </div><div class="info-box info-box-success"><span class="info-icon">🎯</span><strong>哈夫曼编码：</strong>可变1-n位长度，适用于数据压缩，效率最优
                </div></div><h3 style="color: #4a5568; margin: 25px 0 15px 0;">4. ⚠️ 易混淆点</h3><ul style="padding-left: 20px; line-height: 1.8;"><li><strong>编码唯一性：</strong>哈夫曼编码具有前缀性质，任何编码都不是另一个的前缀</li><li><strong>树的构建：</strong>总是合并频率最小的两个节点，而不是任意两个</li><li><strong>左右子树：</strong>通常约定左子树为0，右子树为1（也可反过来）</li></ul></div></div><!-- 可视化展示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                可视化展示
            </h2><div id="huffman-visualization" style="background: linear-gradient(to bottom, #f8f9ff 0%, #e8f4fd 100%); border-radius: 15px; padding: 25px; margin: 20px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.1);"><h3 style="text-align: center; color: #4a5568; margin-bottom: 20px;">🎮 交互式哈夫曼树构建演示</h3><div style="text-align: center; margin: 20px 0;"><input type="text" id="inputData" placeholder="格式: A:5,B:3,C:2,D:1" value="A:5,B:3,C:2,D:1"
                           style="padding: 12px 20px; margin: 0 10px; border: 2px solid #e2e8f0; border-radius: 25px; font-size: 16px; min-width: 300px;"><button class="unified-btn unified-btn-primary" onclick="parseInput()"><span>📊</span> 解析数据
                    </button></div><div style="text-align: center; margin: 20px 0;"><button class="unified-btn unified-btn-success" onclick="startAnimation()"><span>🚀</span> 开始构建
                    </button><button class="unified-btn unified-btn-secondary" onclick="resetAnimation()"><span>🔄</span> 重置
                    </button><button class="unified-btn unified-btn-primary" onclick="nextStep()" id="nextBtn" disabled><span>⭐️</span> 下一步
                    </button><button class="unified-btn unified-btn-warning" onclick="autoPlay()" id="autoBtn" disabled><span>▶️</span> 自动播放
                    </button></div><div class="info-box info-box-info" id="status" style="text-align: center; margin: 20px 0;">
                    请输入数据并点击"解析数据"开始
                </div><div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 10px; margin: 15px 0;"><h4 style="margin-top: 0; color: #4a5568;">📋 当前队列状态：</h4><div id="queueDisplay" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 10px 0;"></div></div><canvas id="canvas" width="1000" height="500" style="border-radius: 10px; display: block; margin: 0 auto; box-shadow: 0 5px 15px rgba(0,0,0,0.1);"></canvas><div class="info-box info-box-success" style="margin-top: 20px;"><span class="info-icon">💡</span><strong>操作提示：</strong><ul style="margin: 10px 0; padding-left: 20px;"><li>🔤 输入格式：字符:频率，用逗号分隔（如：A:5,B:3,C:2）</li><li>👀 观察队列变化：红色表示当前选中的节点</li><li>🎨 最终布局：蓝色连线表示左子树(0)，绿色表示右子树(1)</li></ul></div></div></div></div><!-- 实际应用 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌟</span>
                实际应用
            </h2><h3 style="color: #4a5568; margin: 25px 0 15px 0;">1. 📁 数据压缩领域</h3><div class="unified-grid unified-grid-3"><div class="grid-card"><span class="card-icon">📦</span><h4 class="card-title">ZIP压缩</h4><p class="card-description">文件压缩软件的核心算法之一</p></div><div class="grid-card"><span class="card-icon">🖼️</span><h4 class="card-title">JPEG图像</h4><p class="card-description">图像压缩中用于压缩颜色信息</p></div><div class="grid-card"><span class="card-icon">🎵</span><h4 class="card-title">MP3音频</h4><p class="card-description">音频压缩中的重要组成部分</p></div></div><h3 style="color: #4a5568; margin: 25px 0 15px 0;">2. 🌐 网络传输案例</h3><div class="info-box info-box-success"><span class="info-icon">🚀</span><strong>典型案例：</strong>网页传输时，服务器使用Gzip压缩（基于哈夫曼编码）可以将HTML文件大小减少60-80%，大大提升加载速度。用户访问网页时感受到的快速加载，背后就有哈夫曼算法的贡献。
            </div><h3 style="color: #4a5568; margin: 25px 0 15px 0;">3. 💻 代码实现</h3><div style="margin: 20px 0;"><div style="display: flex; background: #f7fafc; border-radius: 8px 8px 0 0; overflow: hidden;"><button class="code-tab active" onclick="showCode('cpp')" style="padding: 12px 20px; background: #667eea; color: white; border: none; cursor: pointer; font-weight: bold; transition: all 0.3s;">C++</button><button class="code-tab" onclick="showCode('java')" style="padding: 12px 20px; background: #e2e8f0; border: none; cursor: pointer; font-weight: bold; transition: all 0.3s;">Java</button><button class="code-tab" onclick="showCode('python')" style="padding: 12px 20px; background: #e2e8f0; border: none; cursor: pointer; font-weight: bold; transition: all 0.3s;">Python</button></div><div id="cpp-code" class="code-content" style="background: #2d3748; color: #f7fafc; padding: 20px; border-radius: 0 0 8px 8px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; position: relative; overflow-x: auto;"><button class="copy-btn" onclick="copyCode('cpp')" style="position: absolute; top: 10px; right: 10px; background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;">📋 复制</button><pre style="margin: 0; white-space: pre-wrap;">struct HuffmanNode {
    char data;
    int freq;
    HuffmanNode* left;
    HuffmanNode* right;

    HuffmanNode(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {}
};

class Compare {
public:
    bool operator()(HuffmanNode* a, HuffmanNode* b) {
        return a->freq > b->freq; // 最小堆
    }
};

HuffmanNode* buildHuffmanTree(vector&lt;pair&lt;char, int&gt;&gt;& chars) {
    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; pq;

    // 创建叶子节点
    for (auto& p : chars) {
        pq.push(new HuffmanNode(p.first, p.second));
    }

    // 构建哈夫曼树
    while (pq.size() > 1) {
        HuffmanNode* left = pq.top(); pq.pop();
        HuffmanNode* right = pq.top(); pq.pop();

        HuffmanNode* merged = new HuffmanNode('\0', left->freq + right->freq);
        merged->left = left;
        merged->right = right;

        pq.push(merged);
    }

    return pq.top();
}</pre></div><div id="java-code" class="code-content" style="background: #2d3748; color: #f7fafc; padding: 20px; border-radius: 0 0 8px 8px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; position: relative; overflow-x: auto; display: none;"><button class="copy-btn" onclick="copyCode('java')" style="position: absolute; top: 10px; right: 10px; background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;">📋 复制</button><pre style="margin: 0; white-space: pre-wrap;">class HuffmanNode {
    char data;
    int freq;
    HuffmanNode left, right;

    public HuffmanNode(char data, int freq) {
        this.data = data;
        this.freq = freq;
        this.left = this.right = null;
    }
}

public class HuffmanTree {
    public static HuffmanNode buildHuffmanTree(Map&lt;Character, Integer&gt; freqMap) {
        PriorityQueue&lt;HuffmanNode&gt; pq = new PriorityQueue&lt;&gt;(
            (a, b) -&gt; Integer.compare(a.freq, b.freq)
        );

        // 创建叶子节点
        for (Map.Entry&lt;Character, Integer&gt; entry : freqMap.entrySet()) {
            pq.offer(new HuffmanNode(entry.getKey(), entry.getValue()));
        }

        // 构建哈夫曼树
        while (pq.size() > 1) {
            HuffmanNode left = pq.poll();
            HuffmanNode right = pq.poll();

            HuffmanNode merged = new HuffmanNode('\0', left.freq + right.freq);
            merged.left = left;
            merged.right = right;

            pq.offer(merged);
        }

        return pq.poll();
    }
}</pre></div><div id="python-code" class="code-content" style="background: #2d3748; color: #f7fafc; padding: 20px; border-radius: 0 0 8px 8px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; position: relative; overflow-x: auto; display: none;"><button class="copy-btn" onclick="copyCode('python')" style="position: absolute; top: 10px; right: 10px; background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;">📋 复制</button><pre style="margin: 0; white-space: pre-wrap;">import heapq
from collections import defaultdict

class HuffmanNode:
    def __init__(self, char=None, freq=0, left=None, right=None):
        self.char = char
        self.freq = freq
        self.left = left
        self.right = right

    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(freq_dict):
    # 创建优先队列（最小堆）
    heap = [HuffmanNode(char, freq) for char, freq in freq_dict.items()]
    heapq.heapify(heap)

    # 构建哈夫曼树
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        merged = HuffmanNode(freq=left.freq + right.freq, left=left, right=right)
        heapq.heappush(heap, merged)

    return heap[0]

def get_huffman_codes(root):
    if not root:
        return {}

    codes = {}

    def dfs(node, code=""):
        if node.char:  # 叶子节点
            codes[node.char] = code or "0"  # 处理只有一个字符的情况
            return

        if node.left:
            dfs(node.left, code + "0")
        if node.right:
            dfs(node.right, code + "1")

    dfs(root)
    return codes</pre></div></div><h3 style="color: #4a5568; margin: 25px 0 15px 0;">5. 🛠️ 推荐学习工具</h3><div class="unified-grid unified-grid-3"><div class="grid-card"><span class="card-icon">👁️</span><h4 class="card-title">在线可视化</h4><p class="card-description">VisuAlgo、Algorithm Visualizer</p></div><div class="grid-card"><span class="card-icon">💻</span><h4 class="card-title">编程练习</h4><p class="card-description">LeetCode第622题"哈夫曼编码"</p></div><div class="grid-card"><span class="card-icon">📁</span><h4 class="card-title">压缩工具</h4><p class="card-description">7-Zip（可观察压缩效果）</p></div></div></div></div><!-- 学习检验 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">✅</span>
                学习检验
            </h2><div class="question-card" style="background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 10px; margin: 15px 0; overflow: hidden;"><div class="question-header" onclick="toggleQuestion(1)" style="background: #667eea; color: white; padding: 15px; cursor: pointer; font-weight: bold; display: flex; justify-content: space-between; align-items: center;"><span>❓ 问题1：为什么哈夫曼编码是最优的？</span><span id="arrow-1">▼</span></div><div class="question-content" id="question-1" style="padding: 15px; display: none; background: white; border-top: 1px solid #e2e8f0;"><p style="margin-bottom: 15px;">请解释哈夫曼编码在什么意义下是"最优"的，以及这种最优性是如何保证的。</p><button class="unified-btn unified-btn-success" onclick="showAnswer(1)"><span>💡</span> 查看答案
                    </button><div class="answer" id="answer-1" style="background: #f0fff4; border: 1px solid #9ae6b4; border-radius: 5px; padding: 15px; margin-top: 15px; display: none;"><p><strong>答案：</strong>哈夫曼编码在"平均编码长度最短"这个意义下是最优的。具体体现在：</p><ul style="padding-left: 20px; margin: 10px 0;"><li><strong>贪心策略：</strong>每次合并频率最小的两个节点，保证高频字符路径更短</li><li><strong>数学证明：</strong>任何其他编码方案的平均长度都不会比哈夫曼编码更短</li><li><strong>前缀性质：</strong>保证编码的唯一可解性，避免歧义</li></ul><p>这种最优性是通过贪心算法的正确性来保证的，每一步都做出当前最优选择。</p></div></div></div><div class="question-card" style="background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 10px; margin: 15px 0; overflow: hidden;"><div class="question-header" onclick="toggleQuestion(2)" style="background: #667eea; color: white; padding: 15px; cursor: pointer; font-weight: bold; display: flex; justify-content: space-between; align-items: center;"><span>❓ 问题2：如果所有字符频率相同，哈夫曼树是什么样的？</span><span id="arrow-2">▼</span></div><div class="question-content" id="question-2" style="padding: 15px; display: none; background: white; border-top: 1px solid #e2e8f0;"><p style="margin-bottom: 15px;">假设有4个字符A、B、C、D，频率都是1，构建的哈夫曼树有什么特点？编码长度如何？</p><button class="unified-btn unified-btn-success" onclick="showAnswer(2)"><span>💡</span> 查看答案
                    </button><div class="answer" id="answer-2" style="background: #f0fff4; border: 1px solid #9ae6b4; border-radius: 5px; padding: 15px; margin-top: 15px; display: none;"><p><strong>答案：</strong>频率相同时，哈夫曼树具有以下特点：</p><ul style="padding-left: 20px; margin: 10px 0;"><li><strong>近似完全二叉树：</strong>树会尽可能平衡</li><li><strong>编码长度一致：</strong>所有字符的编码长度都相等或最多相差1</li><li><strong>不唯一性：</strong>可能有多种合法的哈夫曼树结构</li></ul><p>对于4个字符，每个字符的编码长度都是2位，与固定长度编码相同，此时哈夫曼编码的优势不明显。</p></div></div></div><div class="question-card" style="background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 10px; margin: 15px 0; overflow: hidden;"><div class="question-header" onclick="toggleQuestion(3)" style="background: #667eea; color: white; padding: 15px; cursor: pointer; font-weight: bold; display: flex; justify-content: space-between; align-items: center;"><span>❓ 问题3：哈夫曼编码如何处理只有一个字符的情况？</span><span id="arrow-3">▼</span></div><div class="question-content" id="question-3" style="padding: 15px; display: none; background: white; border-top: 1px solid #e2e8f0;"><p style="margin-bottom: 15px;">如果待编码的文本只包含一种字符（比如"AAAA"），哈夫曼算法会如何处理？</p><button class="unified-btn unified-btn-success" onclick="showAnswer(3)"><span>💡</span> 查看答案
                    </button><div class="answer" id="answer-3" style="background: #f0fff4; border: 1px solid #9ae6b4; border-radius: 5px; padding: 15px; margin-top: 15px; display: none;"><p><strong>答案：</strong>只有一个字符时需要特殊处理：</p><ul style="padding-left: 20px; margin: 10px 0;"><li><strong>问题：</strong>无法构建二叉树（至少需要2个节点）</li><li><strong>解决方案1：</strong>人为添加一个频率为0的虚拟字符</li><li><strong>解决方案2：</strong>直接给该字符分配编码"0"或"1"</li><li><strong>实际应用：</strong>大多数压缩算法会检测这种情况并使用固定编码</li></ul><p>这是哈夫曼算法的一个边界情况，需要在实现时特殊考虑。</p></div></div></div><div class="question-card" style="background: #f7fafc; border: 2px solid #e2e8f0; border-radius: 10px; margin: 15px 0; overflow: hidden;"><div class="question-header" onclick="toggleQuestion(4)" style="background: #667eea; color: white; padding: 15px; cursor: pointer; font-weight: bold; display: flex; justify-content: space-between; align-items: center;"><span>❓ 问题4：时间复杂度分析</span><span id="arrow-4">▼</span></div><div class="question-content" id="question-4" style="padding: 15px; display: none; background: white; border-top: 1px solid #e2e8f0;"><p style="margin-bottom: 15px;">构建哈夫曼树的时间复杂度是多少？请分析每个步骤的复杂度。</p><button class="unified-btn unified-btn-success" onclick="showAnswer(4)"><span>💡</span> 查看答案
                    </button><div class="answer" id="answer-4" style="background: #f0fff4; border: 1px solid #9ae6b4; border-radius: 5px; padding: 15px; margin-top: 15px; display: none;"><p><strong>答案：</strong>总时间复杂度为 <strong>O(n log n)</strong>，分析如下：</p><ul style="padding-left: 20px; margin: 10px 0;"><li><strong>初始化堆：</strong>O(n)，n为不同字符数</li><li><strong>合并操作：</strong>进行n-1次合并</li><li><strong>每次合并：</strong>2次出队 + 1次入队 = O(log n)</li><li><strong>总体复杂度：</strong>(n-1) × O(log n) = O(n log n)</li></ul><p>空间复杂度为O(n)，主要用于存储树节点和优先队列。</p></div></div></div></div></div><!-- 学习检验 --><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><style>.queue-item {background:rgba(76, 175, 80, 0.8);color:white;padding:8px 12px;border-radius:20px;font-family:monospace;font-weight:bold;display:inline-block}.queue-item.selected {background:rgba(239, 68, 68, 0.9);animation:pulse 1s infinite}@keyframes pulse {0%, 100% {transform:scale(1)}50% {transform:scale(1.1)}}.code-tab {transition:all 0.3s ease}.code-tab:hover {background:#a0aec0 !important}.code-tab.active {background:#667eea !important;color:white !important}.copy-btn:hover {background:#2d3748 !important;transform:translateY(-1px)}.question-header:hover {background:#5a67d8 !important}</style><script>const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const status = document.getElementById('status'); class HuffmanNode { constructor(char = null, freq = 0, left = null, right = null) { this.char = char; this.freq = freq; this.left = left; this.right = right; this.x = 0; this.y = 0; this.targetX = 0; this.targetY = 0; this.id = Math.random().toString(36).substr(2, 9); this.isLeaf = char !== null; this.highlight = false; this.isNew = false; this.visible = true; this.animating = false; this.subtreeWidth = 0; } isAnimating() { const threshold = 2; return Math.abs(this.x - this.targetX) > threshold || Math.abs(this.y - this.targetY) > threshold; } } class PriorityQueue { constructor() { this.items = []; } enqueue(node) { if (this.items.length === 0) { this.items.push(node); } else { let added = false; for (let i = 0; i < this.items.length; i++) { if (node.freq < this.items[i].freq || (node.freq === this.items[i].freq && node.id < this.items[i].id)) { this.items.splice(i, 0, node); added = true; break; } } if (!added) { this.items.push(node); } } } dequeue() { return this.items.shift(); } size() { return this.items.length; } toArray() { return [...this.items]; } } let originalData = []; let queue = new PriorityQueue(); let allNodes = []; let currentStep = 0; let isAnimating = false; let isAutoPlaying = false; let selectedNodes = []; let animationFrame = null; let isLayoutOptimizing = false; function parseInput() { const input = document.getElementById('inputData').value.trim(); if (!input) { status.textContent = "❌ 请输入数据"; status.className = "info-box info-box-error"; return; } try { originalData = []; const pairs = input.split(','); pairs.forEach(pair => { const [char, freqStr] = pair.split(':'); const freq = parseInt(freqStr.trim()); if (isNaN(freq)) { throw new Error(`无效的频率值: ${freqStr}`); } originalData.push({ char: char.trim(), freq }); }); if (originalData.length < 2) { throw new Error("至少需要两个字符"); } originalData.sort((a, b) => a.freq - b.freq); status.textContent = `✅ 解析成功！${originalData.length} 个字符已按频率排序`; status.className = "info-box info-box-success"; displayQueue(); } catch (error) { status.textContent = `❌ ${error.message}`; status.className = "info-box info-box-error"; } } function startAnimation() { if (originalData.length < 2) { status.textContent = "❌ 请先解析数据"; status.className = "info-box info-box-error"; return; } queue = new PriorityQueue(); allNodes = []; selectedNodes = []; currentStep = 0; isAnimating = false; isAutoPlaying = false; isLayoutOptimizing = false; originalData.forEach((data, index) => { const node = new HuffmanNode(data.char, data.freq); allNodes.push(node); queue.enqueue(node); }); layoutInitialNodes(); status.textContent = "🚀 开始构建哈夫曼树 - 初始状态"; status.className = "info-box info-box-info"; document.getElementById('nextBtn').disabled = false; document.getElementById('autoBtn').disabled = false; displayQueue(); startDrawLoop(); } function layoutInitialNodes() { const nodes = queue.toArray(); const spacing = (canvas.width - 200) / (nodes.length + 1); const y = canvas.height - 80; nodes.forEach((node, index) => { node.x = node.targetX = 100 + spacing * (index + 1); node.y = node.targetY = y; node.visible = true; node.highlight = false; node.isNew = false; }); } function nextStep() { if (queue.size() <= 1) { if (!isLayoutOptimizing) { optimizeTreeLayout(); } else { status.textContent = "🎉 哈夫曼树构建完成！标准二叉树布局已优化"; status.className = "info-box info-box-success"; document.getElementById('nextBtn').disabled = true; document.getElementById('autoBtn').disabled = true; isAutoPlaying = false; } return; } if (isAnimating) return; currentStep++; const left = queue.dequeue(); const right = queue.dequeue(); selectedNodes = [left, right]; left.highlight = true; right.highlight = true; status.textContent = `🎯 第${currentStep}步：选择最小的两个节点 ${left.char || 'N'}(${left.freq}) 和 ${right.char || 'N'}(${right.freq})`; status.className = "info-box info-box-warning"; displayQueue(); setTimeout(() => { mergeNodes(left, right); }, 1500); } function mergeNodes(left, right) { isAnimating = true; const mergeLevel = Math.max(getNodeLevel(left), getNodeLevel(right)) + 1; const mergeY = canvas.height - 80 - (mergeLevel * 70); const childY = mergeY + 70; const centerX = (left.x + right.x) / 2; const spacing = 100; left.targetX = centerX - spacing / 2; left.targetY = childY; right.targetX = centerX + spacing / 2; right.targetY = childY; status.textContent = `🔄 第${currentStep}步：将 ${left.char || 'N'}(${left.freq}) 和 ${right.char || 'N'}(${right.freq}) 移动到同一水平线`; Promise.all([ animateNodeToPositionPromise(left), animateNodeToPositionPromise(right) ]).then(() => { const merged = new HuffmanNode(null, left.freq + right.freq, left, right); merged.targetX = centerX; merged.targetY = mergeY; merged.x = centerX; merged.y = childY; merged.isNew = true; merged.visible = true; allNodes.push(merged); queue.enqueue(merged); status.textContent = `✨ 第${currentStep}步：创建新节点(${merged.freq})`; animateNodeToPosition(merged, () => { left.highlight = false; right.highlight = false; merged.isNew = false; selectedNodes = []; isAnimating = false; status.textContent = `✅ 第${currentStep}步完成：${left.char || 'N'}(${left.freq}) + ${right.char || 'N'}(${right.freq}) → 新节点(${merged.freq})`; status.className = "info-box info-box-success"; displayQueue(); if (isAutoPlaying && (queue.size() > 1 || !isLayoutOptimizing)) { setTimeout(() => nextStep(), 1000); } }); }); } function getNodeLevel(node) { if (!node.left && !node.right) { return 0; } const leftLevel = node.left ? getNodeLevel(node.left) : -1; const rightLevel = node.right ? getNodeLevel(node.right) : -1; return Math.max(leftLevel, rightLevel) + 1; } function animateNodeToPositionPromise(node) { return new Promise((resolve) => { animateNodeToPosition(node, resolve); }); } function animateNodeToPosition(node, callback) { const animate = () => { const dx = node.targetX - node.x; const dy = node.targetY - node.y; const speed = 0.12; if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { node.x += dx * speed; node.y += dy * speed; requestAnimationFrame(animate); } else { node.x = node.targetX; node.y = node.targetY; if (callback) callback(); } }; animate(); } function optimizeTreeLayout() { if (queue.size() !== 1) return; isLayoutOptimizing = true; status.textContent = "🎨 优化中：正在调整为标准二叉树布局..."; status.className = "info-box info-box-warning"; const root = queue.items[0]; calculateStandardBinaryTreeLayout(root); animateAllNodesToStandardLayout(() => { status.textContent = "🌟 布局优化完成！点击下一步查看最终结果"; status.className = "info-box info-box-info"; isLayoutOptimizing = false; if (isAutoPlaying) { setTimeout(() => nextStep(), 2000); } }); } function calculateStandardBinaryTreeLayout(root) { calculateSubtreeWidths(root); const treeWidth = root.subtreeWidth; const canvasMargin = 40; const availableWidth = canvas.width - 2 * canvasMargin; const treeHeight = getTreeHeight(root); const levelHeight = Math.max(70, (canvas.height - 100) / (treeHeight + 1)); assignNodePositions(root, canvasMargin, canvasMargin + availableWidth, 40, levelHeight); } function calculateSubtreeWidths(node) { if (!node) return 0; if (node.isLeaf) { node.subtreeWidth = 1; return 1; } const leftWidth = node.left ? calculateSubtreeWidths(node.left) : 0; const rightWidth = node.right ? calculateSubtreeWidths(node.right) : 0; node.subtreeWidth = leftWidth + rightWidth; return node.subtreeWidth; } function getTreeHeight(node) { if (!node) return -1; if (node.isLeaf) return 0; const leftHeight = node.left ? getTreeHeight(node.left) : -1; const rightHeight = node.right ? getTreeHeight(node.right) : -1; return Math.max(leftHeight, rightHeight) + 1; } function assignNodePositions(node, leftBound, rightBound, y, levelHeight) { if (!node) return leftBound; let currentX = leftBound; if (node.isLeaf) { node.targetX = (leftBound + rightBound) / 2; node.targetY = y; return rightBound; } const nextY = y + levelHeight; let leftChildEnd = currentX; let rightChildStart = currentX; if (node.left) { const leftWidth = node.left.subtreeWidth; const leftSpace = (rightBound - leftBound) * (leftWidth / node.subtreeWidth); rightChildStart = assignNodePositions(node.left, currentX, currentX + leftSpace, nextY, levelHeight); leftChildEnd = rightChildStart; } if (node.right) { assignNodePositions(node.right, rightChildStart, rightBound, nextY, levelHeight); } if (node.left && node.right) { node.targetX = (node.left.targetX + node.right.targetX) / 2; } else if (node.left) { node.targetX = node.left.targetX; } else if (node.right) { node.targetX = node.right.targetX; } node.targetY = y; return rightBound; } function animateAllNodesToStandardLayout(callback) { const animateAll = () => { let allReached = true; const speed = 0.06; allNodes.forEach(node => { if (!node.visible) return; const dx = node.targetX - node.x; const dy = node.targetY - node.y; if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { node.x += dx * speed; node.y += dy * speed; allReached = false; } else { node.x = node.targetX; node.y = node.targetY; } }); if (!allReached) { requestAnimationFrame(animateAll); } else { if (callback) callback(); } }; animateAll(); } function startDrawLoop() { const draw = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); allNodes.forEach(node => { if (node.visible && node.left && node.right) { drawConnection(node, node.left); drawConnection(node, node.right); } }); allNodes.forEach(node => { if (node.visible) { drawNode(node); } }); if (document.getElementById('nextBtn').disabled === false || isAnimating || isLayoutOptimizing) { requestAnimationFrame(draw); } }; draw(); } function drawConnection(parent, child) { if (!parent.visible || !child.visible) return; const isLeftChild = parent.left === child; if (queue.size() <= 1 || isLayoutOptimizing) { ctx.strokeStyle = isLeftChild ? '#3b82f6' : '#10b981'; } else { ctx.strokeStyle = '#4a90e2'; } ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(parent.x, parent.y + 20); ctx.lineTo(child.x, child.y - 20); ctx.stroke(); if (queue.size() <= 1 || isLayoutOptimizing) { const midX = (parent.x + child.x) / 2; const midY = (parent.y + child.y) / 2; ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.beginPath(); ctx.arc(midX, midY, 8, 0, 2 * Math.PI); ctx.fillStyle = isLeftChild ? '#3b82f6' : '#10b981'; ctx.fill(); ctx.fillStyle = 'white'; ctx.fillText(isLeftChild ? '0' : '1', midX, midY); } } function drawNode(node) { const radius = 25; const time = Date.now(); ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, radius); if (node.isLeaf) { gradient.addColorStop(0, '#4caf50'); gradient.addColorStop(1, '#388e3c'); } else { gradient.addColorStop(0, '#2196f3'); gradient.addColorStop(1, '#1976d2'); } ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); if (node.highlight) { const alpha = 0.6 + 0.4 * Math.sin(time * 0.008); ctx.strokeStyle = `rgba(244, 67, 54, ${alpha})`; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(node.x, node.y, radius + 3, 0, 2 * Math.PI); ctx.stroke(); } if (node.isNew) { const alpha = 0.6 + 0.4 * Math.sin(time * 0.01); ctx.strokeStyle = `rgba(255, 193, 7, ${alpha})`; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(node.x, node.y, radius + 5, 0, 2 * Math.PI); ctx.stroke(); } ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI); ctx.stroke(); ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 12px Arial'; if (node.isLeaf) { ctx.fillText(node.char, node.x, node.y - 3); ctx.font = 'bold 9px Arial'; ctx.fillText(node.freq.toString(), node.x, node.y + 7); } else { ctx.fillText(node.freq.toString(), node.x, node.y); } } function displayQueue() { const queueDiv = document.getElementById('queueDisplay'); queueDiv.innerHTML = ''; const items = queue.toArray(); items.forEach(node => { const div = document.createElement('div'); div.className = 'queue-item'; if (selectedNodes.includes(node)) { div.className += ' selected'; } div.textContent = `${node.char || 'N'}(${node.freq})`; queueDiv.appendChild(div); }); if (items.length === 0) { const div = document.createElement('div'); div.className = 'queue-item'; div.textContent = '队列为空'; queueDiv.appendChild(div); } } function autoPlay() { if (isAutoPlaying) { isAutoPlaying = false; document.getElementById('autoBtn').innerHTML = "<span>▶️</span> 自动播放"; } else { isAutoPlaying = true; document.getElementById('autoBtn').innerHTML = "<span>⏸️</span> 暂停播放"; if ((queue.size() > 1 || !isLayoutOptimizing) && !isAnimating) { nextStep(); } } } function resetAnimation() { isAnimating = false; isAutoPlaying = false; isLayoutOptimizing = false; currentStep = 0; selectedNodes = []; allNodes = []; queue = new PriorityQueue(); document.getElementById('nextBtn').disabled = true; document.getElementById('autoBtn').disabled = true; document.getElementById('autoBtn').innerHTML = "<span>▶️</span> 自动播放"; status.textContent = "🔄 已重置，请重新开始"; status.className = "info-box info-box-info"; const queueDiv = document.getElementById('queueDisplay'); queueDiv.innerHTML = '<div class="queue-item">等待数据...</div>'; ctx.clearRect(0, 0, canvas.width, canvas.height); } function showCode(lang) { document.querySelectorAll('.code-content').forEach(el => el.style.display = 'none'); document.querySelectorAll('.code-tab').forEach(el => { el.style.background = '#e2e8f0'; el.style.color = '#4a5568'; el.classList.remove('active'); }); document.getElementById(lang + '-code').style.display = 'block'; const activeTab = document.querySelector(`[onclick="showCode('${lang}')"]`); activeTab.style.background = '#667eea'; activeTab.style.color = 'white'; activeTab.classList.add('active'); } function copyCode(lang) { const codeElement = document.getElementById(lang + '-code').querySelector('pre'); const text = codeElement.textContent; if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).then(() => { const btn = document.querySelector(`#${lang}-code .copy-btn`); const originalText = btn.textContent; btn.textContent = '✅ 已复制'; btn.style.background = '#48bb78'; setTimeout(() => { btn.textContent = originalText; btn.style.background = '#4a5568'; }, 2000); }).catch(err => { console.error('复制失败:', err); fallbackCopyTextToClipboard(text, lang); }); } else { fallbackCopyTextToClipboard(text, lang); } } function fallbackCopyTextToClipboard(text, lang) { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-999999px"; textArea.style.top = "-999999px"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); const btn = document.querySelector(`#${lang}-code .copy-btn`); const originalText = btn.textContent; btn.textContent = '✅ 已复制'; btn.style.background = '#48bb78'; setTimeout(() => { btn.textContent = originalText; btn.style.background = '#4a5568'; }, 2000); } catch (err) { console.error('Fallback: 复制失败', err); } document.body.removeChild(textArea); } function toggleQuestion(num) { const content = document.getElementById(`question-${num}`); const arrow = document.getElementById(`arrow-${num}`); if (content.style.display === 'none' || content.style.display === '') { content.style.display = 'block'; arrow.textContent = '▲'; } else { content.style.display = 'none'; arrow.textContent = '▼'; const answer = document.getElementById(`answer-${num}`); if (answer) { answer.style.display = 'none'; const btn = answer.previousElementSibling; if (btn) { btn.innerHTML = '<span>💡</span> 查看答案'; } } } } function showAnswer(num) { const answer = document.getElementById(`answer-${num}`); const btn = answer.previousElementSibling; if (answer.style.display === 'none' || answer.style.display === '') { answer.style.display = 'block'; btn.innerHTML = '<span>🔼</span> 隐藏答案'; btn.style.background = '#ed8936'; } else { answer.style.display = 'none'; btn.innerHTML = '<span>💡</span> 查看答案'; btn.style.background = ''; } } resetAnimation();</script>
{% endblock %}