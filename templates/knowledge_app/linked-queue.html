{% extends 'knowledge_app/base.html' %}

{% block title %}é“¾é˜Ÿåˆ— - è®¡ç®—æœºç§‘å­¦å­¦ä¹ å¹³å°{% endblock %}

{% block content %}
<style>.page-container {max-width:1200px;margin:0 auto;padding:20px;font-family:'Arial', sans-serif}.knowledge-section {background:white;border-radius:12px;box-shadow:0 4px 6px rgba(0,0,0,0.1);margin-bottom:30px;padding:30px;border-left:5px solid #3498db}.section-header {display:flex;align-items:center;margin-bottom:25px;border-bottom:2px solid #ecf0f1;padding-bottom:15px}.section-icon {font-size:2em;margin-right:15px}.section-title {font-size:1.8em;color:#2c3e50;margin:0}.concept-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(250px, 1fr));gap:20px;margin:20px 0}.concept-card {background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:20px;text-align:center;transition:transform 0.3s ease}.concept-card:hover {transform:translateY(-5px);box-shadow:0 4px 12px rgba(0,0,0,0.15)}.canvas-container {background:#f8f9fa;border:2px solid #dee2e6;border-radius:8px;padding:20px;margin:20px 0;text-align:center}.canvas-controls {margin:15px 0}.btn {background:#3498db;color:white;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;margin:0 8px;font-size:14px;font-weight:bold;transition:all 0.3s ease;box-shadow:0 4px 15px rgba(52, 152, 219, 0.3);position:relative;overflow:hidden}.btn:hover {transform:translateY(-2px);box-shadow:0 6px 20px rgba(52, 152, 219, 0.4)}.btn:active {transform:translateY(0);box-shadow:0 2px 10px rgba(52, 152, 219, 0.2)}.btn:disabled {background:#95a5a6;cursor:not-allowed;transform:none;box-shadow:none}.btn-enqueue {background:linear-gradient(135deg, #27ae60, #2ecc71)}.btn-enqueue:hover {background:linear-gradient(135deg, #229954, #27ae60)}.btn-dequeue {background:linear-gradient(135deg, #e74c3c, #ec7063)}.btn-dequeue:hover {background:linear-gradient(135deg, #c0392b, #e74c3c)}.btn-reset {background:linear-gradient(135deg, #f39c12, #f7dc6f)}.btn-reset:hover {background:linear-gradient(135deg, #d68910, #f39c12)}.btn-demo {background:linear-gradient(135deg, #9b59b6, #bb8fce)}.btn-demo:hover {background:linear-gradient(135deg, #8e44ad, #9b59b6)}.btn::before {content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);transition:left 0.5s}.btn:hover::before {left:100%}.code-container {background:#2c3e50;color:#ecf0f1;border-radius:8px;margin:20px 0;overflow:hidden}.code-tabs {display:flex;background:#34495e}.code-tab {padding:12px 20px;cursor:pointer;border:none;background:transparent;color:#bdc3c7;font-weight:bold;transition:all 0.3s ease}.code-tab.active {background:#3498db;color:white}.code-content {position:relative;padding:20px;font-family:'Courier New', monospace;line-height:1.6;overflow-x:auto}.copy-btn {position:absolute;top:10px;right:10px;background:#27ae60;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:12px}.copy-btn:hover {background:#229954}.quiz-question {background:#fff3cd;border:1px solid #ffeaa7;border-radius:8px;padding:20px;margin:15px 0}.quiz-answer {background:#d1ecf1;border:1px solid #bee5eb;border-radius:8px;padding:15px;margin-top:10px;display:none}.show-answer-btn {background:#17a2b8;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;margin-top:10px}.analogy-box {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;padding:25px;border-radius:12px;margin:20px 0}.highlight {background:#ffffcc;padding:2px 4px;border-radius:3px;font-weight:bold}.difficulty-badge {display:inline-block;padding:5px 15px;border-radius:20px;font-size:0.9em;font-weight:bold;color:white;background:#f39c12}.key-point {border-left:4px solid #e74c3c;background:#fdf2f2;padding:15px;margin:15px 0;border-radius:0 8px 8px 0}.comparison-grid {display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:20px 0}.comparison-card {padding:20px;border-radius:8px;border:2px solid}.vs-é¡ºåºé˜Ÿåˆ— {border-color:#e74c3c;background:#fdf2f2}.vs-é“¾é˜Ÿåˆ— {border-color:#27ae60;background:#eafaf1}</style><div class="page-container fade-in"><!-- é¢åŒ…å±‘å¯¼èˆª --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">é¦–é¡µ</a><span>></span><span>æ•°æ®ç»“æ„</span><span>></span><span>é“¾é˜Ÿåˆ—</span></div><!-- é¡µé¢å¤´éƒ¨ --><div class="page-header slide-in-left"><h1><span class="page-icon">ğŸ”—</span>
            é“¾é˜Ÿåˆ— (Linked Queue)
        </h1><p>åŸºäºé“¾è¡¨å®ç°çš„åŠ¨æ€é˜Ÿåˆ—ï¼Œæ— å®¹é‡é™åˆ¶ï¼Œçµæ´»é«˜æ•ˆ</p></div><!-- ğŸ“‹ çŸ¥è¯†ç‚¹æ¦‚è¿° --><div class="knowledge-section slide-in-right"><div class="section-header"><span class="section-icon">ğŸ“‹</span><h2 class="section-title">çŸ¥è¯†ç‚¹æ¦‚è¿°</h2></div><div class="key-point"><strong>æ ¸å¿ƒæ¦‚å¿µï¼š</strong>é“¾é˜Ÿåˆ—æ˜¯ç”¨é“¾è¡¨å®ç°çš„é˜Ÿåˆ—ï¼Œé€šè¿‡åŠ¨æ€åˆ†é…èŠ‚ç‚¹æ¥å­˜å‚¨æ•°æ®ï¼Œæ²¡æœ‰å›ºå®šå®¹é‡é™åˆ¶ï¼Œéµå¾ª"å…ˆè¿›å…ˆå‡º(FIFO)"åŸåˆ™ã€‚
        </div><div class="concept-grid"><div class="concept-card"><h3>ğŸ¯ é˜Ÿå¤´æŒ‡é’ˆ(Front)</h3><p>æŒ‡å‘é˜Ÿåˆ—ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºå‡ºé˜Ÿæ“ä½œ</p></div><div class="concept-card"><h3>ğŸ¯ é˜Ÿå°¾æŒ‡é’ˆ(Rear)</h3><p>æŒ‡å‘é˜Ÿåˆ—æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºå…¥é˜Ÿæ“ä½œ</p></div><div class="concept-card"><h3>ğŸ¯ èŠ‚ç‚¹(Node)</h3><p>åŒ…å«æ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸçš„åŸºæœ¬å•å…ƒ</p></div><div class="concept-card"><h3>ğŸ¯ åŠ¨æ€åˆ†é…</h3><p>æ ¹æ®éœ€è¦åŠ¨æ€åˆ›å»ºå’Œé”€æ¯èŠ‚ç‚¹</p></div></div><p><span class="difficulty-badge">è¿›é˜¶çº§</span><strong>å‰ç½®çŸ¥è¯†ï¼š</strong>é“¾è¡¨åŸºç¡€ã€æŒ‡é’ˆæ“ä½œã€åŠ¨æ€å†…å­˜ç®¡ç†</p></div><!-- ğŸ” æ¦‚å¿µè¯¦è§£ --><div class="knowledge-section"><div class="section-header"><span class="section-icon">ğŸ”</span><h2 class="section-title">æ¦‚å¿µè¯¦è§£</h2></div><div class="analogy-box"><h3>ğŸš‚ ç”Ÿæ´»ç±»æ¯”ï¼šç«è½¦è½¦å¢è¿æ¥</h3><p>æƒ³è±¡ä¸€åˆ—ç«è½¦ï¼š</p><ul><li><strong>è½¦å¤´</strong> = é˜Ÿå¤´æŒ‡é’ˆï¼ˆæŒ‡å‘ç¬¬ä¸€èŠ‚è½¦å¢ï¼‰</li><li><strong>è½¦å°¾</strong> = é˜Ÿå°¾æŒ‡é’ˆï¼ˆæŒ‡å‘æœ€åä¸€èŠ‚è½¦å¢ï¼‰</li><li><strong>è½¦å¢</strong> = èŠ‚ç‚¹ï¼ˆè½½å®¢ + è¿æ¥ä¸‹ä¸€èŠ‚è½¦å¢ï¼‰</li><li><strong>åŠ è½¦å¢</strong> = å…¥é˜Ÿï¼ˆåœ¨å°¾éƒ¨è¿æ¥æ–°è½¦å¢ï¼‰</li><li><strong>æ‘˜è½¦å¢</strong> = å‡ºé˜Ÿï¼ˆä»å¤´éƒ¨æ‘˜æ‰è½¦å¢ï¼‰</li></ul><p>ğŸ’¡ å…³é”®ï¼š<span class="highlight">ç«è½¦å¯ä»¥æ— é™åŠ è½¦å¢ï¼Œä¸å—ç«™å°é•¿åº¦é™åˆ¶ï¼</span></p></div><h3>ğŸ†š é“¾é˜Ÿåˆ— vs é¡ºåºé˜Ÿåˆ—</h3><div class="comparison-grid"><div class="comparison-card vs-é¡ºåºé˜Ÿåˆ—"><h4>ğŸ“š é¡ºåºé˜Ÿåˆ—</h4><ul><li>âœ… è®¿é—®é€Ÿåº¦å¿«ï¼Œæ— æŒ‡é’ˆå¼€é”€</li><li>âœ… å®ç°ç®€å•ï¼Œå†…å­˜è¿ç»­</li><li>âŒ å®¹é‡å›ºå®šï¼Œå¯èƒ½å‡æº¢å‡º</li><li>âŒ æµªè´¹ç©ºé—´ï¼Œæ‰©å®¹å›°éš¾</li></ul></div><div class="comparison-card vs-é“¾é˜Ÿåˆ—"><h4>ğŸ”— é“¾é˜Ÿåˆ—</h4><ul><li>âœ… å®¹é‡åŠ¨æ€ï¼Œæ— å‡æº¢å‡º</li><li>âœ… èŠ‚çœç©ºé—´ï¼ŒæŒ‰éœ€åˆ†é…</li><li>âŒ é¢å¤–æŒ‡é’ˆå¼€é”€</li><li>âŒ å†…å­˜ä¸è¿ç»­ï¼Œç¼“å­˜ä¸å‹å¥½</li></ul></div></div><div class="key-point"><strong>âš ï¸ åˆå­¦è€…æ˜“æ··æ·†ç‚¹ï¼š</strong><ul><li>å¿˜è®°æ›´æ–°front/rearæŒ‡é’ˆï¼šåˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ æ—¶</li><li>å†…å­˜æ³„æ¼ï¼šå‡ºé˜Ÿæ—¶å¿˜è®°é‡Šæ”¾èŠ‚ç‚¹å†…å­˜</li><li>ç©ºé˜Ÿåˆ—åˆ¤æ–­ï¼šfrontä¸ºNULLæ—¶é˜Ÿåˆ—ä¸ºç©º</li><li>æŒ‡é’ˆé¡ºåºï¼šè¦å…ˆä¿å­˜nextå†åˆ é™¤å½“å‰èŠ‚ç‚¹</li></ul></div></div><!-- ğŸ“Š å¯è§†åŒ–å±•ç¤º --><div class="knowledge-section"><div class="section-header"><span class="section-icon">ğŸ“Š</span><h2 class="section-title">å¯è§†åŒ–å±•ç¤º</h2></div><div class="canvas-container"><h3>ğŸ¬ é“¾é˜Ÿåˆ—åŠ¨æ€æ¼”ç¤º</h3><canvas id="queueCanvas" width="900" height="400" style="border: 2px solid #3498db; border-radius: 8px; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);"></canvas><div class="canvas-controls"><input type="number" id="inputValue" placeholder="è¾“å…¥æ•°å­—" min="1" max="99" style="padding: 12px; margin-right: 10px; border-radius: 8px; border: 2px solid #3498db; font-size: 16px; outline: none; transition: all 0.3s ease;"><button class="btn btn-enqueue" onclick="enqueue()">ğŸ“¥ å…¥é˜Ÿ</button><button class="btn btn-dequeue" onclick="dequeue()">ğŸ“¤ å‡ºé˜Ÿ</button><button class="btn btn-reset" onclick="resetQueue()">ğŸ”„ é‡ç½®</button><button class="btn btn-demo" onclick="startDemo()">âœ¨ æ¼”ç¤º</button></div><div id="queueStatus" style="margin-top: 15px; font-weight: bold; color: #2c3e50; padding: 10px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;"></div></div></div><!-- ğŸ’» ä»£ç å®ç° --><div class="knowledge-section"><div class="section-header"><span class="section-icon">ğŸ’»</span><h2 class="section-title">ä»£ç å®ç°</h2></div><div class="code-container"><div class="code-tabs"><button class="code-tab active" onclick="showCode('cpp')">C++</button><button class="code-tab" onclick="showCode('java')">Java</button><button class="code-tab" onclick="showCode('python')">Python</button></div><div id="cpp-code" class="code-content"><button class="copy-btn" onclick="copyCode('cpp', this)">ğŸ“‹ å¤åˆ¶</button><pre><code>#include &lt;iostream&gt;
using namespace std;

// é“¾é˜Ÿåˆ—èŠ‚ç‚¹ç»“æ„
struct Node {
    int data;
    Node* next;

    Node(int value) : data(value), next(nullptr) {}
};

class LinkedQueue {
private:
    Node* front;  // é˜Ÿå¤´æŒ‡é’ˆ
    Node* rear;   // é˜Ÿå°¾æŒ‡é’ˆ
    int size;     // é˜Ÿåˆ—å¤§å°

public:
    LinkedQueue() {
        front = rear = nullptr;
        size = 0;
    }

    ~LinkedQueue() {
        clear();
    }

    // å…¥é˜Ÿæ“ä½œ
    void enqueue(int data) {
        Node* newNode = new Node(data);

        if (rear == nullptr) {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œfrontå’Œrearéƒ½æŒ‡å‘æ–°èŠ‚ç‚¹
            front = rear = newNode;
        } else {
            // é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œæ–°èŠ‚ç‚¹è¿æ¥åˆ°rearåé¢
            rear->next = newNode;
            rear = newNode;
        }
        size++;
        cout << "å…¥é˜ŸæˆåŠŸ: " << data << endl;
    }

    // å‡ºé˜Ÿæ“ä½œ
    int dequeue() {
        if (front == nullptr) {
            cout << "é˜Ÿåˆ—ä¸ºç©º!" << endl;
            return -1;
        }

        Node* temp = front;
        int data = front->data;
        front = front->next;

        // å¦‚æœé˜Ÿåˆ—å˜ç©ºï¼Œrearä¹Ÿè¦ç½®ä¸ºnullptr
        if (front == nullptr) {
            rear = nullptr;
        }

        delete temp;
        size--;
        cout << "å‡ºé˜ŸæˆåŠŸ: " << data << endl;
        return data;
    }

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    int peek() {
        if (front == nullptr) {
            cout << "é˜Ÿåˆ—ä¸ºç©º!" << endl;
            return -1;
        }
        return front->data;
    }

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    bool isEmpty() {
        return front == nullptr;
    }

    // è·å–é˜Ÿåˆ—å¤§å°
    int getSize() {
        return size;
    }

    // æ¸…ç©ºé˜Ÿåˆ—
    void clear() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    // æ˜¾ç¤ºé˜Ÿåˆ—
    void display() {
        if (isEmpty()) {
            cout << "é˜Ÿåˆ—ä¸ºç©º" << endl;
            return;
        }

        cout << "é˜Ÿåˆ—å†…å®¹: ";
        Node* current = front;
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
};</code></pre></div><div id="java-code" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('java', this)">ğŸ“‹ å¤åˆ¶</button><pre><code>// é“¾é˜Ÿåˆ—èŠ‚ç‚¹ç±»
class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class LinkedQueue {
    private Node front;  // é˜Ÿå¤´æŒ‡é’ˆ
    private Node rear;   // é˜Ÿå°¾æŒ‡é’ˆ
    private int size;    // é˜Ÿåˆ—å¤§å°

    public LinkedQueue() {
        front = rear = null;
        size = 0;
    }

    // å…¥é˜Ÿæ“ä½œ
    public void enqueue(int data) {
        Node newNode = new Node(data);

        if (rear == null) {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œfrontå’Œrearéƒ½æŒ‡å‘æ–°èŠ‚ç‚¹
            front = rear = newNode;
        } else {
            // é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œæ–°èŠ‚ç‚¹è¿æ¥åˆ°rearåé¢
            rear.next = newNode;
            rear = newNode;
        }
        size++;
        System.out.println("å…¥é˜ŸæˆåŠŸ: " + data);
    }

    // å‡ºé˜Ÿæ“ä½œ
    public int dequeue() {
        if (front == null) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©º!");
            return -1;
        }

        int data = front.data;
        front = front.next;

        // å¦‚æœé˜Ÿåˆ—å˜ç©ºï¼Œrearä¹Ÿè¦ç½®ä¸ºnull
        if (front == null) {
            rear = null;
        }

        size--;
        System.out.println("å‡ºé˜ŸæˆåŠŸ: " + data);
        return data;
    }

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    public int peek() {
        if (front == null) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©º!");
            return -1;
        }
        return front.data;
    }

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    public boolean isEmpty() {
        return front == null;
    }

    // è·å–é˜Ÿåˆ—å¤§å°
    public int getSize() {
        return size;
    }

    // æ˜¾ç¤ºé˜Ÿåˆ—
    public void display() {
        if (isEmpty()) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©º");
            return;
        }

        System.out.print("é˜Ÿåˆ—å†…å®¹: ");
        Node current = front;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}</code></pre></div><div id="python-code" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('python', this)">ğŸ“‹ å¤åˆ¶</button><pre><code>class Node:
    """é“¾é˜Ÿåˆ—èŠ‚ç‚¹ç±»"""
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedQueue:
    """é“¾é˜Ÿåˆ—ç±»"""
    def __init__(self):
        self.front = None  # é˜Ÿå¤´æŒ‡é’ˆ
        self.rear = None   # é˜Ÿå°¾æŒ‡é’ˆ
        self.size = 0      # é˜Ÿåˆ—å¤§å°

    def enqueue(self, data):
        """å…¥é˜Ÿæ“ä½œ"""
        new_node = Node(data)

        if self.rear is None:
            # é˜Ÿåˆ—ä¸ºç©ºï¼Œfrontå’Œrearéƒ½æŒ‡å‘æ–°èŠ‚ç‚¹
            self.front = self.rear = new_node
        else:
            # é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œæ–°èŠ‚ç‚¹è¿æ¥åˆ°rearåé¢
            self.rear.next = new_node
            self.rear = new_node

        self.size += 1
        print(f"å…¥é˜ŸæˆåŠŸ: {data}")

    def dequeue(self):
        """å‡ºé˜Ÿæ“ä½œ"""
        if self.front is None:
            print("é˜Ÿåˆ—ä¸ºç©º!")
            return None

        data = self.front.data
        self.front = self.front.next

        # å¦‚æœé˜Ÿåˆ—å˜ç©ºï¼Œrearä¹Ÿè¦ç½®ä¸ºNone
        if self.front is None:
            self.rear = None

        self.size -= 1
        print(f"å‡ºé˜ŸæˆåŠŸ: {data}")
        return data

    def peek(self):
        """æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ """
        if self.front is None:
            print("é˜Ÿåˆ—ä¸ºç©º!")
            return None
        return self.front.data

    def is_empty(self):
        """åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º"""
        return self.front is None

    def get_size(self):
        """è·å–é˜Ÿåˆ—å¤§å°"""
        return self.size

    def display(self):
        """æ˜¾ç¤ºé˜Ÿåˆ—"""
        if self.is_empty():
            print("é˜Ÿåˆ—ä¸ºç©º")
            return

        current = self.front
        result = []
        while current:
            result.append(str(current.data))
            current = current.next

        print("é˜Ÿåˆ—å†…å®¹:", " -> ".join(result))

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    queue = LinkedQueue()

    # æµ‹è¯•å…¥é˜Ÿ
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    queue.display()

    # æµ‹è¯•å‡ºé˜Ÿ
    queue.dequeue()
    queue.display()

    print(f"é˜Ÿå¤´å…ƒç´ : {queue.peek()}")
    print(f"é˜Ÿåˆ—å¤§å°: {queue.get_size()}")</code></pre></div></div></div><!-- ğŸŒŸ å®é™…åº”ç”¨ --><div class="knowledge-section"><div class="section-header"><span class="section-icon">ğŸŒŸ</span><h2 class="section-title">å®é™…åº”ç”¨</h2></div><div class="concept-grid"><div class="concept-card"><h3>ğŸŒ WebæœåŠ¡å™¨</h3><p><strong>è¯·æ±‚é˜Ÿåˆ—</strong></p><p>åŠ¨æ€å¤„ç†ä¸å®šæ•°é‡çš„ç”¨æˆ·è¯·æ±‚ï¼Œæ— éœ€é¢„ä¼°æœ€å¤§å¹¶å‘é‡</p></div><div class="concept-card"><h3>ğŸµ éŸ³ä¹æ’­æ”¾å™¨</h3><p><strong>æ’­æ”¾åˆ—è¡¨</strong></p><p>ç”¨æˆ·å¯ä»¥æ— é™æ·»åŠ æ­Œæ›²ï¼ŒåŠ¨æ€ç®¡ç†æ’­æ”¾é˜Ÿåˆ—</p></div><div class="concept-card"><h3>ğŸ§  AIæ¨ç†</h3><p><strong>ä»»åŠ¡è°ƒåº¦</strong></p><p>æœºå™¨å­¦ä¹ ä»»åŠ¡é˜Ÿåˆ—ï¼Œæ ¹æ®è®¡ç®—éœ€æ±‚åŠ¨æ€åˆ†é…</p></div></div><div class="key-point"><h3>ğŸ” æ·±åº¦æ¡ˆä¾‹ï¼šæ¶ˆæ¯ä¸­é—´ä»¶</h3><p>åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œæ¶ˆæ¯é˜Ÿåˆ—æ˜¯æ ¸å¿ƒç»„ä»¶ï¼š</p><ul><li>ğŸ“¨ <strong>åŠ¨æ€æ‰©å±•</strong>ï¼šæ¶ˆæ¯æ•°é‡ä¸å¯é¢„æµ‹ï¼Œé“¾é˜Ÿåˆ—èƒ½åŠ¨æ€é€‚åº”</li><li>ğŸ”„ <strong>æŒç»­æµè½¬</strong>ï¼šæ¶ˆæ¯æŒç»­äº§ç”Ÿå’Œæ¶ˆè´¹ï¼Œæ— å›ºå®šå®¹é‡é™åˆ¶</li><li>âš¡ <strong>é«˜æ•ˆå¤„ç†</strong>ï¼šO(1)çš„å…¥é˜Ÿå‡ºé˜Ÿæ“ä½œä¿è¯ç³»ç»Ÿæ€§èƒ½</li><li>ğŸ›¡ï¸ <strong>å†…å­˜å®‰å…¨</strong>ï¼šåŠæ—¶é‡Šæ”¾å·²å¤„ç†æ¶ˆæ¯ï¼Œé¿å…å†…å­˜æ³„æ¼</li></ul></div><h3>ğŸ’¡ é€‰æ‹©æŒ‡å—</h3><div class="key-point"><strong>ä½•æ—¶é€‰æ‹©é“¾é˜Ÿåˆ—ï¼š</strong><ul><li>é˜Ÿåˆ—å¤§å°æ— æ³•é¢„ä¼°æˆ–å˜åŒ–å¾ˆå¤§</li><li>éœ€è¦èŠ‚çœå†…å­˜ï¼Œé¿å…ç©ºé—´æµªè´¹</li><li>å¯¹æ’å…¥åˆ é™¤æ€§èƒ½è¦æ±‚é«˜</li><li>ä¸å…³å¿ƒå†…å­˜è®¿é—®çš„å±€éƒ¨æ€§</li></ul></div></div><!-- âœ… å­¦ä¹ æ£€éªŒ --><div class="knowledge-section"><div class="section-header"><span class="section-icon">âœ…</span><h2 class="section-title">å­¦ä¹ æ£€éªŒ</h2></div><div class="quiz-question"><h4>ğŸ¤” é—®é¢˜1ï¼šåœ¨ç©ºé˜Ÿåˆ—ä¸­å…¥é˜Ÿä¸€ä¸ªå…ƒç´ åï¼Œfrontå’ŒrearæŒ‡é’ˆæŒ‡å‘å“ªé‡Œï¼Ÿ</h4><button class="show-answer-btn" onclick="toggleAnswer('answer1')">æ˜¾ç¤ºç­”æ¡ˆ</button><div id="answer1" class="quiz-answer"><strong>ç­”æ¡ˆï¼š</strong>frontå’Œrearéƒ½æŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæ–°åˆ›å»ºçš„èŠ‚ç‚¹ï¼‰<br><strong>è§£æï¼š</strong><ul><li>ç©ºé˜Ÿåˆ—æ—¶ï¼šfront = rear = NULL</li><li>ç¬¬ä¸€æ¬¡å…¥é˜Ÿï¼šfront = rear = newNode</li><li>è¿™ç¡®ä¿äº†é˜Ÿåˆ—çš„æ­£ç¡®çŠ¶æ€ç»´æŠ¤</li></ul></div></div><div class="quiz-question"><h4>ğŸ¤” é—®é¢˜2ï¼šå‡ºé˜Ÿæœ€åä¸€ä¸ªå…ƒç´ æ—¶éœ€è¦æ³¨æ„ä»€ä¹ˆï¼Ÿ</h4><button class="show-answer-btn" onclick="toggleAnswer('answer2')">æ˜¾ç¤ºç­”æ¡ˆ</button><div id="answer2" class="quiz-answer"><strong>ç­”æ¡ˆï¼š</strong>éœ€è¦å°†rearæŒ‡é’ˆä¹Ÿç½®ä¸ºNULL<br><strong>è§£æï¼š</strong>å½“frontç§»åŠ¨åˆ°NULLæ—¶ï¼Œè¯´æ˜é˜Ÿåˆ—å·²ç©ºï¼Œæ­¤æ—¶rearä¹Ÿå¿…é¡»ç½®ä¸ºNULLï¼Œå¦åˆ™ä¼šå¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´ã€‚æ­£ç¡®ä»£ç ï¼š
                <pre>if (front == NULL) rear = NULL;</pre></div></div><div class="quiz-question"><h4>ğŸ¤” é—®é¢˜3ï¼šé“¾é˜Ÿåˆ—ç›¸æ¯”é¡ºåºé˜Ÿåˆ—çš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ</h4><button class="show-answer-btn" onclick="toggleAnswer('answer3')">æ˜¾ç¤ºç­”æ¡ˆ</button><div id="answer3" class="quiz-answer"><strong>ç­”æ¡ˆï¼š</strong>åŠ¨æ€å®¹é‡ï¼Œæ— å‡æº¢å‡ºï¼ŒæŒ‰éœ€åˆ†é…å†…å­˜<br><strong>è¯¦ç»†å¯¹æ¯”ï¼š</strong><ul><li><strong>å®¹é‡</strong>ï¼šé“¾é˜Ÿåˆ—æ— å›ºå®šä¸Šé™ï¼Œé¡ºåºé˜Ÿåˆ—å®¹é‡å›ºå®š</li><li><strong>å†…å­˜</strong>ï¼šé“¾é˜Ÿåˆ—æŒ‰éœ€åˆ†é…ï¼Œé¡ºåºé˜Ÿåˆ—å¯èƒ½æµªè´¹ç©ºé—´</li><li><strong>æº¢å‡º</strong>ï¼šé“¾é˜Ÿåˆ—æ— å‡æº¢å‡ºï¼Œé¡ºåºé˜Ÿåˆ—éœ€è¦å¾ªç¯å¤„ç†</li></ul></div></div><div class="quiz-question"><h4>ğŸ¤” é—®é¢˜4ï¼šé“¾é˜Ÿåˆ—çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦åˆ†æï¼Ÿ</h4><button class="show-answer-btn" onclick="toggleAnswer('answer4')">æ˜¾ç¤ºç­”æ¡ˆ</button><div id="answer4" class="quiz-answer"><strong>æ—¶é—´å¤æ‚åº¦ï¼š</strong><ul><li>å…¥é˜Ÿï¼šO(1) - ç›´æ¥åœ¨rearåæ·»åŠ </li><li>å‡ºé˜Ÿï¼šO(1) - ç›´æ¥åˆ é™¤frontèŠ‚ç‚¹</li><li>æŸ¥çœ‹é˜Ÿå¤´ï¼šO(1) - ç›´æ¥è®¿é—®front</li></ul><strong>ç©ºé—´å¤æ‚åº¦ï¼š</strong>O(n) - nä¸ªèŠ‚ç‚¹ + æ¯ä¸ªèŠ‚ç‚¹é¢å¤–çš„æŒ‡é’ˆå¼€é”€
            </div></div><div class="quiz-question"><h4>ğŸ¤” é—®é¢˜5ï¼šå¦‚ä½•é¿å…é“¾é˜Ÿåˆ—çš„å†…å­˜æ³„æ¼ï¼Ÿ</h4><button class="show-answer-btn" onclick="toggleAnswer('answer5')">æ˜¾ç¤ºç­”æ¡ˆ</button><div id="answer5" class="quiz-answer"><strong>ç­”æ¡ˆï¼š</strong>å‡ºé˜Ÿæ—¶åŠæ—¶é‡Šæ”¾èŠ‚ç‚¹å†…å­˜ï¼Œææ„å‡½æ•°æ¸…ç©ºé˜Ÿåˆ—<br><strong>å…³é”®ç‚¹ï¼š</strong><ul><li>å‡ºé˜Ÿæ—¶ï¼šå…ˆä¿å­˜è¦åˆ é™¤çš„èŠ‚ç‚¹æŒ‡é’ˆï¼Œæ›´æ–°frontåå†delete</li><li>ææ„å‡½æ•°ï¼šå¾ªç¯å‡ºé˜Ÿç›´åˆ°é˜Ÿåˆ—ä¸ºç©º</li><li>å¼‚å¸¸å®‰å…¨ï¼šä½¿ç”¨RAIIåŸåˆ™ç®¡ç†èµ„æº</li></ul></div></div><h3>ğŸ“š è¿›ä¸€æ­¥å­¦ä¹ å»ºè®®</h3><ul><li>ğŸ”„ <strong>åŒç«¯é˜Ÿåˆ—</strong>ï¼šä¸¤ç«¯éƒ½å¯ä»¥æ’å…¥åˆ é™¤çš„é˜Ÿåˆ—</li><li>âš¡ <strong>ä¼˜å…ˆé˜Ÿåˆ—</strong>ï¼šåŸºäºå †å®ç°çš„ä¼˜å…ˆçº§é˜Ÿåˆ—</li><li>ğŸ§µ <strong>å¹¶å‘é˜Ÿåˆ—</strong>ï¼šçº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—å®ç°</li><li>ğŸ“Š <strong>é˜Ÿåˆ—åº”ç”¨</strong>ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ã€ä»»åŠ¡è°ƒåº¦ç®—æ³•</li></ul></div><!-- å¯¼èˆªæŒ‰é’® --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>ğŸ </span>
            è¿”å›é¦–é¡µ
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>ğŸŒŒ</span>
            æ¢ç´¢CSå®‡å®™
        </a></div></div><script>class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 1.0; this.decay = 0.02; this.color = color; this.size = Math.random() * 3 + 2; } update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; this.size *= 0.98; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } isDead() { return this.life <= 0 || this.size <= 0.1; } } class QueueNode { constructor(data) { this.data = data; this.next = null; this.x = 0; this.y = 0; this.targetX = 0; this.targetY = 0; this.scale = 1; this.opacity = 1; } } class LinkedQueueVisual { constructor(canvasId) { this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d'); this.front = null; this.rear = null; this.size = 0; this.animating = false; this.particles = []; this.nodeWidth = 80; this.nodeHeight = 60; this.nodeSpacing = 120; this.startX = 100; this.startY = 200; this.hoveredNode = null; this.glowIntensity = 0; this.glowDirection = 1; this.startAnimationLoop(); this.draw(); this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e)); this.canvas.addEventListener('mouseleave', () => this.hoveredNode = null); } handleMouseMove(e) { const rect = this.canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; this.hoveredNode = null; let current = this.front; let index = 0; while (current) { const nodeX = this.startX + index * this.nodeSpacing; const nodeY = this.startY; if (x >= nodeX && x <= nodeX + this.nodeWidth && y >= nodeY && y <= nodeY + this.nodeHeight) { this.hoveredNode = current; break; } current = current.next; index++; } } startAnimationLoop() { const animate = () => { this.glowIntensity += this.glowDirection * 0.02; if (this.glowIntensity >= 1) { this.glowIntensity = 1; this.glowDirection = -1; } else if (this.glowIntensity <= 0) { this.glowIntensity = 0; this.glowDirection = 1; } this.particles = this.particles.filter(particle => { particle.update(); return !particle.isDead(); }); this.updateNodeAnimations(); if (!this.animating) { this.draw(); } requestAnimationFrame(animate); }; animate(); } updateNodeAnimations() { let current = this.front; let index = 0; while (current) { const targetX = this.startX + index * this.nodeSpacing; const targetY = this.startY; current.x += (targetX - current.x) * 0.1; current.y += (targetY - current.y) * 0.1; current.targetX = targetX; current.targetY = targetY; current = current.next; index++; } } createParticles(x, y, color, count = 10) { for (let i = 0; i < count; i++) { this.particles.push(new Particle(x, y, color)); } } draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height); gradient.addColorStop(0, '#f8f9fa'); gradient.addColorStop(1, '#e9ecef'); this.ctx.fillStyle = gradient; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#2c3e50'; this.ctx.font = 'bold 20px Arial'; this.ctx.textAlign = 'left'; this.ctx.fillText('ğŸ”— é“¾é˜Ÿåˆ—åŠ¨æ€å¯è§†åŒ–', 20, 35); this.ctx.font = '14px Arial'; this.ctx.fillStyle = '#7f8c8d'; this.ctx.fillText('é¼ æ ‡æ‚¬åœæŸ¥çœ‹èŠ‚ç‚¹è¯¦æƒ… | ç»¿è‰²=é˜Ÿå¤´ | æ©™è‰²=é˜Ÿå°¾ | ç®­å¤´è¡¨ç¤ºæŒ‡é’ˆè¿æ¥', 20, 55); if (this.size === 0) { this.drawEmptyQueue(); } else { this.drawNodes(); this.drawConnections(); this.drawPointers(); } this.particles.forEach(particle => particle.draw(this.ctx)); this.updateStatus(); } drawEmptyQueue() { const centerX = this.canvas.width / 2; const centerY = this.canvas.height / 2; this.ctx.fillStyle = '#95a5a6'; this.ctx.font = 'bold 24px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('é˜Ÿåˆ—ä¸ºç©º', centerX, centerY - 20); this.ctx.font = '16px Arial'; this.ctx.fillText('front = NULL, rear = NULL', centerX, centerY + 10); this.ctx.setLineDash([10, 5]); this.ctx.strokeStyle = '#bdc3c7'; this.ctx.lineWidth = 2; this.ctx.strokeRect(centerX - 150, centerY - 50, 300, 80); this.ctx.setLineDash([]); } drawNodes() { let current = this.front; let index = 0; while (current) { const x = current.x || (this.startX + index * this.nodeSpacing); const y = current.y || this.startY; const isHovered = this.hoveredNode === current; let fillColor, strokeColor; if (current === this.front && current === this.rear) { fillColor = '#e74c3c'; strokeColor = '#c0392b'; } else if (current === this.front) { fillColor = '#27ae60'; strokeColor = '#229954'; } else if (current === this.rear) { fillColor = '#f39c12'; strokeColor = '#d68910'; } else { fillColor = '#3498db'; strokeColor = '#2980b9'; } this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; this.ctx.shadowBlur = isHovered ? 20 : 10; this.ctx.shadowOffsetX = 3; this.ctx.shadowOffsetY = 3; this.ctx.fillStyle = fillColor; this.ctx.strokeStyle = strokeColor; this.ctx.lineWidth = isHovered ? 4 : 2; this.ctx.fillRect(x, y, this.nodeWidth, this.nodeHeight); this.ctx.strokeRect(x, y, this.nodeWidth, this.nodeHeight); this.ctx.shadowBlur = 0; this.ctx.shadowOffsetX = 0; this.ctx.shadowOffsetY = 0; if (this.glowIntensity > 0) { this.ctx.save(); this.ctx.globalAlpha = this.glowIntensity * 0.3; this.ctx.strokeStyle = fillColor; this.ctx.lineWidth = 6; this.ctx.strokeRect(x - 3, y - 3, this.nodeWidth + 6, this.nodeHeight + 6); this.ctx.restore(); } this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 20px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText(current.data.toString(), x + this.nodeWidth/2, y + this.nodeHeight/2 + 7); this.ctx.fillStyle = '#7f8c8d'; this.ctx.font = 'bold 12px Arial'; this.ctx.fillText('next', x + this.nodeWidth/2, y + this.nodeHeight + 15); if (isHovered) { this.drawNodeTooltip(x, y, current, index); } current = current.next; index++; } } drawConnections() { let current = this.front; let index = 0; while (current && current.next) { const startX = this.startX + index * this.nodeSpacing + this.nodeWidth; const startY = this.startY + this.nodeHeight/2; const endX = this.startX + (index + 1) * this.nodeSpacing; const endY = this.startY + this.nodeHeight/2; this.ctx.strokeStyle = '#3498db'; this.ctx.lineWidth = 3; this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke(); this.drawArrow(endX - 15, endY, endX, endY, '#3498db'); current = current.next; index++; } if (this.rear) { const lastIndex = this.size - 1; const startX = this.startX + lastIndex * this.nodeSpacing + this.nodeWidth; const startY = this.startY + this.nodeHeight/2; const endX = startX + 40; const endY = startY; this.ctx.strokeStyle = '#e74c3c'; this.ctx.lineWidth = 3; this.ctx.setLineDash([5, 5]); this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke(); this.ctx.setLineDash([]); this.ctx.fillStyle = '#e74c3c'; this.ctx.font = 'bold 14px Arial'; this.ctx.textAlign = 'left'; this.ctx.fillText('NULL', endX + 5, endY + 5); } } drawPointers() { if (this.size === 0) return; const frontX = this.startX + this.nodeWidth/2; const frontY = this.startY; this.ctx.fillStyle = '#27ae60'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('ğŸ”¼ Front', frontX, frontY - 20); this.drawArrow(frontX, frontY - 15, frontX, frontY, '#27ae60'); const rearIndex = this.size - 1; const rearX = this.startX + rearIndex * this.nodeSpacing + this.nodeWidth/2; const rearY = this.startY + this.nodeHeight; this.ctx.fillStyle = '#f39c12'; this.ctx.fillText('Rear ğŸ”½', rearX, rearY + 35); this.drawArrow(rearX, rearY + 30, rearX, rearY, '#f39c12'); } drawArrow(fromX, fromY, toX, toY, color) { this.ctx.strokeStyle = color; this.ctx.fillStyle = color; this.ctx.lineWidth = 3; this.ctx.beginPath(); this.ctx.moveTo(fromX, fromY); this.ctx.lineTo(toX, toY); this.ctx.stroke(); const headSize = 8; const angle = Math.atan2(toY - fromY, toX - fromX); this.ctx.beginPath(); this.ctx.moveTo(toX, toY); this.ctx.lineTo(toX - headSize * Math.cos(angle - Math.PI/6), toY - headSize * Math.sin(angle - Math.PI/6)); this.ctx.lineTo(toX - headSize * Math.cos(angle + Math.PI/6), toY - headSize * Math.sin(angle + Math.PI/6)); this.ctx.closePath(); this.ctx.fill(); } drawNodeTooltip(x, y, node, index) { let text = `èŠ‚ç‚¹ ${index}\næ•°æ®: ${node.data}`; if (node === this.front && node === this.rear) { text += '\nçŠ¶æ€: é˜Ÿå¤´é˜Ÿå°¾é‡åˆ'; } else if (node === this.front) { text += '\nçŠ¶æ€: é˜Ÿå¤´èŠ‚ç‚¹'; } else if (node === this.rear) { text += '\nçŠ¶æ€: é˜Ÿå°¾èŠ‚ç‚¹'; } else { text += '\nçŠ¶æ€: ä¸­é—´èŠ‚ç‚¹'; } text += `\nnext: ${node.next ? 'â†’ ' + node.next.data : 'NULL'}`; const lines = text.split('\n'); const padding = 10; const lineHeight = 18; const tooltipWidth = 150; const tooltipHeight = lines.length * lineHeight + padding * 2; let tooltipX = x + this.nodeWidth/2 - tooltipWidth/2; let tooltipY = y - tooltipHeight - 10; if (tooltipX < 0) tooltipX = 0; if (tooltipX + tooltipWidth > this.canvas.width) tooltipX = this.canvas.width - tooltipWidth; if (tooltipY < 0) tooltipY = y + this.nodeHeight + 10; this.ctx.fillStyle = 'rgba(44, 62, 80, 0.95)'; this.ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight); this.ctx.fillStyle = '#ffffff'; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; lines.forEach((line, i) => { this.ctx.fillText(line, tooltipX + tooltipWidth/2, tooltipY + padding + (i + 1) * lineHeight); }); } async enqueue(value) { if (this.animating) return false; this.animating = true; const newNode = new QueueNode(value); if (this.rear === null) { this.front = this.rear = newNode; } else { this.rear.next = newNode; this.rear = newNode; } this.size++; newNode.x = this.canvas.width; newNode.y = this.startY; const targetX = this.startX + (this.size - 1) * this.nodeSpacing + this.nodeWidth/2; const targetY = this.startY + this.nodeHeight/2; this.createParticles(targetX, targetY, '#27ae60', 15); await this.animateEnqueue(newNode); this.animating = false; this.showMessage(`æˆåŠŸå…¥é˜Ÿ: ${value}`, '#27ae60'); return true; } async dequeue() { if (this.animating) return null; if (this.front === null) { this.showMessage('é˜Ÿåˆ—ä¸ºç©ºï¼', '#e74c3c'); return null; } this.animating = true; const value = this.front.data; const nodeToRemove = this.front; const nodeX = this.startX + this.nodeWidth/2; const nodeY = this.startY + this.nodeHeight/2; this.createParticles(nodeX, nodeY, '#e74c3c', 15); await this.animateDequeue(nodeToRemove); this.front = this.front.next; if (this.front === null) { this.rear = null; } this.size--; this.animating = false; this.showMessage(`æˆåŠŸå‡ºé˜Ÿ: ${value}`, '#f39c12'); return value; } async animateEnqueue(newNode) { return new Promise(resolve => { let step = 0; const maxSteps = 40; const animate = () => { this.draw(); const targetX = this.startX + (this.size - 1) * this.nodeSpacing; const progress = this.easeOutCubic(step / maxSteps); const currentX = this.canvas.width + (targetX - this.canvas.width) * progress; const currentY = this.startY - 30 * Math.sin(progress * Math.PI); this.ctx.save(); this.ctx.globalAlpha = Math.min(1, step / 10); this.ctx.shadowColor = 'rgba(39, 174, 96, 0.5)'; this.ctx.shadowBlur = 15; this.ctx.shadowOffsetX = 3; this.ctx.shadowOffsetY = 3; this.ctx.fillStyle = '#27ae60'; this.ctx.strokeStyle = '#229954'; this.ctx.lineWidth = 3; this.ctx.fillRect(currentX, currentY, this.nodeWidth, this.nodeHeight); this.ctx.strokeRect(currentX, currentY, this.nodeWidth, this.nodeHeight); this.ctx.shadowBlur = 0; this.ctx.shadowOffsetX = 0; this.ctx.shadowOffsetY = 0; this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 20px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText(newNode.data.toString(), currentX + this.nodeWidth/2, currentY + this.nodeHeight/2 + 7); this.ctx.restore(); step++; if (step <= maxSteps) { setTimeout(animate, 30); } else { resolve(); } }; animate(); }); } async animateDequeue(nodeToRemove) { return new Promise(resolve => { let step = 0; const maxSteps = 40; const animate = () => { this.draw(); const startX = this.startX; const progress = this.easeInCubic(step / maxSteps); const currentX = startX - 150 * progress; const currentY = this.startY - 20 * progress; this.ctx.save(); this.ctx.globalAlpha = 1 - progress; this.ctx.shadowColor = 'rgba(231, 76, 60, 0.5)'; this.ctx.shadowBlur = 15; this.ctx.shadowOffsetX = 3; this.ctx.shadowOffsetY = 3; this.ctx.fillStyle = '#e74c3c'; this.ctx.strokeStyle = '#c0392b'; this.ctx.lineWidth = 3; this.ctx.fillRect(currentX, currentY, this.nodeWidth, this.nodeHeight); this.ctx.strokeRect(currentX, currentY, this.nodeWidth, this.nodeHeight); this.ctx.shadowBlur = 0; this.ctx.shadowOffsetX = 0; this.ctx.shadowOffsetY = 0; this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 20px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText(nodeToRemove.data.toString(), currentX + this.nodeWidth/2, currentY + this.nodeHeight/2 + 7); this.ctx.restore(); step++; if (step <= maxSteps) { setTimeout(animate, 30); } else { resolve(); } }; animate(); }); } easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); } easeInCubic(t) { return t * t * t; } showMessage(message, color) { const statusDiv = document.getElementById('queueStatus'); statusDiv.innerHTML += `<div style="color: ${color}; margin-top: 5px;">ğŸ”” ${message}</div>`; setTimeout(() => { this.updateStatus(); }, 3000); } updateStatus() { const statusDiv = document.getElementById('queueStatus'); const frontData = this.front ? this.front.data : 'NULL'; const rearData = this.rear ? this.rear.data : 'NULL'; statusDiv.innerHTML = ` <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;"><span><strong>é˜Ÿåˆ—å¤§å°:</strong> ${this.size}</span><span><strong>é˜Ÿå¤´æ•°æ®:</strong> ${frontData}</span><span><strong>é˜Ÿå°¾æ•°æ®:</strong> ${rearData}</span><span style="color: ${this.size === 0 ? '#e74c3c' : '#27ae60'}; font-weight: bold;"><strong>çŠ¶æ€:</strong> ${this.size === 0 ? 'ç©º' : 'æ­£å¸¸'} </span></div> `; } reset() { this.front = this.rear = null; this.size = 0; this.particles = []; this.showMessage('é˜Ÿåˆ—å·²é‡ç½®', '#3498db'); } async demo() { if (this.animating) return; this.reset(); await new Promise(resolve => setTimeout(resolve, 500)); const demoData = [10, 20, 30, 40]; for (let value of demoData) { await this.enqueue(value); await new Promise(resolve => setTimeout(resolve, 1000)); } await new Promise(resolve => setTimeout(resolve, 1000)); for (let i = 0; i < 2; i++) { await this.dequeue(); await new Promise(resolve => setTimeout(resolve, 1000)); } await new Promise(resolve => setTimeout(resolve, 500)); await this.enqueue(50); await new Promise(resolve => setTimeout(resolve, 800)); await this.enqueue(60); this.showMessage('æ¼”ç¤ºå®Œæˆï¼é“¾é˜Ÿåˆ—åŠ¨æ€æ‰©å±•', '#9b59b6'); } } let linkedQueue = new LinkedQueueVisual('queueCanvas'); async function enqueue() { const input = document.getElementById('inputValue'); const value = parseInt(input.value); if (isNaN(value) || value < 1 || value > 99) { alert('è¯·è¾“å…¥1-99ä¹‹é—´çš„æœ‰æ•ˆæ•°å­—ï¼'); return; } const success = await linkedQueue.enqueue(value); if (success) { input.value = ''; } } async function dequeue() { await linkedQueue.dequeue(); } function resetQueue() { linkedQueue.reset(); } async function startDemo() { await linkedQueue.demo(); } function showCode(language) { document.querySelectorAll('.code-content').forEach(el => el.style.display = 'none'); document.querySelectorAll('.code-tab').forEach(el => el.classList.remove('active')); document.getElementById(language + '-code').style.display = 'block'; event.target.classList.add('active'); } function copyCode(language, button) { const codeElement = document.querySelector(`#${language}-code pre code`); const text = codeElement.textContent; if (navigator.clipboard && window.isSecureContext) { navigator.clipboard.writeText(text).then(() => { showCopySuccess(button); }).catch(() => { fallbackCopyText(text, button); }); } else { fallbackCopyText(text, button); } } function fallbackCopyText(text, button) { const textArea = document.createElement('textarea'); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.left = '-999999px'; textArea.style.top = '-999999px'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); showCopySuccess(button); } catch (err) { console.error('å¤åˆ¶å¤±è´¥:', err); alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»£ç '); } document.body.removeChild(textArea); } function showCopySuccess(button) { const originalText = button.textContent; const originalBg = button.style.background; button.textContent = 'âœ… å·²å¤åˆ¶'; button.style.background = '#27ae60'; button.style.transform = 'scale(1.1)'; setTimeout(() => { button.textContent = originalText; button.style.background = originalBg; button.style.transform = 'scale(1)'; }, 2000); } function toggleAnswer(answerId) { const answer = document.getElementById(answerId); const btn = event.target; if (answer.style.display === 'none' || answer.style.display === '') { answer.style.display = 'block'; btn.textContent = 'éšè—ç­”æ¡ˆ'; btn.style.background = '#e74c3c'; } else { answer.style.display = 'none'; btn.textContent = 'æ˜¾ç¤ºç­”æ¡ˆ'; btn.style.background = '#17a2b8'; } } document.getElementById('inputValue').addEventListener('keypress', function(e) { if (e.key === 'Enter') { enqueue(); } }); document.getElementById('inputValue').addEventListener('focus', function() { this.style.borderColor = '#3498db'; this.style.boxShadow = '0 0 10px rgba(52, 152, 219, 0.3)'; }); document.getElementById('inputValue').addEventListener('blur', function() { this.style.borderColor = '#3498db'; this.style.boxShadow = 'none'; });</script>
{% endblock %}