{% extends 'knowledge_app/base.html' %}

{% block title %}{{ page_title|default:"最小生成树——Prim算法" }} - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>{{ breadcrumb_category|default:"数据结构" }}</span>
        <span>></span>
        <span>{{ page_title|default:"最小生成树——Prim算法" }}</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">{{ page_icon|default:"🌲" }}</span>
            {{ page_title|default:"最小生成树——Prim算法" }}
        </h1>
        <p>{{ page_description|default:"从点开始逐步生长的最小生成树算法，体验点优先的贪心策略" }}</p>
    </div>

    <!-- 📋 算法概述 -->
    <div class="content-card slide-in-right">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📋</span>
                算法概述
            </h2>
            <div class="overview-content">
                <div class="concept-intro">
                    <p><strong>核心思想：</strong>Prim算法就像种植一棵树——从一个根节点开始，每次选择能以最小代价连接到已有树的新节点，让树逐步"生长"直到覆盖所有节点！</p>
                </div>

                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <h3>🏷️ 算法特点</h3>
                        <ul>
                            <li><strong>点优先策略：</strong>维护已选顶点集合，逐点扩展</li>
                            <li><strong>贪心选择：</strong>每次选择最小权重的割边</li>
                            <li><strong>连通性保证：</strong>始终保持生成的子图连通</li>
                            <li><strong>优先队列：</strong>高效维护候选边集合</li>
                            <li><strong>适用场景：</strong>稠密图中表现更优</li>
                        </ul>
                    </div>

                    <div class="info-box info-box-success">
                        <h3>📊 复杂度分析</h3>
                        <div class="complexity-table">
                            <div class="complexity-row">
                                <span class="complexity-label">时间复杂度：</span>
                                <span class="complexity-value">O(V²) 或 O(E log V)</span>
                            </div>
                            <div class="complexity-row">
                                <span class="complexity-label">空间复杂度：</span>
                                <span class="complexity-value">O(V)</span>
                            </div>
                            <div class="complexity-row">
                                <span class="complexity-label">最优场景：</span>
                                <span class="complexity-value">稠密图</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 🔄 Prim vs Kruskal对比 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🔄</span>
                Prim vs Kruskal 算法对比
            </h2>

            <div class="algorithm-comparison">
                <div class="comparison-grid">
                    <div class="algorithm-card prim-card">
                        <h3>🌲 Prim算法</h3>
                        <div class="algorithm-features">
                            <div class="feature-item">
                                <span class="feature-icon">🎯</span>
                                <div>
                                    <strong>策略：</strong>点优先（顶点驱动）
                                    <p>从起点开始，逐步扩展已选顶点集合</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">🌱</span>
                                <div>
                                    <strong>生长模式：</strong>从内向外
                                    <p>像树一样从根部开始生长</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">🔗</span>
                                <div>
                                    <strong>连通性：</strong>始终保持连通
                                    <p>任何时刻都是一棵树</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">📈</span>
                                <div>
                                    <strong>适用：</strong>稠密图
                                    <p>边多时优势明显</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="algorithm-card kruskal-card">
                        <h3>🌳 Kruskal算法</h3>
                        <div class="algorithm-features">
                            <div class="feature-item">
                                <span class="feature-icon">🎯</span>
                                <div>
                                    <strong>策略：</strong>边优先（边驱动）
                                    <p>按边权重排序，逐边添加</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">🧩</span>
                                <div>
                                    <strong>生长模式：</strong>分散合并
                                    <p>多个连通分量逐渐合并</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">🔍</span>
                                <div>
                                    <strong>环检测：</strong>并查集
                                    <p>使用并查集避免形成环</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">📉</span>
                                <div>
                                    <strong>适用：</strong>稀疏图
                                    <p>边少时效率更高</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="comparison-summary">
                    <h4>🎯 选择建议</h4>
                    <div class="selection-guide">
                        <div class="guide-item">
                            <strong>选择Prim：</strong>稠密图(E接近V²)、需要从特定起点开始、内存受限
                        </div>
                        <div class="guide-item">
                            <strong>选择Kruskal：</strong>稀疏图(E远小于V²)、边权重分布广泛、并行处理
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 📊 可视化展示 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📊</span>
                可视化演示
            </h2>

            <div class="visualization-container">
                <h3>🎬 Prim算法动画演示</h3>

                <!-- 控制面板 -->
                <div class="demo-controls">
                    <div class="control-panel">
                        <button id="autoDemo" class="unified-btn unified-btn-success">🚀 自动演示</button>
                        <button id="stepDemo" class="unified-btn unified-btn-primary">👆 单步执行</button>
                        <button id="resetDemo" class="unified-btn unified-btn-secondary">🔄 重置</button>
                        <button id="randomGraph" class="unified-btn unified-btn-warning">🎲 随机图</button>
                    </div>
                    <div class="graph-options">
                        <label>起始节点：</label>
                        <select id="startNode">
                            <option value="0">节点 A (0)</option>
                            <option value="1">节点 B (1)</option>
                            <option value="2">节点 C (2)</option>
                            <option value="3">节点 D (3)</option>
                            <option value="4">节点 E (4)</option>
                        </select>
                        <label>速度：</label>
                        <input type="range" id="speedSlider" min="500" max="3000" value="1500" step="250">
                        <span id="speedLabel">正常</span>
                    </div>
                </div>

                <div class="demo-info" id="demoInfo">
                    点击"自动演示"观看Prim算法的完整执行过程
                </div>

                <!-- 主要可视化区域 -->
                <div class="visualization-area">
                    <!-- 图结构展示 -->
                    <div class="graph-display">
                        <canvas id="primCanvas" width="600" height="450"></canvas>
                        <div class="graph-legend">
                            <div class="legend-item">
                                <div class="legend-dot unvisited"></div>
                                <span>未访问节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-dot visited"></div>
                                <span>已访问节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-dot current"></div>
                                <span>当前节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line mst-edge"></div>
                                <span>MST边</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line candidate-edge"></div>
                                <span>候选边</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line current-edge"></div>
                                <span>当前选择的边</span>
                            </div>
                        </div>
                    </div>

                    <!-- 优先队列状态 -->
                    <div class="priority-queue-panel">
                        <h4>🔍 优先队列状态</h4>
                        <div class="queue-display" id="queueDisplay">
                            <div class="queue-header">
                                <span>权重</span>
                                <span>边</span>
                                <span>状态</span>
                            </div>
                            <div class="queue-body" id="queueBody">
                                <div class="empty-queue">队列为空</div>
                            </div>
                        </div>
                        <div class="algorithm-stats" id="algorithmStats">
                            <div>已访问节点: <span id="visitedCount">0</span></div>
                            <div>MST边数: <span id="mstEdgeCount">0</span></div>
                            <div>当前总权重: <span id="currentWeight">0</span></div>
                        </div>
                    </div>
                </div>

                <!-- 步骤详解 -->
                <div class="step-details" id="stepDetails">
                    <h4>📝 执行步骤</h4>
                    <div class="step-list" id="stepList">
                        <div class="step-item">准备开始Prim算法...</div>
                    </div>
                </div>
            </div>

            <!-- 算法伪代码 -->
            <div class="algorithm-pseudocode">
                <h3>🔧 Prim算法伪代码</h3>
                <div class="pseudocode-container">
                    <pre class="pseudocode" id="pseudocode">
<span class="keyword">function</span> <span class="function">PrimMST</span>(<span class="param">graph, start</span>):
    <span class="comment">// 1. 初始化</span>
    <span class="variable">visited</span> ← <span class="function">新建空集合()</span>
    <span class="variable">mstEdges</span> ← <span class="function">新建空列表()</span>
    <span class="variable">priorityQueue</span> ← <span class="function">新建优先队列()</span>

    <span class="comment">// 2. 从起始节点开始</span>
    <span class="function">visited.add</span>(<span class="variable">start</span>)

    <span class="comment">// 3. 将起始节点的所有邻边加入队列</span>
    <span class="keyword">for each</span> <span class="variable">edge</span> <span class="keyword">from</span> <span class="variable">start</span>:
        <span class="function">priorityQueue.add</span>(<span class="variable">edge</span>, <span class="variable">edge.weight</span>)

    <span class="comment">// 4. 重复直到所有节点都被访问</span>
    <span class="keyword">while</span> <span class="variable">visited.size</span> &lt; <span class="variable">graph.nodeCount</span>:
        <span class="comment">// 5. 取出权重最小的边</span>
        <span class="variable">minEdge</span> ← <span class="function">priorityQueue.extractMin</span>()

        <span class="comment">// 6. 检查边的目标节点是否已访问</span>
        <span class="keyword">if</span> <span class="variable">minEdge.to</span> <span class="keyword">not in</span> <span class="variable">visited</span>:
            <span class="comment">// 7. 添加到MST</span>
            <span class="function">mstEdges.add</span>(<span class="variable">minEdge</span>)
            <span class="function">visited.add</span>(<span class="variable">minEdge.to</span>)

            <span class="comment">// 8. 添加新节点的邻边到队列</span>
            <span class="keyword">for each</span> <span class="variable">edge</span> <span class="keyword">from</span> <span class="variable">minEdge.to</span>:
                <span class="keyword">if</span> <span class="variable">edge.to</span> <span class="keyword">not in</span> <span class="variable">visited</span>:
                    <span class="function">priorityQueue.add</span>(<span class="variable">edge</span>, <span class="variable">edge.weight</span>)

    <span class="keyword">return</span> <span class="variable">mstEdges</span>
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 💻 代码实现 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">💻</span>
                代码实现
            </h2>

            <div class="code-examples">
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="python">Python</button>
                    <button class="tab-btn" data-lang="java">Java</button>
                    <button class="tab-btn" data-lang="cpp">C++</button>
                </div>

                <!-- Python 代码 -->
                <div class="code-content active" data-lang="python">
                    <div class="code-header">
                        <span>Prim算法实现 - Python</span>
                        <button class="copy-btn" data-clipboard-target="python-code">📋 复制</button>
                    </div>
                    <pre id="python-code"><code>
import heapq
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
        self.vertices = set()

    def add_edge(self, u, v, weight):
        """添加无向边"""
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))
        self.vertices.add(u)
        self.vertices.add(v)

    def prim_mst(self, start=None):
        """Prim算法求最小生成树"""
        if not self.vertices:
            return [], 0

        # 选择起始节点
        start = start if start is not None else next(iter(self.vertices))

        visited = set()
        mst_edges = []
        total_weight = 0

        # 优先队列存储 (权重, 起点, 终点)
        priority_queue = []

        # 从起始节点开始
        visited.add(start)

        # 将起始节点的所有邻边加入优先队列
        for neighbor, weight in self.graph[start]:
            heapq.heappush(priority_queue, (weight, start, neighbor))

        while priority_queue and len(visited) < len(self.vertices):
            weight, u, v = heapq.heappop(priority_queue)

            # 如果目标节点已经在MST中，跳过
            if v in visited:
                continue

            # 添加边到MST
            visited.add(v)
            mst_edges.append((u, v, weight))
            total_weight += weight

            # 将新节点的邻边加入优先队列
            for neighbor, edge_weight in self.graph[v]:
                if neighbor not in visited:
                    heapq.heappush(priority_queue, (edge_weight, v, neighbor))

        return mst_edges, total_weight

    def prim_mst_matrix(self, adj_matrix):
        """使用邻接矩阵的Prim算法实现"""
        n = len(adj_matrix)
        if n == 0:
            return [], 0

        # 初始化
        visited = [False] * n
        min_weight = [float('inf')] * n
        parent = [-1] * n

        # 从节点0开始
        min_weight[0] = 0
        mst_edges = []
        total_weight = 0

        for _ in range(n):
            # 找到未访问节点中权重最小的
            min_val = float('inf')
            min_index = -1

            for v in range(n):
                if not visited[v] and min_weight[v] < min_val:
                    min_val = min_weight[v]
                    min_index = v

            # 将节点加入MST
            visited[min_index] = True

            # 添加边到结果（除了起始节点）
            if parent[min_index] != -1:
                mst_edges.append((parent[min_index], min_index, min_val))
                total_weight += min_val

            # 更新相邻节点的最小权重
            for v in range(n):
                if (not visited[v] and adj_matrix[min_index][v] > 0 and
                    adj_matrix[min_index][v] < min_weight[v]):
                    min_weight[v] = adj_matrix[min_index][v]
                    parent[v] = min_index

        return mst_edges, total_weight

def compare_algorithms():
    """比较Prim和Kruskal算法"""
    # 创建测试图
    g = Graph()
    edges = [
        (0, 1, 2), (0, 3, 6), (1, 2, 3), (1, 3, 8),
        (1, 4, 5), (2, 4, 7), (3, 4, 9)
    ]

    for u, v, w in edges:
        g.add_edge(u, v, w)

    # Prim算法
    prim_mst, prim_weight = g.prim_mst(0)
    print("Prim算法结果:")
    print(f"MST边: {prim_mst}")
    print(f"总权重: {prim_weight}")

    # 也可以实现Kruskal进行对比...

# 使用示例
if __name__ == "__main__":
    # 创建图
    g = Graph()

    # 添加边 (起点, 终点, 权重)
    edges = [
        ('A', 'B', 2), ('A', 'D', 6), ('B', 'C', 3),
        ('B', 'D', 8), ('B', 'E', 5), ('C', 'E', 7), ('D', 'E', 9)
    ]

    for u, v, weight in edges:
        g.add_edge(u, v, weight)

    # 运行Prim算法
    mst, total_weight = g.prim_mst('A')

    print("最小生成树 (Prim算法):")
    for u, v, weight in mst:
        print(f"  {u} - {v} : {weight}")
    print(f"总权重: {total_weight}")

    # 使用邻接矩阵版本
    adj_matrix = [
        [0, 2, 0, 6, 0],
        [2, 0, 3, 8, 5],
        [0, 3, 0, 0, 7],
        [6, 8, 0, 0, 9],
        [0, 5, 7, 9, 0]
    ]

    mst_matrix, weight_matrix = g.prim_mst_matrix(adj_matrix)
    print("\n邻接矩阵版本结果:")
    print(f"MST边: {mst_matrix}")
    print(f"总权重: {weight_matrix}")
                    </code></pre>
                </div>

                <!-- Java 代码 -->
                <div class="code-content" data-lang="java">
                    <div class="code-header">
                        <span>Prim算法实现 - Java</span>
                        <button class="copy-btn" data-clipboard-target="java-code">📋 复制</button>
                    </div>
                    <pre id="java-code"><code>
import java.util.*;

class Edge implements Comparable&lt;Edge&gt; {
    int from, to, weight;

    public Edge(int from, int to, int weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }

    @Override
    public int compareTo(Edge other) {
        return Integer.compare(this.weight, other.weight);
    }

    @Override
    public String toString() {
        return String.format("(%d-%d:%d)", from, to, weight);
    }
}

public class PrimAlgorithm {

    // 使用优先队列的Prim算法
    public static List&lt;Edge&gt; primMST(List&lt;List&lt;Edge&gt;&gt; graph, int start) {
        int n = graph.size();
        boolean[] visited = new boolean[n];
        List&lt;Edge&gt; mst = new ArrayList&lt;&gt;();
        PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;();

        // 从起始节点开始
        visited[start] = true;

        // 将起始节点的所有邻边加入优先队列
        for (Edge edge : graph.get(start)) {
            pq.offer(edge);
        }

        while (!pq.isEmpty() && mst.size() < n - 1) {
            Edge minEdge = pq.poll();

            // 如果目标节点已访问，跳过
            if (visited[minEdge.to]) {
                continue;
            }

            // 添加边到MST
            mst.add(minEdge);
            visited[minEdge.to] = true;

            // 添加新节点的邻边
            for (Edge edge : graph.get(minEdge.to)) {
                if (!visited[edge.to]) {
                    pq.offer(edge);
                }
            }
        }

        return mst;
    }

    // 使用邻接矩阵的Prim算法
    public static List&lt;Edge&gt; primMSTMatrix(int[][] adjMatrix) {
        int n = adjMatrix.length;
        boolean[] visited = new boolean[n];
        int[] minWeight = new int[n];
        int[] parent = new int[n];
        List&lt;Edge&gt; mst = new ArrayList&lt;&gt;();

        // 初始化
        Arrays.fill(minWeight, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        minWeight[0] = 0; // 从节点0开始

        for (int count = 0; count < n; count++) {
            // 找到未访问节点中权重最小的
            int minVal = Integer.MAX_VALUE;
            int minIndex = -1;

            for (int v = 0; v < n; v++) {
                if (!visited[v] && minWeight[v] < minVal) {
                    minVal = minWeight[v];
                    minIndex = v;
                }
            }

            // 将节点加入MST
            visited[minIndex] = true;

            // 添加边到结果（除了起始节点）
            if (parent[minIndex] != -1) {
                mst.add(new Edge(parent[minIndex], minIndex, minVal));
            }

            // 更新相邻节点的最小权重
            for (int v = 0; v < n; v++) {
                if (!visited[v] && adjMatrix[minIndex][v] > 0 &&
                    adjMatrix[minIndex][v] < minWeight[v]) {
                    minWeight[v] = adjMatrix[minIndex][v];
                    parent[v] = minIndex;
                }
            }
        }

        return mst;
    }

    // 计算MST总权重
    public static int calculateTotalWeight(List&lt;Edge&gt; mst) {
        return mst.stream().mapToInt(edge -> edge.weight).sum();
    }

    // 创建邻接表
    public static List&lt;List&lt;Edge&gt;&gt; createGraph(int vertices, int[][] edges) {
        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();

        for (int i = 0; i < vertices; i++) {
            graph.add(new ArrayList&lt;&gt;());
        }

        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph.get(u).add(new Edge(u, v, w));
            graph.get(v).add(new Edge(v, u, w));
        }

        return graph;
    }

    public static void main(String[] args) {
        // 测试数据
        int[][] edges = {
            {0, 1, 2}, {0, 3, 6}, {1, 2, 3}, {1, 3, 8},
            {1, 4, 5}, {2, 4, 7}, {3, 4, 9}
        };

        // 方法1：使用邻接表和优先队列
        List&lt;List&lt;Edge&gt;&gt; graph = createGraph(5, edges);
        List&lt;Edge&gt; mst1 = primMST(graph, 0);

        System.out.println("Prim算法结果（优先队列版本）:");
        for (Edge edge : mst1) {
            System.out.println("边 " + edge.from + "-" + edge.to + " : " + edge.weight);
        }
        System.out.println("总权重: " + calculateTotalWeight(mst1));

        // 方法2：使用邻接矩阵
        int[][] adjMatrix = {
            {0, 2, 0, 6, 0},
            {2, 0, 3, 8, 5},
            {0, 3, 0, 0, 7},
            {6, 8, 0, 0, 9},
            {0, 5, 7, 9, 0}
        };

        List&lt;Edge&gt; mst2 = primMSTMatrix(adjMatrix);
        System.out.println("\nPrim算法结果（邻接矩阵版本）:");
        for (Edge edge : mst2) {
            System.out.println("边 " + edge.from + "-" + edge.to + " : " + edge.weight);
        }
        System.out.println("总权重: " + calculateTotalWeight(mst2));
    }
}

// 图类封装
class PrimGraph {
    private List&lt;List&lt;Edge&gt;&gt; adjList;
    private int vertices;

    public PrimGraph(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList&lt;&gt;());
        }
    }

    public void addEdge(int from, int to, int weight) {
        adjList.get(from).add(new Edge(from, to, weight));
        adjList.get(to).add(new Edge(to, from, weight));
    }

    public List&lt;Edge&gt; findMST(int start) {
        return PrimAlgorithm.primMST(adjList, start);
    }

    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print("顶点 " + i + ": ");
            for (Edge edge : adjList.get(i)) {
                System.out.print("(" + edge.to + "," + edge.weight + ") ");
            }
            System.out.println();
        }
    }
}
                    </code></pre>
                </div>

                <!-- C++ 代码 -->
                <div class="code-content" data-lang="cpp">
                    <div class="code-header">
                        <span>Prim算法实现 - C++</span>
                        <button class="copy-btn" data-clipboard-target="cpp-code">📋 复制</button>
                    </div>
                    <pre id="cpp-code"><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Edge {
    int from, to, weight;

    Edge(int f, int t, int w) : from(f), to(t), weight(w) {}

    bool operator>(const Edge& other) const {
        return weight > other.weight;
    }
};

class PrimAlgorithm {
private:
    vector&lt;vector&lt;Edge&gt;&gt; graph;
    int vertices;

public:
    PrimAlgorithm(int v) : vertices(v) {
        graph.resize(v);
    }

    void addEdge(int from, int to, int weight) {
        graph[from].emplace_back(from, to, weight);
        graph[to].emplace_back(to, from, weight);
    }

    // 使用优先队列的Prim算法
    vector&lt;Edge&gt; primMST(int start = 0) {
        vector&lt;bool&gt; visited(vertices, false);
        vector&lt;Edge&gt; mst;
        priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;

        // 从起始节点开始
        visited[start] = true;

        // 将起始节点的所有邻边加入优先队列
        for (const auto& edge : graph[start]) {
            pq.push(edge);
        }

        while (!pq.empty() && mst.size() < vertices - 1) {
            Edge minEdge = pq.top();
            pq.pop();

            // 如果目标节点已访问，跳过
            if (visited[minEdge.to]) {
                continue;
            }

            // 添加边到MST
            mst.push_back(minEdge);
            visited[minEdge.to] = true;

            // 添加新节点的邻边
            for (const auto& edge : graph[minEdge.to]) {
                if (!visited[edge.to]) {
                    pq.push(edge);
                }
            }
        }

        return mst;
    }

    // 使用邻接矩阵的Prim算法（更高效的版本）
    vector&lt;Edge&gt; primMSTMatrix(const vector&lt;vector&lt;int&gt;&gt;& adjMatrix) {
        int n = adjMatrix.size();
        vector&lt;bool&gt; visited(n, false);
        vector&lt;int&gt; minWeight(n, INT_MAX);
        vector&lt;int&gt; parent(n, -1);
        vector&lt;Edge&gt; mst;

        // 从节点0开始
        minWeight[0] = 0;

        for (int count = 0; count < n; count++) {
            // 找到未访问节点中权重最小的
            int minVal = INT_MAX;
            int minIndex = -1;

            for (int v = 0; v < n; v++) {
                if (!visited[v] && minWeight[v] < minVal) {
                    minVal = minWeight[v];
                    minIndex = v;
                }
            }

            // 将节点加入MST
            visited[minIndex] = true;

            // 添加边到结果（除了起始节点）
            if (parent[minIndex] != -1) {
                mst.emplace_back(parent[minIndex], minIndex, minVal);
            }

            // 更新相邻节点的最小权重
            for (int v = 0; v < n; v++) {
                if (!visited[v] && adjMatrix[minIndex][v] > 0 &&
                    adjMatrix[minIndex][v] < minWeight[v]) {
                    minWeight[v] = adjMatrix[minIndex][v];
                    parent[v] = minIndex;
                }
            }
        }

        return mst;
    }

    // 计算MST总权重
    int calculateTotalWeight(const vector&lt;Edge&gt;& mst) {
        int total = 0;
        for (const auto& edge : mst) {
            total += edge.weight;
        }
        return total;
    }

    // 打印MST
    void printMST(const vector&lt;Edge&gt;& mst) {
        cout << "最小生成树的边:\n";
        for (const auto& edge : mst) {
            cout << "边 " << edge.from << "-" << edge.to
                 << " : 权重 " << edge.weight << "\n";
        }
        cout << "总权重: " << calculateTotalWeight(mst) << "\n";
    }
};

// 比较两种实现的性能
class PerformanceTest {
public:
    static void comparePrimImplementations() {
        // 创建测试图
        PrimAlgorithm prim(5);

        // 添加边
        vector&lt;vector&lt;int&gt;&gt; edges = {
            {0, 1, 2}, {0, 3, 6}, {1, 2, 3}, {1, 3, 8},
            {1, 4, 5}, {2, 4, 7}, {3, 4, 9}
        };

        for (const auto& edge : edges) {
            prim.addEdge(edge[0], edge[1], edge[2]);
        }

        // 方法1：优先队列版本
        cout << "=== 优先队列版本 ===\n";
        auto mst1 = prim.primMST(0);
        prim.printMST(mst1);

        // 方法2：邻接矩阵版本
        cout << "\n=== 邻接矩阵版本 ===\n";
        vector&lt;vector&lt;int&gt;&gt; adjMatrix = {
            {0, 2, 0, 6, 0},
            {2, 0, 3, 8, 5},
            {0, 3, 0, 0, 7},
            {6, 8, 0, 0, 9},
            {0, 5, 7, 9, 0}
        };

        auto mst2 = prim.primMSTMatrix(adjMatrix);
        prim.printMST(mst2);
    }
};

// 高级特性：带路径追踪的Prim算法
class AdvancedPrim {
public:
    struct MSTResult {
        vector&lt;Edge&gt; edges;
        int totalWeight;
        vector&lt;int&gt; constructionOrder;
    };

    static MSTResult primWithTrace(PrimAlgorithm& prim, int start) {
        // 这里可以实现带详细追踪信息的版本
        MSTResult result;
        result.edges = prim.primMST(start);
        result.totalWeight = prim.calculateTotalWeight(result.edges);

        // 记录构造顺序
        for (size_t i = 0; i < result.edges.size(); i++) {
            result.constructionOrder.push_back(i);
        }

        return result;
    }
};

int main() {
    cout << "Prim算法演示\n";
    cout << "===============\n";

    // 基本测试
    PrimAlgorithm prim(5);

    // 构建测试图
    vector&lt;vector&lt;int&gt;&gt; testEdges = {
        {0, 1, 2}, {0, 3, 6}, {1, 2, 3}, {1, 3, 8},
        {1, 4, 5}, {2, 4, 7}, {3, 4, 9}
    };

    for (const auto& edge : testEdges) {
        prim.addEdge(edge[0], edge[1], edge[2]);
    }

    // 从不同起点运行算法
    cout << "从节点0开始:\n";
    auto mst0 = prim.primMST(0);
    prim.printMST(mst0);

    cout << "\n从节点2开始:\n";
    auto mst2 = prim.primMST(2);
    prim.printMST(mst2);

    // 性能比较
    cout << "\n=== 性能比较 ===\n";
    PerformanceTest::comparePrimImplementations();

    return 0;
}
                    </code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- ✅ 学习检验 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">✅</span>
                学习检验
            </h2>

            <div class="quiz-container">
                <div class="quiz-item">
                    <h3>🤔 思考题1：算法策略差异</h3>
                    <p><strong>问题：</strong>Prim算法为什么被称为"点优先"算法，而Kruskal被称为"边优先"？它们的根本差异是什么？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer1')">点击查看答案</button>
                    <div class="answer-content" id="answer1">
                        <p><strong>答案：</strong>Prim从节点角度思考，每次扩展一个新节点；Kruskal从边角度思考，每次选择一条最小边。</p>
                        <p><strong>详细解释：</strong>①<strong>Prim算法：</strong>维护一个已访问节点集合，每次选择连接已访问和未访问节点的最小权重边，逐步"生长"MST；②<strong>Kruskal算法：</strong>将所有边排序，每次选择权重最小且不形成环的边；③<strong>本质差异：</strong>Prim保证任何时刻都是连通的，Kruskal允许多个连通分量最后合并。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题2：复杂度分析</h3>
                    <p><strong>问题：</strong>Prim算法有O(V²)和O(E log V)两种复杂度，分别对应什么实现方式？什么时候选择哪种？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer2')">点击查看答案</button>
                    <div class="answer-content" id="answer2">
                        <p><strong>答案：</strong>O(V²)对应邻接矩阵实现，O(E log V)对应优先队列实现。</p>
                        <p><strong>选择策略：</strong>①<strong>O(V²)版本：</strong>适合稠密图(E接近V²)，空间效率高，代码简单；②<strong>O(E log V)版本：</strong>适合稀疏图(E远小于V²)，使用优先队列；③<strong>临界点：</strong>当E > V²/log V时选择O(V²)版本更优。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题3：起点选择影响</h3>
                    <p><strong>问题：</strong>Prim算法的起点选择会影响最终的MST结果吗？会影响算法性能吗？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer3')">点击查看答案</button>
                    <div class="answer-content" id="answer3">
                        <p><strong>答案：</strong>不影响MST的总权重，但可能影响具体边的选择顺序和性能。</p>
                        <p><strong>详细分析：</strong>①<strong>结果一致性：</strong>MST总权重相同，但具体边可能不同（当有多条相同权重边时）；②<strong>性能影响：</strong>起点选择可能影响优先队列大小和算法运行时间；③<strong>最优选择：</strong>理论上选择度数最大的节点作为起点可能更优，但实际差异通常不大。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题4：优先队列优化</h3>
                    <p><strong>问题：</strong>在Prim算法中，如何处理优先队列中的"过期边"（目标节点已被访问的边）？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer4')">点击查看答案</button>
                    <div class="answer-content" id="answer4">
                        <p><strong>答案：</strong>惰性删除 - 在弹出时检查目标节点是否已访问，已访问则跳过。</p>
                        <p><strong>实现策略：</strong>①<strong>惰性删除：</strong>不主动删除过期边，弹出时检查；②<strong>主动删除：</strong>使用支持删除的优先队列（如索引优先队列）；③<strong>权衡考虑：</strong>惰性删除实现简单但可能浪费空间，主动删除效率更高但实现复杂；④<strong>实际选择：</strong>对于大多数应用，惰性删除已足够。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题5：算法变种应用</h3>
                    <p><strong>问题：</strong>如何修改Prim算法来解决"最大生成树"问题？还能解决什么其他问题？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer5')">点击查看答案</button>
                    <div class="answer-content" id="answer5">
                        <p><strong>答案：</strong>将最小堆改为最大堆，或者将所有权重取负值后求MST。</p>
                        <p><strong>扩展应用：</strong>①<strong>最大生成树：</strong>修改优先队列为最大堆；②<strong>次小生成树：</strong>在MST基础上替换一条边；③<strong>k-MST问题：</strong>找包含k个节点的最小生成树；④<strong>瓶颈生成树：</strong>最小化最大边权重的生成树；⑤<strong>有根MST：</strong>指定根节点的有向MST问题。</p>
                    </div>
                </div>
            </div>

            <!-- 进阶学习建议 -->
            <div class="learning-progress">
                <h3>📚 进阶学习路径</h3>
                <div class="progress-steps">
                    <div class="progress-step completed">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <h4>Prim算法基础</h4>
                            <p>掌握点优先的贪心策略</p>
                        </div>
                    </div>
                    <div class="progress-step next">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <h4>Kruskal对比</h4>
                            <p>理解两种算法的适用场景</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <h4>高级MST问题</h4>
                            <p>次小生成树、动态MST</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">4</span>
                        <div class="step-content">
                            <h4>实际应用</h4>
                            <p>网络设计、聚类算法</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<!-- CSS样式 -->
<style>
.overview-content {
    margin-top: 20px;
}

.concept-intro {
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 4px solid #2196F3;
}

.complexity-table {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.complexity-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}

.complexity-label {
    font-weight: bold;
    color: #333;
}

.complexity-value {
    color: #2196F3;
    font-family: 'Monaco', 'Consolas', monospace;
    font-weight: bold;
}

.algorithm-comparison {
    margin-top: 20px;
}

.comparison-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 30px;
    margin-bottom: 30px;
}

.algorithm-card {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.prim-card {
    border-left: 5px solid #4CAF50;
}

.kruskal-card {
    border-left: 5px solid #FF9800;
}

.algorithm-card::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    height: 100px;
    background: linear-gradient(135deg, transparent, rgba(255,255,255,0.1));
    border-radius: 50%;
    transform: translate(30px, -30px);
}

.algorithm-card h3 {
    color: #333;
    margin-bottom: 20px;
    font-size: 1.4rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.algorithm-features {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.feature-item {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    transition: all 0.3s ease;
}

.feature-item:hover {
    background: #e9ecef;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.feature-icon {
    font-size: 1.5em;
    flex-shrink: 0;
    margin-top: 2px;
}

.feature-item strong {
    color: #333;
    display: block;
    margin-bottom: 5px;
}

.feature-item p {
    color: #666;
    margin: 0;
    font-size: 14px;
    line-height: 1.4;
}

.comparison-summary {
    background: white;
    padding: 25px;
    border-radius: 15px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    border-left: 5px solid #2196F3;
}

.comparison-summary h4 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.2rem;
}

.selection-guide {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.guide-item {
    padding: 12px 15px;
    background: #f0f7ff;
    border-radius: 8px;
    border-left: 3px solid #2196F3;
    font-size: 14px;
}

.visualization-container {
    margin-top: 20px;
}

.demo-controls {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.control-panel {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.graph-options {
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
}

.graph-options label {
    font-weight: bold;
    color: #333;
}

.graph-options select,
.graph-options input[type="range"] {
    padding: 6px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.demo-info {
    text-align: center;
    padding: 15px;
    background: #e3f2fd;
    border-radius: 6px;
    font-weight: bold;
    color: #1976D2;
    margin-bottom: 20px;
}

.visualization-area {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.graph-display {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

#primCanvas {
    border: 2px solid #ddd;
    border-radius: 8px;
    display: block;
    margin: 0 auto;
}

.graph-legend {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 12px;
    padding: 5px 10px;
    background: #f5f5f5;
    border-radius: 15px;
}

.legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid #333;
}

.legend-dot.unvisited {
    background: #e0e0e0;
}

.legend-dot.visited {
    background: #4CAF50;
}

.legend-dot.current {
    background: #FF5722;
}

.legend-line {
    width: 20px;
    height: 3px;
    border-radius: 2px;
}

.legend-line.mst-edge {
    background: #4CAF50;
}

.legend-line.candidate-edge {
    background: #2196F3;
}

.legend-line.current-edge {
    background: #FF9800;
}

.priority-queue-panel {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.priority-queue-panel h4 {
    margin: 0 0 15px 0;
    color: #333;
    text-align: center;
}

.queue-display {
    margin-bottom: 20px;
}

.queue-header {
    display: grid;
    grid-template-columns: 60px 1fr 60px;
    gap: 10px;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 5px 5px 0 0;
    font-weight: bold;
    text-align: center;
    font-size: 12px;
}

.queue-body {
    min-height: 100px;
    max-height: 200px;
    border: 1px solid #ddd;
    border-radius: 0 0 5px 5px;
    overflow-y: auto;
}

.empty-queue {
    padding: 40px 20px;
    text-align: center;
    color: #999;
    font-style: italic;
}

.queue-item {
    display: grid;
    grid-template-columns: 60px 1fr 60px;
    gap: 10px;
    padding: 8px 10px;
    border-bottom: 1px solid #eee;
    font-size: 12px;
    text-align: center;
    align-items: center;
}

.queue-item:hover {
    background: #f0f7ff;
}

.queue-item.priority {
    background: #fff3e0;
    font-weight: bold;
}

.algorithm-stats {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.algorithm-stats div {
    padding: 8px 12px;
    background: #f5f5f5;
    border-radius: 4px;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
}

.algorithm-stats span {
    font-weight: bold;
    color: #2196F3;
}

.step-details {
    grid-column: 1 / -1;
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.step-details h4 {
    margin: 0 0 15px 0;
    color: #333;
}

.step-list {
    max-height: 200px;
    overflow-y: auto;
}

.step-item {
    padding: 8px 12px;
    border-left: 4px solid #e0e0e0;
    margin-bottom: 6px;
    background: #f9f9f9;
    border-radius: 0 4px 4px 0;
    font-size: 14px;
}

.step-item.active {
    border-left-color: #FF5722;
    background: #fff3e0;
    font-weight: bold;
}

.step-item.completed {
    border-left-color: #4CAF50;
    background: #e8f5e8;
    color: #2E7D32;
}

.algorithm-pseudocode {
    margin-top: 30px;
}

.pseudocode-container {
    background: #1e1e1e;
    border-radius: 8px;
    overflow: hidden;
}

.pseudocode {
    color: #f8f8f2;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.6;
    padding: 20px;
    margin: 0;
    overflow-x: auto;
}

.keyword {
    color: #66d9ef;
    font-weight: bold;
}

.function {
    color: #a6e22e;
}

.param {
    color: #fd971f;
}

.variable {
    color: #f92672;
}

.comment {
    color: #75715e;
    font-style: italic;
}

.code-examples {
    margin-top: 30px;
}

.code-tabs {
    display: flex;
    margin-bottom: 0;
    border-bottom: 2px solid #e0e0e0;
}

.tab-btn {
    padding: 12px 24px;
    background: #f5f5f5;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
}

.tab-btn.active {
    background: #2196F3;
    color: white;
    border-bottom-color: #2196F3;
}

.code-content {
    display: none;
    background: #1e1e1e;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
}

.code-content.active {
    display: block;
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: #333;
    color: white;
    font-size: 14px;
}

.copy-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.2s;
}

.copy-btn:hover {
    background: #45a049;
}

pre {
    margin: 0;
    overflow-x: auto;
}

code {
    color: #f8f8f2;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.5;
    display: block;
    padding: 20px;
}

.quiz-container {
    margin-top: 20px;
}

.quiz-item {
    margin-bottom: 25px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.quiz-item h3 {
    color: #1976D2;
    margin-top: 0;
}

.answer-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin: 10px 0;
    font-weight: bold;
    transition: background 0.2s;
}

.answer-btn:hover {
    background: #45a049;
}

.answer-content {
    display: none;
    margin-top: 15px;
    padding: 15px;
    background: #e8f5e8;
    border-radius: 5px;
    border-left: 4px solid #4CAF50;
}

.answer-content.show {
    display: block;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.learning-progress {
    margin-top: 30px;
    padding: 20px;
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    border-radius: 10px;
}

.progress-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.progress-step {
    display: flex;
    align-items: center;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    opacity: 0.6;
    transition: all 0.3s;
}

.progress-step.completed {
    opacity: 1;
    border-left: 4px solid #4CAF50;
}

.progress-step.next {
    opacity: 1;
    border-left: 4px solid #FF9800;
    transform: scale(1.05);
}

.step-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: #e0e0e0;
    color: white;
    border-radius: 50%;
    margin-right: 15px;
    font-weight: bold;
}

.progress-step.completed .step-number {
    background: #4CAF50;
}

.progress-step.next .step-number {
    background: #FF9800;
}

.step-content h4 {
    margin: 0 0 5px 0;
    color: #333;
}

.step-content p {
    margin: 0;
    color: #666;
    font-size: 14px;
}

@media (max-width: 1200px) {
    .visualization-area {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    .comparison-grid {
        grid-template-columns: 1fr;
    }

    .control-panel {
        flex-direction: column;
        align-items: stretch;
    }

    .graph-options {
        flex-direction: column;
        align-items: stretch;
    }

    .progress-steps {
        grid-template-columns: 1fr;
    }

    .code-tabs {
        flex-wrap: wrap;
    }

    .tab-btn {
        flex: 1;
        min-width: 80px;
    }

    .graph-legend {
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }
}
</style>

<!-- JavaScript -->
<script>
// Prim算法可视化相关变量
let canvas, ctx;
let demoInProgress = false;
let stepByStep = false;
let currentStep = 0;
let animationSpeed = 1500;

// 图数据结构
let nodes = [];
let edges = [];
let visitedNodes = new Set();
let mstEdges = [];
let priorityQueue = [];
let currentWeight = 0;

// 颜色配置
const colors = {
    unvisited: '#e0e0e0',
    visited: '#4CAF50',
    current: '#FF5722',
    mstEdge: '#4CAF50',
    candidateEdge: '#2196F3',
    currentEdge: '#FF9800',
    nodeText: 'white',
    edgeText: '#333'
};

// 初始化
document.addEventListener('DOMContentLoaded', function() {
    canvas = document.getElementById('primCanvas');
    ctx = canvas.getContext('2d');

    initializeDemo();

    // 绑定事件
    document.getElementById('autoDemo').addEventListener('click', startAutoDemo);
    document.getElementById('stepDemo').addEventListener('click', startStepDemo);
    document.getElementById('resetDemo').addEventListener('click', resetDemo);
    document.getElementById('randomGraph').addEventListener('click', generateRandomGraph);

    document.getElementById('startNode').addEventListener('change', resetDemo);

    document.getElementById('speedSlider').addEventListener('input', function() {
        animationSpeed = parseInt(this.value);
        updateSpeedLabel();
    });

    updateSpeedLabel();
    drawGraph();
});

function initializeDemo() {
    // 初始化节点
    nodes = [
        {id: 0, x: 120, y: 80, label: 'A'},
        {id: 1, x: 280, y: 120, label: 'B'},
        {id: 2, x: 400, y: 80, label: 'C'},
        {id: 3, x: 350, y: 250, label: 'D'},
        {id: 4, x: 150, y: 280, label: 'E'}
    ];

    // 初始化边
    edges = [
        {from: 0, to: 1, weight: 2},
        {from: 0, to: 4, weight: 6},
        {from: 1, to: 2, weight: 3},
        {from: 1, to: 3, weight: 8},
        {from: 1, to: 4, weight: 5},
        {from: 2, to: 3, weight: 7},
        {from: 3, to: 4, weight: 9}
    ];

    resetState();
}

function resetState() {
    visitedNodes.clear();
    mstEdges = [];
    priorityQueue = [];
    currentWeight = 0;
    currentStep = 0;
    demoInProgress = false;
    stepByStep = false;

    updateQueueDisplay();
    updateStatsDisplay();
    updateStepsDisplay();

    document.getElementById('demoInfo').textContent = '点击"自动演示"观看Prim算法的完整执行过程';
}

function generateRandomGraph() {
    const nodeCount = 5 + Math.floor(Math.random() * 2);
    nodes = [];
    edges = [];

    // 生成随机节点位置
    for (let i = 0; i < nodeCount; i++) {
        const angle = (2 * Math.PI * i) / nodeCount;
        const radius = 120 + Math.random() * 80;
        const centerX = 300;
        const centerY = 200;

        nodes.push({
            id: i,
            x: centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 40,
            y: centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 40,
            label: String.fromCharCode(65 + i)
        });
    }

    // 生成随机边，确保图连通
    const edgeSet = new Set();

    // 先生成一个生成树确保连通
    for (let i = 1; i < nodeCount; i++) {
        const from = Math.floor(Math.random() * i);
        const weight = Math.floor(Math.random() * 9) + 1;
        const edgeKey = from < i ? `${from}-${i}` : `${i}-${from}`;
        edgeSet.add(edgeKey);
        edges.push({from, to: i, weight});
    }

    // 添加额外的边
    const maxEdges = Math.min(nodeCount * (nodeCount - 1) / 2, nodeCount + 3);
    while (edges.length < maxEdges && edgeSet.size < maxEdges) {
        const from = Math.floor(Math.random() * nodeCount);
        const to = Math.floor(Math.random() * nodeCount);
        if (from !== to) {
            const edgeKey = from < to ? `${from}-${to}` : `${to}-${from}`;
            if (!edgeSet.has(edgeKey)) {
                edgeSet.add(edgeKey);
                const weight = Math.floor(Math.random() * 9) + 1;
                edges.push({from, to, weight});
            }
        }
    }

    // 更新起始节点选项
    updateStartNodeOptions();
    resetState();
    drawGraph();

    document.getElementById('demoInfo').textContent = '生成了新的随机图，点击"自动演示"查看算法执行过程';
}

function updateStartNodeOptions() {
    const startNodeSelect = document.getElementById('startNode');
    startNodeSelect.innerHTML = '';

    for (let node of nodes) {
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = `节点 ${node.label} (${node.id})`;
        startNodeSelect.appendChild(option);
    }
}

async function startAutoDemo() {
    if (demoInProgress) return;

    demoInProgress = true;
    stepByStep = false;

    // 禁用控制按钮
    const buttons = document.querySelectorAll('.control-panel button:not(#resetDemo)');
    buttons.forEach(btn => btn.disabled = true);
    document.getElementById('autoDemo').textContent = '演示进行中...';

    await performPrimAlgorithm();

    // 重新启用按钮
    buttons.forEach(btn => btn.disabled = false);
    document.getElementById('autoDemo').textContent = '🚀 自动演示';
    demoInProgress = false;
}

async function startStepDemo() {
    if (demoInProgress) return;

    if (!stepByStep) {
        stepByStep = true;
        document.getElementById('stepDemo').textContent = '▶️ 下一步';
        initializePrim();
    } else {
        await performPrimStep();

        if (visitedNodes.size === nodes.length) {
            document.getElementById('stepDemo').textContent = '👆 单步执行';
            stepByStep = false;
            addStep('Prim算法完成！');
        }
    }
}

function resetDemo() {
    demoInProgress = false;
    stepByStep = false;

    document.getElementById('autoDemo').textContent = '🚀 自动演示';
    document.getElementById('autoDemo').disabled = false;
    document.getElementById('stepDemo').textContent = '👆 单步执行';

    resetState();
    drawGraph();
}

async function performPrimAlgorithm() {
    initializePrim();

    while (visitedNodes.size < nodes.length) {
        await performPrimStep();
        if (!stepByStep) {
            await sleep(animationSpeed);
        }
    }

    addStep(`Prim算法完成！最小生成树总权重：${currentWeight}`);
    document.getElementById('demoInfo').textContent = 'Prim算法演示完成！🎉';
}

function initializePrim() {
    const startNodeId = parseInt(document.getElementById('startNode').value) || 0;

    // 重置状态
    resetState();

    // 添加起始节点到已访问集合
    visitedNodes.add(startNodeId);

    // 将起始节点的所有邻边加入优先队列
    for (let edge of edges) {
        if (edge.from === startNodeId && !visitedNodes.has(edge.to)) {
            priorityQueue.push({...edge});
        } else if (edge.to === startNodeId && !visitedNodes.has(edge.from)) {
            priorityQueue.push({from: edge.to, to: edge.from, weight: edge.weight});
        }
    }

    // 按权重排序优先队列
    priorityQueue.sort((a, b) => a.weight - b.weight);

    const startNodeLabel = nodes[startNodeId].label;
    addStep(`初始化：从节点${startNodeLabel}开始，将其邻边加入优先队列`);

    updateQueueDisplay();
    updateStatsDisplay();
    drawGraph();
}

async function performPrimStep() {
    if (priorityQueue.length === 0 || visitedNodes.size === nodes.length) {
        return;
    }

    // 找到权重最小且目标节点未访问的边
    let minEdgeIndex = -1;
    for (let i = 0; i < priorityQueue.length; i++) {
        if (!visitedNodes.has(priorityQueue[i].to)) {
            minEdgeIndex = i;
            break;
        }
    }

    if (minEdgeIndex === -1) {
        addStep('优先队列中没有有效边，算法结束');
        return;
    }

    // 取出最小边
    const minEdge = priorityQueue.splice(minEdgeIndex, 1)[0];

    // 添加到MST
    mstEdges.push(minEdge);
    visitedNodes.add(minEdge.to);
    currentWeight += minEdge.weight;

    const fromLabel = nodes[minEdge.from].label;
    const toLabel = nodes[minEdge.to].label;
    addStep(`选择边 ${fromLabel}-${toLabel} (权重:${minEdge.weight})，将节点${toLabel}加入MST`);

    // 将新节点的邻边加入优先队列
    for (let edge of edges) {
        if (edge.from === minEdge.to && !visitedNodes.has(edge.to)) {
            priorityQueue.push({...edge});
        } else if (edge.to === minEdge.to && !visitedNodes.has(edge.from)) {
            priorityQueue.push({from: edge.to, to: edge.from, weight: edge.weight});
        }
    }

    // 重新排序优先队列
    priorityQueue.sort((a, b) => a.weight - b.weight);

    updateQueueDisplay();
    updateStatsDisplay();
    drawGraph();
}

function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制网格
    drawGrid();

    // 绘制边
    for (let edge of edges) {
        drawEdge(edge);
    }

    // 绘制MST边
    for (let edge of mstEdges) {
        drawMSTEdge(edge);
    }

    // 绘制候选边
    if (priorityQueue.length > 0) {
        const nextEdge = priorityQueue.find(edge => !visitedNodes.has(edge.to));
        if (nextEdge) {
            drawCandidateEdge(nextEdge);
        }
    }

    // 绘制节点
    for (let node of nodes) {
        drawNode(node);
    }
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)';
    ctx.lineWidth = 1;
    const gridSize = 30;

    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }

    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawEdge(edge) {
    const fromNode = nodes[edge.from];
    const toNode = nodes[edge.to];

    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(fromNode.x, fromNode.y);
    ctx.lineTo(toNode.x, toNode.y);
    ctx.stroke();

    // 绘制权重
    drawEdgeWeight(edge, '#666', false);
}

function drawMSTEdge(edge) {
    const fromNode = nodes[edge.from];
    const toNode = nodes[edge.to];

    ctx.strokeStyle = colors.mstEdge;
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.shadowColor = colors.mstEdge;
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(fromNode.x, fromNode.y);
    ctx.lineTo(toNode.x, toNode.y);
    ctx.stroke();

    ctx.shadowBlur = 0;

    // 绘制权重
    drawEdgeWeight(edge, 'white', true);
}

function drawCandidateEdge(edge) {
    const fromNode = nodes[edge.from];
    const toNode = nodes[edge.to];

    ctx.strokeStyle = colors.currentEdge;
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.setLineDash([8, 4]);

    ctx.beginPath();
    ctx.moveTo(fromNode.x, fromNode.y);
    ctx.lineTo(toNode.x, toNode.y);
    ctx.stroke();

    ctx.setLineDash([]);

    // 绘制权重
    drawEdgeWeight(edge, colors.currentEdge, true);
}

function drawEdgeWeight(edge, color, highlighted) {
    const fromNode = nodes[edge.from];
    const toNode = nodes[edge.to];
    const midX = (fromNode.x + toNode.x) / 2;
    const midY = (fromNode.y + toNode.y) / 2;

    const bgColor = highlighted ? color : 'white';
    const textColor = highlighted && color === 'white' ? '#333' :
                     highlighted ? 'white' : color;

    const padding = 8;
    const width = 24;
    const height = 18;

    ctx.fillStyle = bgColor;
    ctx.fillRect(midX - width/2, midY - height/2, width, height);

    ctx.strokeStyle = highlighted ? 'transparent' : '#ddd';
    ctx.lineWidth = 1;
    ctx.strokeRect(midX - width/2, midY - height/2, width, height);

    ctx.fillStyle = textColor;
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(edge.weight.toString(), midX, midY);
}

function drawNode(node) {
    let nodeColor = colors.unvisited;
    let textColor = '#333';

    if (visitedNodes.has(node.id)) {
        nodeColor = colors.visited;
        textColor = colors.nodeText;
    }

    const radius = 25;

    // 绘制节点阴影
    if (visitedNodes.has(node.id)) {
        ctx.shadowColor = colors.visited;
        ctx.shadowBlur = 15;
    }

    // 绘制节点
    ctx.fillStyle = nodeColor;
    ctx.beginPath();
    ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
    ctx.fill();

    ctx.shadowBlur = 0;

    // 绘制边框
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.stroke();

    // 绘制标签
    ctx.fillStyle = textColor;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
}

function updateQueueDisplay() {
    const queueBody = document.getElementById('queueBody');

    if (priorityQueue.length === 0) {
        queueBody.innerHTML = '<div class="empty-queue">队列为空</div>';
        return;
    }

    // 过滤出有效边（目标节点未访问）
    const validEdges = priorityQueue.filter(edge => !visitedNodes.has(edge.to));

    if (validEdges.length === 0) {
        queueBody.innerHTML = '<div class="empty-queue">无有效候选边</div>';
        return;
    }

    queueBody.innerHTML = '';

    // 显示前10个边
    const displayEdges = validEdges.slice(0, 10);
    displayEdges.forEach((edge, index) => {
        const item = document.createElement('div');
        item.className = 'queue-item' + (index === 0 ? ' priority' : '');

        const fromLabel = nodes[edge.from].label;
        const toLabel = nodes[edge.to].label;

        item.innerHTML = `
            <span>${edge.weight}</span>
            <span>${fromLabel}-${toLabel}</span>
            <span>${index === 0 ? '下一个' : '等待'}</span>
        `;

        queueBody.appendChild(item);
    });

    if (validEdges.length > 10) {
        const moreItem = document.createElement('div');
        moreItem.className = 'queue-item';
        moreItem.innerHTML = `
            <span>...</span>
            <span>还有${validEdges.length - 10}条边</span>
            <span>等待</span>
        `;
        queueBody.appendChild(moreItem);
    }
}

function updateStatsDisplay() {
    document.getElementById('visitedCount').textContent = visitedNodes.size;
    document.getElementById('mstEdgeCount').textContent = mstEdges.length;
    document.getElementById('currentWeight').textContent = currentWeight;
}

function updateStepsDisplay() {
    const stepList = document.getElementById('stepList');

    if (!window.stepHistory) {
        window.stepHistory = ['准备开始Prim算法...'];
    }

    stepList.innerHTML = '';

    window.stepHistory.forEach((step, index) => {
        const item = document.createElement('div');
        let className = 'step-item';

        if (index === window.stepHistory.length - 1) {
            className += ' active';
        } else {
            className += ' completed';
        }

        item.className = className;
        item.textContent = step;
        stepList.appendChild(item);
    });

    // 滚动到最新步骤
    stepList.scrollTop = stepList.scrollHeight;
}

function addStep(message) {
    if (!window.stepHistory) {
        window.stepHistory = [];
    }
    window.stepHistory.push(message);
    updateStepsDisplay();
}

function updateSpeedLabel() {
    const speed = parseInt(document.getElementById('speedSlider').value);
    const label = document.getElementById('speedLabel');

    if (speed <= 750) {
        label.textContent = '很快';
    } else if (speed <= 1250) {
        label.textContent = '较快';
    } else if (speed <= 1750) {
        label.textContent = '正常';
    } else if (speed <= 2250) {
        label.textContent = '较慢';
    } else {
        label.textContent = '很慢';
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 代码标签页切换
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));

        this.classList.add('active');
        const lang = this.getAttribute('data-lang');
        document.querySelector(`.code-content[data-lang="${lang}"]`).classList.add('active');
    });
});

// 复制代码功能
document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const targetId = this.getAttribute('data-clipboard-target');
        const codeElement = document.getElementById(targetId);

        if (codeElement) {
            const textarea = document.createElement('textarea');
            textarea.value = codeElement.textContent;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            const originalText = this.textContent;
            this.textContent = '✅ 已复制';
            setTimeout(() => {
                this.textContent = originalText;
            }, 2000);
        }
    });
});

// 答案切换功能
function toggleAnswer(answerId) {
    const answerElement = document.getElementById(answerId);
    const button = answerElement.previousElementSibling;

    if (answerElement.classList.contains('show')) {
        answerElement.classList.remove('show');
        button.textContent = '点击查看答案';
    } else {
        answerElement.classList.add('show');
        button.textContent = '隐藏答案';
    }
}
</script>

{% endblock %}