{% extends 'knowledge_app/base.html' %}

{% block title %}快速排序 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>算法设计</span><span>></span><span>快速排序</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">⚡</span>
            快速排序 (Quick Sort)
        </h1><p>基于分治思想的高效排序算法，平均时间复杂度O(n log n)</p></div><!-- 主要内容 --><div class="content-card slide-in-right"><!-- 算法概述 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🎯</span>
                算法原理
            </h2><div class="concept-explanation"><p class="concept-intro">
                    快速排序是一种<strong>分治算法</strong>，通过选择一个"基准"元素，将数组分为两部分：
                    小于基准的元素和大于基准的元素，然后递归地对这两部分进行排序。
                </p><div class="key-points"><div class="point-item"><span class="point-icon">🎯</span><div class="point-content"><h4>分治思想</h4><p>将大问题分解为小问题，递归求解</p></div></div><div class="point-item"><span class="point-icon">⚖️</span><div class="point-content"><h4>分区操作</h4><p>选择基准元素，将数组分为两个子数组</p></div></div><div class="point-item"><span class="point-icon">🔄</span><div class="point-content"><h4>递归排序</h4><p>对左右子数组递归应用快速排序</p></div></div></div></div></div><!-- 可视化演示 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🎮</span>
                交互式演示
            </h2><div class="interactive-demo"><div class="demo-controls"><div class="control-group"><label>数组：</label><input type="text" id="array-input" value="64,34,25,12,22,11,90" placeholder="输入数组，用逗号分隔"><button class="demo-btn" onclick="updateArray()">更新数组</button></div><div class="control-group"><label>基准选择：</label><select id="pivot-strategy"><option value="last">最后一个元素</option><option value="first">第一个元素</option><option value="middle">中间元素</option><option value="random">随机选择</option></select><button class="demo-btn primary" onclick="startSort()">开始排序</button><button class="demo-btn" onclick="resetSort()">重置</button></div></div><div id="array-display" class="array-display"></div><div class="sort-info"><div class="info-row"><div class="info-item"><span class="info-label">当前步骤：</span><span id="current-step">0</span></div><div class="info-item"><span class="info-label">比较次数：</span><span id="comparison-count">0</span></div><div class="info-item"><span class="info-label">交换次数：</span><span id="swap-count">0</span></div><div class="info-item"><span class="info-label">递归深度：</span><span id="recursion-depth">0</span></div></div><div class="sort-status" id="sort-status">准备开始排序</div></div></div></div><!-- 算法步骤 --><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                算法步骤
            </h2><div class="steps-container"><div class="step-item"><div class="step-number">1</div><div class="step-content"><h4>选择基准</h4><p>从数组中选择一个元素作为基准（pivot），常见策略有选择第一个、最后一个、中间或随机元素</p></div></div><div class="step-item"><div class="step-number">2</div><div class="step-content"><h4>分区操作</h4><p>重新排列数组，使得小于基准的元素在左边，大于基准的元素在右边</p></div></div><div class="step-item"><div class="step-number">3</div><div class="step-content"><h4>递归排序</h4><p>对基准左边和右边的子数组递归应用快速排序</p></div></div><div class="step-item"><div class="step-number">4</div><div class="step-content"><h4>合并结果</h4><p>由于是原地排序，不需要额外的合并步骤</p></div></div></div></div><!-- 代码实现 --><div class="content-section"><h2 class="section-title"><span class="section-icon">💻</span>
                代码实现
            </h2><div class="code-tabs"><div class="tab-buttons"><button class="tab-btn active" onclick="showTab('python')">Python</button><button class="tab-btn" onclick="showTab('java')">Java</button><button class="tab-btn" onclick="showTab('cpp')">C++</button></div><div id="python-tab" class="tab-content active"><div class="code-example"><div class="code-header"><span class="code-title">Python实现</span><button class="copy-btn" onclick="copyCode('python-code')">复制代码</button></div><pre id="python-code"><code class="language-python">def quick_sort(arr, low=0, high=None):
    """
    快速排序算法
    :param arr: 待排序数组
    :param low: 起始索引
    :param high: 结束索引
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # 分区操作，获取基准位置
        pivot_index = partition(arr, low, high)
        
        # 递归排序左右子数组
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr, low, high):
    """
    分区函数，选择最后一个元素作为基准
    """
    pivot = arr[high]  # 选择最后一个元素作为基准
    i = low - 1  # 小于基准的元素的索引
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]  # 交换元素
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # 将基准放到正确位置
    return i + 1

# 使用示例
arr = [64, 34, 25, 12, 22, 11, 90]
print("原数组:", arr)
quick_sort(arr)
print("排序后:", arr)</code></pre></div></div><div id="java-tab" class="tab-content"><div class="code-example"><div class="code-header"><span class="code-title">Java实现</span><button class="copy-btn" onclick="copyCode('java-code')">复制代码</button></div><pre id="java-code"><code class="language-java">public class QuickSort {
    
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 分区操作，获取基准位置
            int pivotIndex = partition(arr, low, high);
            
            // 递归排序左右子数组
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // 选择最后一个元素作为基准
        int i = low - 1; // 小于基准的元素的索引
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                // 交换元素
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        // 将基准放到正确位置
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原数组: " + Arrays.toString(arr));
        quickSort(arr, 0, arr.length - 1);
        System.out.println("排序后: " + Arrays.toString(arr));
    }
}</code></pre></div></div><div id="cpp-tab" class="tab-content"><div class="code-example"><div class="code-header"><span class="code-title">C++实现</span><button class="copy-btn" onclick="copyCode('cpp-code')">复制代码</button></div><pre id="cpp-code"><code class="language-cpp">#include <iostream>
#include <vector>

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 分区操作，获取基准位置
        int pivotIndex = partition(arr, low, high);
        
        // 递归排序左右子数组
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 选择最后一个元素作为基准
    int i = low - 1; // 小于基准的元素的索引
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            std::swap(arr[i], arr[j]); // 交换元素
        }
    }
    
    std::swap(arr[i + 1], arr[high]); // 将基准放到正确位置
    return i + 1;
}

int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "原数组: ";
    for (int x : arr) std::cout << x << " ";
    std::cout << std::endl;
    
    quickSort(arr, 0, arr.size() - 1);
    
    std::cout << "排序后: ";
    for (int x : arr) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}</code></pre></div></div></div></div><!-- 复杂度分析 --><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                复杂度分析
            </h2><div class="complexity-grid"><div class="complexity-card best"><h4 class="complexity-title"><span class="complexity-icon">🏆</span>
                        最佳情况
                    </h4><div class="complexity-details"><p><strong>时间复杂度：</strong>O(n log n)</p><p><strong>条件：</strong>每次分区都能将数组平均分割</p><p><strong>空间复杂度：</strong>O(log n)</p></div></div><div class="complexity-card average"><h4 class="complexity-title"><span class="complexity-icon">📊</span>
                        平均情况
                    </h4><div class="complexity-details"><p><strong>时间复杂度：</strong>O(n log n)</p><p><strong>条件：</strong>随机输入数据</p><p><strong>空间复杂度：</strong>O(log n)</p></div></div><div class="complexity-card worst"><h4 class="complexity-title"><span class="complexity-icon">⚠️</span>
                        最坏情况
                    </h4><div class="complexity-details"><p><strong>时间复杂度：</strong>O(n²)</p><p><strong>条件：</strong>数组已排序或逆序排序</p><p><strong>空间复杂度：</strong>O(n)</p></div></div></div></div><!-- 优化策略 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🚀</span>
                优化策略
            </h2><div class="optimization-grid"><div class="opt-card"><h4 class="opt-title"><span class="opt-icon">🎯</span>
                        三数取中
                    </h4><p class="opt-desc">选择首、中、尾三个元素的中位数作为基准，避免最坏情况</p></div><div class="opt-card"><h4 class="opt-title"><span class="opt-icon">🔀</span>
                        随机化基准
                    </h4><p class="opt-desc">随机选择基准元素，降低遇到最坏情况的概率</p></div><div class="opt-card"><h4 class="opt-title"><span class="opt-icon">📏</span>
                        小数组优化
                    </h4><p class="opt-desc">对小数组使用插入排序，减少递归开销</p></div><div class="opt-card"><h4 class="opt-title"><span class="opt-icon">🔄</span>
                        尾递归优化
                    </h4><p class="opt-desc">将递归转换为迭代，减少栈空间使用</p></div></div></div><!-- 应用场景 --><div class="content-section"><h2 class="section-title"><span class="section-icon">🎯</span>
                实际应用
            </h2><div class="application-grid"><div class="app-card"><span class="app-icon">💾</span><h4>系统排序</h4><p>操作系统和编程语言的内置排序函数</p></div><div class="app-card"><span class="app-icon">🔍</span><h4>数据处理</h4><p>大数据处理和数据库查询优化</p></div><div class="app-card"><span class="app-icon">📊</span><h4>统计分析</h4><p>数据分析中的排序和分位数计算</p></div><div class="app-card"><span class="app-icon">🎮</span><h4>游戏开发</h4><p>排行榜、物体渲染顺序等</p></div></div></div></div><!-- 学习提示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">💡</span>
                学习要点
            </h2><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">🎯</span><strong>理解分治：</strong>掌握分治算法的核心思想和递归结构。
                </div><div class="info-box info-box-success"><span class="info-icon">⚖️</span><strong>分区操作：</strong>深入理解分区函数的实现和双指针技巧。
                </div><div class="info-box info-box-warning"><span class="info-icon">⚠️</span><strong>最坏情况：</strong>了解什么情况下会退化为O(n²)及如何避免。
                </div><div class="info-box info-box-info"><span class="info-icon">🚀</span><strong>优化技巧：</strong>学习各种优化策略提高算法性能。
                </div></div></div></div></div><style>.interactive-demo {background:#f8f9fa;border-radius:12px;padding:25px;margin:20px 0}.demo-controls {display:flex;flex-direction:column;gap:15px;margin-bottom:25px}.control-group {display:flex;align-items:center;gap:10px;flex-wrap:wrap}.control-group label {font-weight:600;color:#333;min-width:80px}.control-group input, .control-group select {padding:8px 12px;border:1px solid #ddd;border-radius:6px;flex:1;min-width:200px}.demo-btn {padding:8px 16px;background:#6c757d;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:500;transition:all 0.3s ease}.demo-btn.primary {background:#007bff}.demo-btn:hover {transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,0.2)}.demo-btn.primary:hover {background:#0056b3}.array-display {display:flex;justify-content:center;align-items:flex-end;gap:5px;margin:25px 0;padding:20px;background:white;border-radius:8px;border:1px solid #e9ecef;overflow-x:auto;min-height:120px}.array-element {display:flex;flex-direction:column;align-items:center;transition:all 0.3s ease;position:relative}.array-bar {width:40px;background:#007bff;border-radius:4px 4px 0 0;display:flex;align-items:flex-end;justify-content:center;color:white;font-weight:600;font-size:12px;padding:5px 2px;min-height:30px;transition:all 0.3s ease}.array-value {margin-top:5px;font-size:14px;font-weight:600;color:#333}.array-element.pivot {transform:scale(1.1)}.array-element.pivot .array-bar {background:#dc3545;box-shadow:0 4px 12px rgba(220,53,69,0.4)}.array-element.comparing .array-bar {background:#ffc107;animation:pulse 1s infinite}.array-element.left-partition .array-bar {background:#28a745}.array-element.right-partition .array-bar {background:#6f42c1}.array-element.sorted .array-bar {background:#17a2b8;opacity:0.7}.sort-info {background:white;border-radius:8px;padding:20px;border:1px solid #e9ecef}.info-row {display:grid;grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));gap:15px;margin-bottom:15px}.info-item {text-align:center;padding:10px;background:#f8f9fa;border-radius:6px}.info-label {display:block;font-size:14px;color:#666;margin-bottom:5px}.info-item span:last-child {font-size:18px;font-weight:600;color:#007bff}.sort-status {text-align:center;padding:15px;border-radius:8px;font-weight:600;margin-top:15px}.sort-status.sorting {background:#cce7ff;color:#004085;border:1px solid #b3d7ff}.sort-status.completed {background:#d4edda;color:#155724;border:1px solid #c3e6cb}.complexity-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:20px;margin:20px 0}.complexity-card {padding:20px;border-radius:12px;border:1px solid #e9ecef;text-align:center}.complexity-card.best {background:linear-gradient(135deg, #d4edda, #c3e6cb);border-color:#c3e6cb}.complexity-card.average {background:linear-gradient(135deg, #cce7ff, #b3d7ff);border-color:#b3d7ff}.complexity-card.worst {background:linear-gradient(135deg, #f8d7da, #f5c6cb);border-color:#f5c6cb}.complexity-title {display:flex;align-items:center;justify-content:center;gap:10px;margin-bottom:15px;color:#333}.complexity-details p {margin:8px 0;color:#555}.optimization-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(250px, 1fr));gap:20px;margin:20px 0}.opt-card {background:#f8f9fa;padding:20px;border-radius:12px;border:1px solid #e9ecef;text-align:center;transition:all 0.3s ease}.opt-card:hover {transform:translateY(-5px);box-shadow:0 8px 25px rgba(0,0,0,0.1);background:white}.opt-title {display:flex;align-items:center;justify-content:center;gap:10px;margin-bottom:10px;color:#333}.opt-desc {color:#666;font-size:14px;line-height:1.5}@keyframes pulse {0%, 100% {opacity:1}50% {opacity:0.6}}@media (max-width:768px) {.control-group {flex-direction:column;align-items:stretch}.control-group label {min-width:auto}.control-group input, .control-group select {min-width:auto}.array-display {flex-wrap:wrap;justify-content:center;align-items:flex-start}.array-bar {width:35px;font-size:11px}.info-row {grid-template-columns:1fr}.complexity-grid, .optimization-grid {grid-template-columns:1fr}}</style><script>let currentArray = [64, 34, 25, 12, 22, 11, 90]; let originalArray = [...currentArray]; let sortSteps = []; let currentStep = 0; let isSorting = false; let comparisonCount = 0; let swapCount = 0; let maxDepth = 0; function updateArray() { const input = document.getElementById('array-input').value; try { const newArray = input.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num)); if (newArray.length === 0) { alert('请输入有效的数字数组'); return; } currentArray = [...newArray]; originalArray = [...newArray]; resetSort(); displayArray(); } catch (error) { alert('输入格式错误，请使用逗号分隔的数字'); } } function displayArray() { const displayElement = document.getElementById('array-display'); displayElement.innerHTML = ''; const maxValue = Math.max(...currentArray); currentArray.forEach((value, index) => { const element = document.createElement('div'); element.className = 'array-element'; element.id = `element-${index}`; const bar = document.createElement('div'); bar.className = 'array-bar'; bar.style.height = `${(value / maxValue) * 80 + 20}px`; bar.textContent = value; const valueLabel = document.createElement('div'); valueLabel.className = 'array-value'; valueLabel.textContent = value; element.appendChild(bar); element.appendChild(valueLabel); displayElement.appendChild(element); }); } function startSort() { if (isSorting) return; isSorting = true; currentStep = 0; comparisonCount = 0; swapCount = 0; maxDepth = 0; sortSteps = []; currentArray = [...originalArray]; displayArray(); generateSortSteps(); animateSort(); } function generateSortSteps() { const arr = [...originalArray]; const steps = []; function quickSortSteps(arr, low, high, depth = 0) { maxDepth = Math.max(maxDepth, depth); if (low < high) { const pivotStrategy = document.getElementById('pivot-strategy').value; let pivotIndex = choosePivot(arr, low, high, pivotStrategy); if (pivotIndex !== high) { steps.push({ type: 'swap', indices: [pivotIndex, high], message: `将基准元素移到末尾` }); [arr[pivotIndex], arr[high]] = [arr[high], arr[pivotIndex]]; swapCount++; } steps.push({ type: 'pivot', index: high, value: arr[high], message: `选择 ${arr[high]} 作为基准` }); const finalPivotIndex = partitionSteps(arr, low, high, steps); steps.push({ type: 'partition_complete', pivotIndex: finalPivotIndex, message: `分区完成，基准 ${arr[finalPivotIndex]} 已就位` }); quickSortSteps(arr, low, finalPivotIndex - 1, depth + 1); quickSortSteps(arr, finalPivotIndex + 1, high, depth + 1); } } quickSortSteps(arr, 0, arr.length - 1); steps.push({ type: 'complete', message: '排序完成！' }); sortSteps = steps; } function choosePivot(arr, low, high, strategy) { switch (strategy) { case 'first': return low; case 'middle': return Math.floor((low + high) / 2); case 'random': return Math.floor(Math.random() * (high - low + 1)) + low; case 'last': default: return high; } } function partitionSteps(arr, low, high, steps) { const pivot = arr[high]; let i = low - 1; for (let j = low; j < high; j++) { comparisonCount++; steps.push({ type: 'compare', indices: [j, high], message: `比较 ${arr[j]} 与基准 ${pivot}` }); if (arr[j] <= pivot) { i++; if (i !== j) { steps.push({ type: 'swap', indices: [i, j], message: `交换 ${arr[i]} 和 ${arr[j]}` }); [arr[i], arr[j]] = [arr[j], arr[i]]; swapCount++; } } } steps.push({ type: 'swap', indices: [i + 1, high], message: `将基准 ${pivot} 放到正确位置` }); [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]]; swapCount++; return i + 1; } async function animateSort() { updateSortInfo('sorting', '正在排序...'); for (let i = 0; i < sortSteps.length; i++) { currentStep = i + 1; const step = sortSteps[i]; document.querySelectorAll('.array-element').forEach(el => { el.className = 'array-element'; }); switch (step.type) { case 'pivot': document.getElementById(`element-${step.index}`).classList.add('pivot'); break; case 'compare': step.indices.forEach(idx => { document.getElementById(`element-${idx}`).classList.add('comparing'); }); break; case 'swap': [currentArray[step.indices[0]], currentArray[step.indices[1]]] = [currentArray[step.indices[1]], currentArray[step.indices[0]]]; displayArray(); step.indices.forEach(idx => { document.getElementById(`element-${idx}`).classList.add('comparing'); }); break; case 'partition_complete': document.getElementById(`element-${step.pivotIndex}`).classList.add('sorted'); break; case 'complete': document.querySelectorAll('.array-element').forEach(el => { el.classList.add('sorted'); }); updateSortInfo('completed', '排序完成！'); break; } updateStepInfo(step.message); await new Promise(resolve => setTimeout(resolve, step.type === 'complete' ? 1000 : 800)); } isSorting = false; } function updateStepInfo(message) { document.getElementById('current-step').textContent = currentStep; document.getElementById('comparison-count').textContent = comparisonCount; document.getElementById('swap-count').textContent = swapCount; document.getElementById('recursion-depth').textContent = maxDepth; const statusElement = document.getElementById('sort-status'); statusElement.textContent = message; } function updateSortInfo(status, message) { const statusElement = document.getElementById('sort-status'); statusElement.textContent = message; statusElement.className = `sort-status ${status}`; } function resetSort() { isSorting = false; currentStep = 0; comparisonCount = 0; swapCount = 0; maxDepth = 0; sortSteps = []; currentArray = [...originalArray]; document.querySelectorAll('.array-element').forEach(el => { el.className = 'array-element'; }); updateStepInfo('准备开始排序'); updateSortInfo('', '准备开始排序'); displayArray(); } function showTab(tabName) { document.querySelectorAll('.tab-content').forEach(tab => { tab.classList.remove('active'); }); document.querySelectorAll('.tab-btn').forEach(btn => { btn.classList.remove('active'); }); document.getElementById(`${tabName}-tab`).classList.add('active'); event.target.classList.add('active'); } function copyCode(elementId) { const codeElement = document.getElementById(elementId); const text = codeElement.textContent; navigator.clipboard.writeText(text).then(() => { alert('代码已复制到剪贴板！'); }).catch(() => { alert('复制失败，请手动复制'); }); } document.addEventListener('DOMContentLoaded', function() { displayArray(); document.getElementById('array-input').addEventListener('keypress', function(e) { if (e.key === 'Enter') { updateArray(); } }); });</script>

{% endblock %}
