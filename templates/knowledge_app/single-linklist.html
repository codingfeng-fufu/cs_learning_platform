{% extends 'knowledge_app/base.html' %}

{% block title %}{{ page_title|default:"单链表" }} - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>单链表</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🔗</span>
            单链表 (Singly Linked List)
        </h1><p>一种基础而重要的线性数据结构，通过指针连接节点来存储数据</p></div><!-- 📋 知识点概述 --><div class="content-card slide-in-right"><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                知识点概述
            </h2><div class="info-box info-box-info"><span class="info-icon">💡</span><strong>核心概念：</strong>单链表是由一系列节点组成的数据结构，每个节点包含数据和指向下一个节点的指针。就像一串珍珠项链，每颗珍珠都知道下一颗珍珠在哪里。
            </div><div class="unified-grid unified-grid-2"><div class="grid-card"><span class="card-icon">🏷️</span><h4 class="card-title">关键术语</h4><ul style="text-align: left; margin: 10px 0;"><li><strong>节点(Node):</strong> 存储数据和指针的基本单元</li><li><strong>指针(Pointer):</strong> 指向下一个节点的引用</li><li><strong>头节点(Head):</strong> 链表的第一个节点</li><li><strong>尾节点(Tail):</strong> 链表的最后一个节点</li><li><strong>NULL:</strong> 表示链表结束的空指针</li></ul></div><div class="grid-card"><span class="card-icon">📊</span><h4 class="card-title">学习信息</h4><div style="text-align: left; margin: 10px 0;"><p><strong>难度等级：</strong><span style="color: #28a745;">入门级</span></p><p><strong>前置知识：</strong></p><ul><li>基本的编程概念</li><li>指针/引用的概念</li><li>内存管理基础</li></ul></div></div></div></div></div><!-- 🔍 概念详解 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🔍</span>
                概念详解
            </h2><div class="unified-grid unified-grid-2"><div class="info-box info-box-success"><span class="info-icon">🧩</span><strong>1. 节点结构：</strong>每个节点就像一个小盒子，里面装着两样东西：实际的数据（比如数字或文字）和一张"地址条"，告诉你下一个盒子在哪里。
                </div><div class="info-box info-box-info"><span class="info-icon">🔗</span><strong>2. 链式连接：</strong>节点之间通过指针连接，形成一条链。就像寻宝游戏，每个线索都指向下一个线索的位置。
                </div><div class="info-box info-box-warning"><span class="info-icon">📍</span><strong>3. 顺序访问：</strong>要找到特定数据，必须从头开始一个一个地往下找，不能直接跳到中间。就像看书必须一页一页翻。
                </div><div class="info-box info-box-danger"><span class="info-icon">🚫</span><strong>4. 动态大小：</strong>链表可以在运行时增加或删除节点，大小不固定。就像可以随时在项链上加珠子或取下珠子。
                </div></div><div style="margin-top: 20px;"><h3>🆚 与数组的对比</h3><div class="unified-grid unified-grid-2"><div class="grid-card"><span class="card-icon">📋</span><h4 class="card-title">数组 (Array)</h4><ul style="text-align: left;"><li>✅ 随机访问，可直接跳到任意位置</li><li>✅ 内存连续，访问速度快</li><li>❌ 大小固定，难以动态调整</li><li>❌ 插入删除需要移动大量元素</li></ul></div><div class="grid-card"><span class="card-icon">🔗</span><h4 class="card-title">单链表 (Linked List)</h4><ul style="text-align: left;"><li>❌ 顺序访问，必须从头开始</li><li>❌ 内存分散，额外的指针开销</li><li>✅ 动态大小，可随时调整</li><li>✅ 插入删除操作简单高效</li></ul></div></div></div><div class="info-box info-box-warning"><span class="info-icon">⚠️</span><strong>常见误区：</strong>初学者经常混淆指针和数据，记住：指针只是"路标"，不是真正的数据。另外，忘记处理空指针是最常见的错误！
            </div></div></div><!-- 📊 可视化展示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                可视化展示
            </h2><!-- Canvas动画演示 --><h3>🎬 链表操作动态演示</h3><div style="text-align: center; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 25px; border-radius: 12px; margin: 15px 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1);"><canvas id="linkedListCanvas" width="900" height="350" style="border: 2px solid #ddd; border-radius: 8px; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);"></canvas><div style="margin-top: 20px;"><button onclick="showHeadInsertAnimation()" class="unified-btn unified-btn-success" style="margin: 8px;"><span>🎯</span> 头部插入
                    </button><button onclick="showInsertAnimation()" class="unified-btn unified-btn-primary" style="margin: 8px;"><span>➕</span> 中间插入
                    </button><button onclick="showDeleteAnimation()" class="unified-btn unified-btn-danger" style="margin: 8px;"><span>🗑️</span> 删除节点
                    </button><button onclick="showSearchAnimation()" class="unified-btn unified-btn-secondary" style="margin: 8px;"><span>🔍</span> 查找节点
                    </button><button onclick="resetCanvas()" class="unified-btn unified-btn-outline" style="margin: 8px;"><span>🔄</span> 重置
                    </button></div><div id="animationStatus" style="margin-top: 15px; font-weight: bold; color: #007bff; font-size: 16px; min-height: 24px;">
                    点击按钮开始演示
                </div></div><script>const canvas = document.getElementById('linkedListCanvas'); const ctx = canvas.getContext('2d'); let nodes = [ {x: 200, y: 175, data: 'A', next: true, alpha: 1, targetX: 200, targetY: 175}, {x: 400, y: 175, data: 'B', next: true, alpha: 1, targetX: 400, targetY: 175}, {x: 600, y: 175, data: 'C', next: false, alpha: 1, targetX: 600, targetY: 175} ]; let animationFrame; let newNode = null; let pointerAnimations = []; let deleteNodeRef = null; class PointerAnimation { constructor(startX, startY, endX, endY, type = 'normal', duration = 60) { this.startX = startX; this.startY = startY; this.endX = endX; this.endY = endY; this.currentX = startX; this.currentY = startY; this.type = type; this.progress = 0; this.duration = duration; this.alpha = type === 'destroying' ? 1 : 0; this.pulsePhase = 0; } update() { this.progress += 1 / this.duration; this.pulsePhase += 0.2; if (this.type === 'creating' || this.type === 'bypass') { const easeProgress = this.easeOutElastic(Math.min(this.progress, 1)); this.currentX = this.startX + (this.endX - this.startX) * easeProgress; this.currentY = this.startY + (this.endY - this.startY) * easeProgress; this.alpha = Math.min(this.progress * 2, 1); } else if (this.type === 'destroying') { const easeProgress = this.easeInQuart(Math.min(this.progress, 1)); this.alpha = 1 - easeProgress; this.currentX = this.startX + (this.endX - this.startX) * (1 - easeProgress * 0.3); this.currentY = this.startY + (this.endY - this.startY) * (1 - easeProgress * 0.3); } else { const easeProgress = this.easeOutCubic(Math.min(this.progress, 1)); this.currentX = this.startX + (this.endX - this.startX) * easeProgress; this.currentY = this.startY + (this.endY - this.startY) * easeProgress; this.alpha = 1; } return this.progress < 1; } easeOutElastic(t) { if (t === 0) return 0; if (t === 1) return 1; return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * (2 * Math.PI) / 0.4) + 1; } easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); } easeInQuart(t) { return t * t * t * t; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.alpha; if (this.type === 'highlighting') { const pulseIntensity = 0.5 + 0.5 * Math.sin(this.pulsePhase); ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15 * pulseIntensity; ctx.strokeStyle = `rgba(255, 215, 0, ${0.7 + 0.3 * pulseIntensity})`; ctx.lineWidth = 5 + 2 * pulseIntensity; } else if (this.type === 'creating') { const intensity = 0.7 + 0.3 * Math.sin(this.pulsePhase * 2); ctx.shadowColor = '#27ae60'; ctx.shadowBlur = 12; ctx.strokeStyle = `rgba(39, 174, 96, ${intensity})`; ctx.lineWidth = 4; ctx.setLineDash([8, 4]); ctx.lineDashOffset = this.pulsePhase * 5; } else if (this.type === 'bypass') { const intensity = 0.7 + 0.3 * Math.sin(this.pulsePhase * 1.5); ctx.shadowColor = '#f39c12'; ctx.shadowBlur = 15; ctx.strokeStyle = `rgba(243, 156, 18, ${intensity})`; ctx.lineWidth = 5; ctx.setLineDash([10, 5]); ctx.lineDashOffset = this.pulsePhase * 3; } else if (this.type === 'destroying') { ctx.strokeStyle = `rgba(231, 76, 60, ${this.alpha})`; ctx.lineWidth = 3; ctx.setLineDash([4, 8]); ctx.lineDashOffset = this.pulsePhase * 3; } else { ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.shadowColor = '#3498db'; ctx.shadowBlur = 5; } ctx.beginPath(); ctx.moveTo(this.startX, this.startY); ctx.lineTo(this.currentX - 15, this.currentY); ctx.stroke(); const length = Math.sqrt( Math.pow(this.currentX - this.startX, 2) + Math.pow(this.currentY - this.startY, 2) ); if (length > 20) { this.drawArrowHead(ctx, this.currentX - 15, this.currentY); } ctx.restore(); } drawArrowHead(ctx, x, y) { ctx.setLineDash([]); ctx.shadowColor = 'transparent'; const gradient = ctx.createRadialGradient(x, y, 0, x, y, 15); if (this.type === 'highlighting') { gradient.addColorStop(0, '#ffd700'); gradient.addColorStop(1, '#f39c12'); } else if (this.type === 'creating') { gradient.addColorStop(0, '#2ecc71'); gradient.addColorStop(1, '#27ae60'); } else if (this.type === 'bypass') { gradient.addColorStop(0, '#f39c12'); gradient.addColorStop(1, '#e67e22'); } else if (this.type === 'destroying') { gradient.addColorStop(0, `rgba(231, 76, 60, ${this.alpha})`); gradient.addColorStop(1, `rgba(192, 57, 43, ${this.alpha})`); } else { gradient.addColorStop(0, '#3498db'); gradient.addColorStop(1, '#2980b9'); } ctx.fillStyle = gradient; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x - 15, y - 8); ctx.lineTo(x - 15, y + 8); ctx.closePath(); ctx.fill(); ctx.strokeStyle = this.type === 'highlighting' ? '#f39c12' : this.type === 'creating' ? '#27ae60' : this.type === 'bypass' ? '#e67e22' : this.type === 'destroying' ? `rgba(192, 57, 43, ${this.alpha})` : '#2980b9'; ctx.lineWidth = 1; ctx.stroke(); } } function drawBackground() { const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height); gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(1, '#f8f9fa'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height); } function drawNode(x, y, data, isHighlighted = false, isNew = false, isDeleting = false, alpha = 1) { ctx.save(); ctx.globalAlpha = alpha; if (!isDeleting) { ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; ctx.shadowBlur = 8; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; } const gradient = ctx.createLinearGradient(x - 50, y - 30, x + 50, y + 30); if (isDeleting) { gradient.addColorStop(0, '#ffebee'); gradient.addColorStop(1, '#ffcdd2'); } else if (isNew) { gradient.addColorStop(0, '#fff9e6'); gradient.addColorStop(1, '#ffeaa7'); } else if (isHighlighted) { gradient.addColorStop(0, '#e3f2fd'); gradient.addColorStop(1, '#90caf9'); } else { gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(1, '#f0f8ff'); } ctx.fillStyle = gradient; ctx.fillRect(x - 50, y - 30, 100, 60); ctx.shadowColor = 'transparent'; ctx.strokeStyle = isDeleting ? '#e74c3c' : isNew ? '#f39c12' : (isHighlighted ? '#3498db' : '#2c3e50'); ctx.lineWidth = isHighlighted ? 3 : 2; if (isDeleting) { ctx.setLineDash([5, 5]); } ctx.strokeRect(x - 50, y - 30, 100, 60); ctx.setLineDash([]); ctx.beginPath(); ctx.moveTo(x + 10, y - 30); ctx.lineTo(x + 10, y + 30); ctx.stroke(); ctx.fillStyle = isDeleting ? '#c0392b' : isNew ? '#d68910' : '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(data, x - 20, y); ctx.fillStyle = isDeleting ? '#e74c3c' : isNew ? '#e67e22' : '#3498db'; ctx.font = 'bold 18px Arial'; ctx.fillText('→', x + 30, y); ctx.restore(); } function addPointerAnimation(startX, startY, endX, endY, type = 'normal', duration = 60) { pointerAnimations.push(new PointerAnimation(startX, startY, endX, endY, type, duration)); } function updatePointerAnimations() { pointerAnimations = pointerAnimations.filter(animation => animation.update()); } function drawPointerAnimations() { pointerAnimations.forEach(animation => animation.draw(ctx)); } function updateNodePositions() { let allInPlace = true; for (let node of nodes) { const dx = node.targetX - node.x; const dy = node.targetY - node.y; if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { node.x += dx * 0.1; node.y += dy * 0.1; allInPlace = false; } else { node.x = node.targetX; node.y = node.targetY; } } if (newNode && newNode.targetX !== undefined) { const dx = newNode.targetX - newNode.x; const dy = newNode.targetY - newNode.y; if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { newNode.x += dx * 0.1; newNode.y += dy * 0.1; allInPlace = false; } else { newNode.x = newNode.targetX; newNode.y = newNode.targetY; } } if (deleteNodeRef && deleteNodeRef.targetX !== undefined) { const dx = deleteNodeRef.targetX - deleteNodeRef.x; const dy = deleteNodeRef.targetY - deleteNodeRef.y; if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { deleteNodeRef.x += dx * 0.1; deleteNodeRef.y += dy * 0.1; allInPlace = false; } else { deleteNodeRef.x = deleteNodeRef.targetX; deleteNodeRef.y = deleteNodeRef.targetY; } } return allInPlace; } function drawStaticArrows() { for (let i = 0; i < nodes.length - 1; i++) { if (nodes[i].next) { const animation = new PointerAnimation( nodes[i].x + 50, nodes[i].y, nodes[i + 1].x - 50, nodes[i + 1].y, 'normal' ); animation.progress = 1; animation.currentX = animation.endX; animation.currentY = animation.endY; animation.draw(ctx); } } } function drawLinkedList(highlightIndex = -1, showNewNode = false, showDeleteNode = false) { drawBackground(); for (let i = 0; i < nodes.length; i++) { const alpha = nodes[i].alpha || 1; const isDeleting = showDeleteNode && i === 1; drawNode(nodes[i].x, nodes[i].y, nodes[i].data, i === highlightIndex, false, isDeleting, alpha); } if (showDeleteNode && deleteNodeRef) { drawNode(deleteNodeRef.x, deleteNodeRef.y, deleteNodeRef.data, false, false, true, deleteNodeRef.alpha || 1); } if (showNewNode && newNode) { drawNode(newNode.x, newNode.y, newNode.data, false, true, false, newNode.alpha || 1); } drawStaticArrows(); updatePointerAnimations(); drawPointerAnimations(); ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; const lastNode = nodes[nodes.length - 1]; ctx.fillText('NULL', lastNode.x + 80, lastNode.y); const headX = newNode && newNode.isHead ? newNode.x : nodes[0].x; ctx.fillStyle = '#3498db'; ctx.font = 'bold 14px Arial'; ctx.fillText('Head', headX, headX === newNode?.x ? newNode.y - 60 : nodes[0].y - 60); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(headX, headX === newNode?.x ? newNode.y - 50 : nodes[0].y - 50); ctx.lineTo(headX, headX === newNode?.x ? newNode.y - 30 : nodes[0].y - 30); ctx.stroke(); ctx.beginPath(); ctx.moveTo(headX, headX === newNode?.x ? newNode.y - 30 : nodes[0].y - 30); ctx.lineTo(headX - 5, headX === newNode?.x ? newNode.y - 40 : nodes[0].y - 40); ctx.lineTo(headX + 5, headX === newNode?.x ? newNode.y - 40 : nodes[0].y - 40); ctx.closePath(); ctx.fillStyle = '#3498db'; ctx.fill(); } function showHeadInsertAnimation() { let step = 0; let animationProgress = 0; const status = document.getElementById('animationStatus'); resetToInitialState(); newNode = {x: 100, y: 100, data: 'X', alpha: 0, targetX: 100, targetY: 100}; const animate = () => { switch(step) { case 0: status.textContent = "示例1 - 步骤1: 创建新节点X"; newNode.alpha = Math.min(1, animationProgress * 3); drawLinkedList(-1, true); break; case 1: status.textContent = "示例1 - 步骤2: X指向原头节点A"; drawLinkedList(-1, true); if (animationProgress === 0) { addPointerAnimation( newNode.x + 50, newNode.y, nodes[0].x - 50, nodes[0].y, 'creating', 90 ); } break; case 2: status.textContent = "示例1 - 步骤3: 更新Head指针指向X"; newNode.targetX = 100; newNode.targetY = 175; newNode.isHead = true; nodes.forEach((node, i) => { node.targetX = 250 + (i + 1) * 150; }); updateNodePositions(); drawLinkedList(-1, true); break; case 3: status.textContent = "示例1 - 完成: X → A → B → C"; const allInPlace = updateNodePositions(); if (allInPlace) { nodes.unshift({ x: newNode.x, y: newNode.y, data: newNode.data, next: true, alpha: 1, targetX: newNode.x, targetY: newNode.y }); addPointerAnimation( nodes[0].x + 50, nodes[0].y, nodes[1].x - 50, nodes[1].y, 'highlighting', 60 ); newNode = null; setTimeout(() => { pointerAnimations = []; drawLinkedList(0); }, 1000); return; } drawLinkedList(-1, true); break; } animationProgress += 0.02; if (animationProgress >= 1.5) { animationProgress = 0; step++; if (step > 3) return; } setTimeout(() => requestAnimationFrame(animate), 16); }; animate(); } function showInsertAnimation() { let step = 0; let animationProgress = 0; const status = document.getElementById('animationStatus'); resetToInitialState(); newNode = {x: 300, y: 80, data: 'Y', alpha: 0, targetX: 300, targetY: 80}; const animate = () => { switch(step) { case 0: status.textContent = "示例2 - 步骤1: 定位到节点A（插入位置的前驱）"; drawLinkedList(0); break; case 1: status.textContent = "示例2 - 步骤2: 创建新节点Y"; newNode.alpha = Math.min(1, animationProgress * 3); drawLinkedList(0, true); break; case 2: status.textContent = "示例2 - 步骤3: Y指向B（保存原连接）"; drawLinkedList(0, true); if (animationProgress === 0) { addPointerAnimation( newNode.x + 50, newNode.y, nodes[1].x - 50, nodes[1].y, 'creating', 90 ); } break; case 3: status.textContent = "示例2 - 步骤4: A的指针改为指向Y"; drawLinkedList(0, true); if (animationProgress === 0) { addPointerAnimation( nodes[0].x + 50, nodes[0].y, newNode.x - 50, newNode.y, 'creating', 90 ); } break; case 4: status.textContent = "示例2 - 完成: A → Y → B → C"; nodes[0].targetX = 150; newNode.targetX = 300; newNode.targetY = 175; nodes[1].targetX = 450; nodes[2].targetX = 600; const allInPlace = updateNodePositions(); if (allInPlace && animationProgress > 1) { nodes.splice(1, 0, { x: newNode.x, y: newNode.y, data: newNode.data, next: true, alpha: 1, targetX: newNode.x, targetY: newNode.y }); addPointerAnimation( nodes[1].x + 50, nodes[1].y, nodes[2].x - 50, nodes[2].y, 'highlighting', 60 ); newNode = null; setTimeout(() => { pointerAnimations = []; drawLinkedList(1); }, 1000); return; } drawLinkedList(0, true); break; } animationProgress += 0.02; if (animationProgress >= 1.5) { animationProgress = 0; step++; if (step > 4) return; } setTimeout(() => requestAnimationFrame(animate), 16); }; animate(); } function showDeleteAnimation() { let step = 0; let animationProgress = 0; const status = document.getElementById('animationStatus'); resetToInitialState(); deleteNodeRef = { x: nodes[1].x, y: nodes[1].y, data: 'B', alpha: 1, targetX: nodes[1].x, targetY: nodes[1].y }; const animate = () => { switch(step) { case 0: status.textContent = "示例3 - 步骤1: 定位要删除的节点B"; drawLinkedList(1); break; case 1: status.textContent = "示例3 - 步骤2: 建立跨越连接（A直接指向C）"; drawLinkedList(1); if (animationProgress === 0) { addPointerAnimation( nodes[0].x + 50, nodes[0].y, nodes[2].x - 50, nodes[2].y, 'bypass', 120 ); } break; case 2: status.textContent = "示例3 - 步骤3: 断开B的所有连接"; drawLinkedList(1, false, true); if (animationProgress === 0) { addPointerAnimation( nodes[0].x + 50, nodes[0].y, deleteNodeRef.x - 50, deleteNodeRef.y, 'destroying', 60 ); addPointerAnimation( deleteNodeRef.x + 50, deleteNodeRef.y, nodes[2].x - 50, nodes[2].y, 'destroying', 60 ); } break; case 3: status.textContent = "示例3 - 步骤4: 节点B淡出"; if (deleteNodeRef) { deleteNodeRef.alpha = Math.max(0, 1 - animationProgress * 2); deleteNodeRef.targetY = deleteNodeRef.y + animationProgress * 50; } drawLinkedList(-1, false, true); break; case 4: status.textContent = "示例3 - 完成: A → C（B已被删除）"; if (animationProgress === 0) { nodes.splice(1, 1); setTimeout(() => { addPointerAnimation( nodes[0].x + 50, nodes[0].y, nodes[1].x - 50, nodes[1].y, 'highlighting', 80 ); }, 300); } nodes.forEach((node, i) => { node.targetX = 200 + i * 250; }); const allInPlace = updateNodePositions(); drawLinkedList(); if (allInPlace && animationProgress > 1) { deleteNodeRef = null; setTimeout(() => { pointerAnimations = []; drawLinkedList(); }, 1500); return; } break; } animationProgress += 0.025; if (animationProgress >= 1.8) { animationProgress = 0; step++; if (step > 4) return; } setTimeout(() => requestAnimationFrame(animate), 16); }; animate(); } function showSearchAnimation() { let step = 0; const status = document.getElementById('animationStatus'); resetToInitialState(); const animate = () => { if (step < nodes.length) { status.textContent = `示例4 - 查找节点C：当前检查 ${nodes[step].data}`; if (step > 0) { addPointerAnimation( nodes[step - 1].x + 50, nodes[step - 1].y, nodes[step].x - 50, nodes[step].y, 'highlighting', 30 ); } drawLinkedList(step); if (nodes[step].data === 'C') { setTimeout(() => { status.textContent = "示例4 - 🎉 找到目标节点C！"; drawLinkedList(step); ctx.save(); ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 6; ctx.setLineDash([]); ctx.strokeRect(nodes[step].x - 55, nodes[step].y - 35, 110, 70); ctx.restore(); setTimeout(() => { pointerAnimations = []; drawLinkedList(step); }, 2000); }, 1000); return; } else { setTimeout(() => { step++; requestAnimationFrame(animate); }, 1200); } } }; animate(); } function resetToInitialState() { nodes = [ {x: 200, y: 175, data: 'A', next: true, alpha: 1, targetX: 200, targetY: 175}, {x: 400, y: 175, data: 'B', next: true, alpha: 1, targetX: 400, targetY: 175}, {x: 600, y: 175, data: 'C', next: false, alpha: 1, targetX: 600, targetY: 175} ]; newNode = null; deleteNodeRef = null; pointerAnimations = []; } function resetCanvas() { resetToInitialState(); drawLinkedList(); document.getElementById('animationStatus').textContent = "已重置到初始状态（A → B → C）"; } document.addEventListener('DOMContentLoaded', function() { drawLinkedList(); });</script></div></div><!-- 🌟 实际应用 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌟</span>
                实际应用
            </h2><div class="unified-grid unified-grid-3"><div class="grid-card"><span class="card-icon">🌐</span><h4 class="card-title">浏览器历史记录</h4><p class="card-description">每个访问的网页都是一个节点，通过"前进"和"后退"按钮在链表中导航</p></div><div class="grid-card"><span class="card-icon">🎵</span><h4 class="card-title">音乐播放列表</h4><p class="card-description">每首歌是一个节点，播放器可以轻松添加、删除歌曲或跳到下一首</p></div><div class="grid-card"><span class="card-icon">↩️</span><h4 class="card-title">撤销功能</h4><p class="card-description">文档编辑器的撤销操作，每个操作存储为链表节点</p></div></div><h3>💻 代码示例</h3><div style="margin: 15px 0;"><div class="unified-grid unified-grid-3"><button onclick="showCode('cpp')" id="btn-cpp" class="unified-btn unified-btn-outline" style="width: 100%;"><span>⚡</span> C++
                    </button><button onclick="showCode('java')" id="btn-java" class="unified-btn unified-btn-outline" style="width: 100%;"><span>☕</span> Java
                    </button><button onclick="showCode('python')" id="btn-python" class="unified-btn unified-btn-outline" style="width: 100%;"><span>🐍</span> Python
                    </button></div></div><!-- C++ 代码 --><div id="code-cpp" class="code-container" style="display: none;"><div style="display: flex; justify-content: space-between; align-items: center; background: #2d3748; color: white; padding: 10px; border-radius: 8px 8px 0 0;"><span><strong>🔧 C++ 实现</strong></span><button onclick="copyCode('cpp')" class="unified-btn unified-btn-sm" style="background: #4a5568; color: white; border: none;"><span>📋</span> 复制代码
                    </button></div><div style="background: #f8f9fa; padding: 20px; border-radius: 0 0 8px 8px; font-family: monospace; overflow-x: auto;"><pre id="cpp-code" style="margin: 0; color: #333; white-space: pre-wrap;"><span style="color: #007bff;">// 单链表节点定义</span><span style="color: #d73502;">struct</span> ListNode {
    <span style="color: #d73502;">int</span> data;              <span style="color: #007bff;">// 数据域</span>
    ListNode* next;         <span style="color: #007bff;">// 指针域</span><span style="color: #007bff;">// 构造函数</span>
    ListNode(<span style="color: #d73502;">int</span> x) : data(x), next(<span style="color: #d73502;">nullptr</span>) {}
};

<span style="color: #d73502;">class</span> LinkedList {
<span style="color: #d73502;">private</span>:
    ListNode* head;

<span style="color: #d73502;">public</span>:
    LinkedList() : head(<span style="color: #d73502;">nullptr</span>) {}

    <span style="color: #007bff;">// 在指定位置插入节点</span><span style="color: #d73502;">void</span> insert(<span style="color: #d73502;">int</span> pos, <span style="color: #d73502;">int</span> data) {
        ListNode* newNode = <span style="color: #d73502;">new</span> ListNode(data);

        <span style="color: #d73502;">if</span> (pos == <span style="color: #666;">0</span>) {  <span style="color: #007bff;">// 插入到头部</span>
            newNode->next = head;
            head = newNode;
            <span style="color: #d73502;">return</span>;
        }

        <span style="color: #007bff;">// 找到插入位置的前一个节点</span>
        ListNode* curr = head;
        <span style="color: #d73502;">for</span> (<span style="color: #d73502;">int</span> i = <span style="color: #666;">0</span>; i < pos - <span style="color: #666;">1</span> && curr; i++) {
            curr = curr->next;
        }

        <span style="color: #d73502;">if</span> (curr) {
            newNode->next = curr->next;  <span style="color: #007bff;">// 新节点指向下一个节点</span>
            curr->next = newNode;        <span style="color: #007bff;">// 前一个节点指向新节点</span>
        }
    }

    <span style="color: #007bff;">// 遍历链表</span><span style="color: #d73502;">void</span> traverse() {
        ListNode* curr = head;
        <span style="color: #d73502;">while</span> (curr) {
            cout << curr->data << <span style="color: #28a745;">" -> "</span>;
            curr = curr->next;
        }
        cout << <span style="color: #28a745;">"NULL"</span><< endl;
    }
};
</pre></div></div><!-- Java 代码 --><div id="code-java" class="code-container" style="display: none;"><div style="display: flex; justify-content: space-between; align-items: center; background: #2d3748; color: white; padding: 10px; border-radius: 8px 8px 0 0;"><span><strong>☕ Java 实现</strong></span><button onclick="copyCode('java')" class="unified-btn unified-btn-sm" style="background: #4a5568; color: white; border: none;"><span>📋</span> 复制代码
                    </button></div><div style="background: #f8f9fa; padding: 20px; border-radius: 0 0 8px 8px; font-family: monospace; overflow-x: auto;"><pre id="java-code" style="margin: 0; color: #333; white-space: pre-wrap;"><span style="color: #007bff;">// 单链表节点类</span><span style="color: #d73502;">class</span> ListNode {
    <span style="color: #d73502;">int</span> data;              <span style="color: #007bff;">// 数据域</span>
    ListNode next;          <span style="color: #007bff;">// 指针域</span><span style="color: #007bff;">// 构造函数</span><span style="color: #d73502;">public</span> ListNode(<span style="color: #d73502;">int</span> data) {
        <span style="color: #d73502;">this</span>.data = data;
        <span style="color: #d73502;">this</span>.next = <span style="color: #d73502;">null</span>;
    }
}

<span style="color: #d73502;">public class</span> LinkedList {
    <span style="color: #d73502;">private</span> ListNode head;

    <span style="color: #d73502;">public</span> LinkedList() {
        <span style="color: #d73502;">this</span>.head = <span style="color: #d73502;">null</span>;
    }

    <span style="color: #007bff;">// 在指定位置插入节点</span><span style="color: #d73502;">public void</span> insert(<span style="color: #d73502;">int</span> pos, <span style="color: #d73502;">int</span> data) {
        ListNode newNode = <span style="color: #d73502;">new</span> ListNode(data);

        <span style="color: #d73502;">if</span> (pos == <span style="color: #666;">0</span>) {  <span style="color: #007bff;">// 插入到头部</span>
            newNode.next = head;
            head = newNode;
            <span style="color: #d73502;">return</span>;
        }

        <span style="color: #007bff;">// 找到插入位置的前一个节点</span>
        ListNode curr = head;
        <span style="color: #d73502;">for</span> (<span style="color: #d73502;">int</span> i = <span style="color: #666;">0</span>; i < pos - <span style="color: #666;">1</span> && curr != <span style="color: #d73502;">null</span>; i++) {
            curr = curr.next;
        }

        <span style="color: #d73502;">if</span> (curr != <span style="color: #d73502;">null</span>) {
            newNode.next = curr.next;    <span style="color: #007bff;">// 新节点指向下一个节点</span>
            curr.next = newNode;         <span style="color: #007bff;">// 前一个节点指向新节点</span>
        }
    }

    <span style="color: #007bff;">// 遍历链表</span><span style="color: #d73502;">public void</span> traverse() {
        ListNode curr = head;
        <span style="color: #d73502;">while</span> (curr != <span style="color: #d73502;">null</span>) {
            System.out.print(curr.data + <span style="color: #28a745;">" -> "</span>);
            curr = curr.next;
        }
        System.out.println(<span style="color: #28a745;">"NULL"</span>);
    }

    <span style="color: #007bff;">// 示例用法</span><span style="color: #d73502;">public static void</span> main(String[] args) {
        LinkedList list = <span style="color: #d73502;">new</span> LinkedList();
        list.insert(<span style="color: #666;">0</span>, <span style="color: #666;">1</span>);  <span style="color: #007bff;">// 插入1</span>
        list.insert(<span style="color: #666;">1</span>, <span style="color: #666;">3</span>);  <span style="color: #007bff;">// 插入3</span>
        list.insert(<span style="color: #666;">1</span>, <span style="color: #666;">2</span>);  <span style="color: #007bff;">// 在位置1插入2</span>
        list.traverse();       <span style="color: #007bff;">// 输出: 1 -> 2 -> 3 -> NULL</span>
    }
}
</pre></div></div><!-- Python 代码 --><div id="code-python" class="code-container" style="display: block;"><div style="display: flex; justify-content: space-between; align-items: center; background: #2d3748; color: white; padding: 10px; border-radius: 8px 8px 0 0;"><span><strong>🐍 Python 实现</strong></span><button onclick="copyCode('python')" class="unified-btn unified-btn-sm" style="background: #4a5568; color: white; border: none;"><span>📋</span> 复制代码
                    </button></div><div style="background: #f8f9fa; padding: 20px; border-radius: 0 0 8px 8px; font-family: monospace; overflow-x: auto;"><pre id="python-code" style="margin: 0; color: #333; white-space: pre-wrap;"><span style="color: #007bff;"># 单链表节点类</span><span style="color: #d73502;">class</span> ListNode:
    <span style="color: #d73502;">def</span> __init__(self, data):
        self.data = data      <span style="color: #007bff;"># 数据域</span>
        self.next = <span style="color: #d73502;">None</span><span style="color: #007bff;"># 指针域</span><span style="color: #d73502;">class</span> LinkedList:
    <span style="color: #d73502;">def</span> __init__(self):
        self.head = <span style="color: #d73502;">None</span><span style="color: #d73502;">def</span> insert(self, pos, data):
        <span style="color: #28a745;">"""在指定位置插入节点"""</span>
        new_node = ListNode(data)

        <span style="color: #d73502;">if</span> pos == <span style="color: #666;">0</span>:  <span style="color: #007bff;"># 插入到头部</span>
            new_node.next = self.head
            self.head = new_node
            <span style="color: #d73502;">return</span><span style="color: #007bff;"># 找到插入位置的前一个节点</span>
        curr = self.head
        <span style="color: #d73502;">for</span> i <span style="color: #d73502;">in</span> range(pos - <span style="color: #666;">1</span>):
            <span style="color: #d73502;">if</span> curr <span style="color: #d73502;">is None</span>:
                <span style="color: #d73502;">return</span><span style="color: #007bff;"># 位置超出范围</span>
            curr = curr.next

        <span style="color: #d73502;">if</span> curr <span style="color: #d73502;">is not None</span>:
            new_node.next = curr.next    <span style="color: #007bff;"># 新节点指向下一个节点</span>
            curr.next = new_node         <span style="color: #007bff;"># 前一个节点指向新节点</span><span style="color: #d73502;">def</span> traverse(self):
        <span style="color: #28a745;">"""遍历链表"""</span>
        result = []
        curr = self.head
        <span style="color: #d73502;">while</span> curr:
            result.append(str(curr.data))
            curr = curr.next
        <span style="color: #d73502;">return</span><span style="color: #28a745;">" -> "</span>.join(result) + <span style="color: #28a745;">" -> NULL"</span><span style="color: #d73502;">def</span> display(self):
        <span style="color: #28a745;">"""打印链表"""</span>
        print(self.traverse())

<span style="color: #007bff;"># 示例用法</span><span style="color: #d73502;">if</span> __name__ == <span style="color: #28a745;">"__main__"</span>:
    linked_list = LinkedList()
    linked_list.insert(<span style="color: #666;">0</span>, <span style="color: #666;">1</span>)  <span style="color: #007bff;"># 插入1</span>
    linked_list.insert(<span style="color: #666;">1</span>, <span style="color: #666;">3</span>)  <span style="color: #007bff;"># 插入3</span>
    linked_list.insert(<span style="color: #666;">1</span>, <span style="color: #666;">2</span>)  <span style="color: #007bff;"># 在位置1插入2</span>
    linked_list.display()     <span style="color: #007bff;"># 输出: 1 -> 2 -> 3 -> NULL</span></pre></div></div><script>function showCode(language) { document.querySelectorAll('.code-container').forEach(container => { container.style.display = 'none'; }); document.querySelectorAll('[id^="btn-"]').forEach(btn => { btn.classList.remove('unified-btn-primary'); btn.classList.add('unified-btn-outline'); }); document.getElementById('code-' + language).style.display = 'block'; const btn = document.getElementById('btn-' + language); btn.classList.remove('unified-btn-outline'); btn.classList.add('unified-btn-primary'); } function copyCode(language) { const codeElement = document.getElementById(language + '-code'); const text = codeElement.textContent || codeElement.innerText; const textarea = document.createElement('textarea'); textarea.value = text; document.body.appendChild(textarea); textarea.select(); try { document.execCommand('copy'); const button = event.target.closest('button'); const originalText = button.innerHTML; button.innerHTML = '<span>✅</span> 已复制'; button.style.background = '#28a745'; setTimeout(() => { button.innerHTML = originalText; button.style.background = '#4a5568'; }, 2000); } catch (err) { console.error('复制失败:', err); } finally { document.body.removeChild(textarea); } } document.addEventListener('DOMContentLoaded', function() { showCode('python'); });</script><div class="info-box info-box-info"><span class="info-icon">🛠️</span><strong>推荐工具：</strong><a href="https://visualgo.net/zh/list" style="color: #007bff;">VisuAlgo</a> - 在线可视化工具，
                <a href="https://www.cs.usfca.edu/~galles/visualization/QueueLL.html" style="color: #007bff;">USF动画</a> - 交互式演示
            </div></div></div><!-- ✅ 学习检验 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">✅</span>
                学习检验
            </h2><h3>🤔 常见问题与解答</h3><p style="color: #666; margin-bottom: 20px;">点击问题查看详细解答 👇</p><div class="qa-container"><!-- 问题1 --><div class="qa-item" style="border: 1px solid #ddd; border-radius: 8px; margin: 10px 0;"><div class="qa-question" onclick="toggleAnswer('answer1')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 8px;"><span><strong>❓ 为什么链表的插入操作比数组快？</strong></span><span id="icon1" style="color: #007bff; font-size: 18px;">▼</span></div><div id="answer1" class="qa-answer" style="display: none; padding: 15px; background: white; border-top: 1px solid #eee;"><div style="color: #555;"><p><strong>核心原因：</strong></p><ul><li><strong>数组插入：</strong>需要将插入位置后的所有元素向后移动一位，时间复杂度O(n)</li><li><strong>链表插入：</strong>只需要修改2个指针的指向，时间复杂度O(1)</li></ul><p><strong>形象比喻：</strong></p><p>🚇 数组像地铁车厢，要在中间加一个座位，后面所有乘客都要往后挪</p><p>🔗 链表像项链，要加一颗珠子，只需要解开一个环节重新连接</p></div></div></div><!-- 问题2 --><div class="qa-item" style="border: 1px solid #ddd; border-radius: 8px; margin: 10px 0;"><div class="qa-question" onclick="toggleAnswer('answer2')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 8px;"><span><strong>❓ 什么情况下应该选择链表而不是数组？</strong></span><span id="icon2" style="color: #007bff; font-size: 18px;">▼</span></div><div id="answer2" class="qa-answer" style="display: none; padding: 15px; background: white; border-top: 1px solid #eee;"><div style="color: #555;"><p><strong>选择链表的情况：</strong></p><ul><li>📊 <strong>数据大小不确定：</strong>需要动态增长或缩小</li><li>✏️ <strong>频繁插入删除：</strong>特别是在中间位置的操作</li><li>💾 <strong>内存敏感：</strong>不想预分配大块连续内存</li><li>🔄 <strong>实现其他数据结构：</strong>如栈、队列的基础</li></ul><p><strong>典型应用：</strong>音乐播放列表、浏览器历史记录、文本编辑器的撤销功能</p></div></div></div><!-- 问题3 --><div class="qa-item" style="border: 1px solid #ddd; border-radius: 8px; margin: 10px 0;"><div class="qa-question" onclick="toggleAnswer('answer3')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 8px;"><span><strong>❓ 链表操作中最容易出现的错误是什么？</strong></span><span id="icon3" style="color: #007bff; font-size: 18px;">▼</span></div><div id="answer3" class="qa-answer" style="display: none; padding: 15px; background: white; border-top: 1px solid #eee;"><div style="color: #555;"><p><strong>最常见的3个错误：</strong></p><div style="border-left: 4px solid #dc3545; padding-left: 15px; margin: 10px 0;"><p><strong>1. 空指针错误 (Null Pointer)</strong></p><p>忘记检查指针是否为空就直接访问，导致程序崩溃</p><code style="background: #f8f9fa; padding: 2px 5px;">if (node != null) node.next = ...</code></div><div style="border-left: 4px solid #ffc107; padding-left: 15px; margin: 10px 0;"><p><strong>2. 指针顺序错误</strong></p><p>修改指针时顺序错误，导致链表断裂或形成环</p><p>✅ 正确：先连新的，再断旧的</p></div><div style="border-left: 4px solid #28a745; padding-left: 15px; margin: 10px 0;"><p><strong>3. 内存泄漏</strong></p><p>删除节点时忘记释放内存（C/C++中）</p><code style="background: #f8f9fa; padding: 2px 5px;">delete oldNode; // C++中必须手动释放</code></div></div></div></div><!-- 问题4 --><div class="qa-item" style="border: 1px solid #ddd; border-radius: 8px; margin: 10px 0;"><div class="qa-question" onclick="toggleAnswer('answer4')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 8px;"><span><strong>❓ 如何高效地找到链表的中间节点？</strong></span><span id="icon4" style="color: #007bff; font-size: 18px;">▼</span></div><div id="answer4" class="qa-answer" style="display: none; padding: 15px; background: white; border-top: 1px solid #eee;"><div style="color: #555;"><p><strong>双指针技巧（快慢指针）：</strong></p><div style="background: #e8f4fd; padding: 15px; border-radius: 5px; margin: 10px 0;"><p><strong>🐰 快指针：</strong>每次移动2步</p><p><strong>🐢 慢指针：</strong>每次移动1步</p><p><strong>结果：</strong>当快指针到达末尾时，慢指针正好在中间</p></div><p><strong>代码示例：</strong></p><div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-family: monospace;"><pre style="margin: 0; color: #333;">
fast = slow = head
while fast and fast.next:
    fast = fast.next.next  # 快指针走2步
    slow = slow.next       # 慢指针走1步
# slow现在指向中间节点
</pre></div><p><strong>时间复杂度：</strong>O(n)，但只需要遍历一次！</p></div></div></div></div><script>function toggleAnswer(answerId) { const answer = document.getElementById(answerId); const icon = document.getElementById('icon' + answerId.slice(-1)); if (answer.style.display === 'none') { answer.style.display = 'block'; icon.textContent = '▲'; icon.style.color = '#28a745'; } else { answer.style.display = 'none'; icon.textContent = '▼'; icon.style.color = '#007bff'; } }</script><h3>🎯 练习建议</h3><div class="unified-grid unified-grid-2"><div class="grid-card"><span class="card-icon">🟢</span><h4 class="card-title">基础练习</h4><ul style="text-align: left;"><li>手写链表的基本操作</li><li>LeetCode 206: 反转链表</li><li>LeetCode 21: 合并两个有序链表</li></ul></div><div class="grid-card"><span class="card-icon">🟡</span><h4 class="card-title">进阶练习</h4><ul style="text-align: left;"><li>LeetCode 141: 环形链表</li><li>LeetCode 876: 链表的中间结点</li><li>LeetCode 19: 删除链表的倒数第N个结点</li></ul></div></div><h3>📚 学习路径</h3><div class="info-box info-box-success"><span class="info-icon">🛤️</span><strong>推荐学习顺序：</strong>
                单链表 → 双向链表 → 循环链表 → 栈和队列 → 哈希表 → 二叉树
            </div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div>
{% endblock %}