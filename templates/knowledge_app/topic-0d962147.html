{% extends 'knowledge_app/base.html' %}

{% block title %}队列——缓冲区 - 计算机科学学习平台{% endblock %}

{% block content %}
<style>.page-container {max-width:1200px;margin:0 auto;padding:20px;font-family:'Arial', sans-serif}.knowledge-section {background:white;border-radius:12px;box-shadow:0 4px 6px rgba(0,0,0,0.1);margin-bottom:30px;padding:30px;border-left:5px solid #3498db}.section-header {display:flex;align-items:center;margin-bottom:25px;border-bottom:2px solid #ecf0f1;padding-bottom:15px}.section-icon {font-size:2em;margin-right:15px}.section-title {font-size:1.8em;color:#2c3e50;margin:0}.concept-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(250px, 1fr));gap:20px;margin:20px 0}.concept-card {background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:20px;text-align:center;transition:transform 0.3s ease}.concept-card:hover {transform:translateY(-5px);box-shadow:0 4px 12px rgba(0,0,0,0.15)}.canvas-container {background:#f8f9fa;border:2px solid #dee2e6;border-radius:8px;padding:20px;margin:20px 0;text-align:center}.simulation-controls {margin:15px 0;display:flex;flex-wrap:wrap;justify-content:center;gap:15px;align-items:center}.control-group {display:flex;flex-direction:column;align-items:center;background:white;padding:15px;border-radius:8px;border:1px solid #dee2e6;min-width:120px}.control-label {font-size:12px;font-weight:bold;color:#2c3e50;margin-bottom:8px}.btn {background:#3498db;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;margin:2px;font-size:12px;font-weight:bold;transition:all 0.3s ease;box-shadow:0 3px 10px rgba(52, 152, 219, 0.3)}.btn:hover {transform:translateY(-1px);box-shadow:0 4px 15px rgba(52, 152, 219, 0.4)}.btn:disabled {background:#95a5a6;cursor:not-allowed;transform:none;box-shadow:none}.btn-producer {background:linear-gradient(135deg, #27ae60, #2ecc71)}.btn-consumer {background:linear-gradient(135deg, #e74c3c, #ec7063)}.btn-control {background:linear-gradient(135deg, #f39c12, #f7dc6f)}.speed-control {display:flex;align-items:center;gap:10px}.speed-slider {width:80px;margin:0 5px}.stats-display {display:grid;grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));gap:10px;margin:15px 0;padding:15px;background:white;border-radius:8px;border:1px solid #dee2e6}.stat-item {text-align:center;padding:10px;background:#f8f9fa;border-radius:6px}.stat-value {font-size:18px;font-weight:bold;color:#2c3e50}.stat-label {font-size:12px;color:#7f8c8d;margin-top:5px}.code-container {background:#2c3e50;color:#ecf0f1;border-radius:8px;margin:20px 0;overflow:hidden}.code-tabs {display:flex;background:#34495e}.code-tab {padding:12px 20px;cursor:pointer;border:none;background:transparent;color:#bdc3c7;font-weight:bold;transition:all 0.3s ease}.code-tab.active {background:#3498db;color:white}.code-content {position:relative;padding:20px;font-family:'Courier New', monospace;line-height:1.6;overflow-x:auto}.copy-btn {position:absolute;top:10px;right:10px;background:#27ae60;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:12px}.analogy-box {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;padding:25px;border-radius:12px;margin:20px 0}.highlight {color:#000000;padding:2px 4px;border-radius:3px;font-weight:bold}.difficulty-badge {display:inline-block;padding:5px 15px;border-radius:20px;font-size:0.9em;font-weight:bold;color:white;background:#e67e22}.key-point {border-left:4px solid #e74c3c;background:#fdf2f2;padding:15px;margin:15px 0;border-radius:0 8px 8px 0}.application-grid {display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:20px 0}.application-card {padding:20px;border-radius:8px;border:2px solid;position:relative;overflow:hidden}.app-network {border-color:#3498db;background:linear-gradient(135deg, #ebf3fd 0%, #f8fbff 100%)}.app-audio {border-color:#9b59b6;background:linear-gradient(135deg, #f4ecf7 0%, #faf8fc 100%)}.app-io {border-color:#e67e22;background:linear-gradient(135deg, #fef4e7 0%, #fffaf5 100%)}.app-keyboard {border-color:#27ae60;background:linear-gradient(135deg, #eafaf1 0%, #f7fdf9 100%)}.quiz-question {background:#fff3cd;border:1px solid #ffeaa7;border-radius:8px;padding:20px;margin:15px 0}.quiz-answer {background:#d1ecf1;border:1px solid #bee5eb;border-radius:8px;padding:15px;margin-top:10px;display:none}.show-answer-btn {background:#17a2b8;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;margin-top:10px}</style><div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>队列缓冲区应用</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🔄</span>
            队列——缓冲区 (Queue Buffer Applications)
        </h1><p>探索队列在缓冲区中的核心作用，理解生产者-消费者模式</p></div><!-- 📋 知识点概述 --><div class="knowledge-section slide-in-right"><div class="section-header"><span class="section-icon">📋</span><h2 class="section-title">缓冲区基础概念</h2></div><div class="key-point"><strong>核心概念：</strong>缓冲区是一块临时存储数据的内存区域，用队列实现可以有效平衡不同速度的数据生产者和消费者之间的处理差异，提供流量控制和数据暂存功能。
        </div><div class="concept-grid"><div class="concept-card"><h3>🏭 生产者</h3><p>向缓冲区写入数据的组件<br>例：网络数据包、用户输入</p></div><div class="concept-card"><h3>🛒 消费者</h3><p>从缓冲区读取数据的组件<br>例：应用程序、显示设备</p></div><div class="concept-card"><h3>📦 缓冲区</h3><p>基于队列的临时存储空间<br>FIFO顺序保证数据有序处理</p></div><div class="concept-card"><h3>⚖️ 流量控制</h3><p>平衡生产和消费速度差异<br>防止数据丢失或系统阻塞</p></div></div><p><span class="difficulty-badge">应用级</span><strong>前置知识：</strong>队列基础操作、多线程概念、系统I/O</p></div><!-- 🔍 概念详解 --><div class="knowledge-section"><div class="section-header"><span class="section-icon">🔍</span><h2 class="section-title">缓冲区工作原理</h2></div><div class="analogy-box"><h3>🏪 生活类比：餐厅厨房</h3><p>想象一个繁忙的餐厅：</p><ul><li><strong>厨师</strong> = 生产者（制作菜品的速度可能不稳定）</li><li><strong>服务员</strong> = 消费者（上菜的速度也可能变化）</li><li><strong>传菜台</strong> = 缓冲区（暂时放置做好的菜品）</li><li><strong>传菜顺序</strong> = FIFO（先做好的菜先端走）</li></ul><p>💡 关键：<span class="highlight">传菜台避免了厨师和服务员速度不匹配的问题！</span></p></div><h3>🎯 缓冲区的核心价值</h3><div class="key-point"><strong>解决的关键问题：</strong><ul><li><strong>速度匹配</strong>：生产者和消费者处理速度不同</li><li><strong>时间解耦</strong>：生产和消费可以在不同时间进行</li><li><strong>突发处理</strong>：处理数据流量的短期波动</li><li><strong>系统稳定</strong>：防止快速生产者压垮慢速消费者</li><li><strong>资源优化</strong>：充分利用系统资源，减少等待时间</li></ul></div><h3>⚡ 缓冲区状态管理</h3><div class="application-grid"><div class="application-card app-network"><h4>📊 缓冲区满</h4><ul><li>生产者速度 > 消费者速度</li><li>需要暂停生产或丢弃数据</li><li>可能触发流量控制机制</li></ul></div><div class="application-card app-audio"><h4>📭 缓冲区空</h4><ul><li>消费者速度 > 生产者速度</li><li>消费者需要等待或处理空闲</li><li>可能导致处理中断</li></ul></div></div></div><!-- 📊 可视化展示 --><div class="knowledge-section"><div class="section-header"><span class="section-icon">📊</span><h2 class="section-title">生产者-消费者模拟</h2></div><div class="canvas-container"><h3>🔄 缓冲区动态仿真</h3><canvas id="bufferCanvas" width="900" height="400" style="border: 2px solid #3498db; border-radius: 8px; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);"></canvas><div class="simulation-controls"><div class="control-group"><div class="control-label">🏭 生产者</div><button class="btn btn-producer" onclick="toggleProducer()">启动生产</button><div class="speed-control"><span style="font-size: 10px;">慢</span><input type="range" id="producerSpeed" class="speed-slider" min="1" max="10" value="5"><span style="font-size: 10px;">快</span></div></div><div class="control-group"><div class="control-label">🛒 消费者</div><button class="btn btn-consumer" onclick="toggleConsumer()">启动消费</button><div class="speed-control"><span style="font-size: 10px;">慢</span><input type="range" id="consumerSpeed" class="speed-slider" min="1" max="10" value="5"><span style="font-size: 10px;">快</span></div></div><div class="control-group"><div class="control-label">🎮 系统控制</div><button class="btn btn-control" onclick="resetBuffer()">重置</button><button class="btn btn-control" onclick="startDemo()">自动演示</button></div><div class="control-group"><div class="control-label">📏 缓冲区大小</div><div class="speed-control"><span style="font-size: 10px;">小</span><input type="range" id="bufferSize" class="speed-slider" min="5" max="15" value="10" onchange="resizeBuffer()"><span style="font-size: 10px;">大</span></div></div></div><div class="stats-display"><div class="stat-item"><div class="stat-value" id="producedCount">0</div><div class="stat-label">已生产</div></div><div class="stat-item"><div class="stat-value" id="consumedCount">0</div><div class="stat-label">已消费</div></div><div class="stat-item"><div class="stat-value" id="bufferCount">0</div><div class="stat-label">缓冲区内</div></div><div class="stat-item"><div class="stat-value" id="bufferUsage">0%</div><div class="stat-label">缓冲区使用率</div></div><div class="stat-item"><div class="stat-value" id="blockedProducer">0</div><div class="stat-label">生产者阻塞次数</div></div><div class="stat-item"><div class="stat-value" id="blockedConsumer">0</div><div class="stat-label">消费者阻塞次数</div></div></div></div></div><!-- 🌟 实际应用场景 --><div class="knowledge-section"><div class="section-header"><span class="section-icon">🌟</span><h2 class="section-title">实际应用场景</h2></div><div class="concept-grid"><div class="application-card app-network"><h3>🌐 网络数据包缓冲</h3><p><strong>场景</strong>：网络传输中的数据包处理</p><ul><li><strong>生产者</strong>：网络接口接收数据包</li><li><strong>消费者</strong>：应用程序处理数据包</li><li><strong>缓冲作用</strong>：平滑网络波动，防止数据丢失</li></ul></div><div class="application-card app-audio"><h3>🎵 音频流缓冲</h3><p><strong>场景</strong>：音频播放和录制</p><ul><li><strong>生产者</strong>：音频解码器或麦克风</li><li><strong>消费者</strong>：扬声器或音频处理</li><li><strong>缓冲作用</strong>：确保连续播放，避免卡顿</li></ul></div><div class="application-card app-io"><h3>💾 磁盘I/O缓冲</h3><p><strong>场景</strong>：文件读写操作</p><ul><li><strong>生产者</strong>：应用程序写入请求</li><li><strong>消费者</strong>：磁盘控制器</li><li><strong>缓冲作用</strong>：批量处理，提高I/O效率</li></ul></div><div class="application-card app-keyboard"><h3>⌨️ 键盘输入缓冲</h3><p><strong>场景</strong>：用户输入处理</p><ul><li><strong>生产者</strong>：键盘硬件</li><li><strong>消费者</strong>：应用程序</li><li><strong>缓冲作用</strong>：暂存按键，防止输入丢失</li></ul></div></div><div class="key-point"><h3>🎯 缓冲区设计考虑因素</h3><ul><li><strong>缓冲区大小</strong>：太小容易满，太大浪费内存</li><li><strong>阻塞策略</strong>：满时是阻塞生产者还是丢弃数据</li><li><strong>优先级</strong>：是否需要支持不同优先级的数据</li><li><strong>线程安全</strong>：多线程环境下的同步控制</li><li><strong>性能监控</strong>：缓冲区使用率和阻塞情况统计</li></ul></div></div><!-- 💻 代码实现 --><div class="knowledge-section"><div class="section-header"><span class="section-icon">💻</span><h2 class="section-title">缓冲区代码实现</h2></div><div class="code-container"><div class="code-tabs"><button class="code-tab active" onclick="showCode('simple')">简单缓冲区</button><button class="code-tab" onclick="showCode('threadsafe')">线程安全版本</button><button class="code-tab" onclick="showCode('producer-consumer')">生产者-消费者</button></div><div id="simple-code" class="code-content"><button class="copy-btn" onclick="copyCode('simple', this)">📋 复制</button><pre><code>class SimpleBuffer:
    """简单的队列缓冲区实现"""

    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = []
        self.blocked_producers = 0
        self.blocked_consumers = 0

    def produce(self, item):
        """生产者向缓冲区添加数据"""
        if len(self.buffer) >= self.capacity:
            self.blocked_producers += 1
            print(f"缓冲区已满! 生产者阻塞，数据: {item}")
            return False

        self.buffer.append(item)
        print(f"生产数据: {item}, 缓冲区大小: {len(self.buffer)}")
        return True

    def consume(self):
        """消费者从缓冲区获取数据"""
        if len(self.buffer) == 0:
            self.blocked_consumers += 1
            print("缓冲区为空! 消费者阻塞")
            return None

        item = self.buffer.pop(0)  # FIFO队列
        print(f"消费数据: {item}, 缓冲区大小: {len(self.buffer)}")
        return item

    def is_full(self):
        return len(self.buffer) >= self.capacity

    def is_empty(self):
        return len(self.buffer) == 0

    def size(self):
        return len(self.buffer)

    def usage_rate(self):
        """缓冲区使用率"""
        return (len(self.buffer) / self.capacity) * 100

    def get_stats(self):
        """获取统计信息"""
        return {
            'buffer_size': len(self.buffer),
            'capacity': self.capacity,
            'usage_rate': self.usage_rate(),
            'blocked_producers': self.blocked_producers,
            'blocked_consumers': self.blocked_consumers
        }

# 使用示例
buffer = SimpleBuffer(5)

# 模拟生产和消费
for i in range(7):  # 生产7个，缓冲区只能放5个
    buffer.produce(f"数据{i}")

print("\n开始消费:")
for i in range(3):  # 消费3个
    buffer.consume()

print(f"\n统计信息: {buffer.get_stats()}")</code></pre></div><div id="threadsafe-code" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('threadsafe', this)">📋 复制</button><pre><code>import threading
import time
from collections import deque

class ThreadSafeBuffer:
    """线程安全的缓冲区实现"""

    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = deque()
        self.lock = threading.Lock()
        self.not_full = threading.Condition(self.lock)
        self.not_empty = threading.Condition(self.lock)

        # 统计信息
        self.produced_count = 0
        self.consumed_count = 0
        self.blocked_producers = 0
        self.blocked_consumers = 0

    def produce(self, item, timeout=None):
        """线程安全的生产操作"""
        with self.not_full:
            # 等待缓冲区不满
            start_time = time.time()
            while len(self.buffer) >= self.capacity:
                self.blocked_producers += 1
                if not self.not_full.wait(timeout):
                    return False  # 超时

            # 添加数据
            self.buffer.append(item)
            self.produced_count += 1
            print(f"[生产者] 生产: {item}, 缓冲区: {len(self.buffer)}/{self.capacity}")

            # 通知消费者
            self.not_empty.notify()
            return True

    def consume(self, timeout=None):
        """线程安全的消费操作"""
        with self.not_empty:
            # 等待缓冲区不空
            while len(self.buffer) == 0:
                self.blocked_consumers += 1
                if not self.not_empty.wait(timeout):
                    return None  # 超时

            # 获取数据
            item = self.buffer.popleft()
            self.consumed_count += 1
            print(f"[消费者] 消费: {item}, 缓冲区: {len(self.buffer)}/{self.capacity}")

            # 通知生产者
            self.not_full.notify()
            return item

    def size(self):
        with self.lock:
            return len(self.buffer)

    def is_full(self):
        with self.lock:
            return len(self.buffer) >= self.capacity

    def is_empty(self):
        with self.lock:
            return len(self.buffer) == 0

    def get_stats(self):
        with self.lock:
            return {
                'buffer_size': len(self.buffer),
                'capacity': self.capacity,
                'produced_count': self.produced_count,
                'consumed_count': self.consumed_count,
                'blocked_producers': self.blocked_producers,
                'blocked_consumers': self.blocked_consumers,
                'usage_rate': (len(self.buffer) / self.capacity) * 100
            }</code></pre></div><div id="producer-consumer-code" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('producer-consumer', this)">📋 复制</button><pre><code>import threading
import time
import random

class ProducerConsumerSystem:
    """完整的生产者-消费者系统"""

    def __init__(self, buffer_capacity=10):
        self.buffer = ThreadSafeBuffer(buffer_capacity)
        self.running = False
        self.producer_threads = []
        self.consumer_threads = []

    def producer_worker(self, producer_id, production_rate=1.0):
        """生产者工作线程"""
        item_count = 0
        while self.running:
            item = f"P{producer_id}-{item_count}"

            if self.buffer.produce(item, timeout=1.0):
                item_count += 1

            # 根据生产速率调整休眠时间
            time.sleep(1.0 / production_rate)

    def consumer_worker(self, consumer_id, consumption_rate=1.0):
        """消费者工作线程"""
        while self.running:
            item = self.buffer.consume(timeout=1.0)

            if item:
                # 模拟处理时间
                processing_time = random.uniform(0.1, 0.3)
                time.sleep(processing_time)

            # 根据消费速率调整休眠时间
            time.sleep(1.0 / consumption_rate)

    def start_producer(self, producer_id, production_rate=1.0):
        """启动生产者"""
        thread = threading.Thread(
            target=self.producer_worker,
            args=(producer_id, production_rate),
            daemon=True
        )
        self.producer_threads.append(thread)
        thread.start()
        print(f"生产者 {producer_id} 已启动 (速率: {production_rate}/秒)")

    def start_consumer(self, consumer_id, consumption_rate=1.0):
        """启动消费者"""
        thread = threading.Thread(
            target=self.consumer_worker,
            args=(consumer_id, consumption_rate),
            daemon=True
        )
        self.consumer_threads.append(thread)
        thread.start()
        print(f"消费者 {consumer_id} 已启动 (速率: {consumption_rate}/秒)")

    def start_system(self):
        """启动系统"""
        self.running = True
        print("生产者-消费者系统已启动")

    def stop_system(self):
        """停止系统"""
        self.running = False
        print("生产者-消费者系统已停止")

    def monitor_stats(self, interval=2.0):
        """监控系统状态"""
        while self.running:
            stats = self.buffer.get_stats()
            print(f"\n[监控] 缓冲区状态:")
            print(f"  大小: {stats['buffer_size']}/{stats['capacity']}")
            print(f"  使用率: {stats['usage_rate']:.1f}%")
            print(f"  已生产: {stats['produced_count']}")
            print(f"  已消费: {stats['consumed_count']}")
            print(f"  生产者阻塞: {stats['blocked_producers']}")
            print(f"  消费者阻塞: {stats['blocked_consumers']}")

            time.sleep(interval)

# 使用示例
if __name__ == "__main__":
    system = ProducerConsumerSystem(buffer_capacity=5)

    # 启动系统
    system.start_system()

    # 启动生产者和消费者
    system.start_producer(1, production_rate=2.0)  # 快速生产者
    system.start_producer(2, production_rate=1.0)  # 普通生产者
    system.start_consumer(1, consumption_rate=1.5) # 快速消费者
    system.start_consumer(2, consumption_rate=0.8) # 慢速消费者

    # 启动监控
    monitor_thread = threading.Thread(
        target=system.monitor_stats,
        daemon=True
    )
    monitor_thread.start()

    # 运行10秒后停止
    time.sleep(10)
    system.stop_system()

    # 最终统计
    print(f"\n最终统计: {system.buffer.get_stats()}")</code></pre></div></div></div><!-- ✅ 学习检验 --><div class="knowledge-section"><div class="section-header"><span class="section-icon">✅</span><h2 class="section-title">学习检验</h2></div><div class="quiz-question"><h4>🤔 问题1：为什么网络数据包处理需要缓冲区？</h4><button class="show-answer-btn" onclick="toggleAnswer('answer1')">显示答案</button><div id="answer1" class="quiz-answer"><strong>答案：</strong>因为网络数据包到达速度不稳定，应用程序处理速度也可能变化<br><strong>具体原因：</strong><ul><li><strong>网络波动</strong>：数据包可能突发性大量到达</li><li><strong>处理延迟</strong>：应用程序可能正在处理其他任务</li><li><strong>防止丢失</strong>：缓冲区暂存数据包，避免因处理不及时而丢失</li><li><strong>平滑处理</strong>：将突发流量平摊到较长时间处理</li></ul></div></div><div class="quiz-question"><h4>🤔 问题2：音频播放缓冲区太小会导致什么问题？太大呢？</h4><button class="show-answer-btn" onclick="toggleAnswer('answer2')">显示答案</button><div id="answer2" class="quiz-answer"><strong>缓冲区太小的问题：</strong><ul><li><strong>音频卡顿</strong>：缓冲区很快被消耗完，导致播放中断</li><li><strong>频繁阻塞</strong>：消费者经常等待新数据到达</li><li><strong>不稳定播放</strong>：难以应对网络或处理的短期波动</li></ul><strong>缓冲区太大的问题：</strong><ul><li><strong>延迟增加</strong>：数据从生产到消费的延迟变长</li><li><strong>内存浪费</strong>：占用过多内存资源</li><li><strong>响应性差</strong>：暂停、快进等操作响应慢</li></ul></div></div><div class="quiz-question"><h4>🤔 问题3：在生产者速度远大于消费者速度的情况下，应该采取什么策略？</h4><button class="show-answer-btn" onclick="toggleAnswer('answer3')">显示答案</button><div id="answer3" class="quiz-answer"><strong>可选策略：</strong><ul><li><strong>阻塞生产者</strong>：缓冲区满时暂停生产者，适用于数据不能丢失的场景</li><li><strong>丢弃新数据</strong>：缓冲区满时丢弃新来的数据，适用于实时性要求高的场景</li><li><strong>丢弃旧数据</strong>：缓冲区满时丢弃最旧的数据，保持最新数据</li><li><strong>流量控制</strong>：向上游发送反压信号，要求降低生产速度</li><li><strong>动态扩容</strong>：在资源允许的情况下动态增加缓冲区大小</li><li><strong>多级缓冲</strong>：使用多个级别的缓冲区分层处理</li></ul><strong>选择依据：</strong>数据重要性、实时性要求、资源限制等
            </div></div><div class="quiz-question"><h4>🤔 问题4：如何设计一个高效的线程安全缓冲区？</h4><button class="show-answer-btn" onclick="toggleAnswer('answer4')">显示答案</button><div id="answer4" class="quiz-answer"><strong>关键设计要点：</strong><ul><li><strong>锁策略</strong>：使用读写锁或条件变量减少锁竞争</li><li><strong>数据结构</strong>：选择高效的底层数据结构（如环形缓冲区）</li><li><strong>条件等待</strong>：避免忙等待，使用条件变量进行阻塞</li><li><strong>批量操作</strong>：支持批量读写减少锁开销</li><li><strong>无锁设计</strong>：在特定场景下使用无锁队列提高性能</li><li><strong>内存对齐</strong>：避免false sharing，优化缓存性能</li></ul></div></div><div class="quiz-question"><h4>🤔 问题5：在设计视频流缓冲区时需要考虑哪些特殊因素？</h4><button class="show-answer-btn" onclick="toggleAnswer('answer5')">显示答案</button><div id="answer5" class="quiz-answer"><strong>视频流的特殊考虑：</strong><ul><li><strong>帧率要求</strong>：必须保证稳定的帧率播放（如30fps、60fps）</li><li><strong>I/P/B帧</strong>：不同类型帧的重要性和大小差异很大</li><li><strong>时间戳</strong>：每个帧都有严格的播放时间要求</li><li><strong>数据量大</strong>：视频数据量远大于音频，需要更大缓冲区</li><li><strong>预加载策略</strong>：需要提前缓冲足够的数据防止卡顿</li><li><strong>动态码率</strong>：根据网络状况调整视频质量和缓冲策略</li><li><strong>跳跃播放</strong>：支持快进、后退等随机访问操作</li></ul></div></div><h3>📚 进一步学习建议</h3><ul><li>🔄 <strong>无锁队列</strong>：学习高性能的lock-free数据结构</li><li>🎯 <strong>背压机制</strong>：了解流量控制和反压策略</li><li>🌊 <strong>流处理系统</strong>：研究Apache Kafka、RabbitMQ等消息队列</li><li>🎮 <strong>实时系统</strong>：探索实时操作系统中的缓冲区设计</li></ul></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><script>class BufferSimulation { constructor(canvasId, capacity = 10) { this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d'); this.capacity = capacity; this.buffer = []; this.isProducerRunning = false; this.isConsumerRunning = false; this.stats = { produced: 0, consumed: 0, blockedProducer: 0, blockedConsumer: 0 }; this.particles = []; this.producerPos = { x: 100, y: 200 }; this.consumerPos = { x: 700, y: 200 }; this.bufferPos = { x: 300, y: 150 }; this.cellWidth = 35; this.cellHeight = 40; this.producerSpeed = 5; this.consumerSpeed = 5; this.lastProduceTime = 0; this.lastConsumeTime = 0; this.startAnimation(); this.draw(); } startAnimation() { const animate = () => { this.update(); this.draw(); requestAnimationFrame(animate); }; animate(); } update() { const now = Date.now(); if (this.isProducerRunning) { const produceInterval = 1000 / this.producerSpeed; if (now - this.lastProduceTime > produceInterval) { this.produce(); this.lastProduceTime = now; } } if (this.isConsumerRunning) { const consumeInterval = 1000 / this.consumerSpeed; if (now - this.lastConsumeTime > consumeInterval) { this.consume(); this.lastConsumeTime = now; } } this.particles = this.particles.filter(particle => { particle.update(); return !particle.isDead(); }); this.updateStats(); } produce() { if (this.buffer.length >= this.capacity) { this.stats.blockedProducer++; this.createBlockedEffect(this.producerPos.x, this.producerPos.y, '#e74c3c'); return false; } const item = { id: this.stats.produced, value: Math.floor(Math.random() * 100), timestamp: Date.now() }; this.buffer.push(item); this.stats.produced++; this.createProduceAnimation(item); return true; } consume() { if (this.buffer.length === 0) { this.stats.blockedConsumer++; this.createBlockedEffect(this.consumerPos.x, this.consumerPos.y, '#f39c12'); return null; } const item = this.buffer.shift(); this.stats.consumed++; this.createConsumeAnimation(item); return item; } createProduceAnimation(item) { this.particles.push(new DataParticle( this.producerPos.x, this.producerPos.y, this.bufferPos.x + this.buffer.length * this.cellWidth, this.bufferPos.y, '#27ae60', item.value )); } createConsumeAnimation(item) { const startX = this.bufferPos.x; this.particles.push(new DataParticle( startX, this.bufferPos.y, this.consumerPos.x, this.consumerPos.y, '#e74c3c', item.value )); } createBlockedEffect(x, y, color) { for (let i = 0; i < 5; i++) { this.particles.push(new BlockedParticle(x, y, color)); } } draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height); gradient.addColorStop(0, '#f8f9fa'); gradient.addColorStop(1, '#e9ecef'); this.ctx.fillStyle = gradient; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#2c3e50'; this.ctx.font = 'bold 18px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('🔄 生产者-消费者缓冲区仿真', this.canvas.width/2, 30); this.drawProducer(); this.drawBuffer(); this.drawConsumer(); this.drawConnections(); this.particles.forEach(particle => particle.draw(this.ctx)); this.drawStatusInfo(); } drawProducer() { const x = this.producerPos.x; const y = this.producerPos.y; this.ctx.fillStyle = this.isProducerRunning ? '#27ae60' : '#95a5a6'; this.ctx.fillRect(x - 40, y - 30, 80, 60); this.ctx.strokeStyle = '#2c3e50'; this.ctx.lineWidth = 2; this.ctx.strokeRect(x - 40, y - 30, 80, 60); this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 14px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('🏭', x, y - 5); this.ctx.fillText('生产者', x, y + 10); this.ctx.fillStyle = '#2c3e50'; this.ctx.font = '12px Arial'; this.ctx.fillText(`速度: ${this.producerSpeed}`, x, y + 50); } drawConsumer() { const x = this.consumerPos.x; const y = this.consumerPos.y; this.ctx.fillStyle = this.isConsumerRunning ? '#e74c3c' : '#95a5a6'; this.ctx.fillRect(x - 40, y - 30, 80, 60); this.ctx.strokeStyle = '#2c3e50'; this.ctx.lineWidth = 2; this.ctx.strokeRect(x - 40, y - 30, 80, 60); this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 14px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('🛒', x, y - 5); this.ctx.fillText('消费者', x, y + 10); this.ctx.fillStyle = '#2c3e50'; this.ctx.font = '12px Arial'; this.ctx.fillText(`速度: ${this.consumerSpeed}`, x, y + 50); } drawBuffer() { const x = this.bufferPos.x; const y = this.bufferPos.y; this.ctx.fillStyle = '#2c3e50'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'left'; this.ctx.fillText('📦 缓冲区队列', x, y - 20); for (let i = 0; i < this.capacity; i++) { const cellX = x + i * this.cellWidth; const isOccupied = i < this.buffer.length; this.ctx.fillStyle = isOccupied ? '#3498db' : '#ffffff'; this.ctx.fillRect(cellX, y, this.cellWidth - 2, this.cellHeight); this.ctx.strokeStyle = '#2c3e50'; this.ctx.lineWidth = 1; this.ctx.strokeRect(cellX, y, this.cellWidth - 2, this.cellHeight); if (isOccupied) { this.ctx.fillStyle = '#ffffff'; this.ctx.font = 'bold 12px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText( this.buffer[i].value.toString(), cellX + this.cellWidth/2, y + this.cellHeight/2 + 4 ); } this.ctx.fillStyle = '#7f8c8d'; this.ctx.font = '10px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText(i.toString(), cellX + this.cellWidth/2, y + this.cellHeight + 15); } if (this.buffer.length > 0) { this.ctx.fillStyle = '#27ae60'; this.ctx.font = 'bold 12px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText('Front', x + this.cellWidth/2, y - 5); const rearX = x + (this.buffer.length - 1) * this.cellWidth; this.ctx.fillStyle = '#e74c3c'; this.ctx.fillText('Rear', rearX + this.cellWidth/2, y + this.cellHeight + 30); } const usage = (this.buffer.length / this.capacity) * 100; const usageColor = usage > 80 ? '#e74c3c' : usage > 60 ? '#f39c12' : '#27ae60'; this.ctx.fillStyle = usageColor; this.ctx.font = 'bold 14px Arial'; this.ctx.textAlign = 'left'; this.ctx.fillText(`使用率: ${usage.toFixed(1)}%`, x, y + this.cellHeight + 50); } drawConnections() { this.ctx.strokeStyle = '#3498db'; this.ctx.lineWidth = 3; this.ctx.setLineDash([10, 5]); this.ctx.beginPath(); this.ctx.moveTo(this.producerPos.x + 40, this.producerPos.y); this.ctx.lineTo(this.bufferPos.x - 20, this.bufferPos.y + this.cellHeight/2); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(this.bufferPos.x + this.capacity * this.cellWidth + 20, this.bufferPos.y + this.cellHeight/2); this.ctx.lineTo(this.consumerPos.x - 40, this.consumerPos.y); this.ctx.stroke(); this.ctx.setLineDash([]); } drawStatusInfo() { const startY = 320; this.ctx.fillStyle = '#2c3e50'; this.ctx.font = '14px Arial'; this.ctx.textAlign = 'left'; this.ctx.fillText(`队列状态: ${this.buffer.length}/${this.capacity}`, 50, startY); this.ctx.fillText(`生产者状态: ${this.isProducerRunning ? '运行中' : '已停止'}`, 250, startY); this.ctx.fillText(`消费者状态: ${this.isConsumerRunning ? '运行中' : '已停止'}`, 450, startY); } updateStats() { document.getElementById('producedCount').textContent = this.stats.produced; document.getElementById('consumedCount').textContent = this.stats.consumed; document.getElementById('bufferCount').textContent = this.buffer.length; document.getElementById('bufferUsage').textContent = ((this.buffer.length / this.capacity) * 100).toFixed(1) + '%'; document.getElementById('blockedProducer').textContent = this.stats.blockedProducer; document.getElementById('blockedConsumer').textContent = this.stats.blockedConsumer; } toggleProducer() { this.isProducerRunning = !this.isProducerRunning; } toggleConsumer() { this.isConsumerRunning = !this.isConsumerRunning; } setProducerSpeed(speed) { this.producerSpeed = speed; } setConsumerSpeed(speed) { this.consumerSpeed = speed; } reset() { this.buffer = []; this.particles = []; this.stats = { produced: 0, consumed: 0, blockedProducer: 0, blockedConsumer: 0 }; this.isProducerRunning = false; this.isConsumerRunning = false; } resize(newCapacity) { this.capacity = newCapacity; if (this.buffer.length > newCapacity) { this.buffer = this.buffer.slice(0, newCapacity); } } } class DataParticle { constructor(startX, startY, targetX, targetY, color, value) { this.x = startX; this.y = startY; this.targetX = targetX; this.targetY = targetY; this.color = color; this.value = value; this.progress = 0; this.speed = 0.02; this.size = 20; } update() { this.progress += this.speed; this.x = this.x + (this.targetX - this.x) * 0.1; this.y = this.y + (this.targetY - this.y) * 0.1; } draw(ctx) { ctx.save(); ctx.fillStyle = this.color; ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.value.toString(), this.x, this.y + 4); ctx.restore(); } isDead() { return this.progress >= 1; } } class BlockedParticle { constructor(x, y, color) { this.x = x + (Math.random() - 0.5) * 40; this.y = y + (Math.random() - 0.5) * 40; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.color = color; this.life = 1.0; this.decay = 0.03; this.size = Math.random() * 8 + 4; } update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; this.size *= 0.98; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillText('❌', this.x, this.y); ctx.restore(); } isDead() { return this.life <= 0; } } let bufferSim = new BufferSimulation('bufferCanvas', 10); function toggleProducer() { bufferSim.toggleProducer(); const btn = event.target; btn.textContent = bufferSim.isProducerRunning ? '停止生产' : '启动生产'; } function toggleConsumer() { bufferSim.toggleConsumer(); const btn = event.target; btn.textContent = bufferSim.isConsumerRunning ? '停止消费' : '启动消费'; } function resetBuffer() { bufferSim.reset(); document.querySelector('.btn-producer').textContent = '启动生产'; document.querySelector('.btn-consumer').textContent = '启动消费'; } function resizeBuffer() { const newSize = document.getElementById('bufferSize').value; bufferSim.resize(parseInt(newSize)); } async function startDemo() { resetBuffer(); await new Promise(resolve => setTimeout(resolve, 500)); bufferSim.toggleProducer(); document.querySelector('.btn-producer').textContent = '停止生产'; await new Promise(resolve => setTimeout(resolve, 3000)); bufferSim.toggleConsumer(); document.querySelector('.btn-consumer').textContent = '停止消费'; setTimeout(() => { bufferSim.setProducerSpeed(8); document.getElementById('producerSpeed').value = 8; }, 5000); setTimeout(() => { bufferSim.setConsumerSpeed(3); document.getElementById('consumerSpeed').value = 3; }, 8000); } document.getElementById('producerSpeed').addEventListener('input', function() { bufferSim.setProducerSpeed(parseInt(this.value)); }); document.getElementById('consumerSpeed').addEventListener('input', function() { bufferSim.setConsumerSpeed(parseInt(this.value)); }); function showCode(language) { document.querySelectorAll('.code-content').forEach(el => el.style.display = 'none'); document.querySelectorAll('.code-tab').forEach(el => el.classList.remove('active')); document.getElementById(language + '-code').style.display = 'block'; event.target.classList.add('active'); } function copyCode(language, button) { const codeElement = document.querySelector(`#${language}-code pre code`); const text = codeElement.textContent; if (navigator.clipboard && window.isSecureContext) { navigator.clipboard.writeText(text).then(() => { showCopySuccess(button); }).catch(() => { fallbackCopyText(text, button); }); } else { fallbackCopyText(text, button); } } function fallbackCopyText(text, button) { const textArea = document.createElement('textarea'); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.left = '-999999px'; textArea.style.top = '-999999px'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); showCopySuccess(button); } catch (err) { console.error('复制失败:', err); alert('复制失败，请手动复制代码'); } document.body.removeChild(textArea); } function showCopySuccess(button) { const originalText = button.textContent; const originalBg = button.style.background; button.textContent = '✅ 已复制'; button.style.background = '#27ae60'; button.style.transform = 'scale(1.1)'; setTimeout(() => { button.textContent = originalText; button.style.background = originalBg; button.style.transform = 'scale(1)'; }, 2000); } function toggleAnswer(answerId) { const answer = document.getElementById(answerId); const btn = event.target; if (answer.style.display === 'none' || answer.style.display === '') { answer.style.display = 'block'; btn.textContent = '隐藏答案'; btn.style.background = '#e74c3c'; } else { answer.style.display = 'none'; btn.textContent = '显示答案'; btn.style.background = '#17a2b8'; } }</script>
{% endblock %}