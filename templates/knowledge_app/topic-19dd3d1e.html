{% extends 'knowledge_app/base.html' %}

{% block title %}B+树 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>数据结构</span>
        <span>></span>
        <span>B+树</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">🌲</span>
            B+树 (B+Tree)
        </h1>
        <p>数据库索引的黄金标准，叶子节点链式存储，完美支持范围查询和顺序访问</p>
    </div>

    <!-- 📋 知识点概述 -->
    <div class="content-card slide-in-right">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📋</span>
                知识点概述
            </h2>

            <div class="overview-content">
                <div class="concept-intro">
                    <h3>核心概念</h3>
                    <p>B+树是B树的进化版本，就像图书馆的双层索引系统：上层是目录索引（内部节点），只告诉你在哪个书架；下层是具体的书籍（叶子节点），按顺序排列并且相互连接。这种设计使得B+树在数据库系统中表现卓越，特别适合范围查询和顺序扫描。</p>
                </div>

                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <span class="info-icon">📚</span>
                        <div>
                            <strong>学习难度：</strong>中等偏难
                            <br><strong>前置知识：</strong>B树、数据库基础概念
                        </div>
                    </div>
                    <div class="info-box info-box-success">
                        <span class="info-icon">⏱️</span>
                        <div>
                            <strong>学习时间：</strong>50-80分钟
                            <br><strong>重要程度：</strong>⭐⭐⭐⭐⭐
                        </div>
                    </div>
                </div>

                <div class="terms-list">
                    <h4>🔑 关键术语</h4>
                    <div class="unified-grid unified-grid-2">
                        <div class="term-item">
                            <strong>叶子节点：</strong>存储实际数据的底层节点，形成有序链表
                        </div>
                        <div class="term-item">
                            <strong>内部节点：</strong>只存储索引信息，不存储实际数据
                        </div>
                        <div class="term-item">
                            <strong>顺序链表：</strong>叶子节点间的指针连接，支持顺序访问
                        </div>
                        <div class="term-item">
                            <strong>范围查询：</strong>利用叶子链表高效查询一个区间内的数据
                        </div>
                    </div>
                </div>

                <div class="problem-solution">
                    <h4>💡 相比B树的改进</h4>
                    <div class="unified-grid unified-grid-2">
                        <div class="problem-box">
                            <h5>🔴 B树的局限</h5>
                            <ul>
                                <li>内部节点也存储数据，降低分支因子</li>
                                <li>范围查询需要中序遍历，效率不高</li>
                                <li>顺序访问需要重复查找路径</li>
                                <li>叶子节点无连接，不利于扫描操作</li>
                            </ul>
                        </div>
                        <div class="solution-box">
                            <h5>🟢 B+树优势</h5>
                            <ul>
                                <li>内部节点仅索引，提高分支因子</li>
                                <li>叶子链表支持高效范围查询</li>
                                <li>所有数据在叶子层，查找路径稳定</li>
                                <li>完美适配数据库访问模式</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 📖 概念详解 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📖</span>
                概念详解
            </h2>

            <div class="concept-details">
                <div class="concept-item">
                    <h3>🎯 B+树的核心特征</h3>
                    <p>B+树在B树基础上进行了三个关键改进：数据分离、叶子链表、稳定深度。这些特性使其成为数据库索引的理想选择。</p>
                    <div class="example-box">
                        <strong>关键特性：</strong>所有数据记录都存储在叶子节点中，内部节点只存储用于导航的索引值，叶子节点通过指针链接形成有序链表。
                    </div>
                    <div class="stats-box">
                        <h5>📊 B+树结构特点</h5>
                        <p><strong>内部节点：</strong>只存储索引关键字，不存储数据记录</p>
                        <p><strong>叶子节点：</strong>存储所有数据记录，按关键字有序排列</p>
                        <p><strong>链表结构：</strong>叶子节点间通过指针相互连接</p>
                        <p><strong>查找路径：</strong>所有查找都必须到达叶子节点</p>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 B+树 vs B树 详细对比</h3>
                    <div class="comparison-grid">
                        <div class="compare-box">
                            <h4>🌳 B树结构</h4>
                            <div class="tree-structure-demo">
                                <div class="tree-level">
                                    <div class="tree-node btree-node">
                                        <span class="node-content">50[data]</span>
                                    </div>
                                </div>
                                <div class="tree-level">
                                    <div class="tree-node btree-node">
                                        <span class="node-content">25[data]</span>
                                    </div>
                                    <div class="tree-node btree-node">
                                        <span class="node-content">75[data]</span>
                                    </div>
                                </div>
                            </div>
                            <ul class="compare-features">
                                <li>内部节点存储数据</li>
                                <li>查找可能在内部节点结束</li>
                                <li>节点利用率相对较低</li>
                                <li>范围查询需要遍历树</li>
                            </ul>
                        </div>
                        <div class="compare-box">
                            <h4>🌲 B+树结构</h4>
                            <div class="tree-structure-demo">
                                <div class="tree-level">
                                    <div class="tree-node bplus-internal-node">
                                        <span class="node-content">50</span>
                                    </div>
                                </div>
                                <div class="tree-level">
                                    <div class="tree-node bplus-leaf-node">
                                        <span class="node-content">25[data]</span>
                                    </div>
                                    <div class="leaf-pointer">→</div>
                                    <div class="tree-node bplus-leaf-node">
                                        <span class="node-content">50[data]|75[data]</span>
                                    </div>
                                </div>
                            </div>
                            <ul class="compare-features">
                                <li>内部节点仅存储索引</li>
                                <li>所有查找都到叶子节点</li>
                                <li>更高的节点利用率</li>
                                <li>叶子链表支持范围查询</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 B+树基本操作</h3>
                    <p>B+树的操作虽然与B树类似，但由于结构差异，有其独特的特点和优化策略。</p>
                    <div class="process-steps">
                        <div class="step-box">
                            <div class="step-number">1</div>
                            <div class="step-content">
                                <h5>查找操作</h5>
                                <p>从根节点向下导航，最终必定到达叶子节点</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">2</div>
                            <div class="step-content">
                                <h5>插入操作</h5>
                                <p>在叶子节点插入，可能引发叶子节点分裂</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">3</div>
                            <div class="step-content">
                                <h5>删除操作</h5>
                                <p>从叶子节点删除，维护节点和链表结构</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">4</div>
                            <div class="step-content">
                                <h5>范围查询</h5>
                                <p>定位起始叶子节点，沿链表顺序访问</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 叶子节点链表机制</h3>
                    <p>B+树的叶子节点链表是其最重要的特性，为数据库的范围查询和顺序扫描提供了极大的便利。</p>
                    <div class="traversal-algorithm">
                        <h5>范围查询算法：</h5>
                        <div class="algorithm-steps">
                            <div class="algo-step">
                                <span class="step-label">步骤1：</span>
                                <span>定位范围查询的起始关键字所在的叶子节点</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤2：</span>
                                <span>在叶子节点中找到第一个满足条件的记录</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤3：</span>
                                <span>沿着叶子节点链表向右顺序遍历</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤4：</span>
                                <span>收集所有在查询范围内的数据记录</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤5：</span>
                                <span>遇到超出范围的关键字时停止查询</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-box info-box-warning">
                    <span class="info-icon">⚠️</span>
                    <strong>设计要点：</strong>
                    <ul>
                        <li>叶子节点的分裂不需要将中间关键字上提，而是复制到父节点</li>
                        <li>内部节点的关键字是叶子节点关键字的"路标"，不是实际数据</li>
                        <li>叶子节点链表必须维护有序性，插入和删除时要更新指针</li>
                        <li>范围查询的性能与查询范围大小呈线性关系，而非对数关系</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 📊 可视化展示 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📊</span>
                交互式B+树演示
            </h2>

            <div class="visualization-container">
                <div class="demo-description">
                    <p>体验B+树的独特魅力！<span style="color: #0ea5e9; font-weight: bold;">蓝色节点</span>表示内部索引节点，<span style="color: #16a34a; font-weight: bold;">绿色节点</span>表示叶子数据节点，<span style="color: #dc2626; font-weight: bold; opacity: 0.7;">红色箭头</span>表示叶子节点间的链表连接。</p>
                    <div style="margin-top: 10px; font-size: 14px; color: #666;">
                        ✨ <strong>特色功能：</strong>支持范围查询演示，观察叶子链表如何实现高效的区间查找，体验B+树在数据库索引中的核心优势！
                    </div>
                </div>

                <div class="canvas-demo">
                    <div class="controls">
                        <div class="control-group">
                            <label>B+树阶数：</label>
                            <select id="bplusTreeOrder" onchange="changeOrder()">
                                <option value="3">3阶</option>
                                <option value="4" selected>4阶</option>
                                <option value="5">5阶</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>插入值：</label>
                            <input type="number" id="insertValue" placeholder="输入数字" min="1" max="99">
                            <button class="insert-btn" onclick="insertKey()">🔍 插入</button>
                        </div>
                        <div class="control-group">
                            <label>删除值：</label>
                            <input type="number" id="deleteValue" placeholder="输入数字" min="1" max="99">
                            <button class="delete-btn" onclick="deleteKey()">🗑️ 删除</button>
                        </div>
                    </div>

                    <div class="range-query-controls">
                        <div class="control-group">
                            <label>范围查询：</label>
                            <input type="number" id="rangeStart" placeholder="起始值" min="1" max="99">
                            <span>到</span>
                            <input type="number" id="rangeEnd" placeholder="结束值" min="1" max="99">
                            <button class="range-btn" onclick="rangeQuery()">🔍 范围查询</button>
                        </div>
                    </div>

                    <div class="preset-controls">
                        <button class="demo-btn" onclick="insertDemo()">📝 演示插入</button>
                        <button class="traverse-btn" onclick="leafTraversal()">🔗 叶子遍历</button>
                        <button class="search-btn" onclick="searchDemo()">🔍 查找演示</button>
                        <button class="reset-btn" onclick="resetBPlusTree()">🔄 重置</button>
                    </div>

                    <div class="canvas-container">
                        <canvas id="bplusCanvas" width="950" height="550"></canvas>
                    </div>

                    <div class="legend">
                        <h4>图例说明</h4>
                        <div class="legend-items">
                            <div class="legend-item">
                                <div class="legend-node internal-node">
                                    <span>50|75</span>
                                </div>
                                <span>内部索引节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node leaf-node">
                                    <span>25[D]|30[D]</span>
                                </div>
                                <span>叶子数据节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node current-node">
                                    <span>40[D]</span>
                                </div>
                                <span>当前操作节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node range-node">
                                    <span>60[D]</span>
                                </div>
                                <span>范围查询结果</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-pointer leaf-pointer-demo">→</div>
                                <span>叶子链表指针</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-connection tree-connection-demo"></div>
                                <span>树形连接</span>
                            </div>
                        </div>
                        <div class="legend-explanation">
                            <p><strong>节点类型说明：</strong></p>
                            <ul>
                                <li><strong>内部节点：</strong>只存储索引关键字，用于导航查找</li>
                                <li><strong>叶子节点：</strong>存储关键字和对应的数据记录[D]</li>
                                <li><strong>链表指针：</strong>连接相邻叶子节点，支持顺序访问</li>
                                <li><strong>树形连接：</strong>父子节点间的导航关系</li>
                            </ul>
                            <div style="margin-top: 12px; padding: 10px; background: #f0f9ff; border-left: 3px solid #3b82f6; border-radius: 4px;">
                                <strong>💡 操作技巧：</strong>
                                <ul style="margin: 8px 0 0 15px; font-size: 12px;">
                                    <li>🔢 <strong>基础操作</strong>：插入、删除数字观察树结构变化</li>
                                    <li>🔍 <strong>范围查询</strong>：输入起始和结束值，观察叶子链表遍历</li>
                                    <li>🔗 <strong>叶子遍历</strong>：展示B+树顺序访问的强大能力</li>
                                    <li>🎯 <strong>阶数调节</strong>：体验不同阶数对树结构的影响</li>
                                    <li>📊 <strong>性能对比</strong>：对比点查询和范围查询的效率差异</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="info">
                        <div class="info-box">
                            <h4>操作日志</h4>
                            <div class="sequence" id="bplusHistory"></div>
                            <div class="status" id="bplusStatus">B+树已初始化，开始您的探索之旅</div>
                        </div>
                        <div class="info-box">
                            <h4>树统计信息</h4>
                            <div class="sequence" id="bplusStats"></div>
                            <div class="status" id="bplusStructure">高度: 0, 叶子节点: 0, 内部节点: 0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 💻 代码实现 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">💻</span>
                代码实现
            </h2>

            <div class="code-implementation">
                <div class="code-tabs">
                    <button class="tab-btn active" onclick="showCode('cpp')">C++</button>
                    <button class="tab-btn" onclick="showCode('java')">Java</button>
                    <button class="tab-btn" onclick="showCode('python')">Python</button>
                </div>

                <div id="cpp-code" class="code-content active">
                    <div class="code-header">
                        <span>C++ 实现</span>
                        <button onclick="copyCode('cpp', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="cpp-source">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

template&lt;typename KeyType, typename ValueType&gt;
class BPlusTree {
private:
    struct BPlusNode {
        vector&lt;KeyType&gt; keys;
        bool isLeaf;
        BPlusNode* parent;

        BPlusNode(bool leaf) : isLeaf(leaf), parent(nullptr) {}
        virtual ~BPlusNode() {}
    };

    struct InternalNode : public BPlusNode {
        vector&lt;BPlusNode*&gt; children;

        InternalNode() : BPlusNode(false) {}

        ~InternalNode() {
            for (auto child : children) {
                delete child;
            }
        }
    };

    struct LeafNode : public BPlusNode {
        vector&lt;ValueType&gt; values;
        LeafNode* next;
        LeafNode* prev;

        LeafNode() : BPlusNode(true), next(nullptr), prev(nullptr) {}
    };

    BPlusNode* root;
    LeafNode* leftmostLeaf;  // 指向最左边的叶子节点
    int order;               // B+树的阶数
    int minKeys;            // 最少关键字数
    int maxKeys;            // 最多关键字数

public:
    BPlusTree(int degree) : root(nullptr), leftmostLeaf(nullptr), order(degree) {
        minKeys = (degree - 1) / 2;
        maxKeys = degree - 1;
    }

    ~BPlusTree() {
        delete root;
    }

    // 搜索操作
    ValueType* search(const KeyType& key) {
        LeafNode* leaf = findLeaf(key);
        if (!leaf) return nullptr;

        for (int i = 0; i &lt; leaf-&gt;keys.size(); i++) {
            if (leaf-&gt;keys[i] == key) {
                return &amp;leaf-&gt;values[i];
            }
        }
        return nullptr;
    }

    // 范围查询
    vector&lt;pair&lt;KeyType, ValueType&gt;&gt; rangeQuery(const KeyType& startKey, const KeyType& endKey) {
        vector&lt;pair&lt;KeyType, ValueType&gt;&gt; result;

        LeafNode* leaf = findLeaf(startKey);
        if (!leaf) return result;

        // 在起始叶子节点中找到第一个大于等于startKey的位置
        int startIdx = 0;
        while (startIdx &lt; leaf-&gt;keys.size() && leaf-&gt;keys[startIdx] &lt; startKey) {
            startIdx++;
        }

        // 沿着叶子链表收集范围内的所有数据
        while (leaf && startIdx &lt; leaf-&gt;keys.size()) {
            if (leaf-&gt;keys[startIdx] &gt; endKey) break;

            result.push_back({leaf-&gt;keys[startIdx], leaf-&gt;values[startIdx]});
            startIdx++;

            // 如果当前叶子节点遍历完，移到下一个叶子节点
            if (startIdx == leaf-&gt;keys.size()) {
                leaf = leaf-&gt;next;
                startIdx = 0;
            }
        }

        return result;
    }

    // 插入操作
    bool insert(const KeyType& key, const ValueType& value) {
        if (!root) {
            // 创建第一个叶子节点作为根
            LeafNode* newLeaf = new LeafNode();
            newLeaf-&gt;keys.push_back(key);
            newLeaf-&gt;values.push_back(value);
            root = newLeaf;
            leftmostLeaf = newLeaf;
            return true;
        }

        LeafNode* leaf = findLeaf(key);

        // 检查是否已存在
        for (int i = 0; i &lt; leaf-&gt;keys.size(); i++) {
            if (leaf-&gt;keys[i] == key) {
                leaf-&gt;values[i] = value; // 更新值
                return true;
            }
        }

        // 在叶子节点中插入
        insertIntoLeaf(leaf, key, value);

        // 如果叶子节点溢出，进行分裂
        if (leaf-&gt;keys.size() &gt; maxKeys) {
            splitLeaf(leaf);
        }

        return true;
    }

    // 删除操作
    bool remove(const KeyType& key) {
        if (!root) return false;

        LeafNode* leaf = findLeaf(key);
        if (!leaf) return false;

        // 在叶子节点中查找并删除
        for (int i = 0; i &lt; leaf-&gt;keys.size(); i++) {
            if (leaf-&gt;keys[i] == key) {
                leaf-&gt;keys.erase(leaf-&gt;keys.begin() + i);
                leaf-&gt;values.erase(leaf-&gt;values.begin() + i);

                // 处理节点下溢
                if (leaf-&gt;keys.size() &lt; minKeys && leaf != root) {
                    handleLeafUnderflow(leaf);
                }

                return true;
            }
        }

        return false;
    }

    // 顺序遍历所有叶子节点
    vector&lt;pair&lt;KeyType, ValueType&gt;&gt; getAllData() {
        vector&lt;pair&lt;KeyType, ValueType&gt;&gt; result;

        LeafNode* current = leftmostLeaf;
        while (current) {
            for (int i = 0; i &lt; current-&gt;keys.size(); i++) {
                result.push_back({current-&gt;keys[i], current-&gt;values[i]});
            }
            current = current-&gt;next;
        }

        return result;
    }

    // 打印B+树结构
    void print() {
        if (!root) {
            cout &lt;&lt; "Empty B+ Tree" &lt;&lt; endl;
            return;
        }
        printLevel(root, 0);
    }

private:
    LeafNode* findLeaf(const KeyType& key) {
        if (!root) return nullptr;

        BPlusNode* current = root;

        // 向下搜索直到叶子节点
        while (!current-&gt;isLeaf) {
            InternalNode* internal = static_cast&lt;InternalNode*&gt;(current);

            int i = 0;
            while (i &lt; current-&gt;keys.size() && key &gt;= current-&gt;keys[i]) {
                i++;
            }
            current = internal-&gt;children[i];
        }

        return static_cast&lt;LeafNode*&gt;(current);
    }

    void insertIntoLeaf(LeafNode* leaf, const KeyType& key, const ValueType& value) {
        int i = 0;
        while (i &lt; leaf-&gt;keys.size() && leaf-&gt;keys[i] &lt; key) {
            i++;
        }

        leaf-&gt;keys.insert(leaf-&gt;keys.begin() + i, key);
        leaf-&gt;values.insert(leaf-&gt;values.begin() + i, value);
    }

    void splitLeaf(LeafNode* leaf) {
        LeafNode* newLeaf = new LeafNode();

        int mid = (maxKeys + 1) / 2;

        // 移动后半部分数据到新叶子节点
        newLeaf-&gt;keys.assign(leaf-&gt;keys.begin() + mid, leaf-&gt;keys.end());
        newLeaf-&gt;values.assign(leaf-&gt;values.begin() + mid, leaf-&gt;values.end());

        // 调整原叶子节点大小
        leaf-&gt;keys.resize(mid);
        leaf-&gt;values.resize(mid);

        // 更新叶子链表指针
        newLeaf-&gt;next = leaf-&gt;next;
        newLeaf-&gt;prev = leaf;
        if (leaf-&gt;next) {
            leaf-&gt;next-&gt;prev = newLeaf;
        }
        leaf-&gt;next = newLeaf;

        // 将新叶子节点的第一个关键字提升到父节点
        KeyType promoteKey = newLeaf-&gt;keys[0];

        if (leaf == root) {
            // 创建新的根节点
            InternalNode* newRoot = new InternalNode();
            newRoot-&gt;keys.push_back(promoteKey);
            newRoot-&gt;children.push_back(leaf);
            newRoot-&gt;children.push_back(newLeaf);

            leaf-&gt;parent = newRoot;
            newLeaf-&gt;parent = newRoot;
            root = newRoot;
        } else {
            // 插入到现有父节点
            InternalNode* parent = static_cast&lt;InternalNode*&gt;(leaf-&gt;parent);
            insertIntoInternal(parent, promoteKey, newLeaf);
            newLeaf-&gt;parent = parent;
        }
    }

    void insertIntoInternal(InternalNode* internal, const KeyType& key, BPlusNode* rightChild) {
        int i = 0;
        while (i &lt; internal-&gt;keys.size() && internal-&gt;keys[i] &lt; key) {
            i++;
        }

        internal-&gt;keys.insert(internal-&gt;keys.begin() + i, key);
        internal-&gt;children.insert(internal-&gt;children.begin() + i + 1, rightChild);

        // 如果内部节点溢出，进行分裂
        if (internal-&gt;keys.size() &gt; maxKeys) {
            splitInternal(internal);
        }
    }

    void splitInternal(InternalNode* internal) {
        InternalNode* newInternal = new InternalNode();

        int mid = maxKeys / 2;
        KeyType promoteKey = internal-&gt;keys[mid];

        // 移动后半部分关键字和子节点
        newInternal-&gt;keys.assign(internal-&gt;keys.begin() + mid + 1, internal-&gt;keys.end());
        newInternal-&gt;children.assign(internal-&gt;children.begin() + mid + 1, internal-&gt;children.end());

        // 调整原内部节点大小
        internal-&gt;keys.resize(mid);
        internal-&gt;children.resize(mid + 1);

        // 更新子节点的父指针
        for (auto child : newInternal-&gt;children) {
            child-&gt;parent = newInternal;
        }

        if (internal == root) {
            // 创建新根节点
            InternalNode* newRoot = new InternalNode();
            newRoot-&gt;keys.push_back(promoteKey);
            newRoot-&gt;children.push_back(internal);
            newRoot-&gt;children.push_back(newInternal);

            internal-&gt;parent = newRoot;
            newInternal-&gt;parent = newRoot;
            root = newRoot;
        } else {
            // 插入到现有父节点
            InternalNode* parent = static_cast&lt;InternalNode*&gt;(internal-&gt;parent);
            insertIntoInternal(parent, promoteKey, newInternal);
            newInternal-&gt;parent = parent;
        }
    }

    void handleLeafUnderflow(LeafNode* leaf) {
        // 简化的下溢处理：这里只实现基本逻辑
        // 完整实现需要考虑从兄弟节点借用或合并节点
        if (leaf-&gt;keys.empty()) {
            // 删除空叶子节点
            if (leaf-&gt;prev) leaf-&gt;prev-&gt;next = leaf-&gt;next;
            if (leaf-&gt;next) leaf-&gt;next-&gt;prev = leaf-&gt;prev;
            if (leaf == leftmostLeaf) leftmostLeaf = leaf-&gt;next;
        }
    }

    void printLevel(BPlusNode* node, int level) {
        if (!node) return;

        for (int i = 0; i &lt; level; i++) cout &lt;&lt; "  ";

        if (node-&gt;isLeaf) {
            cout &lt;&lt; "Leaf: ";
            LeafNode* leaf = static_cast&lt;LeafNode*&gt;(node);
            for (int i = 0; i &lt; leaf-&gt;keys.size(); i++) {
                cout &lt;&lt; "[" &lt;&lt; leaf-&gt;keys[i] &lt;&lt; ":" &lt;&lt; leaf-&gt;values[i] &lt;&lt; "]";
            }
            cout &lt;&lt; endl;
        } else {
            cout &lt;&lt; "Internal: ";
            for (auto key : node-&gt;keys) {
                cout &lt;&lt; key &lt;&lt; " ";
            }
            cout &lt;&lt; endl;

            InternalNode* internal = static_cast&lt;InternalNode*&gt;(node);
            for (auto child : internal-&gt;children) {
                printLevel(child, level + 1);
            }
        }
    }
};</code></pre>
                </div>

                <div id="java-code" class="code-content">
                    <div class="code-header">
                        <span>Java 实现</span>
                        <button onclick="copyCode('java', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="java-source">import java.util.*;

public class BPlusTree&lt;K extends Comparable&lt;K&gt;, V&gt; {

    abstract class BPlusNode {
        List&lt;K&gt; keys;
        boolean isLeaf;
        BPlusNode parent;

        BPlusNode(boolean isLeaf) {
            this.keys = new ArrayList&lt;&gt;();
            this.isLeaf = isLeaf;
            this.parent = null;
        }
    }

    class InternalNode extends BPlusNode {
        List&lt;BPlusNode&gt; children;

        InternalNode() {
            super(false);
            this.children = new ArrayList&lt;&gt;();
        }
    }

    class LeafNode extends BPlusNode {
        List&lt;V&gt; values;
        LeafNode next;
        LeafNode prev;

        LeafNode() {
            super(true);
            this.values = new ArrayList&lt;&gt;();
            this.next = null;
            this.prev = null;
        }
    }

    private BPlusNode root;
    private LeafNode leftmostLeaf;
    private int order;
    private int minKeys;
    private int maxKeys;

    public BPlusTree(int order) {
        this.order = order;
        this.minKeys = (order - 1) / 2;
        this.maxKeys = order - 1;
        this.root = null;
        this.leftmostLeaf = null;
    }

    // 搜索操作
    public V search(K key) {
        LeafNode leaf = findLeaf(key);
        if (leaf == null) return null;

        for (int i = 0; i &lt; leaf.keys.size(); i++) {
            if (leaf.keys.get(i).equals(key)) {
                return leaf.values.get(i);
            }
        }
        return null;
    }

    // 范围查询
    public List&lt;Map.Entry&lt;K, V&gt;&gt; rangeQuery(K startKey, K endKey) {
        List&lt;Map.Entry&lt;K, V&gt;&gt; result = new ArrayList&lt;&gt;();

        LeafNode leaf = findLeaf(startKey);
        if (leaf == null) return result;

        int startIdx = 0;
        while (startIdx &lt; leaf.keys.size() &&
               leaf.keys.get(startIdx).compareTo(startKey) &lt; 0) {
            startIdx++;
        }

        while (leaf != null && startIdx &lt; leaf.keys.size()) {
            if (leaf.keys.get(startIdx).compareTo(endKey) &gt; 0) break;

            result.add(new AbstractMap.SimpleEntry&lt;&gt;(
                leaf.keys.get(startIdx), leaf.values.get(startIdx)));
            startIdx++;

            if (startIdx == leaf.keys.size()) {
                leaf = leaf.next;
                startIdx = 0;
            }
        }

        return result;
    }

    // 插入操作
    public boolean insert(K key, V value) {
        if (root == null) {
            LeafNode newLeaf = new LeafNode();
            newLeaf.keys.add(key);
            newLeaf.values.add(value);
            root = newLeaf;
            leftmostLeaf = newLeaf;
            return true;
        }

        LeafNode leaf = findLeaf(key);

        // 检查键是否已存在
        for (int i = 0; i &lt; leaf.keys.size(); i++) {
            if (leaf.keys.get(i).equals(key)) {
                leaf.values.set(i, value);
                return true;
            }
        }

        insertIntoLeaf(leaf, key, value);

        if (leaf.keys.size() &gt; maxKeys) {
            splitLeaf(leaf);
        }

        return true;
    }

    // 删除操作
    public boolean remove(K key) {
        if (root == null) return false;

        LeafNode leaf = findLeaf(key);
        if (leaf == null) return false;

        for (int i = 0; i &lt; leaf.keys.size(); i++) {
            if (leaf.keys.get(i).equals(key)) {
                leaf.keys.remove(i);
                leaf.values.remove(i);

                if (leaf.keys.size() &lt; minKeys && leaf != root) {
                    handleLeafUnderflow(leaf);
                }

                return true;
            }
        }

        return false;
    }

    // 获取所有数据（顺序遍历叶子节点）
    public List&lt;Map.Entry&lt;K, V&gt;&gt; getAllData() {
        List&lt;Map.Entry&lt;K, V&gt;&gt; result = new ArrayList&lt;&gt;();

        LeafNode current = leftmostLeaf;
        while (current != null) {
            for (int i = 0; i &lt; current.keys.size(); i++) {
                result.add(new AbstractMap.SimpleEntry&lt;&gt;(
                    current.keys.get(i), current.values.get(i)));
            }
            current = current.next;
        }

        return result;
    }

    // 打印树结构
    public void printTree() {
        if (root == null) {
            System.out.println("Empty B+ Tree");
            return;
        }
        printLevel(root, 0);
    }

    // 私有辅助方法
    private LeafNode findLeaf(K key) {
        if (root == null) return null;

        BPlusNode current = root;

        while (!current.isLeaf) {
            InternalNode internal = (InternalNode) current;

            int i = 0;
            while (i &lt; current.keys.size() &&
                   key.compareTo(current.keys.get(i)) &gt;= 0) {
                i++;
            }
            current = internal.children.get(i);
        }

        return (LeafNode) current;
    }

    private void insertIntoLeaf(LeafNode leaf, K key, V value) {
        int i = 0;
        while (i &lt; leaf.keys.size() &&
               leaf.keys.get(i).compareTo(key) &lt; 0) {
            i++;
        }

        leaf.keys.add(i, key);
        leaf.values.add(i, value);
    }

    private void splitLeaf(LeafNode leaf) {
        LeafNode newLeaf = new LeafNode();

        int mid = (maxKeys + 1) / 2;

        // 复制后半部分到新叶子节点
        for (int i = mid; i &lt; leaf.keys.size(); i++) {
            newLeaf.keys.add(leaf.keys.get(i));
            newLeaf.values.add(leaf.values.get(i));
        }

        // 调整原叶子节点大小
        leaf.keys.subList(mid, leaf.keys.size()).clear();
        leaf.values.subList(mid, leaf.values.size()).clear();

        // 更新叶子链表
        newLeaf.next = leaf.next;
        newLeaf.prev = leaf;
        if (leaf.next != null) {
            leaf.next.prev = newLeaf;
        }
        leaf.next = newLeaf;

        K promoteKey = newLeaf.keys.get(0);

        if (leaf == root) {
            InternalNode newRoot = new InternalNode();
            newRoot.keys.add(promoteKey);
            newRoot.children.add(leaf);
            newRoot.children.add(newLeaf);

            leaf.parent = newRoot;
            newLeaf.parent = newRoot;
            root = newRoot;
        } else {
            InternalNode parent = (InternalNode) leaf.parent;
            insertIntoInternal(parent, promoteKey, newLeaf);
            newLeaf.parent = parent;
        }
    }

    private void insertIntoInternal(InternalNode internal, K key, BPlusNode rightChild) {
        int i = 0;
        while (i &lt; internal.keys.size() &&
               internal.keys.get(i).compareTo(key) &lt; 0) {
            i++;
        }

        internal.keys.add(i, key);
        internal.children.add(i + 1, rightChild);

        if (internal.keys.size() &gt; maxKeys) {
            splitInternal(internal);
        }
    }

    private void splitInternal(InternalNode internal) {
        InternalNode newInternal = new InternalNode();

        int mid = maxKeys / 2;
        K promoteKey = internal.keys.get(mid);

        // 移动后半部分
        for (int i = mid + 1; i &lt; internal.keys.size(); i++) {
            newInternal.keys.add(internal.keys.get(i));
        }

        for (int i = mid + 1; i &lt; internal.children.size(); i++) {
            newInternal.children.add(internal.children.get(i));
            internal.children.get(i).parent = newInternal;
        }

        // 调整原节点大小
        internal.keys.subList(mid, internal.keys.size()).clear();
        internal.children.subList(mid + 1, internal.children.size()).clear();

        if (internal == root) {
            InternalNode newRoot = new InternalNode();
            newRoot.keys.add(promoteKey);
            newRoot.children.add(internal);
            newRoot.children.add(newInternal);

            internal.parent = newRoot;
            newInternal.parent = newRoot;
            root = newRoot;
        } else {
            InternalNode parent = (InternalNode) internal.parent;
            insertIntoInternal(parent, promoteKey, newInternal);
            newInternal.parent = parent;
        }
    }

    private void handleLeafUnderflow(LeafNode leaf) {
        // 简化的下溢处理
        if (leaf.keys.isEmpty()) {
            if (leaf.prev != null) leaf.prev.next = leaf.next;
            if (leaf.next != null) leaf.next.prev = leaf.prev;
            if (leaf == leftmostLeaf) leftmostLeaf = leaf.next;
        }
    }

    private void printLevel(BPlusNode node, int level) {
        if (node == null) return;

        for (int i = 0; i &lt; level; i++) System.out.print("  ");

        if (node.isLeaf) {
            System.out.print("Leaf: ");
            LeafNode leaf = (LeafNode) node;
            for (int i = 0; i &lt; leaf.keys.size(); i++) {
                System.out.print("[" + leaf.keys.get(i) + ":" +
                                leaf.values.get(i) + "]");
            }
            System.out.println();
        } else {
            System.out.print("Internal: ");
            for (K key : node.keys) {
                System.out.print(key + " ");
            }
            System.out.println();

            InternalNode internal = (InternalNode) node;
            for (BPlusNode child : internal.children) {
                printLevel(child, level + 1);
            }
        }
    }
}</code></pre>
                </div>

                <div id="python-code" class="code-content">
                    <div class="code-header">
                        <span>Python 实现</span>
                        <button onclick="copyCode('python', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="python-source">class BPlusNode:
    """B+树节点基类"""
    def __init__(self, is_leaf=False):
        self.keys = []
        self.is_leaf = is_leaf
        self.parent = None

class InternalNode(BPlusNode):
    """内部节点类"""
    def __init__(self):
        super().__init__(is_leaf=False)
        self.children = []

class LeafNode(BPlusNode):
    """叶子节点类"""
    def __init__(self):
        super().__init__(is_leaf=True)
        self.values = []
        self.next = None  # 指向下一个叶子节点
        self.prev = None  # 指向前一个叶子节点

class BPlusTree:
    """B+树实现类"""
    def __init__(self, order):
        self.order = order
        self.min_keys = (order - 1) // 2
        self.max_keys = order - 1
        self.root = None
        self.leftmost_leaf = None  # 最左边的叶子节点

    def search(self, key):
        """搜索指定关键字"""
        leaf = self._find_leaf(key)
        if not leaf:
            return None

        for i, k in enumerate(leaf.keys):
            if k == key:
                return leaf.values[i]
        return None

    def range_query(self, start_key, end_key):
        """范围查询"""
        result = []

        # 找到起始叶子节点
        leaf = self._find_leaf(start_key)
        if not leaf:
            return result

        # 在起始叶子节点中找到第一个大于等于start_key的位置
        start_idx = 0
        while start_idx < len(leaf.keys) and leaf.keys[start_idx] < start_key:
            start_idx += 1

        # 沿着叶子链表收集范围内的数据
        while leaf and start_idx < len(leaf.keys):
            if leaf.keys[start_idx] > end_key:
                break

            result.append((leaf.keys[start_idx], leaf.values[start_idx]))
            start_idx += 1

            # 如果当前叶子节点遍历完，移到下一个叶子节点
            if start_idx == len(leaf.keys):
                leaf = leaf.next
                start_idx = 0

        return result

    def insert(self, key, value):
        """插入键值对"""
        if not self.root:
            # 创建第一个叶子节点作为根
            new_leaf = LeafNode()
            new_leaf.keys.append(key)
            new_leaf.values.append(value)
            self.root = new_leaf
            self.leftmost_leaf = new_leaf
            return True

        leaf = self._find_leaf(key)

        # 检查键是否已存在
        for i, k in enumerate(leaf.keys):
            if k == key:
                leaf.values[i] = value  # 更新值
                return True

        # 在叶子节点中插入
        self._insert_into_leaf(leaf, key, value)

        # 如果叶子节点溢出，进行分裂
        if len(leaf.keys) > self.max_keys:
            self._split_leaf(leaf)

        return True

    def remove(self, key):
        """删除指定关键字"""
        if not self.root:
            return False

        leaf = self._find_leaf(key)
        if not leaf:
            return False

        # 在叶子节点中查找并删除
        for i, k in enumerate(leaf.keys):
            if k == key:
                del leaf.keys[i]
                del leaf.values[i]

                # 处理节点下溢（简化处理）
                if len(leaf.keys) < self.min_keys and leaf != self.root:
                    self._handle_leaf_underflow(leaf)

                return True

        return False

    def get_all_data(self):
        """获取所有数据（按顺序）"""
        result = []
        current = self.leftmost_leaf

        while current:
            for i in range(len(current.keys)):
                result.append((current.keys[i], current.values[i]))
            current = current.next

        return result

    def print_tree(self):
        """打印树结构"""
        if not self.root:
            print("Empty B+ Tree")
            return
        self._print_level(self.root, 0)

    def print_leaf_chain(self):
        """打印叶子节点链表"""
        print("Leaf chain: ", end="")
        current = self.leftmost_leaf
        while current:
            print(f"[{','.join(map(str, current.keys))}]", end="")
            if current.next:
                print(" -> ", end="")
            current = current.next
        print()

    def _find_leaf(self, key):
        """找到应该包含指定关键字的叶子节点"""
        if not self.root:
            return None

        current = self.root

        # 向下搜索直到叶子节点
        while not current.is_leaf:
            i = 0
            while i < len(current.keys) and key >= current.keys[i]:
                i += 1
            current = current.children[i]

        return current

    def _insert_into_leaf(self, leaf, key, value):
        """在叶子节点中插入键值对"""
        i = 0
        while i < len(leaf.keys) and leaf.keys[i] < key:
            i += 1

        leaf.keys.insert(i, key)
        leaf.values.insert(i, value)

    def _split_leaf(self, leaf):
        """分裂叶子节点"""
        new_leaf = LeafNode()

        mid = (self.max_keys + 1) // 2

        # 将后半部分数据移到新叶子节点
        new_leaf.keys = leaf.keys[mid:]
        new_leaf.values = leaf.values[mid:]

        # 调整原叶子节点
        leaf.keys = leaf.keys[:mid]
        leaf.values = leaf.values[:mid]

        # 更新叶子链表指针
        new_leaf.next = leaf.next
        new_leaf.prev = leaf
        if leaf.next:
            leaf.next.prev = new_leaf
        leaf.next = new_leaf

        # 提升新叶子节点的第一个关键字到父节点
        promote_key = new_leaf.keys[0]

        if leaf == self.root:
            # 创建新的根节点
            new_root = InternalNode()
            new_root.keys.append(promote_key)
            new_root.children.append(leaf)
            new_root.children.append(new_leaf)

            leaf.parent = new_root
            new_leaf.parent = new_root
            self.root = new_root
        else:
            # 插入到现有父节点
            parent = leaf.parent
            self._insert_into_internal(parent, promote_key, new_leaf)
            new_leaf.parent = parent

    def _insert_into_internal(self, internal, key, right_child):
        """在内部节点中插入关键字和右子节点"""
        i = 0
        while i < len(internal.keys) and internal.keys[i] < key:
            i += 1

        internal.keys.insert(i, key)
        internal.children.insert(i + 1, right_child)

        # 如果内部节点溢出，进行分裂
        if len(internal.keys) > self.max_keys:
            self._split_internal(internal)

    def _split_internal(self, internal):
        """分裂内部节点"""
        new_internal = InternalNode()

        mid = self.max_keys // 2
        promote_key = internal.keys[mid]

        # 移动后半部分关键字和子节点
        new_internal.keys = internal.keys[mid + 1:]
        new_internal.children = internal.children[mid + 1:]

        # 调整原内部节点
        internal.keys = internal.keys[:mid]
        internal.children = internal.children[:mid + 1]

        # 更新子节点的父指针
        for child in new_internal.children:
            child.parent = new_internal

        if internal == self.root:
            # 创建新根节点
            new_root = InternalNode()
            new_root.keys.append(promote_key)
            new_root.children.append(internal)
            new_root.children.append(new_internal)

            internal.parent = new_root
            new_internal.parent = new_root
            self.root = new_root
        else:
            # 插入到现有父节点
            parent = internal.parent
            self._insert_into_internal(parent, promote_key, new_internal)
            new_internal.parent = parent

    def _handle_leaf_underflow(self, leaf):
        """处理叶子节点下溢（简化处理）"""
        if not leaf.keys:
            # 删除空叶子节点
            if leaf.prev:
                leaf.prev.next = leaf.next
            if leaf.next:
                leaf.next.prev = leaf.prev
            if leaf == self.leftmost_leaf:
                self.leftmost_leaf = leaf.next

    def _print_level(self, node, level):
        """递归打印树的层次结构"""
        if not node:
            return

        indent = "  " * level

        if node.is_leaf:
            print(f"{indent}Leaf: ", end="")
            for i in range(len(node.keys)):
                print(f"[{node.keys[i]}:{node.values[i]}]", end="")
            print()
        else:
            print(f"{indent}Internal: {' '.join(map(str, node.keys))}")
            for child in node.children:
                self._print_level(child, level + 1)

# 使用示例
def example_usage():
    # 创建一个4阶B+树
    bplus_tree = BPlusTree(order=4)

    # 插入一些数据
    data = [(10, 'A'), (20, 'B'), (30, 'C'), (40, 'D'),
            (50, 'E'), (25, 'F'), (35, 'G'), (15, 'H')]

    print("插入数据:")
    for key, value in data:
        bplus_tree.insert(key, value)
        print(f"插入 ({key}, {value})")

    print("\nB+树结构:")
    bplus_tree.print_tree()

    print("\n叶子节点链表:")
    bplus_tree.print_leaf_chain()

    print("\n所有数据（有序）:")
    all_data = bplus_tree.get_all_data()
    for key, value in all_data:
        print(f"({key}, {value})", end=" ")
    print()

    print("\n范围查询 [20, 40]:")
    range_result = bplus_tree.range_query(20, 40)
    for key, value in range_result:
        print(f"({key}, {value})", end=" ")
    print()

    print("\n搜索关键字 25:")
    result = bplus_tree.search(25)
    print(f"结果: {result}")

if __name__ == "__main__":
    example_usage()</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 🌟 实际应用 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🌟</span>
                实际应用
            </h2>

            <div class="applications">
                <div class="unified-grid unified-grid-2">
                    <div class="app-item">
                        <h4>🗄️ MySQL InnoDB</h4>
                        <p><strong>应用场景：</strong>主键索引（聚簇索引）的底层实现</p>
                        <p><strong>优势：</strong>叶子节点存储完整行数据，支持高效范围扫描</p>
                        <p><strong>实现：</strong>16KB页面大小，叶子节点链表支持顺序IO</p>
                    </div>

                    <div class="app-item">
                        <h4>📊 PostgreSQL BTREE</h4>
                        <p><strong>应用场景：</strong>默认索引类型，支持各种数据类型</p>
                        <p><strong>优势：</strong>优秀的并发控制，支持部分匹配查询</p>
                        <p><strong>实现：</strong>8KB页面，WAL日志保证持久性</p>
                    </div>

                    <div class="app-item">
                        <h4>🔍 Elasticsearch</h4>
                        <p><strong>应用场景：</strong>倒排索引的term dictionary实现</p>
                        <p><strong>优势：</strong>支持前缀匹配和范围查询</p>
                        <p><strong>实现：</strong>结合FST优化内存使用</p>
                    </div>

                    <div class="app-item">
                        <h4>📈 时序数据库</h4>
                        <p><strong>应用场景：</strong>InfluxDB、TimescaleDB的时间索引</p>
                        <p><strong>优势：</strong>时间范围查询性能优异</p>
                        <p><strong>实现：</strong>时间戳作为关键字，叶子链表支持时间序列扫描</p>
                    </div>
                </div>

                <div class="performance-analysis">
                    <h4>📊 性能分析对比</h4>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>操作类型</th>
                                <th>B树</th>
                                <th>B+树</th>
                                <th>B+树优势</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>点查询</td>
                                <td>O(logₘn)</td>
                                <td>O(logₘn)</td>
                                <td>路径稳定，缓存友好</td>
                            </tr>
                            <tr>
                                <td>范围查询</td>
                                <td>O(logₘn + k)</td>
                                <td>O(logₘn + k/f)</td>
                                <td>叶子链表，无需重复查找</td>
                            </tr>
                            <tr>
                                <td>顺序扫描</td>
                                <td>O(n·logₘn)</td>
                                <td>O(n/f)</td>
                                <td>线性时间，IO优化</td>
                            </tr>
                            <tr>
                                <td>插入/删除</td>
                                <td>O(logₘn)</td>
                                <td>O(logₘn)</td>
                                <td>分裂策略更简单</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="performance-note">
                        <strong>注释：</strong>k为查询结果数量，f为叶子节点平均填充因子，m为树的阶数
                    </p>
                </div>

                <div class="concept-item">
                    <h3>🎯 B+树在数据库中的关键优势</h3>
                    <div class="unified-grid unified-grid-2">
                        <div class="advantage-box">
                            <h4>🚀 查询性能</h4>
                            <ul>
                                <li><strong>稳定的查找深度：</strong>所有查询都到叶子节点</li>
                                <li><strong>更高的分支因子：</strong>内部节点不存数据</li>
                                <li><strong>缓存友好：</strong>内部节点可完全驻留内存</li>
                                <li><strong>预读优化：</strong>叶子节点顺序存储</li>
                            </ul>
                        </div>
                        <div class="advantage-box">
                            <h4>📈 存储效率</h4>
                            <ul>
                                <li><strong>空间利用率高：</strong>数据集中存储在叶子层</li>
                                <li><strong>压缩友好：</strong>相似数据聚集存储</li>
                                <li><strong>页面填充度：</strong>叶子节点通常有更高填充率</li>
                                <li><strong>维护成本低：</strong>分裂合并操作相对简单</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="real-world-example">
                    <h4>💼 MySQL InnoDB 实战案例</h4>
                    <div class="example-content">
                        <div class="sql-example">
                            <h5>典型的范围查询场景：</h5>
                            <pre class="sql-code">
-- 查询某个时间范围内的订单
SELECT * FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
ORDER BY order_date;

-- B+树的执行过程：
-- 1. 通过B+树索引定位到 '2024-01-01' 对应的叶子节点
-- 2. 沿着叶子链表顺序读取到 '2024-01-31'
-- 3. 数据天然有序，无需额外排序
                            </pre>
                        </div>
                        <div class="performance-metrics">
                            <h5>性能指标对比：</h5>
                            <ul>
                                <li><strong>IO次数：</strong>B+树约3-4次，B树约20-30次</li>
                                <li><strong>缓存命中率：</strong>B+树90%+，B树60-70%</li>
                                <li><strong>并发性能：</strong>B+树叶子锁粒度更细</li>
                                <li><strong>范围查询速度：</strong>B+树快10-100倍</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ✅ 学习检验 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">✅</span>
                学习检验
            </h2>

            <div class="quiz-section">
                <div class="quiz-item">
                    <h4>🤔 问题1：结构理解</h4>
                    <p>B+树与B树的最主要区别是什么？这种设计带来了哪些优势？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(1)">点击查看答案</button>
                    <div id="answer1" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>主要区别：</strong><br>
                        • B+树的所有数据都存储在叶子节点中，内部节点只存储索引<br>
                        • 叶子节点通过指针连接形成有序链表<br>
                        • 所有查找操作都必须到达叶子节点<br>
                        <strong>带来的优势：</strong><br>
                        • 内部节点不存数据，可容纳更多索引，提高分支因子<br>
                        • 叶子链表支持高效的范围查询和顺序访问<br>
                        • 查找路径稳定，缓存友好
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题2：范围查询机制</h4>
                    <p>B+树是如何实现高效范围查询的？请描述查询[20, 60]范围数据的过程。</p>
                    <button class="quiz-btn" onclick="toggleAnswer(2)">点击查看答案</button>
                    <div id="answer2" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>范围查询过程：</strong><br>
                        1. <strong>定位起始：</strong>通过B+树索引找到包含关键字20的叶子节点<br>
                        2. <strong>找到起点：</strong>在该叶子节点中定位到第一个≥20的数据记录<br>
                        3. <strong>链表遍历：</strong>沿着叶子节点的next指针顺序访问<br>
                        4. <strong>收集数据：</strong>收集所有≤60的数据记录<br>
                        5. <strong>结束条件：</strong>遇到>60的数据时停止<br>
                        <strong>时间复杂度：</strong>O(logₘn + k/f)，其中k是结果数量，f是填充因子
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题3：数据库应用</h4>
                    <p>为什么几乎所有关系数据库都选择B+树作为索引结构？相比哈希索引有什么优势？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(3)">点击查看答案</button>
                    <div id="answer3" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>选择B+树的原因：</strong><br>
                        • <strong>磁盘友好：</strong>树结构匹配磁盘块大小，减少I/O次数<br>
                        • <strong>范围查询：</strong>支持BETWEEN、ORDER BY等SQL操作<br>
                        • <strong>顺序访问：</strong>叶子链表天然支持全表扫描<br>
                        • <strong>并发控制：</strong>更细粒度的锁机制<br>
                        <strong>相比哈希索引优势：</strong><br>
                        • 支持范围查询（哈希不支持）<br>
                        • 支持排序操作（哈希无序）<br>
                        • 支持前缀匹配（LIKE 'abc%'）<br>
                        • 更稳定的性能表现
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题4：叶子节点分裂</h4>
                    <p>B+树叶子节点分裂与B树节点分裂有什么不同？为什么要这样设计？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(4)">点击查看答案</button>
                    <div id="answer4" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>B+树叶子分裂特点：</strong><br>
                        • 中间关键字<strong>复制</strong>到父节点（而非移动）<br>
                        • 分裂后需要更新叶子节点间的链表指针<br>
                        • 原叶子节点保留中间关键字<br>
                        <strong>B树节点分裂：</strong><br>
                        • 中间关键字<strong>移动</strong>到父节点<br>
                        • 无需维护链表关系<br>
                        <strong>设计原因：</strong><br>
                        • 保持叶子链表的完整性和有序性<br>
                        • 确保范围查询不会遗漏数据<br>
                        • 内部节点作为"路标"，叶子节点存储完整数据
                    </div>
                </div>
            </div>

            <div class="next-steps">
                <h4>🚀 下一步学习建议</h4>
                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <span class="info-icon">📖</span>
                        <strong>深入学习：</strong>LSM-Tree、跳表等现代数据库索引结构
                    </div>
                    <div class="info-box info-box-success">
                        <span class="info-icon">💪</span>
                        <strong>实践项目：</strong>实现一个支持事务的B+树存储引擎
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<style>
/* 页面基础样式 - 继承前面页面的样式框架 */
.page-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.breadcrumb {
    margin-bottom: 20px;
    font-size: 14px;
    color: #666;
}

.page-header {
    text-align: center;
    margin-bottom: 30px;
}

.page-header h1 {
    font-size: 2.5rem;
    color: #333;
    margin-bottom: 10px;
}

.page-icon {
    font-size: 3rem;
    margin-right: 15px;
}

.content-card {
    background: white;
    border-radius: 12px;
    padding: 30px;
    margin-bottom: 20px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
}

.section-title {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.section-icon {
    font-size: 1.8rem;
}

/* 网格布局 */
.unified-grid {
    display: grid;
    gap: 20px;
}

.unified-grid-2 {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

/* 信息框样式 */
.info-box {
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #4299e1;
}

.info-box-info {
    background: #ebf8ff;
    border-left-color: #4299e1;
}

.info-box-success {
    background: #f0fff4;
    border-left-color: #48bb78;
}

.info-box-warning {
    background: #fffaf0;
    border-left-color: #ed8936;
}

.info-icon {
    margin-right: 8px;
}

/* 概念详解样式 */
.concept-item {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
}

.concept-item h3 {
    color: #2d3748;
    margin-bottom: 10px;
}

.example-box {
    margin-top: 15px;
    padding: 15px;
    background: #e6fffa;
    border-left: 4px solid #38b2ac;
    border-radius: 4px;
}

/* 问题解决方案样式 */
.problem-solution {
    margin-top: 25px;
}

.problem-box {
    padding: 20px;
    background: #fef2f2;
    border-left: 4px solid #f56565;
    border-radius: 8px;
}

.solution-box {
    padding: 20px;
    background: #f0fff4;
    border-left: 4px solid #48bb78;
    border-radius: 8px;
}

/* 统计框样式 */
.stats-box {
    margin-top: 15px;
    padding: 15px;
    background: #f7fafc;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.stats-box h5 {
    color: #2d3748;
    margin-bottom: 10px;
}

/* B+树对比展示样式 */
.comparison-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.compare-box {
    padding: 20px;
    border-radius: 8px;
    border: 2px solid #e2e8f0;
}

.compare-box h4 {
    text-align: center;
    margin-bottom: 15px;
    color: #2d3748;
}

.tree-structure-demo {
    margin: 15px 0;
    text-align: center;
}

.tree-level {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 10px 0;
    gap: 10px;
}

.tree-node {
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    min-width: 80px;
    text-align: center;
}

.btree-node {
    background: #dbeafe;
    border: 2px solid #3b82f6;
    color: #1d4ed8;
}

.bplus-internal-node {
    background: #dbeafe;
    border: 2px solid #0ea5e9;
    color: #0369a1;
}

.bplus-leaf-node {
    background: #dcfce7;
    border: 2px solid #16a34a;
    color: #15803d;
}

.leaf-pointer {
    font-size: 16px;
    font-weight: bold;
    color: #dc2626;
}

.compare-features {
    margin-top: 15px;
    padding-left: 20px;
}

.compare-features li {
    margin-bottom: 8px;
    color: #4a5568;
    font-size: 14px;
}

/* 过程步骤样式 */
.process-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.step-box {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
}

.step-number {
    background: #4299e1;
    color: white;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    flex-shrink: 0;
}

.step-content h5 {
    color: #2d3748;
    margin-bottom: 5px;
}

/* 遍历算法样式 */
.traversal-algorithm {
    margin-top: 15px;
}

.algorithm-steps {
    background: #f7fafc;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.algo-step {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 10px;
    padding: 8px 0;
}

.step-label {
    background: #ed8936;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    font-weight: bold;
    flex-shrink: 0;
}

/* B+树可视化演示样式 */
.canvas-demo {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group label {
    font-size: 14px;
    color: #4a5568;
    font-weight: 500;
}

.control-group select,
.control-group input {
    padding: 6px 10px;
    border: 2px solid #e2e8f0;
    border-radius: 6px;
    font-size: 14px;
    min-width: 80px;
}

.control-group select:focus,
.control-group input:focus {
    outline: none;
    border-color: #4299e1;
}

/* 范围查询控制样式 */
.range-query-controls {
    display: flex;
    justify-content: center;
    margin-bottom: 15px;
}

.range-query-controls .control-group {
    background: #f0f9ff;
    padding: 10px 15px;
    border-radius: 8px;
    border: 1px solid #bae6fd;
}

.range-query-controls span {
    color: #0369a1;
    font-weight: 500;
    margin: 0 5px;
}

.preset-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 25px;
    flex-wrap: wrap;
}

.preset-controls button {
    padding: 10px 20px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    color: white;
}

.insert-btn { background: linear-gradient(45deg, #16a34a, #22c55e); }
.delete-btn { background: linear-gradient(45deg, #dc2626, #ef4444); }
.range-btn { background: linear-gradient(45deg, #0ea5e9, #38bdf8); }
.demo-btn { background: linear-gradient(45deg, #7c3aed, #a855f7); }
.traverse-btn { background: linear-gradient(45deg, #f59e0b, #fbbf24); }
.search-btn { background: linear-gradient(45deg, #0ea5e9, #38bdf8); }
.reset-btn { background: linear-gradient(45deg, #4a5568, #6b7280); }

.preset-controls button:hover,
.control-group button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
}

.canvas-container {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
}

#bplusCanvas {
    border: 2px solid #e2e8f0;
    border-radius: 10px;
    background: white;
}

/* B+树图例样式 */
.legend {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    margin: 20px 0;
    border: 1px solid #e2e8f0;
}

.legend h4 {
    margin: 0 0 15px 0;
    color: #2d3748;
    font-size: 16px;
}

.legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 15px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* B+树节点样式 */
.legend-node {
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    min-width: 50px;
    text-align: center;
    border: 2px solid;
}

.internal-node {
    background: #dbeafe;
    border-color: #0ea5e9;
    color: #0369a1;
}

.leaf-node {
    background: #dcfce7;
    border-color: #16a34a;
    color: #15803d;
}

.current-node {
    background: #ef4444;
    border-color: #dc2626;
    color: white;
}

.range-node {
    background: #fbbf24;
    border-color: #f59e0b;
    color: #92400e;
}

.leaf-pointer-demo {
    color: #dc2626;
    font-size: 16px;
    font-weight: bold;
}

.tree-connection-demo {
    width: 30px;
    height: 3px;
    background: #6b7280;
}

.legend-explanation {
    background: white;
    padding: 12px;
    border-radius: 6px;
    border-left: 4px solid #3b82f6;
}

.legend-explanation p {
    margin: 0 0 8px 0;
    font-weight: bold;
    color: #2d3748;
}

.legend-explanation ul {
    margin: 0;
    padding-left: 20px;
}

.legend-explanation li {
    margin-bottom: 4px;
    font-size: 14px;
    color: #4a5568;
}

.info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.info .info-box {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
}

.info h4 {
    margin-top: 0;
    color: #2d3748;
}

.sequence {
    font-size: 16px;
    font-weight: bold;
    color: #4299e1;
    min-height: 20px;
}

.status {
    font-size: 14px;
    color: #718096;
    margin-top: 8px;
}

/* 代码样式 */
.code-tabs {
    display: flex;
    border-bottom: 1px solid #e2e8f0;
    margin-bottom: 20px;
}

.tab-btn {
    padding: 12px 24px;
    border: none;
    background: none;
    cursor: pointer;
    font-size: 16px;
    border-bottom: 2px solid transparent;
    transition: all 0.3s ease;
}

.tab-btn.active {
    color: #4299e1;
    border-bottom-color: #4299e1;
}

.code-content {
    display: none;
}

.code-content.active {
    display: block;
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.copy-btn {
    background: #4299e1;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.copy-btn:hover {
    background: #3182ce;
}

pre {
    background: #2d3748;
    color: #e2e8f0;
    padding: 20px;
    border-radius: 8px;
    overflow-x: auto;
    line-height: 1.6;
    font-size: 14px;
}

/* 应用场景样式 */
.app-item {
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #4299e1;
}

.app-item h4 {
    color: #2d3748;
    margin-bottom: 15px;
}

/* 性能分析表格样式 */
.performance-analysis {
    margin-top: 30px;
}

.comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
}

.comparison-table th,
.comparison-table td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
}

.comparison-table th {
    background: #f7fafc;
    font-weight: bold;
    color: #2d3748;
}

.performance-note {
    margin-top: 10px;
    font-size: 14px;
    color: #666;
    font-style: italic;
}

/* 优势框样式 */
.advantage-box {
    padding: 20px;
    background: #f0f9ff;
    border-radius: 8px;
    border-left: 4px solid #0ea5e9;
}

.advantage-box h4 {
    color: #0c4a6e;
    margin-bottom: 15px;
}

.advantage-box ul {
    margin: 0;
    padding-left: 20px;
}

.advantage-box li {
    margin-bottom: 8px;
    color: #1e40af;
}

/* 实战案例样式 */
.real-world-example {
    margin-top: 30px;
    padding: 25px;
    background: #f8fafc;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
}

.example-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 25px;
    margin-top: 20px;
}

.sql-example {
    background: white;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #16a34a;
}

.sql-code {
    background: #1e293b;
    color: #e2e8f0;
    padding: 15px;
    border-radius: 6px;
    font-size: 13px;
    margin-top: 10px;
}

.performance-metrics {
    background: white;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
}

.performance-metrics ul {
    margin-top: 15px;
    padding-left: 20px;
}

.performance-metrics li {
    margin-bottom: 8px;
    color: #374151;
}

/* 术语列表样式 */
.terms-list .unified-grid-2 {
    margin-top: 15px;
}

.term-item {
    padding: 12px;
    background: white;
    border-radius: 6px;
    border-left: 3px solid #4299e1;
}

/* 测验样式 */
.quiz-item {
    margin-bottom: 25px;
    padding: 20px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
}

.quiz-btn {
    background: #4299e1;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    margin-top: 15px;
    transition: background 0.3s ease;
}

.quiz-btn:hover {
    background: #3182ce;
}

.quiz-answer {
    display: none;
    margin-top: 15px;
    padding: 15px;
    background: #f0fff4;
    border-left: 4px solid #48bb78;
    border-radius: 4px;
}

.quiz-answer.show {
    display: block;
}

.unified-btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 500;
    margin: 0 10px;
    transition: all 0.3s ease;
}

.unified-btn-primary {
    background: #4299e1;
    color: white;
}

.unified-btn-secondary {
    background: #718096;
    color: white;
}

.unified-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

@media (max-width: 768px) {
    .info {
        grid-template-columns: 1fr;
    }

    .controls {
        flex-direction: column;
    }

    .preset-controls {
        flex-direction: column;
        align-items: center;
    }

    .preset-controls button {
        width: 200px;
    }

    .unified-grid-2 {
        grid-template-columns: 1fr;
    }

    .comparison-grid {
        grid-template-columns: 1fr;
    }

    .process-steps {
        grid-template-columns: 1fr;
    }

    .comparison-table {
        font-size: 12px;
    }

    .example-content {
        grid-template-columns: 1fr;
    }
}
</style>

<script>
// B+树可视化演示相关代码
const bplusCanvas = document.getElementById('bplusCanvas');
const bplusCtx = bplusCanvas.getContext('2d');

// B+树节点类
class BPlusNode {
    constructor(isLeaf = false) {
        this.keys = [];
        this.isLeaf = isLeaf;
        this.parent = null;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 40;
        this.state = 'normal'; // normal, current, new, range
    }
}

class InternalNode extends BPlusNode {
    constructor() {
        super(false);
        this.children = [];
    }
}

class LeafNode extends BPlusNode {
    constructor() {
        super(true);
        this.values = [];
        this.next = null;
        this.prev = null;
    }
}

// B+树类
class BPlusTree {
    constructor(order = 4) {
        this.root = null;
        this.order = order;
        this.minKeys = Math.floor((order - 1) / 2);
        this.maxKeys = order - 1;
        this.leftmostLeaf = null;
    }

    search(key) {
        const leaf = this.findLeaf(key);
        if (!leaf) return null;

        for (let i = 0; i < leaf.keys.length; i++) {
            if (leaf.keys[i] === key) {
                return { leaf: leaf, index: i, value: leaf.values[i] };
            }
        }
        return null;
    }

    rangeQuery(startKey, endKey) {
        const result = [];
        const leaf = this.findLeaf(startKey);
        if (!leaf) return result;

        let currentLeaf = leaf;
        let startIdx = 0;

        // 在起始叶子节点中找到第一个 >= startKey 的位置
        while (startIdx < currentLeaf.keys.length && currentLeaf.keys[startIdx] < startKey) {
            startIdx++;
        }

        // 沿着叶子链表收集数据
        while (currentLeaf && startIdx < currentLeaf.keys.length) {
            if (currentLeaf.keys[startIdx] > endKey) break;

            result.push({
                key: currentLeaf.keys[startIdx],
                value: currentLeaf.values[startIdx],
                leaf: currentLeaf,
                index: startIdx
            });
            startIdx++;

            if (startIdx === currentLeaf.keys.length) {
                currentLeaf = currentLeaf.next;
                startIdx = 0;
            }
        }

        return result;
    }

    insert(key, value = `D${key}`) {
        if (!this.root) {
            const newLeaf = new LeafNode();
            newLeaf.keys.push(key);
            newLeaf.values.push(value);
            this.root = newLeaf;
            this.leftmostLeaf = newLeaf;
            return { type: 'create', node: newLeaf };
        }

        const leaf = this.findLeaf(key);

        // 检查键是否已存在
        for (let i = 0; i < leaf.keys.length; i++) {
            if (leaf.keys[i] === key) {
                leaf.values[i] = value;
                return { type: 'update', node: leaf };
            }
        }

        this.insertIntoLeaf(leaf, key, value);

        if (leaf.keys.length > this.maxKeys) {
            this.splitLeaf(leaf);
        }

        return { type: 'insert', node: leaf };
    }

    findLeaf(key) {
        if (!this.root) return null;

        let current = this.root;

        while (!current.isLeaf) {
            let i = 0;
            while (i < current.keys.length && key >= current.keys[i]) {
                i++;
            }
            current = current.children[i];
        }

        return current;
    }

    insertIntoLeaf(leaf, key, value) {
        let i = 0;
        while (i < leaf.keys.length && leaf.keys[i] < key) {
            i++;
        }

        leaf.keys.splice(i, 0, key);
        leaf.values.splice(i, 0, value);
    }

    splitLeaf(leaf) {
        const newLeaf = new LeafNode();
        const mid = Math.ceil(this.maxKeys / 2);

        // 移动后半部分数据
        newLeaf.keys = leaf.keys.splice(mid);
        newLeaf.values = leaf.values.splice(mid);

        // 更新叶子链表
        newLeaf.next = leaf.next;
        newLeaf.prev = leaf;
        if (leaf.next) {
            leaf.next.prev = newLeaf;
        }
        leaf.next = newLeaf;

        const promoteKey = newLeaf.keys[0];

        if (leaf === this.root) {
            const newRoot = new InternalNode();
            newRoot.keys.push(promoteKey);
            newRoot.children.push(leaf);
            newRoot.children.push(newLeaf);

            leaf.parent = newRoot;
            newLeaf.parent = newRoot;
            this.root = newRoot;
        } else {
            const parent = leaf.parent;
            this.insertIntoInternal(parent, promoteKey, newLeaf);
            newLeaf.parent = parent;
        }
    }

    insertIntoInternal(internal, key, rightChild) {
        let i = 0;
        while (i < internal.keys.length && internal.keys[i] < key) {
            i++;
        }

        internal.keys.splice(i, 0, key);
        internal.children.splice(i + 1, 0, rightChild);

        if (internal.keys.length > this.maxKeys) {
            this.splitInternal(internal);
        }
    }

    splitInternal(internal) {
        const newInternal = new InternalNode();
        const mid = Math.floor(this.maxKeys / 2);
        const promoteKey = internal.keys[mid];

        newInternal.keys = internal.keys.splice(mid + 1);
        newInternal.children = internal.children.splice(mid + 1);
        internal.keys.splice(mid, 1); // 移除提升的关键字

        // 更新子节点的父指针
        for (const child of newInternal.children) {
            child.parent = newInternal;
        }

        if (internal === this.root) {
            const newRoot = new InternalNode();
            newRoot.keys.push(promoteKey);
            newRoot.children.push(internal);
            newRoot.children.push(newInternal);

            internal.parent = newRoot;
            newInternal.parent = newRoot;
            this.root = newRoot;
        } else {
            const parent = internal.parent;
            this.insertIntoInternal(parent, promoteKey, newInternal);
            newInternal.parent = parent;
        }
    }

    getAllData() {
        const result = [];
        let current = this.leftmostLeaf;

        while (current) {
            for (let i = 0; i < current.keys.length; i++) {
                result.push({ key: current.keys[i], value: current.values[i] });
            }
            current = current.next;
        }

        return result;
    }

    getHeight(node = this.root) {
        if (!node) return 0;
        if (node.isLeaf) return 1;
        return this.getHeight(node.children[0]) + 1;
    }

    getNodeCount(node = this.root) {
        if (!node) return { total: 0, internal: 0, leaf: 0 };

        if (node.isLeaf) {
            return { total: 1, internal: 0, leaf: 1 };
        }

        let counts = { total: 1, internal: 1, leaf: 0 };
        for (const child of node.children) {
            const childCounts = this.getNodeCount(child);
            counts.total += childCounts.total;
            counts.internal += childCounts.internal;
            counts.leaf += childCounts.leaf;
        }

        return counts;
    }
}

// 全局变量
let bplusTree = new BPlusTree(4);
let animationState = {
    isAnimating: false,
    history: [],
    rangeResults: []
};

// 计算B+树布局
function calculateBPlusLayout(node, level = 0, x = 475, levelWidth = 900) {
    if (!node) return;

    const keyWidth = node.isLeaf ? 45 : 35;
    const nodeMargin = 20;
    node.width = node.keys.length * keyWidth + nodeMargin;
    node.x = x;
    node.y = 80 + level * 80;

    if (!node.isLeaf && node.children.length > 0) {
        const childrenCount = node.children.length;
        const childWidth = levelWidth / childrenCount;
        const startX = x - levelWidth / 2 + childWidth / 2;

        for (let i = 0; i < node.children.length; i++) {
            const childX = startX + i * childWidth;
            calculateBPlusLayout(node.children[i], level + 1, childX, childWidth * 0.8);
        }
    }
}

// 绘制B+树节点
function drawBPlusNode(node) {
    if (!node) return;

    const keyWidth = node.isLeaf ? 45 : 35;
    const nodeHeight = 40;
    const x = node.x - node.width / 2;
    const y = node.y - nodeHeight / 2;

    // 根据节点类型和状态设置颜色
    let fillColor, strokeColor, textColor;

    if (node.state === 'current') {
        fillColor = '#ef4444';
        strokeColor = '#dc2626';
        textColor = 'white';
    } else if (node.state === 'range') {
        fillColor = '#fbbf24';
        strokeColor = '#f59e0b';
        textColor = '#92400e';
    } else if (node.isLeaf) {
        fillColor = '#dcfce7';
        strokeColor = '#16a34a';
        textColor = '#15803d';
    } else {
        fillColor = '#dbeafe';
        strokeColor = '#0ea5e9';
        textColor = '#0369a1';
    }

    // 绘制节点背景
    bplusCtx.fillStyle = fillColor;
    bplusCtx.fillRect(x, y, node.width, nodeHeight);

    // 绘制节点边框
    bplusCtx.strokeStyle = strokeColor;
    bplusCtx.lineWidth = 2;
    bplusCtx.strokeRect(x, y, node.width, nodeHeight);

    // 绘制分隔线和内容
    bplusCtx.strokeStyle = strokeColor;
    bplusCtx.lineWidth = 1;
    bplusCtx.fillStyle = textColor;
    bplusCtx.font = 'bold 12px Arial';
    bplusCtx.textAlign = 'center';
    bplusCtx.textBaseline = 'middle';

    for (let i = 0; i < node.keys.length; i++) {
        const keyX = x + (i + 0.5) * keyWidth + 10;
        const keyY = node.y;

        // 绘制分隔线
        if (i > 0) {
            bplusCtx.beginPath();
            bplusCtx.moveTo(x + i * keyWidth + 10, y);
            bplusCtx.lineTo(x + i * keyWidth + 10, y + nodeHeight);
            bplusCtx.stroke();
        }

        // 绘制内容
        if (node.isLeaf) {
            // 叶子节点显示 key[data]
            bplusCtx.fillText(`${node.keys[i]}[D]`, keyX, keyY);
        } else {
            // 内部节点只显示 key
            bplusCtx.fillText(node.keys[i].toString(), keyX, keyY);
        }
    }
}

// 绘制树形连接线
function drawTreeConnections(node) {
    if (!node || node.isLeaf) return;

    const nodeY = node.y + 20;

    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childY = child.y - 20;

        const parentX = node.x + (i - node.children.length / 2 + 0.5) * 25;

        bplusCtx.strokeStyle = '#6b7280';
        bplusCtx.lineWidth = 2;
        bplusCtx.beginPath();
        bplusCtx.moveTo(parentX, nodeY);
        bplusCtx.lineTo(child.x, childY);
        bplusCtx.stroke();

        drawTreeConnections(child);
    }
}

// 绘制叶子节点链表连接
function drawLeafConnections() {
    let current = bplusTree.leftmostLeaf;

    while (current && current.next) {
        const startX = current.x + current.width / 2 - 10;
        const startY = current.y + 25;
        const endX = current.next.x - current.next.width / 2 + 10;
        const endY = current.next.y + 25;

        // 绘制箭头连接线
        bplusCtx.strokeStyle = '#dc2626';
        bplusCtx.lineWidth = 2;
        bplusCtx.setLineDash([5, 3]);

        bplusCtx.beginPath();
        bplusCtx.moveTo(startX, startY);
        bplusCtx.lineTo(endX, endY);
        bplusCtx.stroke();

        // 绘制箭头
        const angle = Math.atan2(endY - startY, endX - startX);
        const arrowLength = 8;
        const arrowAngle = Math.PI / 6;

        bplusCtx.fillStyle = '#dc2626';
        bplusCtx.beginPath();
        bplusCtx.moveTo(endX, endY);
        bplusCtx.lineTo(
            endX - arrowLength * Math.cos(angle - arrowAngle),
            endY - arrowLength * Math.sin(angle - arrowAngle)
        );
        bplusCtx.lineTo(
            endX - arrowLength * Math.cos(angle + arrowAngle),
            endY - arrowLength * Math.sin(angle + arrowAngle)
        );
        bplusCtx.closePath();
        bplusCtx.fill();

        bplusCtx.setLineDash([]); // 重置虚线
        current = current.next;
    }
}

// 绘制整个B+树
function drawBPlusTree() {
    bplusCtx.clearRect(0, 0, bplusCanvas.width, bplusCanvas.height);

    if (!bplusTree.root) {
        bplusCtx.fillStyle = '#6b7280';
        bplusCtx.font = '18px Arial';
        bplusCtx.textAlign = 'center';
        bplusCtx.fillText('B+树为空，请插入数据', bplusCanvas.width / 2, bplusCanvas.height / 2);
        return;
    }

    // 计算布局
    calculateBPlusLayout(bplusTree.root);

    // 绘制树形连接线（底层）
    drawTreeConnections(bplusTree.root);

    // 绘制叶子链表连接
    drawLeafConnections();

    // 绘制节点（顶层）
    function drawAllNodes(node) {
        if (node) {
            drawBPlusNode(node);
            if (!node.isLeaf) {
                for (const child of node.children) {
                    drawAllNodes(child);
                }
            }
        }
    }
    drawAllNodes(bplusTree.root);
}

// 重置节点状态
function resetNodeStates(node = bplusTree.root) {
    if (node) {
        node.state = 'normal';
        if (!node.isLeaf) {
            for (const child of node.children) {
                resetNodeStates(child);
            }
        }
    }
}

// 更新统计信息
function updateBPlusStats() {
    const height = bplusTree.getHeight();
    const counts = bplusTree.getNodeCount();
    const keyCount = bplusTree.getAllData().length;

    document.getElementById('bplusStats').textContent =
        `关键字: ${keyCount}, 内部节点: ${counts.internal}, 叶子节点: ${counts.leaf}`;
    document.getElementById('bplusStructure').textContent =
        `高度: ${height}, 阶数: ${bplusTree.order}, 总节点: ${counts.total}`;
}

// 插入关键字
async function insertKey() {
    if (animationState.isAnimating) return;

    const input = document.getElementById('insertValue');
    const value = parseInt(input.value);

    if (isNaN(value) || value < 1 || value > 99) {
        alert('请输入1-99之间的数字');
        return;
    }

    animationState.isAnimating = true;

    try {
        resetNodeStates();
        const result = bplusTree.insert(value);

        if (result.node) {
            result.node.state = 'current';
        }

        drawBPlusTree();
        updateBPlusStats();

        animationState.history.push(`插入 ${value}`);
        updateHistory();

        document.getElementById('bplusStatus').textContent = `成功插入关键字 ${value}`;

        // 重置状态
        setTimeout(() => {
            resetNodeStates();
            drawBPlusTree();
        }, 2000);

    } catch (error) {
        console.error('插入操作出错:', error);
        document.getElementById('bplusStatus').textContent = '插入操作失败';
    }

    input.value = '';
    animationState.isAnimating = false;
}

// 删除关键字（简化实现）
async function deleteKey() {
    const input = document.getElementById('deleteValue');
    const value = parseInt(input.value);

    if (isNaN(value)) {
        alert('请输入有效数字');
        return;
    }

    // 简化删除 - 重建树
    const allData = bplusTree.getAllData();
    const filteredData = allData.filter(item => item.key !== value);

    if (filteredData.length === allData.length) {
        alert(`关键字 ${value} 不存在`);
        return;
    }

    bplusTree = new BPlusTree(bplusTree.order);
    for (const item of filteredData) {
        bplusTree.insert(item.key, item.value);
    }

    drawBPlusTree();
    updateBPlusStats();

    animationState.history.push(`删除 ${value}`);
    updateHistory();

    document.getElementById('bplusStatus').textContent = `成功删除关键字 ${value}`;
    input.value = '';
}

// 范围查询
async function rangeQuery() {
    const startInput = document.getElementById('rangeStart');
    const endInput = document.getElementById('rangeEnd');
    const startKey = parseInt(startInput.value);
    const endKey = parseInt(endInput.value);

    if (isNaN(startKey) || isNaN(endKey) || startKey > endKey) {
        alert('请输入有效的范围（起始值 ≤ 结束值）');
        return;
    }

    resetNodeStates();

    const results = bplusTree.rangeQuery(startKey, endKey);
    animationState.rangeResults = results;

    // 高亮范围查询结果
    for (const result of results) {
        result.leaf.state = 'range';
    }

    drawBPlusTree();

    const resultKeys = results.map(r => r.key).join(', ');
    document.getElementById('bplusStatus').textContent =
        `范围查询 [${startKey}, ${endKey}]: ${resultKeys || '无结果'}`;

    animationState.history.push(`范围查询 [${startKey}, ${endKey}]`);
    updateHistory();

    // 3秒后重置高亮
    setTimeout(() => {
        resetNodeStates();
        drawBPlusTree();
    }, 3000);

    startInput.value = '';
    endInput.value = '';
}

// 叶子遍历演示
async function leafTraversal() {
    if (!bplusTree.root) {
        alert('请先插入一些数据');
        return;
    }

    resetNodeStates();

    const allData = bplusTree.getAllData();
    const keys = allData.map(item => item.key).join(' → ');

    // 高亮所有叶子节点
    let current = bplusTree.leftmostLeaf;
    while (current) {
        current.state = 'range';
        current = current.next;
    }

    drawBPlusTree();

    document.getElementById('bplusStatus').textContent =
        `叶子链表遍历: ${keys}`;

    animationState.history.push('叶子链表遍历');
    updateHistory();

    setTimeout(() => {
        resetNodeStates();
        drawBPlusTree();
    }, 3000);
}

// 查找演示
async function searchDemo() {
    if (!bplusTree.root) {
        alert('请先插入一些数据');
        return;
    }

    const allData = bplusTree.getAllData();
    if (allData.length === 0) return;

    const randomIndex = Math.floor(Math.random() * allData.length);
    const randomKey = allData[randomIndex].key;

    resetNodeStates();
    const result = bplusTree.search(randomKey);

    if (result) {
        result.leaf.state = 'current';
        drawBPlusTree();

        document.getElementById('bplusStatus').textContent =
            `找到关键字 ${randomKey}，值: ${result.value}`;
    }

    animationState.history.push(`查找 ${randomKey}`);
    updateHistory();

    setTimeout(() => {
        resetNodeStates();
        drawBPlusTree();
    }, 2000);
}

// 演示插入
async function insertDemo() {
    if (animationState.isAnimating) return;

    const demoKeys = [50, 25, 75, 10, 30, 60, 80, 15, 35, 65];
    animationState.isAnimating = true;

    for (const key of demoKeys) {
        const existing = bplusTree.search(key);
        if (!existing) {
            await new Promise(resolve => {
                setTimeout(() => {
                    resetNodeStates();
                    const result = bplusTree.insert(key);
                    if (result.node) {
                        result.node.state = 'current';
                    }
                    drawBPlusTree();
                    updateBPlusStats();

                    animationState.history.push(`演示插入 ${key}`);
                    updateHistory();

                    document.getElementById('bplusStatus').textContent =
                        `演示插入关键字 ${key}`;

                    setTimeout(() => {
                        resetNodeStates();
                        drawBPlusTree();
                        resolve();
                    }, 1500);
                }, 800);
            });
        }
    }

    animationState.isAnimating = false;
    document.getElementById('bplusStatus').textContent = '演示插入完成';
}

// 重置B+树
function resetBPlusTree() {
    bplusTree = new BPlusTree(bplusTree.order);
    animationState.history = [];
    animationState.rangeResults = [];
    resetNodeStates();
    drawBPlusTree();
    updateBPlusStats();
    updateHistory();
    document.getElementById('bplusStatus').textContent = 'B+树已重置';
}

// 改变阶数
function changeOrder() {
    const select = document.getElementById('bplusTreeOrder');
    const newOrder = parseInt(select.value);
    bplusTree = new BPlusTree(newOrder);
    resetBPlusTree();
    document.getElementById('bplusStatus').textContent = `已切换到${newOrder}阶B+树`;
}

// 更新历史记录
function updateHistory() {
    const history = animationState.history.slice(-8); // 只显示最近8条
    document.getElementById('bplusHistory').textContent =
        history.length > 0 ? history.join(' → ') : '暂无操作';
}

// 代码相关功能
function showCode(language) {
    const codeContents = document.querySelectorAll('.code-content');
    codeContents.forEach(content => content.classList.remove('active'));

    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => tab.classList.remove('active'));

    document.getElementById(`${language}-code`).classList.add('active');
    event.target.classList.add('active');
}

function copyCode(language, buttonElement) {
    let button = buttonElement;
    if (!button) {
        button = event ? event.target : null;
    }

    if (!button) {
        console.error('无法获取按钮元素');
        return;
    }

    const codeElement = document.getElementById(`${language}-source`);

    if (!codeElement) {
        console.error(`找不到代码元素: ${language}-source`);
        showCopyError(button);
        return;
    }

    const text = codeElement.textContent || codeElement.innerText;
    const cleanText = text.trim();

    if (!cleanText) {
        console.error('代码内容为空');
        showCopyError(button);
        return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(cleanText).then(() => {
            showCopySuccess(button);
        }).catch(err => {
            console.error('现代API复制失败:', err);
            fallbackCopyTextToClipboard(cleanText, button);
        });
    } else {
        fallbackCopyTextToClipboard(cleanText, button);
    }
}

function fallbackCopyTextToClipboard(text, button) {
    const textArea = document.createElement("textarea");
    textArea.value = text;

    textArea.style.position = "fixed";
    textArea.style.top = "-1000px";
    textArea.style.left = "-1000px";
    textArea.style.width = "1px";
    textArea.style.height = "1px";
    textArea.style.padding = "0";
    textArea.style.border = "none";
    textArea.style.outline = "none";
    textArea.style.boxShadow = "none";
    textArea.style.background = "transparent";

    document.body.appendChild(textArea);

    try {
        textArea.focus();
        textArea.select();
        textArea.setSelectionRange(0, text.length);

        const successful = document.execCommand('copy');

        if (successful) {
            showCopySuccess(button);
        } else {
            console.error('execCommand复制失败');
            showCopyError(button);
        }
    } catch (err) {
        console.error('降级复制方法出错:', err);
        showCopyError(button);
    } finally {
        document.body.removeChild(textArea);
    }
}

function showCopySuccess(button) {
    if (!button) return;

    const originalText = button.innerHTML;
    const originalClass = button.className;

    button.innerHTML = '✅ 已复制';
    button.className = originalClass + ' copy-success';
    button.disabled = true;

    const originalStyle = button.style.cssText;
    button.style.cssText = originalStyle + '; background: #22c55e !important; color: white !important;';

    setTimeout(() => {
        button.innerHTML = originalText;
        button.className = originalClass;
        button.disabled = false;
        button.style.cssText = originalStyle;
    }, 2000);
}

function showCopyError(button) {
    if (!button) return;

    const originalText = button.innerHTML;
    const originalClass = button.className;

    button.innerHTML = '❌ 复制失败';
    button.className = originalClass + ' copy-error';
    button.disabled = true;

    const originalStyle = button.style.cssText;
    button.style.cssText = originalStyle + '; background: #ef4444 !important; color: white !important;';

    setTimeout(() => {
        button.innerHTML = originalText;
        button.className = originalClass;
        button.disabled = false;
        button.style.cssText = originalStyle;
    }, 2000);
}

// 测验功能
function toggleAnswer(questionNumber) {
    const answer = document.getElementById(`answer${questionNumber}`);
    const button = event.target;

    if (answer.classList.contains('show')) {
        answer.classList.remove('show');
        button.textContent = '点击查看答案';
    } else {
        answer.classList.add('show');
        button.textContent = '隐藏答案';
    }
}

// 键盘事件支持
document.getElementById('insertValue').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        insertKey();
    }
});

document.getElementById('deleteValue').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        deleteKey();
    }
});

document.getElementById('rangeStart').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        rangeQuery();
    }
});

document.getElementById('rangeEnd').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        rangeQuery();
    }
});

// 初始化
drawBPlusTree();
updateBPlusStats();
updateHistory();
</script>

{% endblock %}