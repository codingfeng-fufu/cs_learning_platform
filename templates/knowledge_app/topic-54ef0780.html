{% extends 'knowledge_app/base.html' %}

{% block title %}A*å¯å‘å¼æœç´¢ç®—æ³• - è®¡ç®—æœºç§‘å­¦å­¦ä¹ å¹³å°{% endblock %}

{% block content %}
<style>
    .visualization-container {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .concept-card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        border-left: 4px solid #ff6b6b;
    }

    .key-term {
        display: inline-block;
        background: #ffe0e0;
        padding: 4px 8px;
        border-radius: 4px;
        margin: 2px;
        font-weight: 600;
    }

    .difficulty-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 20px;
        font-weight: bold;
        margin: 10px 0;
    }

    .difficulty-hard {
        background: #f8d7da;
        color: #721c24;
    }

    .code-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        border-bottom: 2px solid #e0e0e0;
    }

    .code-tab {
        padding: 10px 20px;
        cursor: pointer;
        background: #f5f5f5;
        border: none;
        border-radius: 8px 8px 0 0;
        transition: all 0.3s;
    }

    .code-tab.active {
        background: #ff6b6b;
        color: white;
    }

    .code-content {
        display: none;
        background: #2d2d2d;
        color: #f8f8f2;
        padding: 20px;
        border-radius: 0 8px 8px 8px;
        position: relative;
        font-family: 'Courier New', monospace;
        overflow-x: auto;
    }

    .code-content.active {
        display: block;
    }

    .copy-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
    }

    .copy-btn:hover {
        background: #ff5252;
    }

    #astarCanvas {
        border: 2px solid #ddd;
        border-radius: 8px;
        margin: 20px auto;
        display: block;
        background: white;
        cursor: pointer;
    }

    .control-panel {
        text-align: center;
        margin: 20px 0;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }

    .control-btn {
        padding: 10px 20px;
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
    }

    .control-btn:hover {
        background: #ff5252;
        transform: translateY(-2px);
    }

    .control-btn.secondary {
        background: #4ecdc4;
    }

    .control-btn.secondary:hover {
        background: #45b7aa;
    }

    .control-btn.danger {
        background: #dc3545;
    }

    .control-btn.danger:hover {
        background: #c82333;
    }

    .mode-selector {
        display: inline-flex;
        gap: 5px;
        padding: 5px;
        background: #f0f0f0;
        border-radius: 6px;
        margin: 0 10px;
    }

    .mode-btn {
        padding: 8px 16px;
        background: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .mode-btn.active {
        background: #ff6b6b;
        color: white;
    }

    .stats-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin: 20px 0;
    }

    .stat-card {
        background: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #ff6b6b;
    }

    .stat-label {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
    }

    .legend {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid #ddd;
    }

    .heuristic-selector {
        margin: 15px 0;
        text-align: center;
    }

    .heuristic-selector select {
        padding: 8px 16px;
        border: 2px solid #ff6b6b;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
    }

    .speed-control {
        display: inline-block;
        margin: 0 15px;
    }

    .speed-control label {
        margin-right: 10px;
        font-weight: 600;
    }

    .quiz-item {
        background: #f8f9fa;
        padding: 20px;
        margin: 15px 0;
        border-radius: 8px;
        border: 2px solid #e9ecef;
    }

    .quiz-question {
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
    }

    .show-answer-btn {
        padding: 8px 16px;
        background: #17a2b8;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
    }

    .quiz-answer {
        display: none;
        background: #d4edda;
        padding: 15px;
        border-radius: 6px;
        margin-top: 10px;
        border-left: 4px solid #28a745;
    }

    .analogy-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 12px;
        margin: 20px 0;
    }

    .application-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin: 20px 0;
    }

    .app-card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.3s;
    }

    .app-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .highlight {
        background: #ffeb3b;
        padding: 2px 4px;
        border-radius: 3px;
    }

    .formula-box {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        font-size: 18px;
        margin: 20px 0;
        font-family: 'Courier New', monospace;
    }

    .algorithm-step {
        background: #f8f9fa;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #ff6b6b;
    }

    .step-number {
        display: inline-block;
        width: 30px;
        height: 30px;
        background: #ff6b6b;
        color: white;
        border-radius: 50%;
        text-align: center;
        line-height: 30px;
        margin-right: 10px;
        font-weight: bold;
    }
</style>

<div class="page-container fade-in">
    <!-- é¢åŒ…å±‘å¯¼èˆª -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">é¦–é¡µ</a>
        <span>></span>
        <span>ç®—æ³•</span>
        <span>></span>
        <span>A*æœç´¢ç®—æ³•</span>
    </div>

    <!-- é¡µé¢å¤´éƒ¨ -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">â­</span>
            A*å¯å‘å¼æœç´¢ç®—æ³•
        </h1>
        <p>æ™ºèƒ½å¯»è·¯çš„é»„é‡‘æ ‡å‡† - ç”¨å¯å‘å‡½æ•°æŒ‡å¼•æœ€çŸ­è·¯å¾„</p>
    </div>

    <!-- çŸ¥è¯†ç‚¹æ¦‚è¿° -->
    <div class="content-card slide-in-right">
        <h2 class="section-title">
            <span class="section-icon">ğŸ“‹</span>
            çŸ¥è¯†ç‚¹æ¦‚è¿°
        </h2>

        <div class="concept-card">
            <p style="font-size: 18px; line-height: 1.6;">
                <strong>æ ¸å¿ƒæ¦‚å¿µï¼š</strong>A*ç®—æ³•å°±åƒä¸€ä¸ª<span class="highlight">æ™ºèƒ½å¯¼èˆªå‘˜</span>ï¼Œå®ƒä¸ä»…çŸ¥é“å·²èµ°çš„è·¯ç¨‹ï¼Œè¿˜èƒ½ä¼°è®¡åˆ°ç›®æ ‡çš„è·ç¦»ï¼Œæ€»æ˜¯é€‰æ‹©"æœ€æœ‰å¸Œæœ›"çš„æ–¹å‘å‰è¿›ï¼Œæ—¢ä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œåˆæ¯”ç›²ç›®æœç´¢å¿«å¾—å¤šï¼
            </p>

            <div style="margin: 20px 0;">
                <h4>ğŸ”¤ å…³é”®æœ¯è¯­ï¼š</h4>
                <span class="key-term">å¯å‘å‡½æ•° h(n)</span> - ä¼°è®¡å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡çš„ä»£ä»·<br>
                <span class="key-term">å®é™…ä»£ä»· g(n)</span> - ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…ä»£ä»·<br>
                <span class="key-term">è¯„ä¼°å‡½æ•° f(n)</span> - f(n) = g(n) + h(n)ï¼Œæ€»ä»£ä»·ä¼°è®¡<br>
                <span class="key-term">å¼€æ”¾åˆ—è¡¨</span> - å¾…æ¢ç´¢çš„èŠ‚ç‚¹é›†åˆ<br>
                <span class="key-term">å…³é—­åˆ—è¡¨</span> - å·²æ¢ç´¢çš„èŠ‚ç‚¹é›†åˆ<br>
                <span class="key-term">å¯é‡‡çº³æ€§</span> - å¯å‘å‡½æ•°ä¸é«˜ä¼°å®é™…ä»£ä»·
            </div>

            <div class="difficulty-badge difficulty-hard">
                ğŸ“Š å­¦ä¹ éš¾åº¦ï¼šé«˜çº§
            </div>

            <div style="margin-top: 15px;">
                <strong>å‰ç½®çŸ¥è¯†ï¼š</strong>å›¾æœç´¢ã€Dijkstraç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ—ã€å¯å‘å¼æ–¹æ³•
            </div>
        </div>
    </div>

    <!-- æ¦‚å¿µè¯¦è§£ -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">ğŸ”</span>
            æ¦‚å¿µè¯¦è§£
        </h2>

        <div class="analogy-box">
            <h3>ğŸ—ºï¸ ç”Ÿæ´»ç±»æ¯”ï¼šå¯»å®æ¸¸æˆ</h3>
            <p>æƒ³è±¡ä½ åœ¨ä¸€ä¸ªå¤§å‹å…¬å›­é‡Œå¯»å®ï¼š</p>
            <ul style="list-style: none; padding-left: 0;">
                <li>ğŸ“ ä½ çŸ¥é“è‡ªå·±èµ°äº†å¤šè¿œï¼ˆg(n) - å®é™…ä»£ä»·ï¼‰</li>
                <li>ğŸ§­ æŒ‡å—é’ˆæ˜¾ç¤ºå®è—çš„ç›´çº¿æ–¹å‘ï¼ˆh(n) - å¯å‘ä¼°è®¡ï¼‰</li>
                <li>ğŸ¯ ä½ é€‰æ‹©"å·²èµ°è·ç¦»+é¢„ä¼°è·ç¦»"æœ€å°çš„è·¯çº¿ï¼ˆf(n) = g(n) + h(n)ï¼‰</li>
                <li>ğŸš¶ è¿™æ ·æ—¢ä¸ä¼šèµ°å†¤æ‰è·¯ï¼Œåˆèƒ½å¿«é€Ÿæ¥è¿‘ç›®æ ‡</li>
                <li>âš¡ æ¯”æ²¡æœ‰æŒ‡å—é’ˆï¼ˆDijkstraï¼‰å¿«å¾—å¤š</li>
                <li>âœ… å¦‚æœä¼°è®¡ä¸è¿‡åˆ†ä¹è§‚ï¼Œä¸€å®šèƒ½æ‰¾åˆ°æœ€çŸ­è·¯å¾„</li>
            </ul>
        </div>

        <div class="concept-card">
            <h4>1ï¸âƒ£ æ ¸å¿ƒå…¬å¼ï¼šf(n) = g(n) + h(n)</h4>

            <div class="formula-box">
                <strong>f(n) = g(n) + h(n)</strong><br>
                æ€»ä»£ä»· = å·²çŸ¥ä»£ä»· + ä¼°è®¡ä»£ä»·
            </div>

            <ul>
                <li><strong>g(n)ï¼š</strong>ä»èµ·ç‚¹åˆ°èŠ‚ç‚¹nçš„å®é™…ä»£ä»·ï¼ˆå·²çŸ¥ï¼‰</li>
                <li><strong>h(n)ï¼š</strong>ä»èŠ‚ç‚¹nåˆ°ç›®æ ‡çš„ä¼°è®¡ä»£ä»·ï¼ˆå¯å‘å‡½æ•°ï¼‰</li>
                <li><strong>f(n)ï¼š</strong>ç»è¿‡èŠ‚ç‚¹nçš„è·¯å¾„æ€»ä»£ä»·ä¼°è®¡</li>
            </ul>

            <p><strong>å…³é”®æ´å¯Ÿï¼š</strong>ä¼˜å…ˆæ¢ç´¢f(n)æœ€å°çš„èŠ‚ç‚¹ï¼Œå¹³è¡¡äº†"èµ°å¾—è¿‘"å’Œ"æ–¹å‘å¯¹"</p>
        </div>

        <div class="concept-card">
            <h4>2ï¸âƒ£ å¸¸ç”¨å¯å‘å‡½æ•°</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background: #f0f0f0;">
                    <th style="padding: 10px; border: 1px solid #ddd;">å¯å‘å‡½æ•°</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">å…¬å¼</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">é€‚ç”¨åœºæ™¯</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">ç‰¹ç‚¹</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">æ›¼å“ˆé¡¿è·ç¦»</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">|xâ‚-xâ‚‚| + |yâ‚-yâ‚‚|</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">ç½‘æ ¼ï¼Œ4æ–¹å‘ç§»åŠ¨</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">æœ€å¸¸ç”¨ï¼Œè®¡ç®—å¿«</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">æ¬§å‡ é‡Œå¾—è·ç¦»</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">âˆš((xâ‚-xâ‚‚)Â² + (yâ‚-yâ‚‚)Â²)</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">ä»»æ„æ–¹å‘ç§»åŠ¨</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">æ›´å‡†ç¡®ï¼Œè®¡ç®—æ…¢</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">åˆ‡æ¯”é›ªå¤«è·ç¦»</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">max(|xâ‚-xâ‚‚|, |yâ‚-yâ‚‚|)</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">8æ–¹å‘ç§»åŠ¨</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">å¯¹è§’çº¿=ç›´çº¿</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">é›¶å¯å‘ï¼ˆh=0ï¼‰</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">0</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">é€€åŒ–ä¸ºDijkstra</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">ä¿è¯æœ€ä¼˜ï¼Œæ•ˆç‡ä½</td>
                </tr>
            </table>
        </div>

        <div class="concept-card">
            <h4>3ï¸âƒ£ ç®—æ³•æ‰§è¡Œæ­¥éª¤</h4>
            <div class="algorithm-step">
                <span class="step-number">1</span>
                åˆå§‹åŒ–ï¼šèµ·ç‚¹åŠ å…¥å¼€æ”¾åˆ—è¡¨ï¼Œf(start) = h(start)
            </div>
            <div class="algorithm-step">
                <span class="step-number">2</span>
                é€‰æ‹©å¼€æ”¾åˆ—è¡¨ä¸­få€¼æœ€å°çš„èŠ‚ç‚¹current
            </div>
            <div class="algorithm-step">
                <span class="step-number">3</span>
                å¦‚æœcurrentæ˜¯ç›®æ ‡ï¼Œé‡å»ºè·¯å¾„å¹¶è¿”å›
            </div>
            <div class="algorithm-step">
                <span class="step-number">4</span>
                å°†currentä»å¼€æ”¾åˆ—è¡¨ç§»åˆ°å…³é—­åˆ—è¡¨
            </div>
            <div class="algorithm-step">
                <span class="step-number">5</span>
                å¯¹currentçš„æ¯ä¸ªé‚»å±…ï¼šè®¡ç®—gã€hã€få€¼ï¼Œæ›´æ–°æˆ–åŠ å…¥å¼€æ”¾åˆ—è¡¨
            </div>
            <div class="algorithm-step">
                <span class="step-number">6</span>
                é‡å¤2-5ç›´åˆ°æ‰¾åˆ°ç›®æ ‡æˆ–å¼€æ”¾åˆ—è¡¨ä¸ºç©º
            </div>
        </div>

        <div class="concept-card" style="background: #fff3cd; border-left-color: #ffc107;">
            <h4>âš ï¸ åˆå­¦è€…æ˜“æ··æ·†ç‚¹</h4>
            <ul>
                <li>A*ä¸æ˜¯è´ªå¿ƒç®—æ³•ï¼Œå®ƒè€ƒè™‘äº†å®Œæ•´è·¯å¾„ä»£ä»·</li>
                <li>å¯å‘å‡½æ•°å¿…é¡»<strong>å¯é‡‡çº³</strong>ï¼ˆä¸é«˜ä¼°ï¼‰æ‰èƒ½ä¿è¯æœ€ä¼˜</li>
                <li>å¯å‘å‡½æ•°è¶Šç²¾ç¡®ï¼Œæœç´¢è¶Šå¿«ï¼Œä½†è®¡ç®—æˆæœ¬å¯èƒ½æ›´é«˜</li>
                <li>A*çš„æ•ˆç‡é«˜åº¦ä¾èµ–å¯å‘å‡½æ•°çš„è´¨é‡</li>
                <li>åœ¨æœ€åæƒ…å†µä¸‹ï¼ˆh=0ï¼‰ï¼ŒA*é€€åŒ–ä¸ºDijkstra</li>
            </ul>
        </div>
    </div>

    <!-- å¯è§†åŒ–å±•ç¤º -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">ğŸ“Š</span>
            å¯è§†åŒ–å±•ç¤º
        </h2>

        <div class="visualization-container">
            <h3 style="text-align: center;">ğŸ¯ A*ç®—æ³•è·¯å¾„æœç´¢æ¼”ç¤º</h3>

            <div class="heuristic-selector">
                <label><strong>å¯å‘å‡½æ•°ï¼š</strong></label>
                <select id="heuristicSelect" onchange="changeHeuristic()">
                    <option value="manhattan">æ›¼å“ˆé¡¿è·ç¦»ï¼ˆ4æ–¹å‘ï¼‰</option>
                    <option value="euclidean">æ¬§å‡ é‡Œå¾—è·ç¦»ï¼ˆä»»æ„æ–¹å‘ï¼‰</option>
                    <option value="chebyshev">åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼ˆ8æ–¹å‘ï¼‰</option>
                    <option value="zero">é›¶å¯å‘ï¼ˆDijkstraï¼‰</option>
                </select>
            </div>

            <canvas id="astarCanvas" width="600" height="600"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>èµ·ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>ç»ˆç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #333;"></div>
                    <span>éšœç¢ç‰©</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #87CEEB;"></div>
                    <span>å¼€æ”¾åˆ—è¡¨</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>å…³é—­åˆ—è¡¨</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    <span>æœ€çŸ­è·¯å¾„</span>
                </div>
            </div>

            <div class="control-panel">
                <div class="mode-selector">
                    <button class="mode-btn active" onclick="setMode('wall')">ğŸ§± å¢™å£</button>
                    <button class="mode-btn" onclick="setMode('start')">ğŸŸ¢ èµ·ç‚¹</button>
                    <button class="mode-btn" onclick="setMode('end')">ğŸ”´ ç»ˆç‚¹</button>
                </div>

                <button class="control-btn" onclick="startSearch()">â–¶ï¸ å¼€å§‹æœç´¢</button>
                <button class="control-btn" onclick="stepSearch()">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
                <button class="control-btn secondary" onclick="resetGrid()">ğŸ”„ é‡ç½®è·¯å¾„</button>
                <button class="control-btn secondary" onclick="generateMaze()">ğŸ² éšæœºè¿·å®«</button>
                <button class="control-btn danger" onclick="clearGrid()">ğŸ—‘ï¸ æ¸…ç©ºç½‘æ ¼</button>

                <div class="speed-control">
                    <label for="speedSlider">é€Ÿåº¦ï¼š</label>
                    <input type="range" id="speedSlider" min="10" max="500" value="50" step="10">
                    <span id="speedValue">50ms</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-value" id="pathLength">0</div>
                    <div class="stat-label">è·¯å¾„é•¿åº¦</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="nodesExpanded">0</div>
                    <div class="stat-label">æ‰©å±•èŠ‚ç‚¹</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="nodesInOpen">0</div>
                    <div class="stat-label">å¼€æ”¾åˆ—è¡¨</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="timeElapsed">0ms</div>
                    <div class="stat-label">æœç´¢æ—¶é—´</div>
                </div>
            </div>

            <div id="operationLog" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; min-height: 60px;">
                <strong>æ“ä½œæ—¥å¿—ï¼š</strong><span id="logText">ç‚¹å‡»ç½‘æ ¼è®¾ç½®å¢™å£ï¼Œæˆ–ä½¿ç”¨"éšæœºè¿·å®«"ç”Ÿæˆåœ°å›¾</span>
            </div>
        </div>
    </div>

    <!-- ä»£ç ç¤ºä¾‹ -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">ğŸ’»</span>
            ä»£ç å®ç°
        </h2>

        <div class="code-tabs">
            <button class="code-tab active" onclick="switchCode('python', event)">Python</button>
            <button class="code-tab" onclick="switchCode('cpp', event)">C++</button>
            <button class="code-tab" onclick="switchCode('java', event)">Java</button>
        </div>

        <div id="python-code" class="code-content active">
            <button class="copy-btn" onclick="copyCode('python', event)">ğŸ“‹ å¤åˆ¶ä»£ç </button>
            <pre><code>import heapq
import math
from typing import List, Tuple, Optional, Set

class Node:
    """A*ç®—æ³•çš„èŠ‚ç‚¹ç±»"""
    def __init__(self, position: Tuple[int, int], parent=None):
        self.position = position
        self.parent = parent

        self.g = 0  # ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…ä»£ä»·
        self.h = 0  # ä»å½“å‰èŠ‚ç‚¹åˆ°ç»ˆç‚¹çš„ä¼°è®¡ä»£ä»·ï¼ˆå¯å‘å€¼ï¼‰
        self.f = 0  # æ€»ä»£ä»· f = g + h

    def __lt__(self, other):
        """ç”¨äºä¼˜å…ˆé˜Ÿåˆ—æ¯”è¾ƒ"""
        return self.f < other.f

    def __eq__(self, other):
        return self.position == other.position

    def __hash__(self):
        return hash(self.position)

class AStar:
    """A*å¯»è·¯ç®—æ³•å®ç°"""

    def __init__(self, grid: List[List[int]]):
        """
        åˆå§‹åŒ–A*ç®—æ³•
        Args:
            grid: äºŒç»´ç½‘æ ¼ï¼Œ0è¡¨ç¤ºå¯é€šè¡Œï¼Œ1è¡¨ç¤ºéšœç¢ç‰©
        """
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if grid else 0

    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int],
                  method: str = 'manhattan') -> float:
        """
        è®¡ç®—å¯å‘å‡½æ•°å€¼
        Args:
            pos1: å½“å‰ä½ç½®
            pos2: ç›®æ ‡ä½ç½®
            method: å¯å‘å‡½æ•°ç±»å‹
        """
        x1, y1 = pos1
        x2, y2 = pos2

        if method == 'manhattan':
            # æ›¼å“ˆé¡¿è·ç¦»ï¼ˆ4æ–¹å‘ç§»åŠ¨ï¼‰
            return abs(x1 - x2) + abs(y1 - y2)
        elif method == 'euclidean':
            # æ¬§å‡ é‡Œå¾—è·ç¦»ï¼ˆä»»æ„æ–¹å‘ï¼‰
            return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
        elif method == 'chebyshev':
            # åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼ˆ8æ–¹å‘ç§»åŠ¨ï¼‰
            return max(abs(x1 - x2), abs(y1 - y2))
        else:
            # é›¶å¯å‘ï¼ˆé€€åŒ–ä¸ºDijkstraï¼‰
            return 0

    def get_neighbors(self, node: Node, allow_diagonal: bool = False) -> List[Node]:
        """
        è·å–èŠ‚ç‚¹çš„é‚»å±…
        Args:
            node: å½“å‰èŠ‚ç‚¹
            allow_diagonal: æ˜¯å¦å…è®¸å¯¹è§’ç§»åŠ¨
        """
        neighbors = []
        x, y = node.position

        # 4æ–¹å‘ç§»åŠ¨
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        # 8æ–¹å‘ç§»åŠ¨ï¼ˆåŒ…æ‹¬å¯¹è§’ï¼‰
        if allow_diagonal:
            directions += [(1, 1), (1, -1), (-1, 1), (-1, -1)]

        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy

            # æ£€æŸ¥è¾¹ç•Œ
            if 0 <= new_x < self.rows and 0 <= new_y < self.cols:
                # æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©
                if self.grid[new_x][new_y] == 0:
                    neighbors.append(Node((new_x, new_y), node))

        return neighbors

    def reconstruct_path(self, node: Node) -> List[Tuple[int, int]]:
        """
        é‡å»ºè·¯å¾„
        Args:
            node: ç»ˆç‚¹èŠ‚ç‚¹
        Returns:
            è·¯å¾„åæ ‡åˆ—è¡¨
        """
        path = []
        current = node

        while current:
            path.append(current.position)
            current = current.parent

        return path[::-1]  # åè½¬è·¯å¾„

    def search(self, start: Tuple[int, int], end: Tuple[int, int],
               heuristic_method: str = 'manhattan',
               allow_diagonal: bool = False) -> Optional[List[Tuple[int, int]]]:
        """
        æ‰§è¡ŒA*æœç´¢
        Args:
            start: èµ·ç‚¹åæ ‡
            end: ç»ˆç‚¹åæ ‡
            heuristic_method: å¯å‘å‡½æ•°ç±»å‹
            allow_diagonal: æ˜¯å¦å…è®¸å¯¹è§’ç§»åŠ¨
        Returns:
            æ‰¾åˆ°çš„è·¯å¾„ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›None
        """
        # åˆ›å»ºèµ·ç‚¹å’Œç»ˆç‚¹èŠ‚ç‚¹
        start_node = Node(start)
        end_node = Node(end)

        # å¼€æ”¾åˆ—è¡¨ï¼ˆä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰
        open_list = []
        heapq.heappush(open_list, start_node)

        # å…³é—­åˆ—è¡¨ï¼ˆä½¿ç”¨é›†åˆæé«˜æŸ¥æ‰¾æ•ˆç‡ï¼‰
        closed_set = set()

        # è®°å½•å·²åœ¨å¼€æ”¾åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹
        open_dict = {start: start_node}

        # ç»Ÿè®¡ä¿¡æ¯
        nodes_expanded = 0

        while open_list:
            # å–å‡ºfå€¼æœ€å°çš„èŠ‚ç‚¹
            current_node = heapq.heappop(open_list)
            open_dict.pop(current_node.position, None)

            # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if current_node.position == end:
                print(f"è·¯å¾„æ‰¾åˆ°ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š{nodes_expanded}")
                return self.reconstruct_path(current_node)

            # åŠ å…¥å…³é—­åˆ—è¡¨
            closed_set.add(current_node.position)
            nodes_expanded += 1

            # æ£€æŸ¥æ‰€æœ‰é‚»å±…
            for neighbor in self.get_neighbors(current_node, allow_diagonal):
                # è·³è¿‡å·²åœ¨å…³é—­åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹
                if neighbor.position in closed_set:
                    continue

                # è®¡ç®—gå€¼ï¼ˆå®é™…ä»£ä»·ï¼‰
                if allow_diagonal and \
                   abs(neighbor.position[0] - current_node.position[0]) + \
                   abs(neighbor.position[1] - current_node.position[1]) == 2:
                    # å¯¹è§’ç§»åŠ¨ï¼Œä»£ä»·ä¸ºâˆš2
                    move_cost = 1.414
                else:
                    # ç›´çº¿ç§»åŠ¨ï¼Œä»£ä»·ä¸º1
                    move_cost = 1

                tentative_g = current_node.g + move_cost

                # å¦‚æœé‚»å±…å·²åœ¨å¼€æ”¾åˆ—è¡¨ä¸­
                if neighbor.position in open_dict:
                    existing_node = open_dict[neighbor.position]
                    # å¦‚æœæ–°è·¯å¾„æ›´çŸ­ï¼Œæ›´æ–°
                    if tentative_g < existing_node.g:
                        existing_node.g = tentative_g
                        existing_node.f = existing_node.g + existing_node.h
                        existing_node.parent = current_node
                else:
                    # æ–°èŠ‚ç‚¹ï¼Œè®¡ç®—få€¼å¹¶åŠ å…¥å¼€æ”¾åˆ—è¡¨
                    neighbor.g = tentative_g
                    neighbor.h = self.heuristic(neighbor.position, end,
                                               heuristic_method)
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.parent = current_node

                    heapq.heappush(open_list, neighbor)
                    open_dict[neighbor.position] = neighbor

        print(f"æœªæ‰¾åˆ°è·¯å¾„ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š{nodes_expanded}")
        return None

    def print_path(self, path: List[Tuple[int, int]]):
        """æ‰“å°è·¯å¾„å¯è§†åŒ–"""
        if not path:
            print("æ²¡æœ‰æ‰¾åˆ°è·¯å¾„")
            return

        # åˆ›å»ºæ˜¾ç¤ºç½‘æ ¼
        display = [['â–¡' if cell == 0 else 'â– '
                   for cell in row] for row in self.grid]

        # æ ‡è®°è·¯å¾„
        for x, y in path:
            if (x, y) == path[0]:
                display[x][y] = 'S'  # èµ·ç‚¹
            elif (x, y) == path[-1]:
                display[x][y] = 'E'  # ç»ˆç‚¹
            else:
                display[x][y] = 'â—†'  # è·¯å¾„

        # æ‰“å°ç½‘æ ¼
        for row in display:
            print(' '.join(row))

        print(f"\nè·¯å¾„é•¿åº¦: {len(path) - 1}")


# ä½¿ç”¨ç¤ºä¾‹
def example():
    """A*ç®—æ³•ä½¿ç”¨ç¤ºä¾‹"""

    # åˆ›å»ºåœ°å›¾ï¼ˆ0: å¯é€šè¡Œ, 1: éšœç¢ç‰©ï¼‰
    grid = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 1, 1, 1, 0],
        [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1, 1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ]

    astar = AStar(grid)

    # è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹
    start = (0, 0)
    end = (9, 9)

    print("=== A*ç®—æ³•å¯»è·¯ç¤ºä¾‹ ===\n")
    print("åœ°å›¾ï¼ˆâ– è¡¨ç¤ºéšœç¢ç‰©ï¼‰ï¼š")
    astar.print_path([])

    # æµ‹è¯•ä¸åŒçš„å¯å‘å‡½æ•°
    heuristics = ['manhattan', 'euclidean', 'chebyshev', 'zero']

    for h_method in heuristics:
        print(f"\n--- ä½¿ç”¨{h_method}å¯å‘å‡½æ•° ---")
        path = astar.search(start, end, h_method,
                           allow_diagonal=(h_method != 'manhattan'))

        if path:
            print("\næ‰¾åˆ°çš„è·¯å¾„ï¼š")
            astar.print_path(path)

    # æ¯”è¾ƒæœ‰æ— å¯å‘çš„å·®å¼‚
    print("\n=== æ€§èƒ½æ¯”è¾ƒ ===")
    print("å¯å‘å¼æœç´¢ï¼ˆA*ï¼‰é€šå¸¸æ¯”æ— å¯å‘æœç´¢ï¼ˆDijkstraï¼‰æ‰©å±•æ›´å°‘çš„èŠ‚ç‚¹")


class AStarWithVisualization(AStar):
    """å¸¦å¯è§†åŒ–çš„A*ç®—æ³•"""

    def search_with_steps(self, start: Tuple[int, int], end: Tuple[int, int],
                          heuristic_method: str = 'manhattan'):
        """
        è¿”å›æœç´¢çš„æ¯ä¸€æ­¥çŠ¶æ€ï¼Œç”¨äºå¯è§†åŒ–
        """
        steps = []
        start_node = Node(start)
        end_node = Node(end)

        open_list = []
        heapq.heappush(open_list, start_node)
        closed_set = set()
        open_dict = {start: start_node}

        while open_list:
            # è®°å½•å½“å‰æ­¥éª¤
            step_info = {
                'open_list': [node.position for node in open_list],
                'closed_list': list(closed_set),
                'current': None,
                'path': None
            }

            current_node = heapq.heappop(open_list)
            open_dict.pop(current_node.position, None)
            step_info['current'] = current_node.position

            if current_node.position == end:
                step_info['path'] = self.reconstruct_path(current_node)
                steps.append(step_info)
                return steps

            closed_set.add(current_node.position)

            for neighbor in self.get_neighbors(current_node):
                if neighbor.position in closed_set:
                    continue

                tentative_g = current_node.g + 1

                if neighbor.position in open_dict:
                    existing_node = open_dict[neighbor.position]
                    if tentative_g < existing_node.g:
                        existing_node.g = tentative_g
                        existing_node.f = existing_node.g + existing_node.h
                        existing_node.parent = current_node
                else:
                    neighbor.g = tentative_g
                    neighbor.h = self.heuristic(neighbor.position, end,
                                               heuristic_method)
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.parent = current_node

                    heapq.heappush(open_list, neighbor)
                    open_dict[neighbor.position] = neighbor

            steps.append(step_info)

        return steps


if __name__ == "__main__":
    example()</code></pre>
        </div>

        <div id="cpp-code" class="code-content">
            <button class="copy-btn" onclick="copyCode('cpp', event)">ğŸ“‹ å¤åˆ¶ä»£ç </button>
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

// èŠ‚ç‚¹ç»“æ„
struct Node {
    int x, y;           // ä½ç½®
    double g, h, f;     // ä»£ä»·å€¼
    Node* parent;       // çˆ¶èŠ‚ç‚¹

    Node(int x, int y) : x(x), y(y), g(0), h(0), f(0), parent(nullptr) {}

    // ç”¨äºä¼˜å…ˆé˜Ÿåˆ—æ¯”è¾ƒ
    bool operator>(const Node& other) const {
        return f > other.f;
    }
};

// ä½ç½®å“ˆå¸Œå‡½æ•°
struct PositionHash {
    size_t operator()(const pair&lt;int, int&gt;& p) const {
        return hash&lt;int&gt;()(p.first) ^ (hash&lt;int&gt;()(p.second) &lt;&lt; 1);
    }
};

class AStar {
private:
    vector&lt;vector&lt;int&gt;&gt; grid;
    int rows, cols;

    // å¯å‘å‡½æ•°
    double heuristic(int x1, int y1, int x2, int y2, const string& method) {
        if (method == "manhattan") {
            return abs(x1 - x2) + abs(y1 - y2);
        } else if (method == "euclidean") {
            return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
        } else if (method == "chebyshev") {
            return max(abs(x1 - x2), abs(y1 - y2));
        } else {
            return 0;  // Dijkstra
        }
    }

    // è·å–é‚»å±…èŠ‚ç‚¹
    vector&lt;pair&lt;int, int&gt;&gt; getNeighbors(int x, int y, bool allowDiagonal) {
        vector&lt;pair&lt;int, int&gt;&gt; neighbors;

        // 4æ–¹å‘
        int dx[] = {0, 1, 0, -1};
        int dy[] = {1, 0, -1, 0};

        for (int i = 0; i &lt; 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx &gt;= 0 && nx &lt; rows && ny &gt;= 0 && ny &lt; cols && grid[nx][ny] == 0) {
                neighbors.push_back({nx, ny});
            }
        }

        // 8æ–¹å‘ï¼ˆå¯¹è§’ï¼‰
        if (allowDiagonal) {
            int dx2[] = {1, 1, -1, -1};
            int dy2[] = {1, -1, 1, -1};

            for (int i = 0; i &lt; 4; i++) {
                int nx = x + dx2[i];
                int ny = y + dy2[i];

                if (nx &gt;= 0 && nx &lt; rows && ny &gt;= 0 && ny &lt; cols && grid[nx][ny] == 0) {
                    // æ£€æŸ¥å¯¹è§’ç§»åŠ¨æ˜¯å¦è¢«é˜»æŒ¡
                    if (grid[x + dx2[i]][y] == 0 || grid[x][y + dy2[i]] == 0) {
                        neighbors.push_back({nx, ny});
                    }
                }
            }
        }

        return neighbors;
    }

    // é‡å»ºè·¯å¾„
    vector&lt;pair&lt;int, int&gt;&gt; reconstructPath(Node* node) {
        vector&lt;pair&lt;int, int&gt;&gt; path;

        while (node != nullptr) {
            path.push_back({node-&gt;x, node-&gt;y});
            node = node-&gt;parent;
        }

        reverse(path.begin(), path.end());
        return path;
    }

public:
    AStar(const vector&lt;vector&lt;int&gt;&gt;& grid) : grid(grid) {
        rows = grid.size();
        cols = grid[0].size();
    }

    // A*æœç´¢
    vector&lt;pair&lt;int, int&gt;&gt; search(pair&lt;int, int&gt; start, pair&lt;int, int&gt; end,
                                   const string& heuristicMethod = "manhattan",
                                   bool allowDiagonal = false) {
        // ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°é¡¶å †ï¼‰
        priority_queue&lt;Node*, vector&lt;Node*&gt;, function&lt;bool(Node*, Node*)&gt;&gt; openList(
            [](Node* a, Node* b) { return a-&gt;f &gt; b-&gt;f; }
        );

        // è®°å½•å·²å¤„ç†çš„èŠ‚ç‚¹
        unordered_set&lt;pair&lt;int, int&gt;, PositionHash&gt; closedSet;

        // è®°å½•åœ¨å¼€æ”¾åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹
        unordered_map&lt;pair&lt;int, int&gt;, Node*, PositionHash&gt; openMap;

        // åˆ›å»ºèµ·ç‚¹
        Node* startNode = new Node(start.first, start.second);
        startNode-&gt;h = heuristic(start.first, start.second, end.first, end.second, heuristicMethod);
        startNode-&gt;f = startNode-&gt;h;

        openList.push(startNode);
        openMap[start] = startNode;

        int nodesExpanded = 0;

        while (!openList.empty()) {
            // å–å‡ºfå€¼æœ€å°çš„èŠ‚ç‚¹
            Node* current = openList.top();
            openList.pop();

            pair&lt;int, int&gt; currentPos = {current-&gt;x, current-&gt;y};
            openMap.erase(currentPos);

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if (currentPos == end) {
                cout &lt;&lt; "æ‰¾åˆ°è·¯å¾„ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š" &lt;&lt; nodesExpanded &lt;&lt; endl;
                return reconstructPath(current);
            }

            // åŠ å…¥å…³é—­åˆ—è¡¨
            closedSet.insert(currentPos);
            nodesExpanded++;

            // æ£€æŸ¥æ‰€æœ‰é‚»å±…
            for (auto& neighborPos : getNeighbors(current-&gt;x, current-&gt;y, allowDiagonal)) {
                // è·³è¿‡å·²å¤„ç†çš„èŠ‚ç‚¹
                if (closedSet.find(neighborPos) != closedSet.end()) {
                    continue;
                }

                // è®¡ç®—ç§»åŠ¨ä»£ä»·
                double moveCost = 1.0;
                if (allowDiagonal &&
                    abs(neighborPos.first - current-&gt;x) + abs(neighborPos.second - current-&gt;y) == 2) {
                    moveCost = 1.414;  // å¯¹è§’ç§»åŠ¨
                }

                double tentativeG = current-&gt;g + moveCost;

                // æ£€æŸ¥æ˜¯å¦å·²åœ¨å¼€æ”¾åˆ—è¡¨ä¸­
                auto it = openMap.find(neighborPos);
                if (it != openMap.end()) {
                    Node* existingNode = it-&gt;second;
                    // å¦‚æœæ–°è·¯å¾„æ›´çŸ­ï¼Œæ›´æ–°
                    if (tentativeG &lt; existingNode-&gt;g) {
                        existingNode-&gt;g = tentativeG;
                        existingNode-&gt;f = existingNode-&gt;g + existingNode-&gt;h;
                        existingNode-&gt;parent = current;
                    }
                } else {
                    // åˆ›å»ºæ–°èŠ‚ç‚¹
                    Node* neighbor = new Node(neighborPos.first, neighborPos.second);
                    neighbor-&gt;g = tentativeG;
                    neighbor-&gt;h = heuristic(neighborPos.first, neighborPos.second,
                                          end.first, end.second, heuristicMethod);
                    neighbor-&gt;f = neighbor-&gt;g + neighbor-&gt;h;
                    neighbor-&gt;parent = current;

                    openList.push(neighbor);
                    openMap[neighborPos] = neighbor;
                }
            }
        }

        cout &lt;&lt; "æœªæ‰¾åˆ°è·¯å¾„ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š" &lt;&lt; nodesExpanded &lt;&lt; endl;
        return {};
    }

    // æ‰“å°è·¯å¾„
    void printPath(const vector&lt;pair&lt;int, int&gt;&gt;& path) {
        if (path.empty()) {
            cout &lt;&lt; "æ²¡æœ‰æ‰¾åˆ°è·¯å¾„" &lt;&lt; endl;
            return;
        }

        // åˆ›å»ºæ˜¾ç¤ºç½‘æ ¼
        vector&lt;vector&lt;char&gt;&gt; display(rows, vector&lt;char&gt;(cols));
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                display[i][j] = (grid[i][j] == 0) ? '.' : '#';
            }
        }

        // æ ‡è®°è·¯å¾„
        for (size_t i = 0; i &lt; path.size(); i++) {
            int x = path[i].first;
            int y = path[i].second;

            if (i == 0) {
                display[x][y] = 'S';  // èµ·ç‚¹
            } else if (i == path.size() - 1) {
                display[x][y] = 'E';  // ç»ˆç‚¹
            } else {
                display[x][y] = '*';  // è·¯å¾„
            }
        }

        // æ‰“å°ç½‘æ ¼
        for (const auto& row : display) {
            for (char cell : row) {
                cout &lt;&lt; cell &lt;&lt; ' ';
            }
            cout &lt;&lt; endl;
        }

        cout &lt;&lt; "è·¯å¾„é•¿åº¦: " &lt;&lt; path.size() - 1 &lt;&lt; endl;
    }
};

int main() {
    // åˆ›å»ºåœ°å›¾ï¼ˆ0: å¯é€šè¡Œ, 1: éšœç¢ç‰©ï¼‰
    vector&lt;vector&lt;int&gt;&gt; grid = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 1, 1, 1, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
        {0, 1, 1, 0, 0, 0, 0, 0, 1, 0},
        {0, 0, 0, 0, 1, 1, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
        {0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };

    AStar astar(grid);

    // è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹
    pair&lt;int, int&gt; start = {0, 0};
    pair&lt;int, int&gt; end = {9, 9};

    cout &lt;&lt; "=== A*ç®—æ³•å¯»è·¯ç¤ºä¾‹ ===" &lt;&lt; endl;

    // æµ‹è¯•ä¸åŒçš„å¯å‘å‡½æ•°
    vector&lt;string&gt; heuristics = {"manhattan", "euclidean", "chebyshev"};

    for (const auto& method : heuristics) {
        cout &lt;&lt; "\nä½¿ç”¨ " &lt;&lt; method &lt;&lt; " å¯å‘å‡½æ•°ï¼š" &lt;&lt; endl;

        auto path = astar.search(start, end, method, method != "manhattan");
        astar.printPath(path);
    }

    return 0;
}</code></pre>
        </div>

        <div id="java-code" class="code-content">
            <button class="copy-btn" onclick="copyCode('java', event)">ğŸ“‹ å¤åˆ¶ä»£ç </button>
            <pre><code>import java.util.*;

public class AStar {

    // èŠ‚ç‚¹ç±»
    static class Node implements Comparable&lt;Node&gt; {
        int x, y;
        double g, h, f;
        Node parent;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
            this.g = 0;
            this.h = 0;
            this.f = 0;
            this.parent = null;
        }

        @Override
        public int compareTo(Node other) {
            return Double.compare(this.f, other.f);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Node node = (Node) obj;
            return x == node.x && y == node.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }

    private int[][] grid;
    private int rows;
    private int cols;

    public AStar(int[][] grid) {
        this.grid = grid;
        this.rows = grid.length;
        this.cols = grid[0].length;
    }

    // å¯å‘å‡½æ•°
    private double heuristic(int x1, int y1, int x2, int y2, String method) {
        switch (method) {
            case "manhattan":
                return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            case "euclidean":
                return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
            case "chebyshev":
                return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
            default:
                return 0; // Dijkstra
        }
    }

    // è·å–é‚»å±…èŠ‚ç‚¹
    private List&lt;Node&gt; getNeighbors(Node node, boolean allowDiagonal) {
        List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();
        int x = node.x;
        int y = node.y;

        // 4æ–¹å‘
        int[][] directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };

        for (int[] dir : directions) {
            int nx = x + dir[0];
            int ny = y + dir[1];

            if (nx &gt;= 0 && nx &lt; rows && ny &gt;= 0 && ny &lt; cols && grid[nx][ny] == 0) {
                neighbors.add(new Node(nx, ny));
            }
        }

        // 8æ–¹å‘ï¼ˆå¯¹è§’ï¼‰
        if (allowDiagonal) {
            int[][] diagonals = { {1, 1}, {1, -1}, {-1, 1}, {-1, -1} };

            for (int[] dir : diagonals) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if (nx &gt;= 0 && nx &lt; rows && ny &gt;= 0 && ny &lt; cols && grid[nx][ny] == 0) {
                    // æ£€æŸ¥å¯¹è§’ç§»åŠ¨æ˜¯å¦è¢«é˜»æŒ¡
                    if (grid[x + dir[0]][y] == 0 || grid[x][y + dir[1]] == 0) {
                        neighbors.add(new Node(nx, ny));
                    }
                }
            }
        }

        return neighbors;
    }

    // é‡å»ºè·¯å¾„
    private List&lt;int[]&gt; reconstructPath(Node node) {
        List&lt;int[]&gt; path = new ArrayList&lt;&gt;();

        while (node != null) {
            path.add(new int[]{node.x, node.y});
            node = node.parent;
        }

        Collections.reverse(path);
        return path;
    }

    // A*æœç´¢
    public List&lt;int[]&gt; search(int[] start, int[] end, String heuristicMethod, boolean allowDiagonal) {
        PriorityQueue&lt;Node&gt; openList = new PriorityQueue&lt;&gt;();
        Set&lt;Node&gt; closedSet = new HashSet&lt;&gt;();
        Map&lt;String, Node&gt; openMap = new HashMap&lt;&gt;();

        // åˆ›å»ºèµ·ç‚¹
        Node startNode = new Node(start[0], start[1]);
        startNode.h = heuristic(start[0], start[1], end[0], end[1], heuristicMethod);
        startNode.f = startNode.h;

        openList.offer(startNode);
        openMap.put(startNode.x + "," + startNode.y, startNode);

        int nodesExpanded = 0;

        while (!openList.isEmpty()) {
            // å–å‡ºfå€¼æœ€å°çš„èŠ‚ç‚¹
            Node current = openList.poll();
            String currentKey = current.x + "," + current.y;
            openMap.remove(currentKey);

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if (current.x == end[0] && current.y == end[1]) {
                System.out.println("æ‰¾åˆ°è·¯å¾„ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š" + nodesExpanded);
                return reconstructPath(current);
            }

            // åŠ å…¥å…³é—­åˆ—è¡¨
            closedSet.add(current);
            nodesExpanded++;

            // æ£€æŸ¥æ‰€æœ‰é‚»å±…
            for (Node neighbor : getNeighbors(current, allowDiagonal)) {
                // è·³è¿‡å·²å¤„ç†çš„èŠ‚ç‚¹
                if (closedSet.contains(neighbor)) {
                    continue;
                }

                // è®¡ç®—ç§»åŠ¨ä»£ä»·
                double moveCost = 1.0;
                if (allowDiagonal &&
                    Math.abs(neighbor.x - current.x) + Math.abs(neighbor.y - current.y) == 2) {
                    moveCost = 1.414; // å¯¹è§’ç§»åŠ¨
                }

                double tentativeG = current.g + moveCost;

                // æ£€æŸ¥æ˜¯å¦å·²åœ¨å¼€æ”¾åˆ—è¡¨ä¸­
                String neighborKey = neighbor.x + "," + neighbor.y;
                Node existingNode = openMap.get(neighborKey);

                if (existingNode != null) {
                    // å¦‚æœæ–°è·¯å¾„æ›´çŸ­ï¼Œæ›´æ–°
                    if (tentativeG &lt; existingNode.g) {
                        existingNode.g = tentativeG;
                        existingNode.f = existingNode.g + existingNode.h;
                        existingNode.parent = current;

                        // é‡æ–°æ’åºä¼˜å…ˆé˜Ÿåˆ—
                        openList.remove(existingNode);
                        openList.offer(existingNode);
                    }
                } else {
                    // åˆ›å»ºæ–°èŠ‚ç‚¹
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor.x, neighbor.y, end[0], end[1], heuristicMethod);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = current;

                    openList.offer(neighbor);
                    openMap.put(neighborKey, neighbor);
                }
            }
        }

        System.out.println("æœªæ‰¾åˆ°è·¯å¾„ï¼æ‰©å±•èŠ‚ç‚¹æ•°ï¼š" + nodesExpanded);
        return null;
    }

    // æ‰“å°è·¯å¾„
    public void printPath(List&lt;int[]&gt; path) {
        if (path == null || path.isEmpty()) {
            System.out.println("æ²¡æœ‰æ‰¾åˆ°è·¯å¾„");
            return;
        }

        // åˆ›å»ºæ˜¾ç¤ºç½‘æ ¼
        char[][] display = new char[rows][cols];
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                display[i][j] = (grid[i][j] == 0) ? '.' : '#';
            }
        }

        // æ ‡è®°è·¯å¾„
        for (int i = 0; i &lt; path.size(); i++) {
            int x = path.get(i)[0];
            int y = path.get(i)[1];

            if (i == 0) {
                display[x][y] = 'S'; // èµ·ç‚¹
            } else if (i == path.size() - 1) {
                display[x][y] = 'E'; // ç»ˆç‚¹
            } else {
                display[x][y] = '*'; // è·¯å¾„
            }
        }

        // æ‰“å°ç½‘æ ¼
        for (char[] row : display) {
            for (char cell : row) {
                System.out.print(cell + " ");
            }
            System.out.println();
        }

        System.out.println("è·¯å¾„é•¿åº¦: " + (path.size() - 1));
    }

    public static void main(String[] args) {
        // åˆ›å»ºåœ°å›¾ï¼ˆ0: å¯é€šè¡Œ, 1: éšœç¢ç‰©ï¼‰
        int[][] grid = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 0, 1, 1, 1, 0},
            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
            {0, 1, 1, 0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 1, 1, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };

        AStar astar = new AStar(grid);

        // è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹
        int[] start = {0, 0};
        int[] end = {9, 9};

        System.out.println("=== A*ç®—æ³•å¯»è·¯ç¤ºä¾‹ ===\n");

        // æµ‹è¯•ä¸åŒçš„å¯å‘å‡½æ•°
        String[] heuristics = {"manhattan", "euclidean", "chebyshev"};

        for (String method : heuristics) {
            System.out.println("\nä½¿ç”¨ " + method + " å¯å‘å‡½æ•°ï¼š");

            List&lt;int[]&gt; path = astar.search(start, end, method, !method.equals("manhattan"));
            astar.printPath(path);
        }
    }
}</code></pre>
        </div>
    </div>

    <!-- å®é™…åº”ç”¨ -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">ğŸŒŸ</span>
            å®é™…åº”ç”¨
        </h2>

        <div class="application-grid">
            <div class="app-card">
                <h3>ğŸ® æ¸¸æˆAIå¯»è·¯</h3>
                <p>å‡ ä¹æ‰€æœ‰RTSã€MOBAæ¸¸æˆéƒ½ä½¿ç”¨A*ç®—æ³•è¿›è¡Œå•ä½ç§»åŠ¨ï¼Œå¦‚æ˜Ÿé™…äº‰éœ¸ã€è‹±é›„è”ç›Ÿ</p>
            </div>

            <div class="app-card">
                <h3>ğŸ¤– æœºå™¨äººå¯¼èˆª</h3>
                <p>æ‰«åœ°æœºå™¨äººã€æ— äººæœºã€è‡ªåŠ¨é©¾é©¶æ±½è½¦çš„è·¯å¾„è§„åˆ’æ ¸å¿ƒç®—æ³•</p>
            </div>

            <div class="app-card">
                <h3>ğŸ—ºï¸ GPSå¯¼èˆª</h3>
                <p>ç»“åˆå®æ—¶è·¯å†µçš„A*å˜ç§ç®—æ³•ï¼Œä¸ºå¸æœºè§„åˆ’æœ€ä¼˜è·¯çº¿</p>
            </div>

            <div class="app-card">
                <h3>ğŸ­ ç‰©æµè§„åˆ’</h3>
                <p>ä»“åº“æœºå™¨äººè·¯å¾„è§„åˆ’ã€é…é€è·¯çº¿ä¼˜åŒ–</p>
            </div>

            <div class="app-card">
                <h3>ğŸ§© æ‹¼å›¾æ±‚è§£</h3>
                <p>å…«æ•°ç ã€åäº”æ•°ç ç­‰æ»‘åŠ¨æ‹¼å›¾æ¸¸æˆçš„è‡ªåŠ¨æ±‚è§£</p>
            </div>

            <div class="app-card">
                <h3>ğŸ“¡ ç½‘ç»œè·¯ç”±</h3>
                <p>è®¡ç®—æœºç½‘ç»œä¸­çš„QoSè·¯ç”±ï¼Œè€ƒè™‘å¸¦å®½ã€å»¶è¿Ÿç­‰å¤šä¸ªå› ç´ </p>
            </div>
        </div>
    </div>

    <!-- å­¦ä¹ æ£€éªŒ -->
    <div class="content-card">
        <h2 class="section-title">
            <span class="section-icon">âœ…</span>
            å­¦ä¹ æ£€éªŒ
        </h2>

        <div class="quiz-item">
            <div class="quiz-question">
                â“ é—®é¢˜1ï¼šä¸ºä»€ä¹ˆA*ç®—æ³•èƒ½ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ï¼Ÿéœ€è¦ä»€ä¹ˆæ¡ä»¶ï¼Ÿ
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(1, event)">æŸ¥çœ‹ç­”æ¡ˆ</button>
            <div id="answer1" class="quiz-answer">
                <strong>ç­”æ¡ˆï¼š</strong>A*ç®—æ³•åœ¨å¯å‘å‡½æ•°æ»¡è¶³<strong>å¯é‡‡çº³æ€§</strong>æ¡ä»¶æ—¶ä¿è¯æœ€ä¼˜ã€‚

                <p><strong>å¯é‡‡çº³æ€§æ¡ä»¶ï¼š</strong>h(n) â‰¤ h*(n)</p>
                <ul>
                    <li>h(n)ï¼šå¯å‘å‡½æ•°çš„ä¼°è®¡å€¼</li>
                    <li>h*(n)ï¼šå®é™…æœ€çŸ­è·ç¦»</li>
                    <li>å³ï¼šå¯å‘å‡½æ•°ä¸èƒ½é«˜ä¼°å®é™…ä»£ä»·</li>
                </ul>

                <p><strong>è¯æ˜æ€è·¯ï¼š</strong></p>
                <ol>
                    <li>å‡è®¾å­˜åœ¨éæœ€ä¼˜è·¯å¾„På…ˆè¢«æ‰¾åˆ°</li>
                    <li>æœ€ä¼˜è·¯å¾„P*ä¸Šå¿…æœ‰èŠ‚ç‚¹nåœ¨å¼€æ”¾åˆ—è¡¨ä¸­</li>
                    <li>å› ä¸ºh(n)ä¸é«˜ä¼°ï¼Œf(n) â‰¤ f*(ç»ˆç‚¹)</li>
                    <li>è€ŒPçš„få€¼ > f*(ç»ˆç‚¹)</li>
                    <li>æ‰€ä»¥nä¼šå…ˆäºPè¢«æ¢ç´¢ï¼ŒçŸ›ç›¾</li>
                </ol>

                <p><strong>å¸¸è§å¯é‡‡çº³å¯å‘å‡½æ•°ï¼š</strong></p>
                <ul>
                    <li>æ›¼å“ˆé¡¿è·ç¦»ï¼ˆç½‘æ ¼4æ–¹å‘ï¼‰</li>
                    <li>æ¬§å‡ é‡Œå¾—è·ç¦»ï¼ˆä»»æ„æ–¹å‘ï¼‰</li>
                    <li>é›¶å¯å‘ï¼ˆé€€åŒ–ä¸ºDijkstraï¼‰</li>
                </ul>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                â“ é—®é¢˜2ï¼šA*ã€Dijkstraã€è´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(2, event)">æŸ¥çœ‹ç­”æ¡ˆ</button>
            <div id="answer2" class="quiz-answer">
                <strong>ç­”æ¡ˆï¼š</strong>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #f0f0f0;">
                        <th style="padding: 10px; border: 1px solid #ddd;">ç®—æ³•</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">è¯„ä¼°å‡½æ•°</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">ç‰¹ç‚¹</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">æœ€ä¼˜æ€§</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>A*</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">f = g + h</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">å¹³è¡¡å·²èµ°å’Œé¢„ä¼°</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âœ… æœ€ä¼˜ï¼ˆhå¯é‡‡çº³ï¼‰</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Dijkstra</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">f = g</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">åªçœ‹å·²èµ°è·ç¦»</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âœ… æœ€ä¼˜</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>è´ªå¿ƒæœ€ä½³ä¼˜å…ˆ</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">f = h</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">åªçœ‹é¢„ä¼°è·ç¦»</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âŒ ä¸ä¿è¯æœ€ä¼˜</td>
                    </tr>
                </table>

                <p><strong>æ•ˆç‡å¯¹æ¯”ï¼š</strong></p>
                <ul>
                    <li>è´ªå¿ƒæœ€å¿«ä½†å¯èƒ½é”™è¿‡æœ€ä¼˜è§£</li>
                    <li>Dijkstraæœ€æ…¢ä½†ä¿è¯æœ€ä¼˜</li>
                    <li>A*åœ¨ä¿è¯æœ€ä¼˜çš„å‰æä¸‹å°½å¯èƒ½å¿«</li>
                </ul>

                <p><strong>æœç´¢èŒƒå›´ï¼š</strong></p>
                <ul>
                    <li>Dijkstraï¼šåœ†å½¢æ‰©æ•£</li>
                    <li>è´ªå¿ƒï¼šç›´å¥”ç›®æ ‡</li>
                    <li>A*ï¼šæ¤­åœ†å½¢ï¼Œåå‘ç›®æ ‡</li>
                </ul>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                â“ é—®é¢˜3ï¼šå¦‚ä½•ä¼˜åŒ–A*ç®—æ³•çš„æ€§èƒ½ï¼Ÿ
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(3, event)">æŸ¥çœ‹ç­”æ¡ˆ</button>
            <div id="answer3" class="quiz-answer">
                <strong>ç­”æ¡ˆï¼š</strong>A*ç®—æ³•æœ‰å¤šç§ä¼˜åŒ–æ–¹æ³•ï¼š

                <p><strong>1. æ•°æ®ç»“æ„ä¼˜åŒ–ï¼š</strong></p>
                <ul>
                    <li>ä½¿ç”¨äºŒå‰å †/æ–æ³¢é‚£å¥‘å †ä¼˜åŒ–ä¼˜å…ˆé˜Ÿåˆ—</li>
                    <li>ä½¿ç”¨å“ˆå¸Œè¡¨åŠ é€ŸæŸ¥æ‰¾</li>
                    <li>ä½è¿ç®—ä¼˜åŒ–çŠ¶æ€è¡¨ç¤º</li>
                </ul>

                <p><strong>2. å¯å‘å‡½æ•°ä¼˜åŒ–ï¼š</strong></p>
                <ul>
                    <li>ä½¿ç”¨æ›´ç²¾ç¡®çš„å¯å‘å‡½æ•°ï¼ˆä½†ä¸èƒ½é«˜ä¼°ï¼‰</li>
                    <li>é¢„è®¡ç®—å¯å‘å€¼ï¼ˆå¦‚æ¨¡å¼æ•°æ®åº“ï¼‰</li>
                    <li>åŠ¨æ€æƒé‡ï¼šw*A*ç®—æ³•ï¼Œf = g + w*h</li>
                </ul>

                <p><strong>3. æœç´¢ç­–ç•¥ä¼˜åŒ–ï¼š</strong></p>
                <ul>
                    <li><strong>åŒå‘A*ï¼š</strong>ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶æœç´¢</li>
                    <li><strong>IDA*ï¼š</strong>è¿­ä»£åŠ æ·±A*ï¼ŒèŠ‚çœå†…å­˜</li>
                    <li><strong>Jump Point Searchï¼š</strong>è·³è¿‡å¯¹ç§°è·¯å¾„</li>
                    <li><strong>åˆ†å±‚è·¯å¾„è§„åˆ’ï¼š</strong>å…ˆç²—ç•¥åç²¾ç»†</li>
                </ul>

                <p><strong>4. å‰ªæä¼˜åŒ–ï¼š</strong></p>
                <ul>
                    <li>è®¾ç½®æœç´¢è¾¹ç•Œ</li>
                    <li>æå‰ç»ˆæ­¢ï¼ˆæ‰¾åˆ°è¶³å¤Ÿå¥½çš„è§£ï¼‰</li>
                    <li>è·¯å¾„å¹³æ»‘åå¤„ç†</li>
                </ul>
            </div>
        </div>

        <div class="quiz-item">
            <div class="quiz-question">
                â“ é—®é¢˜4ï¼šA*ç®—æ³•åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¼šé€€åŒ–ï¼Ÿå¦‚ä½•å¤„ç†ï¼Ÿ
            </div>
            <button class="show-answer-btn" onclick="toggleAnswer(4, event)">æŸ¥çœ‹ç­”æ¡ˆ</button>
            <div id="answer4" class="quiz-answer">
                <strong>ç­”æ¡ˆï¼š</strong>

                <p><strong>é€€åŒ–æƒ…å†µï¼š</strong></p>
                <ol>
                    <li><strong>h = 0ï¼š</strong>é€€åŒ–ä¸ºDijkstraç®—æ³•
                        <ul>
                            <li>æœç´¢èŒƒå›´å‘ˆåœ†å½¢æ‰©æ•£</li>
                            <li>ä¿è¯æœ€ä¼˜ä½†æ•ˆç‡ä½</li>
                        </ul>
                    </li>
                    <li><strong>h >> gï¼š</strong>é€€åŒ–ä¸ºè´ªå¿ƒæœ€ä½³ä¼˜å…ˆ
                        <ul>
                            <li>è¿‡åº¦ä¾èµ–å¯å‘å‡½æ•°</li>
                            <li>å¯èƒ½é”™è¿‡æœ€ä¼˜è§£</li>
                        </ul>
                    </li>
                    <li><strong>hé«˜ä¼°å®é™…ä»£ä»·ï¼š</strong>å¤±å»æœ€ä¼˜æ€§ä¿è¯
                        <ul>
                            <li>å¯èƒ½æ‰¾åˆ°æ¬¡ä¼˜è§£</li>
                            <li>ä½†æœç´¢é€Ÿåº¦å¯èƒ½æ›´å¿«</li>
                        </ul>
                    </li>
                </ol>

                <p><strong>å¤„ç†æ–¹æ³•ï¼š</strong></p>
                <ul>
                    <li><strong>é€‰æ‹©åˆé€‚çš„å¯å‘å‡½æ•°ï¼š</strong>
                        <ul>
                            <li>ç½‘æ ¼ç”¨æ›¼å“ˆé¡¿/åˆ‡æ¯”é›ªå¤«</li>
                            <li>è‡ªç”±ç©ºé—´ç”¨æ¬§å‡ é‡Œå¾—</li>
                        </ul>
                    </li>
                    <li><strong>åŠ¨æ€è°ƒæ•´æƒé‡ï¼š</strong>
                        <ul>
                            <li>å¼€å§‹æ—¶å¢å¤§hæƒé‡å¿«é€Ÿæ¥è¿‘</li>
                            <li>æ¥è¿‘ç›®æ ‡æ—¶å‡å°hæƒé‡ä¿è¯ç²¾åº¦</li>
                        </ul>
                    </li>
                    <li><strong>æ··åˆç­–ç•¥ï¼š</strong>
                        <ul>
                            <li>è¿œè·ç¦»ç”¨A*</li>
                            <li>è¿‘è·ç¦»ç”¨Dijkstra</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>

        <div style="margin-top: 30px; padding: 20px; background: #e3f2fd; border-radius: 8px;">
            <h4>ğŸ“š è¿›é˜¶å­¦ä¹ å»ºè®®</h4>
            <ol>
                <li><strong>å®ç°å˜ç§ï¼š</strong>IDA*ã€åŒå‘A*ã€D*ç®—æ³•</li>
                <li><strong>ä¼˜åŒ–æŠ€æœ¯ï¼š</strong>Jump Point Searchã€Theta*</li>
                <li><strong>åº”ç”¨åœºæ™¯ï¼š</strong>å¤šæ™ºèƒ½ä½“å¯»è·¯ã€åŠ¨æ€ç¯å¢ƒå¯»è·¯</li>
                <li><strong>ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š</strong>RRTã€äººå·¥åŠ¿åœºæ³•ã€å¼ºåŒ–å­¦ä¹ è·¯å¾„è§„åˆ’</li>
            </ol>
        </div>
    </div>

    <!-- è¿”å›å¯¼èˆª -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>ğŸ </span>
            è¿”å›é¦–é¡µ
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>ğŸŒŒ</span>
            æ¢ç´¢CSå®‡å®™
        </a>
    </div>
</div>

<script>
// Canvasç›¸å…³ä»£ç 
const canvas = document.getElementById('astarCanvas');
const ctx = canvas.getContext('2d');

// ç½‘æ ¼é…ç½®
const GRID_SIZE = 20;  // ç½‘æ ¼å¤§å° 20x20
const CELL_SIZE = 30;  // æ¯ä¸ªæ ¼å­çš„åƒç´ å¤§å°

// ç½‘æ ¼ç±»
class Grid {
    constructor() {
        this.cells = [];
        this.start = null;
        this.end = null;
        this.path = [];
        this.openList = [];
        this.closedList = [];
        this.init();
    }

    init() {
        // åˆå§‹åŒ–ç½‘æ ¼
        for (let i = 0; i < GRID_SIZE; i++) {
            this.cells[i] = [];
            for (let j = 0; j < GRID_SIZE; j++) {
                this.cells[i][j] = {
                    x: i,
                    y: j,
                    wall: false,
                    g: 0,
                    h: 0,
                    f: 0,
                    parent: null
                };
            }
        }

        // è®¾ç½®é»˜è®¤èµ·ç‚¹å’Œç»ˆç‚¹
        this.setStart(1, 1);
        this.setEnd(GRID_SIZE - 2, GRID_SIZE - 2);
    }

    setStart(x, y) {
        if (this.cells[x][y].wall) return false;
        this.start = { x, y };
        return true;
    }

    setEnd(x, y) {
        if (this.cells[x][y].wall) return false;
        this.end = { x, y };
        return true;
    }

    toggleWall(x, y) {
        if ((x === this.start.x && y === this.start.y) ||
            (x === this.end.x && y === this.end.y)) {
            return false;
        }
        this.cells[x][y].wall = !this.cells[x][y].wall;
        return true;
    }

    reset() {
        this.path = [];
        this.openList = [];
        this.closedList = [];

        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const cell = this.cells[i][j];
                cell.g = 0;
                cell.h = 0;
                cell.f = 0;
                cell.parent = null;
            }
        }
    }

    clear() {
        this.init();
    }
}

// A*ç®—æ³•å®ç°
class AStarAlgorithm {
    constructor(grid) {
        this.grid = grid;
        this.heuristicMethod = 'manhattan';
        this.animationRunning = false;
        this.startTime = 0;
    }

    heuristic(pos1, pos2) {
        const dx = Math.abs(pos1.x - pos2.x);
        const dy = Math.abs(pos1.y - pos2.y);

        switch (this.heuristicMethod) {
            case 'manhattan':
                return dx + dy;
            case 'euclidean':
                return Math.sqrt(dx * dx + dy * dy);
            case 'chebyshev':
                return Math.max(dx, dy);
            case 'zero':
                return 0;
            default:
                return dx + dy;
        }
    }

    getNeighbors(node) {
        const neighbors = [];
        const x = node.x;
        const y = node.y;

        // 4æ–¹å‘
        const directions = [
            { dx: 0, dy: 1 },
            { dx: 1, dy: 0 },
            { dx: 0, dy: -1 },
            { dx: -1, dy: 0 }
        ];

        // å¦‚æœä¸æ˜¯æ›¼å“ˆé¡¿è·ç¦»ï¼Œæ·»åŠ å¯¹è§’æ–¹å‘
        if (this.heuristicMethod !== 'manhattan') {
            directions.push(
                { dx: 1, dy: 1 },
                { dx: 1, dy: -1 },
                { dx: -1, dy: 1 },
                { dx: -1, dy: -1 }
            );
        }

        for (let dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;

            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (!this.grid.cells[nx][ny].wall) {
                    neighbors.push(this.grid.cells[nx][ny]);
                }
            }
        }

        return neighbors;
    }

    async search() {
        this.grid.reset();
        this.animationRunning = true;
        this.startTime = Date.now();

        const start = this.grid.cells[this.grid.start.x][this.grid.start.y];
        const end = this.grid.cells[this.grid.end.x][this.grid.end.y];

        const openList = [start];
        const closedList = [];

        start.h = this.heuristic(start, end);
        start.f = start.h;

        while (openList.length > 0 && this.animationRunning) {
            // æ‰¾åˆ°få€¼æœ€å°çš„èŠ‚ç‚¹
            let current = openList[0];
            let currentIndex = 0;

            for (let i = 1; i < openList.length; i++) {
                if (openList[i].f < current.f) {
                    current = openList[i];
                    currentIndex = i;
                }
            }

            // ä»å¼€æ”¾åˆ—è¡¨ç§»é™¤
            openList.splice(currentIndex, 1);
            closedList.push(current);

            // æ›´æ–°å¯è§†åŒ–
            this.grid.openList = openList.map(n => ({ x: n.x, y: n.y }));
            this.grid.closedList = closedList.map(n => ({ x: n.x, y: n.y }));

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if (current.x === end.x && current.y === end.y) {
                // é‡å»ºè·¯å¾„
                const path = [];
                let temp = current;
                while (temp) {
                    path.push({ x: temp.x, y: temp.y });
                    temp = temp.parent;
                }
                this.grid.path = path.reverse();

                const timeElapsed = Date.now() - this.startTime;
                updateStats(path.length - 1, closedList.length, openList.length, timeElapsed);
                updateLog(`âœ… æ‰¾åˆ°è·¯å¾„ï¼é•¿åº¦ï¼š${path.length - 1}ï¼Œæ‰©å±•èŠ‚ç‚¹ï¼š${closedList.length}`);

                this.animationRunning = false;
                return true;
            }

            // æ£€æŸ¥é‚»å±…
            const neighbors = this.getNeighbors(current);

            for (let neighbor of neighbors) {
                if (closedList.includes(neighbor)) continue;

                const isDiagonal = Math.abs(neighbor.x - current.x) +
                                  Math.abs(neighbor.y - current.y) === 2;
                const moveCost = isDiagonal ? 1.414 : 1;
                const tentativeG = current.g + moveCost;

                if (!openList.includes(neighbor)) {
                    openList.push(neighbor);
                } else if (tentativeG >= neighbor.g) {
                    continue;
                }

                neighbor.parent = current;
                neighbor.g = tentativeG;
                neighbor.h = this.heuristic(neighbor, end);
                neighbor.f = neighbor.g + neighbor.h;
            }

            drawGrid();
            await sleep(animationSpeed);
        }

        const timeElapsed = Date.now() - this.startTime;
        updateStats(0, closedList.length, openList.length, timeElapsed);
        updateLog('âŒ æœªæ‰¾åˆ°è·¯å¾„ï¼');
        this.animationRunning = false;
        return false;
    }

    step() {
        // å•æ­¥æ‰§è¡Œï¼ˆç®€åŒ–ç‰ˆï¼‰
        // å®é™…å®ç°éœ€è¦ä¿å­˜çŠ¶æ€
        updateLog('å•æ­¥æ‰§è¡ŒåŠŸèƒ½å¼€å‘ä¸­...');
    }
}

// å…¨å±€å˜é‡
const grid = new Grid();
const astar = new AStarAlgorithm(grid);
let animationSpeed = 50;
let currentMode = 'wall';

// ç»˜åˆ¶ç½‘æ ¼
function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç»˜åˆ¶ç½‘æ ¼çº¿
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;

    for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
        ctx.stroke();
    }

    // ç»˜åˆ¶å•å…ƒæ ¼
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            const cell = grid.cells[i][j];
            let color = '#fff';

            // ç¡®å®šé¢œè‰²
            if (cell.wall) {
                color = '#333';
            } else if (grid.start && i === grid.start.x && j === grid.start.y) {
                color = '#4CAF50';
            } else if (grid.end && i === grid.end.x && j === grid.end.y) {
                color = '#f44336';
            } else if (grid.path.some(p => p.x === i && p.y === j)) {
                color = '#9C27B0';
            } else if (grid.closedList.some(p => p.x === i && p.y === j)) {
                color = '#FFD700';
            } else if (grid.openList.some(p => p.x === i && p.y === j)) {
                color = '#87CEEB';
            }

            // å¡«å……é¢œè‰²
            if (color !== '#fff') {
                ctx.fillStyle = color;
                ctx.fillRect(i * CELL_SIZE + 1, j * CELL_SIZE + 1,
                           CELL_SIZE - 2, CELL_SIZE - 2);
            }

            // æ˜¾ç¤ºfå€¼ï¼ˆè°ƒè¯•ç”¨ï¼‰
            if (cell.f > 0 && !cell.wall) {
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cell.f),
                           i * CELL_SIZE + CELL_SIZE/2,
                           j * CELL_SIZE + CELL_SIZE/2);
            }
        }
    }
}

// Canvasç‚¹å‡»äº‹ä»¶
canvas.addEventListener('click', (e) => {
    if (astar.animationRunning) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
    const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

    switch (currentMode) {
        case 'wall':
            grid.toggleWall(x, y);
            break;
        case 'start':
            if (grid.setStart(x, y)) {
                updateLog(`ğŸŸ¢ èµ·ç‚¹è®¾ç½®ä¸º (${x}, ${y})`);
            }
            break;
        case 'end':
            if (grid.setEnd(x, y)) {
                updateLog(`ğŸ”´ ç»ˆç‚¹è®¾ç½®ä¸º (${x}, ${y})`);
            }
            break;
    }

    grid.reset();
    drawGrid();
});

// æ§åˆ¶å‡½æ•°
function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
}

function startSearch() {
    if (astar.animationRunning) return;
    astar.search();
}

function stepSearch() {
    if (astar.animationRunning) return;
    astar.step();
}

function resetGrid() {
    astar.animationRunning = false;
    grid.reset();
    drawGrid();
    updateStats(0, 0, 0, 0);
    updateLog('ğŸ”„ è·¯å¾„å·²é‡ç½®');
}

function clearGrid() {
    astar.animationRunning = false;
    grid.clear();
    drawGrid();
    updateStats(0, 0, 0, 0);
    updateLog('ğŸ—‘ï¸ ç½‘æ ¼å·²æ¸…ç©º');
}

function generateMaze() {
    astar.animationRunning = false;
    grid.clear();

    // éšæœºç”Ÿæˆéšœç¢ç‰©
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (Math.random() < 0.3) {  // 30%æ¦‚ç‡ç”Ÿæˆå¢™
                grid.toggleWall(i, j);
            }
        }
    }

    drawGrid();
    updateLog('ğŸ² éšæœºè¿·å®«å·²ç”Ÿæˆ');
}

function changeHeuristic() {
    const select = document.getElementById('heuristicSelect');
    astar.heuristicMethod = select.value;
    updateLog(`ğŸ”§ å¯å‘å‡½æ•°åˆ‡æ¢ä¸ºï¼š${select.options[select.selectedIndex].text}`);
}

// è¾…åŠ©å‡½æ•°
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function updateLog(message) {
    document.getElementById('logText').innerHTML = message;
}

function updateStats(pathLength, expanded, inOpen, time) {
    document.getElementById('pathLength').textContent = pathLength;
    document.getElementById('nodesExpanded').textContent = expanded;
    document.getElementById('nodesInOpen').textContent = inOpen;
    document.getElementById('timeElapsed').textContent = time + 'ms';
}

// ä»£ç åˆ‡æ¢
function switchCode(lang, event) {
    document.querySelectorAll('.code-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.code-content').forEach(content => content.classList.remove('active'));

    event.target.classList.add('active');
    document.getElementById(`${lang}-code`).classList.add('active');
}

// å¤åˆ¶ä»£ç 
function copyCode(lang, event) {
    const codeElement = document.getElementById(`${lang}-code`).querySelector('code');
    const text = codeElement.textContent;

    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²å¤åˆ¶ï¼';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }).catch(err => {
        // é™çº§æ–¹æ¡ˆ
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();

        try {
            document.execCommand('copy');
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ… å·²å¤åˆ¶ï¼';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        } catch (err) {
            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»£ç ');
        }

        document.body.removeChild(textArea);
    });
}

// æ˜¾ç¤º/éšè—ç­”æ¡ˆ
function toggleAnswer(num, event) {
    const answer = document.getElementById(`answer${num}`);
    const btn = event.target;

    if (answer.style.display === 'block') {
        answer.style.display = 'none';
        btn.textContent = 'æŸ¥çœ‹ç­”æ¡ˆ';
    } else {
        answer.style.display = 'block';
        btn.textContent = 'éšè—ç­”æ¡ˆ';
    }
}

// é€Ÿåº¦æ§åˆ¶
document.getElementById('speedSlider').addEventListener('input', (e) => {
    animationSpeed = parseInt(e.target.value);
    document.getElementById('speedValue').textContent = `${animationSpeed}ms`;
});

// åˆå§‹åŒ–
drawGrid();
updateStats(0, 0, 0, 0);
</script>

{% endblock %}