{% extends 'knowledge_app/base.html' %}

{% block title %}二叉树四序遍历 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>二叉树四序遍历</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🌳</span>
            二叉树四序遍历
        </h1><p>掌握二叉树的四种遍历方式：前序、中序、后序、层次遍历</p></div><!-- 📋 知识点概述 --><div class="content-card slide-in-right"><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                知识点概述
            </h2><div class="overview-content"><div class="concept-intro"><h3>核心概念</h3><p>二叉树遍历就像按不同路线游览一座城市，每条路线都能访问所有景点，但顺序不同。四序遍历提供了四种不同的"游览路线"来访问树中的每个节点。</p></div><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">📚</span><div><strong>学习难度：</strong>入门
                            <br><strong>前置知识：</strong>二叉树基本概念、递归思想
                        </div></div><div class="info-box info-box-success"><span class="info-icon">⏱️</span><div><strong>学习时间：</strong>30-45分钟
                            <br><strong>重要程度：</strong>⭐⭐⭐⭐⭐
                        </div></div></div><div class="terms-list"><h4>🔑 关键术语</h4><div class="unified-grid unified-grid-2"><div class="term-item"><strong>前序遍历：</strong>根→左→右的访问顺序
                        </div><div class="term-item"><strong>中序遍历：</strong>左→根→右的访问顺序
                        </div><div class="term-item"><strong>后序遍历：</strong>左→右→根的访问顺序
                        </div><div class="term-item"><strong>层次遍历：</strong>按树的层级从上到下、从左到右访问
                        </div></div></div></div></div></div><!-- 📖 概念详解 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📖</span>
                概念详解
            </h2><div class="concept-details"><div class="concept-item"><h3>🎯 前序遍历 (Pre-order)</h3><p><strong>口诀：根左右</strong></p><p>就像老师点名一样，先叫班长（根节点），再叫左边的同学，最后叫右边的同学。这种方式常用于复制树结构。</p><div class="example-box"><strong>生活例子：</strong>打扫房间时，先整理桌面（根），再整理左抽屉（左子树），最后整理右抽屉（右子树）。
                    </div></div><div class="concept-item"><h3>🎯 中序遍历 (In-order)</h3><p><strong>口诀：左根右</strong></p><p>对于二叉搜索树，中序遍历能得到升序排列的结果！就像从小到大数数一样自然。</p><div class="example-box"><strong>生活例子：</strong>阅读书籍时，先看左页（左子树），再看书脊页码（根），最后看右页（右子树）。
                    </div></div><div class="concept-item"><h3>🎯 后序遍历 (Post-order)</h3><p><strong>口诀：左右根</strong></p><p>就像拆房子一样，要先拆除左边和右边的附属建筑，最后才能拆主体建筑。常用于释放内存。</p><div class="example-box"><strong>生活例子：</strong>计算文件夹大小时，先计算子文件夹（左右子树），最后加上当前文件夹（根）的大小。
                    </div></div><div class="concept-item"><h3>🎯 层次遍历 (Level-order)</h3><p><strong>特点：广度优先</strong></p><p>像水波纹扩散一样，一层一层地访问节点。需要借助队列数据结构实现。</p><div class="example-box"><strong>生活例子：</strong>公司汇报工作，CEO先汇报，然后各部门经理汇报，最后普通员工汇报。
                    </div></div><div class="info-box info-box-warning"><span class="info-icon">⚠️</span><strong>初学者易混淆点：</strong><ul><li>前、中、后序的"序"指的是根节点的访问时机，不是整体顺序</li><li>层次遍历使用队列，其他三种使用递归（本质是栈）</li><li>中序遍历对二叉搜索树有特殊意义（升序输出）</li></ul></div></div></div></div><!-- 📊 可视化展示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                交互式可视化演示
            </h2><div class="visualization-container"><div class="demo-description"><p>点击下方按钮，观看不同遍历方式的动画演示。注意观察节点的访问顺序和路径！</p></div><!-- 集成原有的canvas动画 --><div class="canvas-demo"><div class="controls"><button class="preorder" onclick="startTraversal('preorder')">🔴 前序遍历</button><button class="inorder" onclick="startTraversal('inorder')">🟢 中序遍历</button><button class="postorder" onclick="startTraversal('postorder')">🔵 后序遍历</button><button class="levelorder" onclick="startTraversal('levelorder')">🟣 层次遍历</button><button class="reset" onclick="resetAnimation()">🔄 重置</button></div><div class="canvas-container"><canvas id="treeCanvas" width="800" height="400"></canvas></div><div class="info"><div class="info-box"><h4>遍历序列</h4><div class="sequence" id="sequence"></div><div class="status" id="status">选择一种遍历方式开始演示</div></div><div class="info-box"><h4>当前操作</h4><div class="sequence" id="currentAction">等待开始...</div><div class="status" id="stepInfo">点击按钮开始遍历动画</div></div></div></div></div></div></div><!-- 💻 代码实现 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">💻</span>
                代码实现
            </h2><div class="code-implementation"><div class="code-tabs"><button class="tab-btn active" onclick="showCode('cpp')">C++</button><button class="tab-btn" onclick="showCode('java')">Java</button><button class="tab-btn" onclick="showCode('python')">Python</button></div><div id="cpp-code" class="code-content active"><div class="code-header"><span>C++ 实现</span><button onclick="copyCode('cpp', this)" class="copy-btn">📋 复制代码</button></div><pre><code id="cpp-source">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class TreeTraversal {
public:
    // 前序遍历：根 -> 左 -> 右
    void preorder(TreeNode* root) {
        if (!root) return;
        cout << root->val << " ";  // 先访问根
        preorder(root->left);      // 再访问左子树
        preorder(root->right);     // 最后访问右子树
    }

    // 中序遍历：左 -> 根 -> 右
    void inorder(TreeNode* root) {
        if (!root) return;
        inorder(root->left);       // 先访问左子树
        cout << root->val << " ";  // 再访问根
        inorder(root->right);      // 最后访问右子树
    }

    // 后序遍历：左 -> 右 -> 根
    void postorder(TreeNode* root) {
        if (!root) return;
        postorder(root->left);     // 先访问左子树
        postorder(root->right);    // 再访问右子树
        cout << root->val << " ";  // 最后访问根
    }

    // 层次遍历：使用队列实现
    void levelorder(TreeNode* root) {
        if (!root) return;
        queue&lt;TreeNode*&gt; q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            cout << node->val << " ";

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
};</code></pre></div><div id="java-code" class="code-content"><div class="code-header"><span>Java 实现</span><button onclick="copyCode('java', this)" class="copy-btn">📋 复制代码</button></div><pre><code id="java-source">import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class TreeTraversal {
    // 前序遍历：根 -> 左 -> 右
    public void preorder(TreeNode root) {
        if (root == null) return;
        System.out.print(root.val + " ");  // 先访问根
        preorder(root.left);               // 再访问左子树
        preorder(root.right);              // 最后访问右子树
    }

    // 中序遍历：左 -> 根 -> 右
    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);                // 先访问左子树
        System.out.print(root.val + " ");  // 再访问根
        inorder(root.right);               // 最后访问右子树
    }

    // 后序遍历：左 -> 右 -> 根
    public void postorder(TreeNode root) {
        if (root == null) return;
        postorder(root.left);              // 先访问左子树
        postorder(root.right);             // 再访问右子树
        System.out.print(root.val + " ");  // 最后访问根
    }

    // 层次遍历：使用队列实现
    public void levelorder(TreeNode root) {
        if (root == null) return;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + " ");

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
}</code></pre></div><div id="python-code" class="code-content"><div class="code-header"><span>Python 实现</span><button onclick="copyCode('python', this)" class="copy-btn">📋 复制代码</button></div><pre><code id="python-source">from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeTraversal:
    # 前序遍历：根 -> 左 -> 右
    def preorder(self, root):
        if not root:
            return
        print(root.val, end=" ")  # 先访问根
        self.preorder(root.left)  # 再访问左子树
        self.preorder(root.right) # 最后访问右子树

    # 中序遍历：左 -> 根 -> 右
    def inorder(self, root):
        if not root:
            return
        self.inorder(root.left)   # 先访问左子树
        print(root.val, end=" ")  # 再访问根
        self.inorder(root.right)  # 最后访问右子树

    # 后序遍历：左 -> 右 -> 根
    def postorder(self, root):
        if not root:
            return
        self.postorder(root.left)  # 先访问左子树
        self.postorder(root.right) # 再访问右子树
        print(root.val, end=" ")   # 最后访问根

    # 层次遍历：使用队列实现
    def levelorder(self, root):
        if not root:
            return
        queue = deque([root])

        while queue:
            node = queue.popleft()
            print(node.val, end=" ")

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)</code></pre></div></div></div></div><!-- 🌟 实际应用 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌟</span>
                实际应用
            </h2><div class="applications"><div class="unified-grid unified-grid-2"><div class="app-item"><h4>🗂️ 文件系统遍历</h4><p><strong>前序遍历：</strong>复制整个文件夹结构</p><p><strong>后序遍历：</strong>计算文件夹大小、删除文件夹</p><p><strong>层次遍历：</strong>按目录层级显示文件</p></div><div class="app-item"><h4>🔍 搜索引擎</h4><p><strong>前序遍历：</strong>索引网站结构</p><p><strong>中序遍历：</strong>获取排序结果</p><p><strong>层次遍历：</strong>广度优先搜索相关内容</p></div><div class="app-item"><h4>🧮 表达式求值</h4><p><strong>前序：</strong>前缀表达式（+ 1 2）</p><p><strong>中序：</strong>中缀表达式（1 + 2）</p><p><strong>后序：</strong>后缀表达式（1 2 +）</p></div><div class="app-item"><h4>🎮 游戏开发</h4><p><strong>层次遍历：</strong>AI寻路算法</p><p><strong>前序遍历：</strong>场景对象渲染</p><p><strong>后序遍历：</strong>资源释放管理</p></div></div></div></div></div><!-- ✅ 学习检验 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">✅</span>
                学习检验
            </h2><div class="quiz-section"><div class="quiz-item"><h4>🤔 问题1：遍历结果判断</h4><p>给定二叉树结构如下（根节点为A），请写出四种遍历的结果：</p><pre class="tree-structure">
        A
       / \
      B   C
     / \   \
    D   E   F
                    </pre><button class="quiz-btn" onclick="toggleAnswer(1)">点击查看答案</button><div id="answer1" class="quiz-answer"><strong>答案：</strong><br>
                        • 前序遍历：A → B → D → E → C → F<br>
                        • 中序遍历：D → B → E → A → C → F<br>
                        • 后序遍历：D → E → B → F → C → A<br>
                        • 层次遍历：A → B → C → D → E → F
                    </div></div><div class="quiz-item"><h4>🤔 问题2：应用场景选择</h4><p>如果你要实现一个功能来删除整棵二叉树并释放内存，应该选择哪种遍历方式？为什么？</p><button class="quiz-btn" onclick="toggleAnswer(2)">点击查看答案</button><div id="answer2" class="quiz-answer"><strong>答案：</strong>后序遍历<br><strong>原因：</strong>后序遍历先访问子节点，后访问父节点。这样可以确保在删除父节点之前，所有子节点都已经被删除，避免了悬空指针的问题。就像拆房子要先拆附属建筑，最后拆主体建筑一样。
                    </div></div><div class="quiz-item"><h4>🤔 问题3：算法复杂度</h4><p>所有四种遍历算法的时间复杂度和空间复杂度分别是多少？</p><button class="quiz-btn" onclick="toggleAnswer(3)">点击查看答案</button><div id="answer3" class="quiz-answer"><strong>答案：</strong><br><strong>时间复杂度：</strong>都是 O(n)，其中n是节点数量，因为每个节点都要访问一次<br><strong>空间复杂度：</strong><br>
                        • 前序、中序、后序：O(h)，其中h是树的高度（递归栈的深度）<br>
                        • 层次遍历：O(w)，其中w是树的最大宽度（队列的最大长度）
                    </div></div><div class="quiz-item"><h4>🤔 问题4：特殊性质</h4><p>为什么说中序遍历对二叉搜索树（BST）有特殊意义？</p><button class="quiz-btn" onclick="toggleAnswer(4)">点击查看答案</button><div id="answer4" class="quiz-answer"><strong>答案：</strong>因为二叉搜索树的特性是左子树的所有节点都小于根节点，右子树的所有节点都大于根节点。中序遍历的顺序是"左→根→右"，所以对BST进行中序遍历会得到一个严格递增的数字序列。这个特性可以用来：<br>
                        • 验证一棵树是否为BST<br>
                        • 获取BST中的有序数据<br>
                        • 找到BST中的第k小元素
                    </div></div></div><div class="next-steps"><h4>🚀 下一步学习建议</h4><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">📖</span><strong>继续学习：</strong>二叉搜索树、AVL树、红黑树
                    </div><div class="info-box info-box-success"><span class="info-icon">💪</span><strong>练习建议：</strong>LeetCode相关题目，手画遍历过程
                    </div></div></div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><style>.page-container {max-width:1200px;margin:0 auto;padding:20px;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif}.breadcrumb {margin-bottom:20px;font-size:14px;color:#666}.page-header {text-align:center;margin-bottom:30px}.page-header h1 {font-size:2.5rem;color:#333;margin-bottom:10px}.page-icon {font-size:3rem;margin-right:15px}.content-card {background:white;border-radius:12px;padding:30px;margin-bottom:20px;box-shadow:0 2px 12px rgba(0,0,0,0.1)}.section-title {font-size:1.5rem;color:#333;margin-bottom:20px;display:flex;align-items:center;gap:10px}.section-icon {font-size:1.8rem}.unified-grid {display:grid;gap:20px}.unified-grid-2 {grid-template-columns:repeat(auto-fit, minmax(300px, 1fr))}.unified-grid-3 {grid-template-columns:repeat(auto-fit, minmax(250px, 1fr))}.info-box {padding:20px;border-radius:8px;border-left:4px solid #4299e1}.info-box-info {background:#ebf8ff;border-left-color:#4299e1}.info-box-success {background:#f0fff4;border-left-color:#48bb78}.info-box-warning {background:#fffaf0;border-left-color:#ed8936}.info-icon {margin-right:8px}.concept-item {margin-bottom:25px;padding:20px;background:#f8f9fa;border-radius:8px}.concept-item h3 {color:#2d3748;margin-bottom:10px}.example-box {margin-top:15px;padding:15px;background:#e6fffa;border-left:4px solid #38b2ac;border-radius:4px}.terms-list .unified-grid-2 {margin-top:15px}.term-item {padding:12px;background:white;border-radius:6px;border-left:3px solid #4299e1}.canvas-demo {background:white;border-radius:15px;padding:25px;box-shadow:0 4px 20px rgba(0,0,0,0.1)}.controls {display:flex;justify-content:center;gap:15px;margin-bottom:25px;flex-wrap:wrap}.controls button {padding:12px 20px;border:none;border-radius:25px;cursor:pointer;font-size:16px;font-weight:bold;transition:all 0.3s ease;color:white}.preorder {background:linear-gradient(45deg, #ff6b6b, #ee5a52)}.inorder {background:linear-gradient(45deg, #4ecdc4, #44a08d)}.postorder {background:linear-gradient(45deg, #45b7d1, #96c93d)}.levelorder {background:linear-gradient(45deg, #f093fb, #f5576c)}.reset {background:linear-gradient(45deg, #4a5568, #2d3748)}.controls button:hover {transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,0.15)}.canvas-container {display:flex;justify-content:center;margin-bottom:20px}#treeCanvas {border:2px solid #e2e8f0;border-radius:10px;background:white}.info {display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px}.info .info-box {background:#f7fafc;border:1px solid #e2e8f0}.info h4 {margin-top:0;color:#2d3748}.sequence {font-size:16px;font-weight:bold;color:#4299e1;min-height:20px}.status {font-size:14px;color:#718096;margin-top:8px}.code-tabs {display:flex;border-bottom:1px solid #e2e8f0;margin-bottom:20px}.tab-btn {padding:12px 24px;border:none;background:none;cursor:pointer;font-size:16px;border-bottom:2px solid transparent;transition:all 0.3s ease}.tab-btn.active {color:#4299e1;border-bottom-color:#4299e1}.code-content {display:none}.code-content.active {display:block}.code-header {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.copy-btn {background:#4299e1;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px}.copy-btn:hover {background:#3182ce}pre {background:#2d3748;color:#e2e8f0;padding:20px;border-radius:8px;overflow-x:auto;line-height:1.6;font-size:14px}.app-item {padding:20px;background:#f8f9fa;border-radius:8px;border-left:4px solid #4299e1}.app-item h4 {color:#2d3748;margin-bottom:15px}.quiz-item {margin-bottom:25px;padding:20px;border:1px solid #e2e8f0;border-radius:8px}.quiz-btn {background:#4299e1;color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-top:15px;transition:background 0.3s ease}.quiz-btn:hover {background:#3182ce}.quiz-answer {display:none;margin-top:15px;padding:15px;background:#f0fff4;border-left:4px solid #48bb78;border-radius:4px}.quiz-answer.show {display:block}.tree-structure {background:#f7fafc;color:#2d3748;font-family:'Courier New', monospace;text-align:center;margin:15px 0}.unified-btn {display:inline-block;padding:12px 24px;border-radius:8px;text-decoration:none;font-weight:500;margin:0 10px;transition:all 0.3s ease}.unified-btn-primary {background:#4299e1;color:white}.unified-btn-secondary {background:#718096;color:white}.unified-btn:hover {transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.15)}.legend {background:#f8f9fa;border-radius:8px;padding:15px;margin:20px 0;border:1px solid #e2e8f0}.legend h4 {margin:0 0 15px 0;color:#2d3748;font-size:16px}.legend-items {display:flex;flex-wrap:wrap;gap:15px;justify-content:center;margin-bottom:20px}.legend-item {display:flex;align-items:center;gap:8px;padding:5px 10px;background:white;border-radius:6px;box-shadow:0 2px 4px rgba(0,0,0,0.1)}.legend-color {width:20px;height:20px;border-radius:50%;flex-shrink:0}.legend-color.pulsing {animation:pulse 1s infinite}.arrow-example {width:30px;height:20px;position:relative;flex-shrink:0}.down-arrow::after {content:'';position:absolute;left:50%;top:2px;transform:translateX(-50%);width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid #22c55e}.down-arrow::before {content:'递';position:absolute;left:50%;bottom:0;transform:translateX(-50%);font-size:10px;color:#16a34a;font-weight:bold}.up-arrow::after {content:'';position:absolute;left:50%;bottom:2px;transform:translateX(-50%);width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:12px solid #3b82f6}.up-arrow::before {content:'归';position:absolute;left:50%;top:0;transform:translateX(-50%);font-size:10px;color:#1d4ed8;font-weight:bold}.number-example {width:20px;height:20px;border-radius:50%;background:#2d3748;color:white;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:bold;flex-shrink:0}@keyframes pulse {0% {transform:scale(1)}50% {transform:scale(1.1)}100% {transform:scale(1)}}.legend-item span {font-size:14px;color:#4a5568;font-weight:500}@media (max-width:768px) {.info {grid-template-columns:1fr}.controls {flex-direction:column;align-items:center}.controls button {width:200px}.unified-grid-2, .unified-grid-3 {grid-template-columns:1fr}.legend-items {justify-content:flex-start}}</style><script>const canvas = document.getElementById('treeCanvas'); const ctx = canvas.getContext('2d'); class TreeNode { constructor(val, x, y) { this.val = val; this.x = x; this.y = y; this.left = null; this.right = null; this.visited = false; this.current = false; this.completed = false; this.processing = false; this.inPath = false; this.visitOrder = 0; this.arrows = []; } } function createSampleTree() { const root = new TreeNode('A', 400, 80); root.left = new TreeNode('B', 250, 140); root.right = new TreeNode('C', 550, 140); root.left.left = new TreeNode('D', 150, 200); root.left.right = new TreeNode('E', 350, 200); root.right.left = new TreeNode('F', 450, 200); root.right.right = new TreeNode('G', 650, 200); function initArrows(node) { if (node) { node.arrows = []; initArrows(node.left); initArrows(node.right); } } initArrows(root); return root; } let tree = createSampleTree(); let animationState = { isAnimating: false, currentTraversal: '', sequence: [], step: 0, visitCounter: 0 }; function drawNode(node) { if (node.visitOrder && node.visitOrder > 0) { ctx.beginPath(); ctx.arc(node.x - 35, node.y - 25, 12, 0, 2 * Math.PI); ctx.fillStyle = '#2d3748'; ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(node.visitOrder.toString(), node.x - 35, node.y - 25); } ctx.beginPath(); ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI); if (node.current) { const pulseSize = 25 + Math.sin(Date.now() * 0.008) * 3; ctx.beginPath(); ctx.arc(node.x, node.y, pulseSize, 0, 2 * Math.PI); ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#cc0000'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(node.x, node.y, pulseSize + 8, 0, 2 * Math.PI); ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)'; ctx.lineWidth = 6; ctx.stroke(); ctx.beginPath(); ctx.arc(node.x, node.y, pulseSize, 0, 2 * Math.PI); ctx.fillStyle = '#ff4444'; ctx.strokeStyle = '#cc0000'; ctx.lineWidth = 4; } else if (node.processing) { ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#ffb000'; ctx.lineWidth = 3; } else if (node.completed) { ctx.fillStyle = '#22c55e'; ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; } else if (node.visited) { ctx.fillStyle = '#f97316'; ctx.strokeStyle = '#ea580c'; ctx.lineWidth = 3; } else if (node.inPath) { ctx.fillStyle = '#a855f7'; ctx.strokeStyle = '#9333ea'; ctx.lineWidth = 2; } else { ctx.fillStyle = '#64b5f6'; ctx.strokeStyle = '#42a5f5'; ctx.lineWidth = 2; } ctx.fill(); ctx.stroke(); ctx.fillStyle = node.current ? 'white' : (node.completed || node.visited || node.processing) ? 'white' : '#1a1a1a'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(node.val, node.x, node.y); } function drawArrow(fromX, fromY, toX, toY, type) { const headLength = 15; const headAngle = Math.PI / 6; const angle = Math.atan2(toY - fromY, toX - fromX); const nodeRadius = 25; const startX = fromX + Math.cos(angle) * nodeRadius; const startY = fromY + Math.sin(angle) * nodeRadius; const endX = toX - Math.cos(angle) * nodeRadius; const endY = toY - Math.sin(angle) * nodeRadius; ctx.strokeStyle = type === 'down' ? '#22c55e' : '#3b82f6'; ctx.fillStyle = type === 'down' ? '#22c55e' : '#3b82f6'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(endX, endY); ctx.lineTo( endX - headLength * Math.cos(angle - headAngle), endY - headLength * Math.sin(angle - headAngle) ); ctx.lineTo( endX - headLength * Math.cos(angle + headAngle), endY - headLength * Math.sin(angle + headAngle) ); ctx.closePath(); ctx.fill(); const midX = (startX + endX) / 2; const midY = (startY + endY) / 2; const labelOffset = 20; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; if (type === 'down') { ctx.fillStyle = '#16a34a'; ctx.fillText('递', midX + labelOffset * Math.sin(angle), midY - labelOffset * Math.cos(angle)); } else { ctx.fillStyle = '#1d4ed8'; ctx.fillText('归', midX + labelOffset * Math.sin(angle), midY - labelOffset * Math.cos(angle)); } } function drawConnection(parent, child) { ctx.beginPath(); ctx.moveTo(parent.x, parent.y + 25); ctx.lineTo(child.x, child.y - 25); ctx.strokeStyle = '#a0aec0'; ctx.lineWidth = 2; ctx.stroke(); } function drawArrows(root) { if (!root) return; root.arrows.forEach(arrow => { if (arrow.active) { drawArrow(root.x, root.y, arrow.to.x, arrow.to.y, arrow.type); } }); drawArrows(root.left); drawArrows(root.right); } function drawTree(root) { ctx.clearRect(0, 0, canvas.width, canvas.height); function drawConnections(node) { if (node.left) { drawConnection(node, node.left); drawConnections(node.left); } if (node.right) { drawConnection(node, node.right); drawConnections(node.right); } } drawConnections(root); drawArrows(root); function drawNodes(node) { if (node) { drawNode(node); drawNodes(node.left); drawNodes(node.right); } } drawNodes(root); } function addArrow(from, to, type) { from.arrows.push({ to: to, type: type, active: true }); } function removeArrow(from, to) { from.arrows = from.arrows.filter(arrow => arrow.to !== to); } function clearAllArrows(root) { if (!root) return; root.arrows = []; clearAllArrows(root.left); clearAllArrows(root.right); } function resetNodeStates(root) { if (root) { root.visited = false; root.current = false; root.completed = false; root.processing = false; root.inPath = false; root.visitOrder = 0; root.arrows = []; resetNodeStates(root.left); resetNodeStates(root.right); } } function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } function updateDisplay(action, info) { document.getElementById('currentAction').textContent = action; document.getElementById('stepInfo').textContent = info; } function updateSequence() { document.getElementById('sequence').textContent = animationState.sequence.join(' → '); } async function preorderTraversal(root, sequence) { if (!root || !animationState.isAnimating) return; root.processing = true; updateDisplay(`到达节点: ${root.val}`, `前序遍历: 根 → 左 → 右`); drawTree(tree); await sleep(600); root.processing = false; root.current = true; animationState.visitCounter++; root.visitOrder = animationState.visitCounter; updateDisplay(`访问节点: ${root.val} (第${root.visitOrder}个)`, `前序遍历: 根 → 左 → 右`); drawTree(tree); await sleep(800); root.visited = true; root.current = false; sequence.push(root.val); updateSequence(); drawTree(tree); await sleep(400); if (root.left && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的左子树`, `前序遍历: 根 → 左 → 右 (向下递)`); addArrow(root, root.left, 'down'); root.left.inPath = true; drawTree(tree); await sleep(500); await preorderTraversal(root.left, sequence); if (animationState.isAnimating) { removeArrow(root, root.left); addArrow(root.left, root, 'up'); updateDisplay(`从 ${root.left.val} 返回到 ${root.val}`, `前序遍历: 左子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.left, root); } root.left.inPath = false; } if (root.right && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的右子树`, `前序遍历: 根 → 左 → 右 (向下递)`); addArrow(root, root.right, 'down'); root.right.inPath = true; drawTree(tree); await sleep(500); await preorderTraversal(root.right, sequence); if (animationState.isAnimating) { removeArrow(root, root.right); addArrow(root.right, root, 'up'); updateDisplay(`从 ${root.right.val} 返回到 ${root.val}`, `前序遍历: 右子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.right, root); } root.right.inPath = false; } if (animationState.isAnimating) { root.completed = true; updateDisplay(`完成节点: ${root.val}`, `前序遍历: 根 → 左 → 右`); drawTree(tree); await sleep(300); } } async function inorderTraversal(root, sequence) { if (!root || !animationState.isAnimating) return; root.processing = true; updateDisplay(`到达节点: ${root.val}`, `中序遍历: 左 → 根 → 右`); drawTree(tree); await sleep(600); if (root.left && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的左子树`, `中序遍历: 左 → 根 → 右 (向下递)`); addArrow(root, root.left, 'down'); root.left.inPath = true; drawTree(tree); await sleep(500); await inorderTraversal(root.left, sequence); if (animationState.isAnimating) { removeArrow(root, root.left); addArrow(root.left, root, 'up'); updateDisplay(`从 ${root.left.val} 返回到 ${root.val}`, `中序遍历: 左子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.left, root); } root.left.inPath = false; } if (!animationState.isAnimating) return; root.processing = false; root.current = true; animationState.visitCounter++; root.visitOrder = animationState.visitCounter; updateDisplay(`访问节点: ${root.val} (第${root.visitOrder}个)`, `中序遍历: 左 → 根 → 右`); drawTree(tree); await sleep(800); root.visited = true; root.current = false; sequence.push(root.val); updateSequence(); drawTree(tree); await sleep(400); if (root.right && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的右子树`, `中序遍历: 左 → 根 → 右 (向下递)`); addArrow(root, root.right, 'down'); root.right.inPath = true; drawTree(tree); await sleep(500); await inorderTraversal(root.right, sequence); if (animationState.isAnimating) { removeArrow(root, root.right); addArrow(root.right, root, 'up'); updateDisplay(`从 ${root.right.val} 返回到 ${root.val}`, `中序遍历: 右子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.right, root); } root.right.inPath = false; } if (animationState.isAnimating) { root.completed = true; updateDisplay(`完成节点: ${root.val}`, `中序遍历: 左 → 根 → 右`); drawTree(tree); await sleep(300); } } async function postorderTraversal(root, sequence) { if (!root || !animationState.isAnimating) return; root.processing = true; updateDisplay(`到达节点: ${root.val}`, `后序遍历: 左 → 右 → 根`); drawTree(tree); await sleep(600); if (root.left && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的左子树`, `后序遍历: 左 → 右 → 根 (向下递)`); addArrow(root, root.left, 'down'); root.left.inPath = true; drawTree(tree); await sleep(500); await postorderTraversal(root.left, sequence); if (animationState.isAnimating) { removeArrow(root, root.left); addArrow(root.left, root, 'up'); updateDisplay(`从 ${root.left.val} 返回到 ${root.val}`, `后序遍历: 左子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.left, root); } root.left.inPath = false; } if (!animationState.isAnimating) return; if (root.right && animationState.isAnimating) { updateDisplay(`准备访问 ${root.val} 的右子树`, `后序遍历: 左 → 右 → 根 (向下递)`); addArrow(root, root.right, 'down'); root.right.inPath = true; drawTree(tree); await sleep(500); await postorderTraversal(root.right, sequence); if (animationState.isAnimating) { removeArrow(root, root.right); addArrow(root.right, root, 'up'); updateDisplay(`从 ${root.right.val} 返回到 ${root.val}`, `后序遍历: 右子树完成，向上归`); drawTree(tree); await sleep(400); removeArrow(root.right, root); } root.right.inPath = false; } if (!animationState.isAnimating) return; root.processing = false; root.current = true; animationState.visitCounter++; root.visitOrder = animationState.visitCounter; updateDisplay(`访问节点: ${root.val} (第${root.visitOrder}个)`, `后序遍历: 左 → 右 → 根`); drawTree(tree); await sleep(800); root.visited = true; root.current = false; sequence.push(root.val); updateSequence(); drawTree(tree); await sleep(400); root.completed = true; updateDisplay(`完成节点: ${root.val}`, `后序遍历: 左 → 右 → 根`); drawTree(tree); await sleep(300); } async function levelorderTraversal(root, sequence) { if (!root || !animationState.isAnimating) return; const queue = [root]; root.inPath = true; while (queue.length > 0 && animationState.isAnimating) { const node = queue.shift(); node.inPath = false; node.processing = true; updateDisplay(`从队列取出节点: ${node.val}`, `层次遍历: 按层从左到右访问`); drawTree(tree); await sleep(600); node.processing = false; node.current = true; animationState.visitCounter++; node.visitOrder = animationState.visitCounter; updateDisplay(`访问节点: ${node.val} (第${node.visitOrder}个)`, `层次遍历: 按层从左到右访问`); drawTree(tree); await sleep(800); node.visited = true; node.current = false; sequence.push(node.val); updateSequence(); drawTree(tree); await sleep(400); if (node.left) { queue.push(node.left); node.left.inPath = true; updateDisplay(`将 ${node.left.val} 加入队列`, `层次遍历: 按层从左到右访问`); drawTree(tree); await sleep(300); } if (node.right) { queue.push(node.right); node.right.inPath = true; updateDisplay(`将 ${node.right.val} 加入队列`, `层次遍历: 按层从左到右访问`); drawTree(tree); await sleep(300); } node.completed = true; drawTree(tree); await sleep(200); } } async function startTraversal(type) { if (animationState.isAnimating) return; resetAnimation(); animationState.isAnimating = true; animationState.currentTraversal = type; animationState.sequence = []; animationState.visitCounter = 0; const traversalNames = { 'preorder': '前序遍历', 'inorder': '中序遍历', 'postorder': '后序遍历', 'levelorder': '层次遍历' }; document.getElementById('status').textContent = `正在执行${traversalNames[type]}...`; try { switch(type) { case 'preorder': await preorderTraversal(tree, animationState.sequence); break; case 'inorder': await inorderTraversal(tree, animationState.sequence); break; case 'postorder': await postorderTraversal(tree, animationState.sequence); break; case 'levelorder': await levelorderTraversal(tree, animationState.sequence); break; } if (animationState.isAnimating) { document.getElementById('status').textContent = `${traversalNames[type]}完成！`; updateDisplay(`${traversalNames[type]}完成`, `最终序列: ${animationState.sequence.join(' → ')}`); } } catch (error) { console.error('遍历过程中发生错误:', error); } animationState.isAnimating = false; } function resetAnimation() { animationState.isAnimating = false; animationState.sequence = []; animationState.visitCounter = 0; resetNodeStates(tree); drawTree(tree); document.getElementById('sequence').textContent = ''; document.getElementById('status').textContent = '选择一种遍历方式开始演示'; updateDisplay('等待开始...', '点击按钮开始遍历动画'); } function showCode(language) { const codeContents = document.querySelectorAll('.code-content'); codeContents.forEach(content => content.classList.remove('active')); const tabs = document.querySelectorAll('.tab-btn'); tabs.forEach(tab => tab.classList.remove('active')); document.getElementById(`${language}-code`).classList.add('active'); event.target.classList.add('active'); } function copyCode(language, buttonElement) { let button = buttonElement; if (!button) { button = event ? event.target : null; } if (!button) { console.error('无法获取按钮元素'); return; } const codeElement = document.getElementById(`${language}-source`); if (!codeElement) { console.error(`找不到代码元素: ${language}-source`); showCopyError(button); return; } const text = codeElement.textContent || codeElement.innerText; const cleanText = text.trim(); if (!cleanText) { console.error('代码内容为空'); showCopyError(button); return; } if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(cleanText).then(() => { showCopySuccess(button); }).catch(err => { console.error('现代API复制失败:', err); fallbackCopyTextToClipboard(cleanText, button); }); } else { fallbackCopyTextToClipboard(cleanText, button); } } function fallbackCopyTextToClipboard(text, button) { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.top = "-1000px"; textArea.style.left = "-1000px"; textArea.style.width = "1px"; textArea.style.height = "1px"; textArea.style.padding = "0"; textArea.style.border = "none"; textArea.style.outline = "none"; textArea.style.boxShadow = "none"; textArea.style.background = "transparent"; document.body.appendChild(textArea); try { textArea.focus(); textArea.select(); textArea.setSelectionRange(0, text.length); const successful = document.execCommand('copy'); if (successful) { showCopySuccess(button); } else { console.error('execCommand复制失败'); showCopyError(button); } } catch (err) { console.error('降级复制方法出错:', err); showCopyError(button); } finally { document.body.removeChild(textArea); } } function showCopySuccess(button) { if (!button) return; const originalText = button.innerHTML; const originalClass = button.className; button.innerHTML = '✅ 已复制'; button.className = originalClass + ' copy-success'; button.disabled = true; const originalStyle = button.style.cssText; button.style.cssText = originalStyle + '; background: #22c55e !important; color: white !important;'; setTimeout(() => { button.innerHTML = originalText; button.className = originalClass; button.disabled = false; button.style.cssText = originalStyle; }, 2000); } function showCopyError(button) { if (!button) return; const originalText = button.innerHTML; const originalClass = button.className; button.innerHTML = '❌ 复制失败'; button.className = originalClass + ' copy-error'; button.disabled = true; const originalStyle = button.style.cssText; button.style.cssText = originalStyle + '; background: #ef4444 !important; color: white !important;'; setTimeout(() => { button.innerHTML = originalText; button.className = originalClass; button.disabled = false; button.style.cssText = originalStyle; }, 2000); } function toggleAnswer(questionNumber) { const answer = document.getElementById(`answer${questionNumber}`); const button = event.target; if (answer.classList.contains('show')) { answer.classList.remove('show'); button.textContent = '点击查看答案'; } else { answer.classList.add('show'); button.textContent = '隐藏答案'; } } let animationFrame; function startAnimation() { function animate() { drawTree(tree); animationFrame = requestAnimationFrame(animate); } animate(); } function stopAnimation() { if (animationFrame) { cancelAnimationFrame(animationFrame); } } drawTree(tree); startAnimation();</script>

{% endblock %}