{% extends 'knowledge_app/base.html' %}

{% block title %}栈——表达式求值 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>栈——表达式求值</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🧮</span>
            栈——表达式求值
        </h1><p>学习使用栈解析和计算数学表达式，掌握运算符优先级处理</p></div><!-- 📋 知识点概述 --><div class="content-card slide-in-right"><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                知识点概述
            </h2><div class="info-box info-box-info"><span class="info-icon">🎯</span><strong>核心概念：</strong>利用栈处理运算符优先级和结合性，将中缀表达式转换为后缀表达式并求值，或直接对中缀表达式进行计算。
            </div><div class="unified-grid unified-grid-2"><div class="grid-card"><span class="card-icon">📚</span><h4 class="card-title">关键术语</h4><ul style="text-align: left; margin: 10px 0;"><li><strong>中缀表达式：</strong>运算符在操作数中间，如 3+4*2</li><li><strong>后缀表达式：</strong>运算符在操作数后面，如 3 4 2 * +</li><li><strong>运算符优先级：</strong>* / 优先于 + -</li><li><strong>调度场算法：</strong>中缀转后缀的经典算法</li><li><strong>操作数栈：</strong>存储数字和中间结果</li><li><strong>运算符栈：</strong>临时存储运算符</li></ul></div><div class="grid-card"><span class="card-icon">📊</span><h4 class="card-title">学习指标</h4><div style="text-align: left;"><p><strong>难度等级：</strong><span style="color: #ffc107;">进阶级</span></p><p><strong>前置知识：</strong></p><ul style="margin: 5px 0;"><li>栈的基本操作</li><li>运算符优先级概念</li><li>字符串处理和解析</li><li>基本数学运算</li></ul></div></div></div></div></div><!-- 🔍 概念详解 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🔍</span>
                概念详解
            </h2><div class="unified-grid unified-grid-2"><div class="info-box info-box-success"><span class="info-icon">🥞</span><strong>双栈策略：</strong>就像厨师用两个盘子，一个放食材（数字），一个放调料（运算符），按顺序搭配制作。
                </div><div class="info-box info-box-warning"><span class="info-icon">⚖️</span><strong>优先级处理：</strong>高优先级运算符优先出栈执行，就像紧急任务优先处理一样。
                </div></div><h3>🔹 核心子概念分解</h3><div style="margin: 20px 0;"><h4>1️⃣ 表达式类型理解</h4><p>中缀表达式是人类习惯的写法(如3+4*2)，但计算机更适合处理后缀表达式(如3 4 2 * +)，因为后缀表达式无需考虑优先级。</p><h4>2️⃣ 运算符优先级规则</h4><p>乘除法(* /)优先级高于加减法(+ -)，同级运算符从左到右计算。括号可以改变优先级，括号内的表达式优先计算。</p><h4>3️⃣ 双栈工作机制</h4><p>操作数栈存储数字，运算符栈存储待处理的运算符。遇到运算符时，根据优先级决定是入栈还是先处理栈中的运算符。</p><h4>4️⃣ 计算执行过程</h4><p>从操作数栈取出两个数字，从运算符栈取出一个运算符，执行计算后将结果放回操作数栈，重复直到表达式处理完毕。</p></div><div class="info-box info-box-warning"><span class="info-icon">⚠️</span><strong>易错点提醒：</strong><ul style="text-align: left; margin: 10px 0;"><li>忽视运算符的左右结合性（如减法3-2-1应该是(3-2)-1=0而不是3-(2-1)=2）</li><li>处理负数时的符号识别（-3+2中的负号vs减号）</li><li>括号的优先级处理（括号内表达式必须先计算完成）</li><li>除零错误和浮点数精度问题</li></ul></div></div></div><!-- 📊 可视化展示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                可视化展示
            </h2><div class="demo-container" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;"><h3>🎯 交互式演示：表达式求值过程</h3><!-- 输入区域 --><div style="margin-bottom: 20px;"><label for="expressionInput" style="display: block; margin-bottom: 8px; font-weight: bold;">输入数学表达式：</label><div style="display: flex; gap: 10px; align-items: center;"><input type="text" id="expressionInput" placeholder="如：3+4*2-1 或 (1+2)*3"
                               style="flex: 1; padding: 10px; border: 2px solid #007bff; border-radius: 5px; font-family: monospace; font-size: 16px;"
                               value="3+4*2-1" onkeyup="handleExpressionInput(event)"><button onclick="startEvaluation()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            开始求值
                        </button></div><div style="margin-top: 8px; font-size: 14px; color: #6c757d;">
                        💡 支持：数字、+、-、*、/、括号()，如：(1+2)*3-4/2
                    </div></div><div id="evaluationDemo" style="margin: 20px 0;"><!-- 当前表达式显示 --><div style="margin-bottom: 20px;"><h4>当前表达式</h4><div id="currentExpression" style="font-family: monospace; font-size: 20px; padding: 15px; background: white; border: 2px solid #007bff; border-radius: 5px; min-height: 50px; text-align: center;">
                            3 + 4 * 2 - 1
                        </div></div><!-- 双栈显示 --><div style="display: flex; justify-content: space-between; margin-bottom: 20px;"><div style="flex: 1; margin-right: 10px;"><h4>操作数栈 (存储数字)</h4><div id="numberStack" style="height: 200px; background: white; border: 2px solid #28a745; border-radius: 5px; position: relative; overflow: hidden;"><div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #6c757d;">栈底</div></div></div><div style="flex: 1; margin-left: 10px;"><h4>运算符栈 (存储运算符)</h4><div id="operatorStack" style="height: 200px; background: white; border: 2px solid #ffc107; border-radius: 5px; position: relative; overflow: hidden;"><div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #6c757d;">栈底</div></div></div></div><!-- 结果显示 --><div style="margin-bottom: 20px;"><h4>计算结果</h4><div id="resultDisplay" style="font-size: 24px; font-weight: bold; padding: 15px; background: white; border: 2px solid #dc3545; border-radius: 5px; text-align: center; color: #dc3545;">
                            等待计算...
                        </div></div><div style="text-align: center;"><button id="evalStepBtn" onclick="nextEvalStep()" style="background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; margin: 5px;">下一步</button><button onclick="autoEvaluation()" id="autoEvalBtn" style="background: #ffc107; color: #000; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; margin: 5px;">自动演示</button><button onclick="resetEvaluation()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; margin: 5px;">重置</button></div><div id="evalStepInfo" style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-radius: 5px; min-height: 60px;"><strong>准备开始：</strong>输入数学表达式，点击"开始求值"查看详细计算过程
                    </div></div></div><div class="unified-grid unified-grid-3"><div class="info-box info-box-info"><span class="info-icon">✅</span><strong>有效表达式示例：</strong><ul style="text-align: left; font-size: 14px;"><li>3+4*2 → 11</li><li>(1+2)*3 → 9</li><li>10/2-3 → 2</li><li>2*3+4*5 → 26</li></ul></div><div class="info-box info-box-warning"><span class="info-icon">🔍</span><strong>优先级规则：</strong><ul style="text-align: left; font-size: 14px;"><li>括号() - 最高</li><li>乘除* / - 较高</li><li>加减+ - - 较低</li><li>同级从左到右</li></ul></div><div class="info-box info-box-danger"><span class="info-icon">❌</span><strong>常见错误：</strong><ul style="text-align: left; font-size: 14px;"><li>括号不匹配</li><li>连续运算符++</li><li>除零错误/0</li><li>空表达式</li></ul></div></div></div></div><!-- 🌟 实际应用 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌟</span>
                实际应用
            </h2><div class="unified-grid unified-grid-3"><div class="grid-card"><span class="card-icon">🧮</span><h4 class="card-title">计算器应用</h4><p class="card-description">科学计算器、手机计算器等应用使用表达式求值引擎处理复杂的数学计算。</p></div><div class="grid-card"><span class="card-icon">📊</span><h4 class="card-title">电子表格</h4><p class="card-description">Excel、Google Sheets等表格软件使用表达式求值来处理单元格公式计算。</p></div><div class="grid-card"><span class="card-icon">⚙️</span><h4 class="card-title">编程语言编译器</h4><p class="card-description">编译器在代码生成阶段需要计算常量表达式，优化程序性能。</p></div></div><h3>💡 多语言代码实现</h3><!-- 代码标签页 --><div style="margin: 20px 0;"><div class="code-tabs" style="display: flex; border-bottom: 2px solid #dee2e6;"><button class="tab-btn active" onclick="showCode('python')" data-lang="python">Python</button><button class="tab-btn" onclick="showCode('java')" data-lang="java">Java</button><button class="tab-btn" onclick="showCode('cpp')" data-lang="cpp">C++</button></div><!-- Python代码 --><div id="python-code" class="code-block"><div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #2d3748; color: white;"><span>Python 实现</span><button onclick="copyCode('python')" style="background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                            📋 复制代码
                        </button></div><pre id="python-pre" style="margin: 0; background: #f8f9fa; padding: 15px; overflow-x: auto;"><code>def evaluate_expression(expression):
    """
    使用双栈算法计算中缀表达式
    """
    def precedence(op):
        if op in ['+', '-']:
            return 1
        if op in ['*', '/']:
            return 2
        return 0

    def apply_operator(operators, values):
        op = operators.pop()
        right = values.pop()
        left = values.pop()

        if op == '+':
            values.append(left + right)
        elif op == '-':
            values.append(left - right)
        elif op == '*':
            values.append(left * right)
        elif op == '/':
            if right == 0:
                raise ValueError("除零错误")
            values.append(left / right)

    values = []  # 操作数栈
    operators = []  # 运算符栈
    i = 0

    while i < len(expression):
        if expression[i] == ' ':
            i += 1
            continue

        # 处理数字
        if expression[i].isdigit():
            val = 0
            while i < len(expression) and expression[i].isdigit():
                val = val * 10 + int(expression[i])
                i += 1
            values.append(val)
            continue

        # 处理左括号
        if expression[i] == '(':
            operators.append(expression[i])

        # 处理右括号
        elif expression[i] == ')':
            while operators and operators[-1] != '(':
                apply_operator(operators, values)
            operators.pop()  # 移除 '('

        # 处理运算符
        else:
            while (operators and operators[-1] != '(' and
                   precedence(operators[-1]) >= precedence(expression[i])):
                apply_operator(operators, values)
            operators.append(expression[i])

        i += 1

    # 处理剩余的运算符
    while operators:
        apply_operator(operators, values)

    return values[0]

# 测试示例
test_expressions = [
    "3+4*2",      # 11
    "(1+2)*3",    # 9
    "10/2-3",     # 2
    "2*3+4*5"     # 26
]

for expr in test_expressions:
    try:
        result = evaluate_expression(expr)
        print(f"{expr} = {result}")
    except Exception as e:
        print(f"{expr} -> 错误: {e}")
</code></pre></div><!-- Java代码 --><div id="java-code" class="code-block" style="display: none;"><div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #2d3748; color: white;"><span>Java 实现</span><button onclick="copyCode('java')" style="background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                            📋 复制代码
                        </button></div><pre id="java-pre" style="margin: 0; background: #f8f9fa; padding: 15px; overflow-x: auto;"><code>import java.util.*;

public class ExpressionEvaluator {

    /**
     * 获取运算符优先级
     */
    private static int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
        }
        return -1;
    }

    /**
     * 执行运算
     */
    private static double applyOp(char op, double b, double a) {
        switch (op) {
            case '+':
                return a + b;
            case '-':
                return a - b;
            case '*':
                return a * b;
            case '/':
                if (b == 0)
                    throw new ArithmeticException("除零错误");
                return a / b;
        }
        return 0;
    }

    /**
     * 计算中缀表达式
     */
    public static double evaluate(String expression) {
        Stack&lt;Double&gt; values = new Stack&lt;&gt;();     // 操作数栈
        Stack&lt;Character&gt; operators = new Stack&lt;&gt;(); // 运算符栈

        for (int i = 0; i &lt; expression.length(); i++) {
            char c = expression.charAt(i);

            // 跳过空格
            if (c == ' ')
                continue;

            // 处理数字
            if (Character.isDigit(c)) {
                StringBuffer sbuf = new StringBuffer();
                while (i &lt; expression.length() &&
                       Character.isDigit(expression.charAt(i)))
                    sbuf.append(expression.charAt(i++));
                values.push(Double.parseDouble(sbuf.toString()));
                i--; // 回退一位
            }

            // 处理左括号
            else if (c == '(')
                operators.push(c);

            // 处理右括号
            else if (c == ')') {
                while (!operators.empty() && operators.peek() != '(')
                    values.push(applyOp(operators.pop(), values.pop(), values.pop()));
                operators.pop(); // 移除 '('
            }

            // 处理运算符
            else if (c == '+' || c == '-' || c == '*' || c == '/') {
                while (!operators.empty() && precedence(c) &lt;= precedence(operators.peek()))
                    values.push(applyOp(operators.pop(), values.pop(), values.pop()));
                operators.push(c);
            }
        }

        // 处理剩余运算符
        while (!operators.empty())
            values.push(applyOp(operators.pop(), values.pop(), values.pop()));

        return values.pop();
    }

    public static void main(String[] args) {
        String[] testExpressions = {
            "3+4*2",      // 11
            "(1+2)*3",    // 9
            "10/2-3",     // 2
            "2*3+4*5"     // 26
        };

        for (String expr : testExpressions) {
            try {
                double result = evaluate(expr);
                System.out.println(expr + " = " + result);
            } catch (Exception e) {
                System.out.println(expr + " -> 错误: " + e.getMessage());
            }
        }
    }
}
</code></pre></div><!-- C++代码 --><div id="cpp-code" class="code-block" style="display: none;"><div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #2d3748; color: white;"><span>C++ 实现</span><button onclick="copyCode('cpp')" style="background: #4a5568; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                            📋 复制代码
                        </button></div><pre id="cpp-pre" style="margin: 0; background: #f8f9fa; padding: 15px; overflow-x: auto;"><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

using namespace std;

class ExpressionEvaluator {
private:
    /**
     * 获取运算符优先级
     */
    static int precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    }

    /**
     * 执行运算
     */
    static double applyOp(char op, double b, double a) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/':
                if (b == 0)
                    throw runtime_error("除零错误");
                return a / b;
            default: return 0;
        }
    }

public:
    /**
     * 计算中缀表达式
     */
    static double evaluate(const string&amp; expression) {
        stack&lt;double&gt; values;      // 操作数栈
        stack&lt;char&gt; operators;    // 运算符栈

        for (int i = 0; i &lt; expression.length(); i++) {
            char c = expression[i];

            // 跳过空格
            if (c == ' ') continue;

            // 处理数字
            if (isdigit(c)) {
                double val = 0;
                while (i &lt; expression.length() && isdigit(expression[i])) {
                    val = val * 10 + (expression[i] - '0');
                    i++;
                }
                values.push(val);
                i--; // 回退一位
            }

            // 处理左括号
            else if (c == '(') {
                operators.push(c);
            }

            // 处理右括号
            else if (c == ')') {
                while (!operators.empty() && operators.top() != '(') {
                    double val2 = values.top(); values.pop();
                    double val1 = values.top(); values.pop();
                    char op = operators.top(); operators.pop();
                    values.push(applyOp(op, val2, val1));
                }
                operators.pop(); // 移除 '('
            }

            // 处理运算符
            else if (c == '+' || c == '-' || c == '*' || c == '/') {
                while (!operators.empty() &&
                       precedence(c) &lt;= precedence(operators.top())) {
                    double val2 = values.top(); values.pop();
                    double val1 = values.top(); values.pop();
                    char op = operators.top(); operators.pop();
                    values.push(applyOp(op, val2, val1));
                }
                operators.push(c);
            }
        }

        // 处理剩余运算符
        while (!operators.empty()) {
            double val2 = values.top(); values.pop();
            double val1 = values.top(); values.pop();
            char op = operators.top(); operators.pop();
            values.push(applyOp(op, val2, val1));
        }

        return values.top();
    }
};

int main() {
    vector&lt;string&gt; testExpressions = {
        "3+4*2",      // 11
        "(1+2)*3",    // 9
        "10/2-3",     // 2
        "2*3+4*5"     // 26
    };

    for (const string&amp; expr : testExpressions) {
        try {
            double result = ExpressionEvaluator::evaluate(expr);
            cout &lt;&lt; expr &lt;&lt; " = " &lt;&lt; result &lt;&lt; endl;
        } catch (const exception&amp; e) {
            cout &lt;&lt; expr &lt;&lt; " -> 错误: " &lt;&lt; e.what() &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre></div></div></div></div><!-- ✅ 学习检验 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">✅</span>
                学习检验
            </h2><div class="unified-grid unified-grid-1" style="gap: 15px;"><!-- 题目1 --><div class="question-card" style="border: 1px solid #dee2e6; border-radius: 8px; overflow: hidden;"><div class="question-header" onclick="toggleAnswer('q1')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"><span><strong>题目1：</strong>为什么表达式求值需要用到两个栈而不是一个？</span><span id="q1-icon">🔽</span></div><div id="q1-answer" class="answer-content" style="display: none; padding: 15px; background: #e8f4fd;"><p><strong>答案：</strong></p><p>两个栈各有不同的职责，缺一不可：</p><ul style="text-align: left; margin: 10px 0;"><li><strong>操作数栈：</strong>存储数字和中间计算结果，按顺序保存待计算的操作数</li><li><strong>运算符栈：</strong>临时存储运算符，处理优先级和延迟计算</li><li><strong>协同工作：</strong>当遇到低优先级运算符时，需要先处理栈中高优先级运算符</li><li><strong>单栈问题：</strong>无法同时管理数字和运算符的不同处理逻辑</li></ul><p>例如：计算"3+4*2"时，遇到"*"需要暂存"+"，遇到"2"后先计算4*2=8，再计算3+8=11</p></div></div><!-- 题目2 --><div class="question-card" style="border: 1px solid #dee2e6; border-radius: 8px; overflow: hidden;"><div class="question-header" onclick="toggleAnswer('q2')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"><span><strong>题目2：</strong>手动计算表达式"2*3+4*5-6"的详细过程。</span><span id="q2-icon">🔽</span></div><div id="q2-answer" class="answer-content" style="display: none; padding: 15px; background: #e8f4fd;"><p><strong>答案：最终结果 = 20</strong></p><p><strong>详细计算过程：</strong></p><table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px;"><tr style="background: #f8f9fa;"><th style="border: 1px solid #ddd; padding: 8px;">步骤</th><th style="border: 1px solid #ddd; padding: 8px;">当前字符</th><th style="border: 1px solid #ddd; padding: 8px;">操作数栈</th><th style="border: 1px solid #ddd; padding: 8px;">运算符栈</th><th style="border: 1px solid #ddd; padding: 8px;">说明</th></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">1</td><td style="border: 1px solid #ddd; padding: 6px;">2</td><td style="border: 1px solid #ddd; padding: 6px;">[2]</td><td style="border: 1px solid #ddd; padding: 6px;">[]</td><td style="border: 1px solid #ddd; padding: 6px;">数字入操作数栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">2</td><td style="border: 1px solid #ddd; padding: 6px;">*</td><td style="border: 1px solid #ddd; padding: 6px;">[2]</td><td style="border: 1px solid #ddd; padding: 6px;">[*]</td><td style="border: 1px solid #ddd; padding: 6px;">运算符入栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">3</td><td style="border: 1px solid #ddd; padding: 6px;">3</td><td style="border: 1px solid #ddd; padding: 6px;">[2,3]</td><td style="border: 1px solid #ddd; padding: 6px;">[*]</td><td style="border: 1px solid #ddd; padding: 6px;">数字入操作数栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">4</td><td style="border: 1px solid #ddd; padding: 6px;">+</td><td style="border: 1px solid #ddd; padding: 6px;">[6]</td><td style="border: 1px solid #ddd; padding: 6px;">[+]</td><td style="border: 1px solid #ddd; padding: 6px;">*优先级高，先计算2*3=6</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">5</td><td style="border: 1px solid #ddd; padding: 6px;">4</td><td style="border: 1px solid #ddd; padding: 6px;">[6,4]</td><td style="border: 1px solid #ddd; padding: 6px;">[+]</td><td style="border: 1px solid #ddd; padding: 6px;">数字入操作数栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">6</td><td style="border: 1px solid #ddd; padding: 6px;">*</td><td style="border: 1px solid #ddd; padding: 6px;">[6,4]</td><td style="border: 1px solid #ddd; padding: 6px;">[+,*]</td><td style="border: 1px solid #ddd; padding: 6px;">*优先级高于+，入栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">7</td><td style="border: 1px solid #ddd; padding: 6px;">5</td><td style="border: 1px solid #ddd; padding: 6px;">[6,4,5]</td><td style="border: 1px solid #ddd; padding: 6px;">[+,*]</td><td style="border: 1px solid #ddd; padding: 6px;">数字入操作数栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">8</td><td style="border: 1px solid #ddd; padding: 6px;">-</td><td style="border: 1px solid #ddd; padding: 6px;">[6,20]</td><td style="border: 1px solid #ddd; padding: 6px;">[+]</td><td style="border: 1px solid #ddd; padding: 6px;">先计算4*5=20</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">9</td><td style="border: 1px solid #ddd; padding: 6px;">-</td><td style="border: 1px solid #ddd; padding: 6px;">[26]</td><td style="border: 1px solid #ddd; padding: 6px;">[-]</td><td style="border: 1px solid #ddd; padding: 6px;">再计算6+20=26</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">10</td><td style="border: 1px solid #ddd; padding: 6px;">6</td><td style="border: 1px solid #ddd; padding: 6px;">[26,6]</td><td style="border: 1px solid #ddd; padding: 6px;">[-]</td><td style="border: 1px solid #ddd; padding: 6px;">数字入操作数栈</td></tr><tr><td style="border: 1px solid #ddd; padding: 6px;">11</td><td style="border: 1px solid #ddd; padding: 6px;">结束</td><td style="border: 1px solid #ddd; padding: 6px;">[20]</td><td style="border: 1px solid #ddd; padding: 6px;">[]</td><td style="border: 1px solid #ddd; padding: 6px;">最后计算26-6=20</td></tr></table></div></div><!-- 题目3 --><div class="question-card" style="border: 1px solid #dee2e6; border-radius: 8px; overflow: hidden;"><div class="question-header" onclick="toggleAnswer('q3')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"><span><strong>题目3：</strong>如何扩展算法以支持更多运算符（如幂运算^、取模%）？</span><span id="q3-icon">🔽</span></div><div id="q3-answer" class="answer-content" style="display: none; padding: 15px; background: #e8f4fd;"><p><strong>答案：</strong></p><p><strong>扩展步骤：</strong></p><ol style="text-align: left; margin: 10px 0;"><li><strong>优先级定义：</strong>建立更完整的优先级层次</li><li><strong>结合性考虑：</strong>有些运算符是右结合的（如幂运算）</li><li><strong>运算逻辑：</strong>在applyOp函数中添加新的运算分支</li><li><strong>特殊处理：</strong>某些运算符可能需要特殊的错误检查</li></ol><p><strong>优先级表示例：</strong></p><pre style="background: #2d3748; color: white; padding: 10px; border-radius: 4px; font-size: 12px;">
def precedence(op):
    precedence_map = {
        '+': 1, '-': 1,    # 加减法
        '*': 2, '/': 2, '%': 2,  # 乘除模
        '^': 3             # 幂运算（最高优先级）
    }
    return precedence_map.get(op, 0)

def is_right_associative(op):
    return op == '^'  # 幂运算是右结合的</pre><p><strong>右结合性处理：</strong>幂运算2^3^2应该计算为2^(3^2)=512而不是(2^3)^2=64</p></div></div><!-- 题目4 --><div class="question-card" style="border: 1px solid #dee2e6; border-radius: 8px; overflow: hidden;"><div class="question-header" onclick="toggleAnswer('q4')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"><span><strong>题目4：</strong>为什么后缀表达式(逆波兰表达式)更适合计算机处理？</span><span id="q4-icon">🔽</span></div><div id="q4-answer" class="answer-content" style="display: none; padding: 15px; background: #e8f4fd;"><p><strong>答案：</strong></p><div style="text-align: left;"><p><strong>后缀表达式的优势：</strong></p><ul style="margin: 5px 0;"><li><strong>无需括号：</strong>运算顺序完全由位置决定，不需要括号</li><li><strong>无优先级：</strong>从左到右顺序计算，不需要考虑运算符优先级</li><li><strong>单栈即可：</strong>只需要一个操作数栈，算法更简单</li><li><strong>天然递归：</strong>符合栈的处理方式，每个运算符处理最近的两个操作数</li></ul><p><strong>示例对比：</strong></p><ul style="margin: 5px 0;"><li>中缀：(3+4)*2-1 → 需要处理括号和优先级</li><li>后缀：3 4 + 2 * 1 - → 从左到右直接计算</li></ul><p><strong>后缀表达式计算步骤：</strong></p><ol style="margin: 5px 0; font-size: 14px;"><li>遇到数字就入栈</li><li>遇到运算符就取出栈顶两个数字计算</li><li>将结果入栈</li><li>重复直到表达式结束</li></ol><p><strong>这就是为什么编译器经常将中缀表达式转换为后缀表达式的原因。</strong></p></div></div></div></div><div class="info-box info-box-info" style="margin-top: 20px;"><span class="info-icon">📚</span><strong>进阶学习路径：</strong>
                掌握表达式求值后，可以学习：编译原理中的语法分析、抽象语法树(AST)、递归下降解析器、LR/LALR语法分析器、表达式优化技术等更高级的主题。
            </div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><style>.code-tabs {background:#f8f9fa}.tab-btn {background:#e9ecef;border:none;padding:12px 24px;cursor:pointer;border-bottom:3px solid transparent;transition:all 0.3s ease}.tab-btn.active {background:#fff;border-bottom-color:#007bff;color:#007bff;font-weight:bold}.tab-btn:hover {background:#fff}.code-block {border:1px solid #dee2e6;border-top:none}.question-card {transition:all 0.3s ease}.question-card:hover {box-shadow:0 2px 8px rgba(0,0,0,0.1)}.question-header {transition:background-color 0.3s ease}.question-header:hover {background:#e9ecef !important}.answer-content {animation:fadeIn 0.3s ease}@keyframes fadeIn {from {opacity:0}to {opacity:1}}.stack-item {animation:stackSlide 0.3s ease}@keyframes stackSlide {from {opacity:0;transform:translateX(-50%) translateY(20px)}to {opacity:1;transform:translateX(-50%) translateY(0)}}</style><script>let currentEvalStep = 0; let currentExpression = "3+4*2-1"; let evalSteps = []; let evalAutoInterval; class ExpressionEvaluator { constructor() { this.precedence = {'+': 1, '-': 1, '*': 2, '/': 2}; } isDigit(char) { return char >= '0' && char <= '9'; } isOperator(char) { return ['+', '-', '*', '/'].includes(char); } applyOperator(op, b, a) { switch(op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': if (b === 0) throw new Error("除零错误"); return a / b; default: return 0; } } generateSteps(expression) { const steps = []; const values = []; const operators = []; let i = 0; steps.push({ step: 0, char: '', values: [...values], operators: [...operators], action: '开始解析表达式', highlight: -1 }); try { while (i < expression.length) { const char = expression[i]; if (char === ' ') { i++; continue; } if (this.isDigit(char)) { let num = 0; const startI = i; while (i < expression.length && this.isDigit(expression[i])) { num = num * 10 + parseInt(expression[i]); i++; } values.push(num); steps.push({ step: steps.length, char: num.toString(), values: [...values], operators: [...operators], action: `数字 ${num} 入操作数栈`, highlight: startI, success: true }); } else if (char === '(') { operators.push(char); steps.push({ step: steps.length, char: char, values: [...values], operators: [...operators], action: `左括号 '(' 入运算符栈`, highlight: i, success: true }); i++; } else if (char === ')') { while (operators.length > 0 && operators[operators.length - 1] !== '(') { const op = operators.pop(); const b = values.pop(); const a = values.pop(); const result = this.applyOperator(op, b, a); values.push(result); steps.push({ step: steps.length, char: char, values: [...values], operators: [...operators], action: `执行运算: ${a} ${op} ${b} = ${result}`, highlight: i, calculation: {a, op, b, result}, success: true }); } if (operators.length > 0) { operators.pop(); } steps.push({ step: steps.length, char: char, values: [...values], operators: [...operators], action: `右括号 ')' 匹配完成，移除左括号`, highlight: i, success: true }); i++; } else if (this.isOperator(char)) { while (operators.length > 0 && operators[operators.length - 1] !== '(' && this.precedence[operators[operators.length - 1]] >= this.precedence[char]) { const op = operators.pop(); const b = values.pop(); const a = values.pop(); const result = this.applyOperator(op, b, a); values.push(result); steps.push({ step: steps.length, char: char, values: [...values], operators: [...operators], action: `${op} 优先级较高，先执行: ${a} ${op} ${b} = ${result}`, highlight: i, calculation: {a, op, b, result}, success: true }); } operators.push(char); steps.push({ step: steps.length, char: char, values: [...values], operators: [...operators], action: `运算符 '${char}' 入运算符栈`, highlight: i, success: true }); i++; } else { throw new Error(`无效字符: ${char}`); } } while (operators.length > 0) { const op = operators.pop(); const b = values.pop(); const a = values.pop(); const result = this.applyOperator(op, b, a); values.push(result); steps.push({ step: steps.length, char: '', values: [...values], operators: [...operators], action: `处理剩余运算符: ${a} ${op} ${b} = ${result}`, highlight: -1, calculation: {a, op, b, result}, success: true }); } steps.push({ step: steps.length, char: '', values: [...values], operators: [...operators], action: `计算完成！最终结果: ${values[0]}`, highlight: -1, final: true, result: values[0], success: true }); } catch (error) { steps.push({ step: steps.length, char: '', values: [...values], operators: [...operators], action: `错误: ${error.message}`, highlight: i, success: false, error: true }); } return steps; } } const evaluator = new ExpressionEvaluator(); function initializeEvaluationSteps(expression) { evalSteps = evaluator.generateSteps(expression); } function updateEvaluationDisplay() { if (evalSteps.length === 0) return; const step = evalSteps[currentEvalStep]; const exprDiv = document.getElementById('currentExpression'); let highlighted = ''; for (let i = 0; i < currentExpression.length; i++) { if (i === step.highlight) { const color = step.success ? '#ffc107' : '#dc3545'; highlighted += `<span style="background: ${color}; color: #000; padding: 2px 4px; border-radius: 3px; font-weight: bold;">${currentExpression[i]}</span>`; } else if (i < step.highlight) { highlighted += `<span style="color: #28a745;">${currentExpression[i]}</span>`; } else { highlighted += currentExpression[i]; } } exprDiv.innerHTML = highlighted || currentExpression; const numberStackDiv = document.getElementById('numberStack'); numberStackDiv.innerHTML = '<div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #6c757d;">栈底</div>'; step.values.forEach((value, index) => { const element = document.createElement('div'); element.className = 'stack-item'; element.style.cssText = ` position: absolute; bottom: ${30 + index * 35}px; left: 50%; transform: translateX(-50%); background: ${step.success ? '#28a745' : '#dc3545'}; color: white; padding: 6px 12px; border-radius: 5px; font-weight: bold; font-size: 16px; min-width: 30px; text-align: center; `; element.textContent = value; numberStackDiv.appendChild(element); }); const operatorStackDiv = document.getElementById('operatorStack'); operatorStackDiv.innerHTML = '<div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #6c757d;">栈底</div>'; step.operators.forEach((op, index) => { const element = document.createElement('div'); element.className = 'stack-item'; element.style.cssText = ` position: absolute; bottom: ${30 + index * 35}px; left: 50%; transform: translateX(-50%); background: ${step.success ? '#ffc107' : '#dc3545'}; color: #000; padding: 6px 12px; border-radius: 5px; font-weight: bold; font-size: 16px; min-width: 30px; text-align: center; `; element.textContent = op; operatorStackDiv.appendChild(element); }); const resultDiv = document.getElementById('resultDisplay'); if (step.final && step.result !== undefined) { resultDiv.textContent = `结果: ${step.result}`; resultDiv.style.color = '#28a745'; resultDiv.style.borderColor = '#28a745'; } else if (step.error) { resultDiv.textContent = '计算错误'; resultDiv.style.color = '#dc3545'; resultDiv.style.borderColor = '#dc3545'; } else { resultDiv.textContent = '计算中...'; resultDiv.style.color = '#007bff'; resultDiv.style.borderColor = '#007bff'; } let actionText = step.action; if (step.calculation) { const {a, op, b, result} = step.calculation; actionText += ` (${a} ${op} ${b} = ${result})`; } const infoColor = step.success ? '#e3f2fd' : '#ffebee'; document.getElementById('evalStepInfo').innerHTML = `<strong>第${currentEvalStep}步：</strong>${actionText}`; document.getElementById('evalStepInfo').style.background = infoColor; const stepBtn = document.getElementById('evalStepBtn'); if (currentEvalStep >= evalSteps.length - 1) { stepBtn.textContent = '演示完成'; stepBtn.disabled = true; stepBtn.style.background = '#6c757d'; } else { stepBtn.textContent = '下一步'; stepBtn.disabled = false; stepBtn.style.background = '#007bff'; } } function nextEvalStep() { if (currentEvalStep < evalSteps.length - 1) { currentEvalStep++; updateEvaluationDisplay(); } } function startEvaluation() { currentExpression = document.getElementById('expressionInput').value.trim(); if (!currentExpression) { alert('请输入要计算的表达式！'); return; } currentEvalStep = 0; initializeEvaluationSteps(currentExpression); updateEvaluationDisplay(); const stepBtn = document.getElementById('evalStepBtn'); stepBtn.disabled = false; stepBtn.style.background = '#007bff'; stepBtn.textContent = '下一步'; if (evalAutoInterval) { clearInterval(evalAutoInterval); evalAutoInterval = null; document.getElementById('autoEvalBtn').textContent = '自动演示'; } } function autoEvaluation() { const autoBtn = document.getElementById('autoEvalBtn'); if (evalAutoInterval) { clearInterval(evalAutoInterval); evalAutoInterval = null; autoBtn.textContent = '自动演示'; return; } autoBtn.textContent = '停止自动'; evalAutoInterval = setInterval(() => { if (currentEvalStep < evalSteps.length - 1) { nextEvalStep(); } else { clearInterval(evalAutoInterval); evalAutoInterval = null; autoBtn.textContent = '自动演示'; } }, 2000); } function resetEvaluation() { currentEvalStep = 0; if (evalAutoInterval) { clearInterval(evalAutoInterval); evalAutoInterval = null; document.getElementById('autoEvalBtn').textContent = '自动演示'; } if (evalSteps.length > 0) { updateEvaluationDisplay(); } else { currentExpression = document.getElementById('expressionInput').value.trim() || "3+4*2-1"; initializeEvaluationSteps(currentExpression); updateEvaluationDisplay(); } } function handleExpressionInput(event) { if (event.key === 'Enter') { startEvaluation(); } } function showCode(language) { document.querySelectorAll('.code-block').forEach(block => { block.style.display = 'none'; }); document.querySelectorAll('.tab-btn').forEach(btn => { btn.classList.remove('active'); }); document.getElementById(language + '-code').style.display = 'block'; document.querySelector(`[data-lang="${language}"]`).classList.add('active'); } async function copyCode(language) { const codeElement = document.getElementById(language + '-pre'); const text = codeElement.textContent; try { await navigator.clipboard.writeText(text); const button = document.querySelector(`#${language}-code button`); const originalText = button.innerHTML; button.innerHTML = '✅ 已复制'; button.style.background = '#28a745'; setTimeout(() => { button.innerHTML = originalText; button.style.background = '#4a5568'; }, 2000); } catch (err) { alert('复制失败，请手动选择代码复制'); } } function toggleAnswer(questionId) { const answer = document.getElementById(questionId + '-answer'); const icon = document.getElementById(questionId + '-icon'); if (answer.style.display === 'none') { answer.style.display = 'block'; icon.textContent = '🔼'; } else { answer.style.display = 'none'; icon.textContent = '🔽'; } } document.addEventListener('DOMContentLoaded', function() { initializeEvaluationSteps(currentExpression); updateEvaluationDisplay(); });</script>

{% endblock %}