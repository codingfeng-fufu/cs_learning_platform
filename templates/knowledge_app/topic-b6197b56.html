{% extends 'knowledge_app/base.html' %}

{% block title %}栈——递归 - 计算机科学学习平台{% endblock %}

{% block content %}
<style>.content-card {margin-bottom:30px;padding:30px;background:white;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.1)}.section-title {color:#2c3e50;font-size:1.8rem;margin-bottom:20px;display:flex;align-items:center;gap:12px}.section-icon {font-size:1.6rem}.difficulty-badge {padding:6px 12px;border-radius:20px;font-size:0.9rem;font-weight:bold;margin-left:15px}.difficulty-beginner {background:#e8f5e8;color:#2e7d32}.key-terms {display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:15px;margin:20px 0}.term-card {background:#f8f9fa;padding:15px;border-radius:8px;border-left:4px solid #3498db}.term-title {font-weight:bold;color:#2c3e50;margin-bottom:5px}.concept-box {background:#fff3cd;border:1px solid #ffeaa7;border-radius:8px;padding:20px;margin:15px 0}.analogy-box {background:#e8f4fd;border:1px solid #74b9ff;border-radius:8px;padding:20px;margin:15px 0}.analogy-title {font-weight:bold;color:#0984e3;margin-bottom:10px}.danger-box {background:#ffeaea;border:1px solid #ff7675;border-radius:8px;padding:20px;margin:15px 0}.danger-title {font-weight:bold;color:#d63031;margin-bottom:10px}.visualization-container {background:#f8f9fa;border-radius:12px;padding:30px;margin:20px 0;text-align:center}.canvas-container {position:relative;background:white;border:2px solid #ddd;border-radius:8px;margin:20px auto;display:inline-block}.control-panel {margin:20px 0;display:flex;justify-content:center;gap:15px;flex-wrap:wrap}.control-btn {padding:10px 20px;border:none;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.3s}.btn-primary {background:#3498db;color:white}.btn-success {background:#27ae60;color:white}.btn-warning {background:#f39c12;color:white}.btn-info {background:#17a2b8;color:white}.control-btn:hover {transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,0.2)}.memory-info {position:absolute;right:10px;top:10px;background:rgba(231, 76, 60, 0.9);color:white;padding:5px 10px;border-radius:4px;font-size:12px;font-weight:bold}.animation-legend {display:flex;justify-content:center;gap:20px;margin:15px 0;flex-wrap:wrap}.legend-item {display:flex;align-items:center;gap:8px;font-size:0.9rem}.legend-color {width:20px;height:15px;border-radius:3px;display:inline-block}.recursion-tree {position:absolute;right:20px;top:60px;width:200px;height:300px;background:rgba(255,255,255,0.95);border-radius:8px;padding:10px}.calculation-panel {position:absolute;left:20px;bottom:60px;width:280px;background:rgba(255,255,255,0.95);border-radius:8px;padding:15px;border:2px solid #3498db}.formula-display {font-family:'Courier New', monospace;font-size:14px;color:#2c3e50;margin:5px 0}.current-formula {background:#e8f6f3;padding:8px;border-radius:4px;border-left:4px solid #27ae60}.depth-chart {position:absolute;right:20px;bottom:20px;width:150px;height:100px}.tooltip {position:absolute;background:rgba(0,0,0,0.8);color:white;padding:8px 12px;border-radius:4px;font-size:12px;pointer-events:none;opacity:0;transition:opacity 0.3s;z-index:1000}.code-container {margin:20px 0}.code-tabs {display:flex;background:#f1f2f6;border-radius:8px 8px 0 0;overflow:hidden}.code-tab {padding:12px 24px;cursor:pointer;border:none;background:transparent;font-weight:bold;transition:all 0.3s}.code-tab.active {background:#2c3e50;color:white}.code-tab:hover:not(.active) {background:#ddd}.code-content {background:#2c3e50;color:#ecf0f1;padding:20px;border-radius:0 0 8px 8px;position:relative;overflow-x:auto}.copy-btn {position:absolute;top:10px;right:10px;background:#3498db;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:0.8rem}.copy-btn:hover {background:#2980b9}.quiz-container {margin:20px 0}.quiz-item {background:#f8f9fa;border-radius:8px;padding:20px;margin:15px 0;border-left:4px solid #3498db}.quiz-question {font-weight:bold;color:#2c3e50;margin-bottom:15px}.answer-btn {background:#e74c3c;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;margin-bottom:10px}.answer-btn:hover {background:#c0392b}.quiz-answer {display:none;background:#d5f4e6;border:1px solid #27ae60;border-radius:4px;padding:15px;margin-top:10px}.quiz-answer.show {display:block}.step-indicator {margin:15px 0;font-weight:bold;color:#2c3e50;background:rgba(255,255,255,0.9);padding:10px;border-radius:5px;border-left:4px solid #3498db}.recursion-formula {background:#f8f9fa;border:2px solid #3498db;border-radius:8px;padding:15px;margin:15px 0;text-align:center;font-family:'Courier New', monospace;font-size:1.1rem}pre {font-family:'Courier New', monospace;white-space:pre-wrap;margin:0}.fade-in {animation:fadeIn 0.8s ease-out}.slide-in-left {animation:slideInLeft 0.6s ease-out}.slide-in-right {animation:slideInRight 0.6s ease-out}@keyframes fadeIn {from {opacity:0}to {opacity:1}}@keyframes slideInLeft {from {transform:translateX(-50px);opacity:0}to {transform:translateX(0);opacity:1}}@keyframes slideInRight {from {transform:translateX(50px);opacity:0}to {transform:translateX(0);opacity:1}}.highlight {background:#fff3cd;padding:2px 4px;border-radius:3px}.recursion-depth {position:absolute;left:10px;top:10px;background:rgba(52, 152, 219, 0.9);color:white;padding:5px 10px;border-radius:4px;font-size:12px;font-weight:bold}</style><div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>栈——递归</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🔄</span>
            栈——递归
            <span class="difficulty-badge difficulty-beginner">入门级</span></h1><p>深入理解递归函数的执行机制，掌握递归调用栈的变化过程</p></div><!-- 📋 知识点概述 --><div class="content-card slide-in-right"><h2 class="section-title"><span class="section-icon">📋</span>
            知识点概述
        </h2><div class="concept-box"><h3>核心概念</h3><p><strong>递归</strong>是一种编程技术，函数直接或间接地调用自身来解决问题。递归函数通过将复杂问题分解为相同类型的更小子问题，最终达到基本情况（终止条件），然后逐层返回结果。</p></div><div class="recursion-formula">
            递归 = 基本情况（Base Case）+ 递归情况（Recursive Case）
        </div><div class="key-terms"><div class="term-card"><div class="term-title">基本情况 (Base Case)</div><div>递归的终止条件，不再进行递归调用，直接返回结果</div></div><div class="term-card"><div class="term-title">递归情况 (Recursive Case)</div><div>函数调用自身处理规模更小的同类问题</div></div><div class="term-card"><div class="term-title">递归深度 (Recursion Depth)</div><div>递归调用的层数，每次调用都会在栈中创建新的栈帧</div></div><div class="term-card"><div class="term-title">栈溢出 (Stack Overflow)</div><div>递归深度过大或缺少终止条件时，栈空间耗尽导致的错误</div></div></div><div style="margin-top: 20px;"><strong>前置知识：</strong>函数概念、函数调用栈、条件语句、数学归纳法思维
        </div></div><!-- 🔍 概念详解 --><div class="content-card"><h2 class="section-title"><span class="section-icon">🔍</span>
            概念详解
        </h2><div class="analogy-box"><div class="analogy-title">生活类比：俄罗斯套娃</div><p>递归就像打开俄罗斯套娃的过程：</p><ul><li><strong>套娃 = 递归函数</strong>：每个套娃里面还有更小的套娃</li><li><strong>打开套娃 = 递归调用</strong>：不断打开直到找到最小的套娃</li><li><strong>最小套娃 = 基本情况</strong>：不能再打开的套娃，递归终止</li><li><strong>重新组装 = 返回过程</strong>：按照相反的顺序重新组装套娃</li></ul></div><h3>1. 递归的组成要素</h3><p>每个递归函数必须包含两个关键部分：</p><ul><li><strong>基本情况（终止条件）</strong>：防止无限递归，是递归的"出口"</li><li><strong>递归情况</strong>：函数调用自身，但参数必须向基本情况靠近</li></ul><h3>2. 递归的执行过程</h3><p>递归执行分为两个阶段：</p><ol><li><strong>递归阶段（Winding）</strong>：不断调用自身，栈帧逐层增加</li><li><strong>回溯阶段（Unwinding）</strong>：达到基本情况后，逐层返回，栈帧逐层减少</li></ol><h3>3. 递归与栈的关系</h3><p>递归调用时：</p><ul><li>每次递归调用都会创建新的栈帧</li><li>栈帧包含当前调用的参数、局部变量、返回地址</li><li>所有递归调用的栈帧会堆叠在调用栈中</li><li>达到基本情况后，栈帧按LIFO顺序逐个弹出</li></ul><div class="danger-box"><div class="danger-title">⚠️ 常见错误与风险</div><ul><li><strong>缺少基本情况</strong>：导致无限递归，最终栈溢出</li><li><strong>基本情况永远不会达到</strong>：参数没有向终止条件收敛</li><li><strong>递归深度过大</strong>：即使有终止条件，深度太大也可能栈溢出</li><li><strong>效率问题</strong>：重复计算导致时间复杂度指数增长</li></ul></div></div><!-- 📊 可视化展示 --><div class="content-card"><h2 class="section-title"><span class="section-icon">📊</span>
            可视化展示
        </h2><div class="visualization-container"><h3>阶乘函数递归调用栈演示</h3><p>观察 factorial(4) 的完整递归过程：4! = 4 × 3 × 2 × 1 = 24</p><div class="canvas-container"><canvas id="recursionCanvas" width="1000" height="600"></canvas><div class="recursion-depth" id="depthIndicator">递归深度: 0</div><div class="memory-info" id="memoryInfo">内存使用: 0 KB</div></div><div class="control-panel"><button class="control-btn btn-primary" onclick="resetAnimation()">🔄 重置</button><button class="control-btn btn-success" onclick="stepForward()">▶️ 下一步</button><button class="control-btn btn-warning" onclick="stepBackward()">◀️ 上一步</button><button class="control-btn btn-info" onclick="autoPlay()">🎬 自动播放</button></div><div class="step-indicator" id="stepIndicator">
                第 1 步：开始调用 factorial(4)
            </div><div class="animation-legend"><div class="legend-item"><span class="legend-color" style="background: #3498db;"></span><span>调用中</span></div><div class="legend-item"><span class="legend-color" style="background: #f39c12;"></span><span>等待中</span></div><div class="legend-item"><span class="legend-color" style="background: #27ae60;"></span><span>返回中</span></div><div class="legend-item"><span class="legend-color" style="background: #e74c3c;"></span><span>基本情况</span></div></div></div><div class="code-container"><h3>阶乘函数实现</h3><div class="code-tabs"><button class="code-tab active" onclick="showCode('cpp')">C++</button><button class="code-tab" onclick="showCode('java')">Java</button><button class="code-tab" onclick="showCode('python')">Python</button></div><div id="cppCode" class="code-content"><button class="copy-btn" onclick="copyCode('cpp')">复制代码</button><pre>#include &lt;iostream&gt;
using namespace std;

int factorial(int n) {
    // 基本情况：阶乘的终止条件
    if (n == 0 || n == 1) {
        cout &lt;&lt; "基本情况: factorial(" &lt;&lt; n &lt;&lt; ") = 1" &lt;&lt; endl;
        return 1;
    }

    // 递归情况：n! = n × (n-1)!
    cout &lt;&lt; "递归调用: factorial(" &lt;&lt; n &lt;&lt; ") = " &lt;&lt; n
         &lt;&lt; " × factorial(" &lt;&lt; (n-1) &lt;&lt; ")" &lt;&lt; endl;

    int result = n * factorial(n - 1);  // 递归调用

    cout &lt;&lt; "返回结果: factorial(" &lt;&lt; n &lt;&lt; ") = " &lt;&lt; result &lt;&lt; endl;
    return result;
}

int main() {
    int num = 4;
    cout &lt;&lt; "计算 " &lt;&lt; num &lt;&lt; "! 的过程：" &lt;&lt; endl;
    int result = factorial(num);
    cout &lt;&lt; "最终结果：" &lt;&lt; num &lt;&lt; "! = " &lt;&lt; result &lt;&lt; endl;
    return 0;
}</pre></div><div id="javaCode" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('java')">复制代码</button><pre>public class FactorialDemo {
    public static int factorial(int n) {
        // 基本情况：阶乘的终止条件
        if (n == 0 || n == 1) {
            System.out.println("基本情况: factorial(" + n + ") = 1");
            return 1;
        }

        // 递归情况：n! = n × (n-1)!
        System.out.println("递归调用: factorial(" + n + ") = " + n
                         + " × factorial(" + (n-1) + ")");

        int result = n * factorial(n - 1);  // 递归调用

        System.out.println("返回结果: factorial(" + n + ") = " + result);
        return result;
    }

    public static void main(String[] args) {
        int num = 4;
        System.out.println("计算 " + num + "! 的过程：");
        int result = factorial(num);
        System.out.println("最终结果：" + num + "! = " + result);
    }
}</pre></div><div id="pythonCode" class="code-content" style="display: none;"><button class="copy-btn" onclick="copyCode('python')">复制代码</button><pre>def factorial(n):
    # 基本情况：阶乘的终止条件
    if n == 0 or n == 1:
        print(f"基本情况: factorial({n}) = 1")
        return 1

    # 递归情况：n! = n × (n-1)!
    print(f"递归调用: factorial({n}) = {n} × factorial({n-1})")

    result = n * factorial(n - 1)  # 递归调用

    print(f"返回结果: factorial({n}) = {result}")
    return result

def main():
    num = 4
    print(f"计算 {num}! 的过程：")
    result = factorial(num)
    print(f"最终结果：{num}! = {result}")

if __name__ == "__main__":
    main()</pre></div></div><div class="concept-box"><h3>递归调用过程分析</h3><p><strong>递归阶段（向下调用）：</strong></p><ul><li>factorial(4) → factorial(3) → factorial(2) → factorial(1)</li><li>每次调用都在栈中创建新的栈帧</li><li>参数逐渐减小，向基本情况靠近</li></ul><p><strong>回溯阶段（向上返回）：</strong></p><ul><li>factorial(1) 返回 1</li><li>factorial(2) 返回 2 × 1 = 2</li><li>factorial(3) 返回 3 × 2 = 6</li><li>factorial(4) 返回 4 × 6 = 24</li></ul></div></div><!-- 🌟 实际应用 --><div class="content-card"><h2 class="section-title"><span class="section-icon">🌟</span>
            实际应用
        </h2><h3>1. 数学计算</h3><div class="analogy-box"><strong>典型应用：</strong><ul><li><strong>阶乘计算</strong>：n! = n × (n-1)!</li><li><strong>斐波那契数列</strong>：F(n) = F(n-1) + F(n-2)</li><li><strong>幂运算</strong>：a^n = a × a^(n-1)</li><li><strong>最大公约数</strong>：GCD(a,b) = GCD(b, a%b)</li></ul></div><h3>2. 数据结构遍历</h3><p>递归是处理树形和图形数据结构的自然方式：</p><ul><li><strong>二叉树遍历</strong>：前序、中序、后序遍历</li><li><strong>文件系统遍历</strong>：递归访问目录和子目录</li><li><strong>图的深度优先搜索</strong>：递归探索图的路径</li></ul><h3>3. 分治算法</h3><p>许多高效算法都基于递归的分治思想：</p><ul><li><strong>快速排序</strong>：将数组分为两部分，分别递归排序</li><li><strong>归并排序</strong>：将数组分半，递归排序后合并</li><li><strong>二分查找</strong>：递归在一半区间中查找目标</li><li><strong>汉诺塔问题</strong>：递归移动盘子的经典例子</li></ul><div class="concept-box"><h3>递归的优缺点</h3><p><strong>优点：</strong></p><ul><li>代码简洁优雅，易于理解</li><li>自然地表达分治思想</li><li>适合处理递归定义的数据结构</li></ul><p><strong>缺点：</strong></p><ul><li>可能存在重复计算，效率较低</li><li>占用较多栈空间</li><li>递归深度受限，可能栈溢出</li></ul></div><div class="concept-box"><h3>推荐学习工具</h3><ul><li><strong>可视化工具</strong>：Python Tutor、VisuAlgo递归专题</li><li><strong>调试工具</strong>：IDE断点调试观察递归过程</li><li><strong>练习平台</strong>：LeetCode递归专题、牛客网</li></ul></div></div><!-- ✅ 学习检验 --><div class="content-card"><h2 class="section-title"><span class="section-icon">✅</span>
            学习检验
        </h2><div class="quiz-container"><div class="quiz-item"><div class="quiz-question">
                    1. 递归函数必须包含哪两个关键要素？缺少其中任何一个会导致什么问题？
                </div><button class="answer-btn" onclick="toggleAnswer('answer1')">查看答案</button><div id="answer1" class="quiz-answer"><strong>答案：</strong>递归函数必须包含：(1)<span class="highlight">基本情况(Base Case)</span>：递归的终止条件；(2)<span class="highlight">递归情况(Recursive Case)</span>：函数调用自身。缺少基本情况会导致无限递归，最终栈溢出；缺少递归情况则不是递归函数，无法解决复杂问题。
                </div></div><div class="quiz-item"><div class="quiz-question">
                    2. 计算factorial(3)时，调用栈的变化过程是怎样的？请列出每一步。
                </div><button class="answer-btn" onclick="toggleAnswer('answer2')">查看答案</button><div id="answer2" class="quiz-answer"><strong>答案：</strong>栈变化过程：<br><strong>递归阶段：</strong><br>
                    1. [factorial(3)] - 调用factorial(3)<br>
                    2. [factorial(3), factorial(2)] - 调用factorial(2)<br>
                    3. [factorial(3), factorial(2), factorial(1)] - 调用factorial(1)<br><strong>回溯阶段：</strong><br>
                    4. [factorial(3), factorial(2)] - factorial(1)返回1<br>
                    5. [factorial(3)] - factorial(2)返回2×1=2<br>
                    6. [] - factorial(3)返回3×2=6
                </div></div><div class="quiz-item"><div class="quiz-question">
                    3. 下面的递归函数有什么问题？如何修复？<br><code>int fibonacci(int n) { return fibonacci(n-1) + fibonacci(n-2); }</code></div><button class="answer-btn" onclick="toggleAnswer('answer3')">查看答案</button><div id="answer3" class="quiz-answer"><strong>答案：</strong>问题：缺少基本情况，会导致无限递归。<br><strong>修复方法：</strong>添加终止条件：<br><code>
                    int fibonacci(int n) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (n == 0) return 0;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (n == 1) return 1;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return fibonacci(n-1) + fibonacci(n-2);<br>
                    }
                    </code></div></div><div class="quiz-item"><div class="quiz-question">
                    4. 为什么递归可能比循环效率低？在什么情况下应该避免使用递归？
                </div><button class="answer-btn" onclick="toggleAnswer('answer4')">查看答案</button><div id="answer4" class="quiz-answer"><strong>答案：</strong>递归效率低的原因：(1)<span class="highlight">函数调用开销</span>：每次调用都要创建栈帧；(2)<span class="highlight">重复计算</span>：如斐波那契数列中的重复子问题；(3)<span class="highlight">栈空间占用</span>：深度递归占用大量内存。<br><strong>应避免递归的情况：</strong>递归深度很大、存在大量重复计算、对性能要求极高的场景。可以考虑使用循环、动态规划或记忆化技术。
                </div></div><div class="quiz-item"><div class="quiz-question">
                    5. 观察递归调用过程，为什么说递归体现了"分治"的思想？
                </div><button class="answer-btn" onclick="toggleAnswer('answer5')">查看答案</button><div id="answer5" class="quiz-answer"><strong>答案：</strong>递归体现分治思想的原因：<br>
                    (1)<span class="highlight">分解问题</span>：将复杂问题分解为同类型的更小子问题<br>
                    (2)<span class="highlight">解决子问题</span>：递归解决每个子问题，直到基本情况<br>
                    (3)<span class="highlight">合并结果</span>：将子问题的解合并得到原问题的解<br>
                    例如factorial(4) = 4 × factorial(3)，将求4!的问题分解为求3!的子问题，最终组合得到结果。
                </div></div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><script>let currentStep = 0; let canvas, ctx; let animationId = null; let isAutoPlaying = false; const recursionSteps = [ { step: 1, description: "开始调用 factorial(4)", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "calling" } ], calculation: "计算 4!", depth: 1 }, { step: 2, description: "factorial(4) 调用 factorial(3)", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3"], depth: 2, phase: "calling" } ], calculation: "4! = 4 × 3!", depth: 2 }, { step: 3, description: "factorial(3) 调用 factorial(2)", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3"], depth: 2, phase: "waiting" }, { name: "factorial(2)", vars: ["n=2"], depth: 3, phase: "calling" } ], calculation: "3! = 3 × 2!", depth: 3 }, { step: 4, description: "factorial(2) 调用 factorial(1)", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3"], depth: 2, phase: "waiting" }, { name: "factorial(2)", vars: ["n=2"], depth: 3, phase: "waiting" }, { name: "factorial(1)", vars: ["n=1"], depth: 4, phase: "calling" } ], calculation: "2! = 2 × 1!", depth: 4 }, { step: 5, description: "到达基本情况，factorial(1) 返回 1", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3"], depth: 2, phase: "waiting" }, { name: "factorial(2)", vars: ["n=2"], depth: 3, phase: "waiting" }, { name: "factorial(1)", vars: ["n=1", "return 1"], depth: 4, phase: "base" } ], calculation: "1! = 1 (基本情况)", depth: 4 }, { step: 6, description: "factorial(2) 计算并返回 2", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3"], depth: 2, phase: "waiting" }, { name: "factorial(2)", vars: ["n=2", "return 2"], depth: 3, phase: "returning" } ], calculation: "2! = 2 × 1 = 2", depth: 3 }, { step: 7, description: "factorial(3) 计算并返回 6", stack: [ { name: "factorial(4)", vars: ["n=4"], depth: 1, phase: "waiting" }, { name: "factorial(3)", vars: ["n=3", "return 6"], depth: 2, phase: "returning" } ], calculation: "3! = 3 × 2 = 6", depth: 2 }, { step: 8, description: "factorial(4) 计算并返回 24", stack: [ { name: "factorial(4)", vars: ["n=4", "return 24"], depth: 1, phase: "returning" } ], calculation: "4! = 4 × 6 = 24", depth: 1 }, { step: 9, description: "递归完成，得到最终结果", stack: [], calculation: "最终结果：4! = 24", depth: 0 } ]; document.addEventListener('DOMContentLoaded', function() { canvas = document.getElementById('recursionCanvas'); ctx = canvas.getContext('2d'); drawRecursionStack(); }); function drawRecursionStack() { ctx.clearRect(0, 0, canvas.width, canvas.height); const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); bgGradient.addColorStop(0, '#f8f9fa'); bgGradient.addColorStop(1, '#e9ecef'); ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, canvas.width, canvas.height); drawStackArea(); drawCalculationPanel(); drawRecursionTree(); drawDepthChart(); drawMemoryUsage(); } function drawStackArea() { const stackX = 80; const stackY = 80; const stackWidth = 320; const stackHeight = 450; ctx.fillStyle = '#ffffff'; ctx.fillRect(stackX, stackY, stackWidth, stackHeight); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 3; ctx.strokeRect(stackX, stackY, stackWidth, stackHeight); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px Arial'; ctx.fillText('函数调用栈', stackX, stackY - 10); drawDepthRuler(stackX, stackY, stackHeight); const currentStack = recursionSteps[currentStep].stack; drawStackFrames(currentStack, stackX, stackY, stackWidth, stackHeight); if (currentStack.length > 0) { drawStackPointer(currentStack, stackX, stackWidth); } } function drawDepthRuler(stackX, stackY, stackHeight) { ctx.font = 'bold 14px Arial'; ctx.fillStyle = '#2c3e50'; for (let i = 0; i <= 4; i++) { const y = stackY + stackHeight - (i * 90) - 45; ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(stackX + 10, y); ctx.lineTo(stackX + 30, y); ctx.stroke(); ctx.setLineDash([]); if (i > 0) { ctx.fillText(`${i}`, stackX - 30, y + 5); } } } function drawStackFrames(currentStack, stackX, stackY, stackWidth, stackHeight) { const frameHeight = 80; const frameMargin = 10; currentStack.forEach((frame, index) => { const frameY = stackY + stackHeight - (frame.depth * 90) - frameHeight + 10; const frameX = stackX + frameMargin; const frameW = stackWidth - 2 * frameMargin; drawSingleFrame(frame, frameX, frameY, frameW, frameHeight, index); }); } function drawSingleFrame(frame, x, y, width, height, index) { let bgColor, borderColor; if (frame.phase === "calling") { bgColor = '#3498db'; borderColor = '#2980b9'; } else if (frame.phase === "returning") { bgColor = '#27ae60'; borderColor = '#229954'; } else if (frame.phase === "base") { bgColor = '#e74c3c'; borderColor = '#c0392b'; } else { bgColor = '#f39c12'; borderColor = '#e67e22'; } ctx.fillStyle = bgColor; ctx.fillRect(x, y, width, height); ctx.strokeStyle = borderColor; ctx.lineWidth = 3; ctx.strokeRect(x, y, width, height); drawFrameContent(frame, x, y, width, height); drawStatusIndicator(frame, x, y, width); } function drawFrameContent(frame, x, y, width, height) { ctx.fillStyle = '#ffffff'; ctx.font = 'bold 16px Arial'; ctx.fillText(frame.name, x + 15, y + 25); ctx.font = 'bold 14px Arial'; ctx.fillStyle = '#ffffff'; const vars = frame.vars.join(', '); ctx.fillText(`参数/变量: ${vars}`, x + 15, y + 45); ctx.font = 'bold 12px Arial'; ctx.fillStyle = '#ffffff'; const returnAddr = `0x${(1000 + frame.depth * 100).toString(16).toUpperCase()}`; ctx.fillText(`返回地址: ${returnAddr}`, x + 15, y + 65); } function drawStatusIndicator(frame, x, y, width) { const indicatorX = x + width - 30; const indicatorY = y + 20; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(indicatorX, indicatorY, 15, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; if (frame.phase === "calling") { ctx.fillText('↓', indicatorX, indicatorY + 4); } else if (frame.phase === "returning") { ctx.fillText('↑', indicatorX, indicatorY + 4); } else if (frame.phase === "base") { ctx.fillText('●', indicatorX, indicatorY + 4); } else { ctx.fillText('⏳', indicatorX, indicatorY + 4); } ctx.textAlign = 'left'; } function drawStackPointer(currentStack, stackX, stackWidth) { if (currentStack.length === 0) return; const topFrame = currentStack[currentStack.length - 1]; const pointerY = 80 + 450 - (topFrame.depth * 90) - 40; const pointerX = stackX + stackWidth + 20; ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(pointerX, pointerY); ctx.lineTo(pointerX + 20, pointerY - 10); ctx.lineTo(pointerX + 20, pointerY + 10); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.fillRect(pointerX + 25, pointerY - 12, 50, 24); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; ctx.strokeRect(pointerX + 25, pointerY - 12, 50, 24); ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 14px Arial'; ctx.fillText('栈顶', pointerX + 30, pointerY + 5); } function drawCalculationPanel() { const panelX = 450; const panelY = 80; const panelWidth = 300; const panelHeight = 200; ctx.fillStyle = '#ffffff'; ctx.fillRect(panelX, panelY, panelWidth, panelHeight); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.strokeRect(panelX, panelY, panelWidth, panelHeight); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px Arial'; ctx.fillText('计算过程', panelX + 15, panelY + 30); ctx.font = 'bold 16px monospace'; ctx.fillStyle = '#0984e3'; const calculation = recursionSteps[currentStep].calculation; ctx.fillText(calculation, panelX + 15, panelY + 65); drawFormulaHistory(panelX, panelY, panelWidth); drawCurrentState(panelX, panelY, panelWidth, panelHeight); } function drawFormulaHistory(panelX, panelY, panelWidth) { ctx.font = 'bold 14px monospace'; const step = currentStep; const completedCalculations = [ "4! = 4 × 3!", "3! = 3 × 2!", "2! = 2 × 1!", "1! = 1 (基本情况)", "2! = 2 × 1 = 2", "3! = 3 × 2 = 6", "4! = 4 × 6 = 24" ]; for (let i = 0; i < Math.min(step, completedCalculations.length); i++) { const y = panelY + 95 + i * 20; if (i < 4) { ctx.fillStyle = '#7f8c8d'; } else { ctx.fillStyle = '#27ae60'; } ctx.fillText(completedCalculations[i], panelX + 15, y); } } function drawCurrentState(panelX, panelY, panelWidth, panelHeight) { const stateY = panelY + panelHeight - 30; ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 14px Arial'; const currentStack = recursionSteps[currentStep].stack; if (currentStack.length > 0) { const phase = currentStack[currentStack.length - 1].phase; let stateText = ''; if (phase === 'calling') { stateText = '🔄 正在调用函数'; } else if (phase === 'returning') { stateText = '✅ 正在返回结果'; } else if (phase === 'base') { stateText = '🔴 基本情况'; } else { stateText = '⏳ 等待子函数返回'; } ctx.fillText(stateText, panelX + 15, stateY); } else { ctx.fillText('🎉 递归完成！', panelX + 15, stateY); } } function drawRecursionTree() { const treeX = 800; const treeY = 80; const treeWidth = 180; const treeHeight = 200; ctx.fillStyle = '#ffffff'; ctx.fillRect(treeX, treeY, treeWidth, treeHeight); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(treeX, treeY, treeWidth, treeHeight); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 16px Arial'; ctx.fillText('递归调用树', treeX + 10, treeY + 25); const nodeRadius = 20; const startX = treeX + treeWidth / 2; const startY = treeY + 55; const levelHeight = 35; const maxStep = Math.min(currentStep + 1, 5); for (let i = 0; i < maxStep; i++) { const x = startX - (i * 15) + (i * 5); const y = startY + i * levelHeight; if (i > 0) { ctx.strokeStyle = '#74b9ff'; ctx.lineWidth = 3; ctx.beginPath(); const prevX = startX - ((i-1) * 15) + ((i-1) * 5); const prevY = startY + (i-1) * levelHeight; ctx.moveTo(prevX, prevY + nodeRadius); ctx.lineTo(x, y - nodeRadius); ctx.stroke(); } const isActive = i === maxStep - 1; if (isActive) { ctx.fillStyle = '#e74c3c'; } else { ctx.fillStyle = '#3498db'; } ctx.beginPath(); ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText(`${4-i}`, x, y + 5); } ctx.textAlign = 'left'; } function drawDepthChart() { const chartX = 800; const chartY = 320; const chartWidth = 180; const chartHeight = 120; ctx.fillStyle = '#ffffff'; ctx.fillRect(chartX, chartY, chartWidth, chartHeight); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(chartX, chartY, chartWidth, chartHeight); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 16px Arial'; ctx.fillText('递归深度', chartX + 10, chartY + 25); const currentDepth = recursionSteps[currentStep].depth; const maxDepth = 4; const barWidth = 30; const barMaxHeight = 70; for (let i = 1; i <= maxDepth; i++) { const barX = chartX + 20 + (i - 1) * 35; const barHeight = (i <= currentDepth) ? (i / maxDepth) * barMaxHeight : 0; const barY = chartY + chartHeight - 30 - barHeight; if (i <= currentDepth) { ctx.fillStyle = '#3498db'; } else { ctx.fillStyle = '#ecf0f1'; } ctx.fillRect(barX, barY, barWidth, barHeight); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText(i.toString(), barX + barWidth/2, chartY + chartHeight - 10); } ctx.textAlign = 'left'; } function drawMemoryUsage() { const currentStack = recursionSteps[currentStep].stack; const memoryUsed = currentStack.length * 1.2; document.getElementById('memoryInfo').textContent = `内存使用: ${memoryUsed.toFixed(1)} KB`; } function resetAnimation() { currentStep = 0; isAutoPlaying = false; updateStepIndicator(); updateDepthIndicator(); drawRecursionStack(); } function stepForward() { if (currentStep < recursionSteps.length - 1) { currentStep++; updateStepIndicator(); updateDepthIndicator(); drawRecursionStack(); } } function stepBackward() { if (currentStep > 0) { currentStep--; updateStepIndicator(); updateDepthIndicator(); drawRecursionStack(); } } function autoPlay() { if (isAutoPlaying) { isAutoPlaying = false; event.target.textContent = '🎬 自动播放'; return; } isAutoPlaying = true; event.target.textContent = '⏸️ 暂停'; function playStep() { if (isAutoPlaying && currentStep < recursionSteps.length - 1) { stepForward(); setTimeout(playStep, 1500); } else { isAutoPlaying = false; event.target.textContent = '🎬 自动播放'; } } playStep(); } function updateStepIndicator() { const indicator = document.getElementById('stepIndicator'); indicator.textContent = `第 ${recursionSteps[currentStep].step} 步：${recursionSteps[currentStep].description}`; } function updateDepthIndicator() { const depthIndicator = document.getElementById('depthIndicator'); depthIndicator.textContent = `递归深度: ${recursionSteps[currentStep].depth}`; } function showCode(language) { const codes = ['cpp', 'java', 'python']; codes.forEach(code => { document.getElementById(code + 'Code').style.display = 'none'; }); document.getElementById(language + 'Code').style.display = 'block'; document.querySelectorAll('.code-tab').forEach(tab => { tab.classList.remove('active'); }); event.target.classList.add('active'); } function copyCode(language) { const codeElement = document.querySelector(`#${language}Code pre`); const text = codeElement.textContent; navigator.clipboard.writeText(text).then(() => { const btn = event.target; const originalText = btn.textContent; btn.textContent = '已复制!'; btn.style.background = '#27ae60'; setTimeout(() => { btn.textContent = originalText; btn.style.background = '#3498db'; }, 2000); }); } function toggleAnswer(answerId) { const answer = document.getElementById(answerId); answer.classList.toggle('show'); } document.addEventListener('keydown', function(event) { switch(event.key) { case 'ArrowRight': stepForward(); break; case 'ArrowLeft': stepBackward(); break; case 'r': case 'R': resetAnimation(); break; case ' ': event.preventDefault(); autoPlay(); break; } });</script>

{% endblock %}