{% extends 'knowledge_app/base.html' %}

{% block title %}B树 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>数据结构</span>
        <span>></span>
        <span>B树</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">🌳</span>
            B树 (B-Tree)
        </h1>
        <p>多路平衡搜索树，数据库索引的基石，支持高效的磁盘存储和检索</p>
    </div>

    <!-- 📋 知识点概述 -->
    <div class="content-card slide-in-right">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📋</span>
                知识点概述
            </h2>

            <div class="overview-content">
                <div class="concept-intro">
                    <h3>核心概念</h3>
                    <p>B树就像一本多级索引的百科全书，每个节点可以容纳多个关键字，通过巧妙的平衡机制确保所有叶子节点都在同一层。它专为磁盘存储优化，减少磁盘I/O次数，是现代数据库管理系统的核心数据结构。</p>
                </div>

                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <span class="info-icon">📚</span>
                        <div>
                            <strong>学习难度：</strong>中等偏难
                            <br><strong>前置知识：</strong>二叉搜索树、平衡树概念
                        </div>
                    </div>
                    <div class="info-box info-box-success">
                        <span class="info-icon">⏱️</span>
                        <div>
                            <strong>学习时间：</strong>60-90分钟
                            <br><strong>重要程度：</strong>⭐⭐⭐⭐⭐
                        </div>
                    </div>
                </div>

                <div class="terms-list">
                    <h4>🔑 关键术语</h4>
                    <div class="unified-grid unified-grid-2">
                        <div class="term-item">
                            <strong>阶数(Order)：</strong>B树的重要参数，决定节点最大子树数量
                        </div>
                        <div class="term-item">
                            <strong>关键字：</strong>存储在节点中的数据项，用于索引和查找
                        </div>
                        <div class="term-item">
                            <strong>分裂(Split)：</strong>当节点过满时一分为二的操作
                        </div>
                        <div class="term-item">
                            <strong>合并(Merge)：</strong>当节点过少时合并相邻节点的操作
                        </div>
                    </div>
                </div>

                <div class="problem-solution">
                    <h4>💡 解决的问题</h4>
                    <div class="unified-grid unified-grid-2">
                        <div class="problem-box">
                            <h5>🔴 传统问题</h5>
                            <ul>
                                <li>二叉树在磁盘存储中I/O次数过多</li>
                                <li>数据量大时树的高度过高</li>
                                <li>磁盘块利用率低，存储浪费</li>
                                <li>顺序访问效率不高</li>
                            </ul>
                        </div>
                        <div class="solution-box">
                            <h5>🟢 B树优势</h5>
                            <ul>
                                <li>多路结构减少树的高度</li>
                                <li>每个节点存储多个关键字</li>
                                <li>完美适配磁盘块大小</li>
                                <li>保证所有叶子在同一层</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 📖 概念详解 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📖</span>
                概念详解
            </h2>

            <div class="concept-details">
                <div class="concept-item">
                    <h3>🎯 什么是B树</h3>
                    <p>B树是一种多路平衡搜索树，每个节点可以包含多个关键字和子树指针。它通过严格的平衡条件确保优秀的查找性能。</p>
                    <div class="example-box">
                        <strong>B树性质：</strong>对于m阶B树，每个节点最多有m个子树，最多包含m-1个关键字，所有叶子节点都在同一层。
                    </div>
                    <div class="stats-box">
                        <h5>📊 m阶B树特性</h5>
                        <p><strong>根节点：</strong>至少1个关键字（除空树外）</p>
                        <p><strong>内部节点：</strong>至少⌈m/2⌉-1个关键字</p>
                        <p><strong>最大关键字数：</strong>m-1个</p>
                        <p><strong>最大子树数：</strong>m个</p>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 B树类型与变种</h3>
                    <div class="thread-types">
                        <div class="type-box">
                            <h4>B树 (B-Tree)</h4>
                            <p>经典的多路平衡搜索树</p>
                            <div class="type-feature">特点：内部节点和叶子节点都存储数据</div>
                        </div>
                        <div class="type-box">
                            <h4>B+树 (B+Tree)</h4>
                            <p>B树的改进版本</p>
                            <div class="type-feature">特点：只有叶子节点存储数据，内部节点只做索引</div>
                        </div>
                        <div class="type-box">
                            <h4>B*树 (B*Tree)</h4>
                            <p>B+树的进一步优化</p>
                            <div class="type-feature">特点：提高节点利用率，延迟分裂操作</div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 B树基本操作</h3>
                    <p>B树的三大核心操作：查找、插入、删除，每个操作都需要维护B树的平衡性质。</p>
                    <div class="process-steps">
                        <div class="step-box">
                            <div class="step-number">1</div>
                            <div class="step-content">
                                <h5>查找操作</h5>
                                <p>从根节点开始，在节点内部进行二分查找</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">2</div>
                            <div class="step-content">
                                <h5>插入操作</h5>
                                <p>先查找插入位置，如果节点满了则进行分裂</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">3</div>
                            <div class="step-content">
                                <h5>删除操作</h5>
                                <p>根据不同情况进行删除、借位或合并</p>
                            </div>
                        </div>
                        <div class="step-box">
                            <div class="step-number">4</div>
                            <div class="step-content">
                                <h5>平衡维护</h5>
                                <p>通过分裂和合并保持B树的平衡性质</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🎯 分裂与合并机制</h3>
                    <p>B树的自平衡特性通过节点的分裂和合并来实现，确保树的高度始终保持在对数级别。</p>
                    <div class="traversal-algorithm">
                        <h5>节点分裂过程：</h5>
                        <div class="algorithm-steps">
                            <div class="algo-step">
                                <span class="step-label">步骤1：</span>
                                <span>当节点关键字数量达到m-1时触发分裂</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤2：</span>
                                <span>选择中间关键字作为分裂点</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤3：</span>
                                <span>中间关键字上升到父节点</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤4：</span>
                                <span>左右部分形成两个新的子节点</span>
                            </div>
                            <div class="algo-step">
                                <span class="step-label">步骤5：</span>
                                <span>如果父节点也满了，则递归分裂</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-box info-box-warning">
                    <span class="info-icon">⚠️</span>
                    <strong>重要提示：</strong>
                    <ul>
                        <li>B树的阶数选择要考虑磁盘块大小和关键字大小</li>
                        <li>所有叶子节点必须在同一层，这是B树的重要特征</li>
                        <li>节点中关键字必须保持有序状态</li>
                        <li>适合读多写少的场景，如数据库索引和文件系统</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 📊 可视化展示 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📊</span>
                交互式B树演示
            </h2>

            <div class="visualization-container">
                <div class="demo-description">
                    <p>观看B树插入和删除操作的动画演示。<span style="color: #16a34a; font-weight: bold;">绿色节点</span>表示新插入的关键字，<span style="color: #dc2626; font-weight: bold;">红色节点</span>表示正在处理的节点，<span style="color: #f59e0b; font-weight: bold;">橙色节点</span>表示分裂或合并的节点。</p>
                    <div style="margin-top: 10px; font-size: 14px; color: #666;">
                        ✨ <strong>交互式学习：</strong>通过动画演示理解B树的分裂、合并机制，以及平衡性质的维护过程。支持自定义阶数和关键字插入！
                    </div>
                </div>

                <div class="canvas-demo">
                    <div class="controls">
                        <div class="control-group">
                            <label>B树阶数：</label>
                            <select id="btreeOrder" onchange="changeOrder()">
                                <option value="3">3阶</option>
                                <option value="4" selected>4阶</option>
                                <option value="5">5阶</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>插入值：</label>
                            <input type="number" id="insertValue" placeholder="输入数字" min="1" max="99">
                            <button class="insert-btn" onclick="insertKey()">🔍 插入</button>
                        </div>
                        <div class="control-group">
                            <label>删除值：</label>
                            <input type="number" id="deleteValue" placeholder="输入数字" min="1" max="99">
                            <button class="delete-btn" onclick="deleteKey()">🗑️ 删除</button>
                        </div>
                    </div>

                    <div class="preset-controls">
                        <button class="demo-btn" onclick="insertDemo()">📝 演示插入</button>
                        <button class="search-btn" onclick="searchDemo()">🔍 查找演示</button>
                        <button class="reset-btn" onclick="resetBTree()">🔄 重置</button>
                    </div>

                    <div class="canvas-container">
                        <canvas id="btreeCanvas" width="900" height="500"></canvas>
                    </div>

                    <div class="legend">
                        <h4>图例说明</h4>
                        <div class="legend-items">
                            <div class="legend-item">
                                <div class="legend-node normal-node">
                                    <span>25|50</span>
                                </div>
                                <span>正常节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node current-node">
                                    <span>25|50</span>
                                </div>
                                <span>当前处理节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node new-node">
                                    <span>25|50</span>
                                </div>
                                <span>新插入节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-node split-node">
                                    <span>25|50</span>
                                </div>
                                <span>分裂节点</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-connection"></div>
                                <span>父子连接</span>
                            </div>
                        </div>
                        <div class="legend-explanation">
                            <p><strong>节点结构说明：</strong></p>
                            <ul>
                                <li><strong>关键字：</strong>节点内的数据项，用"|"分隔</li>
                                <li><strong>子指针：</strong>指向子树的连接线</li>
                                <li><strong>有序性：</strong>节点内关键字从左到右递增</li>
                                <li><strong>平衡性：</strong>所有叶子节点都在同一层</li>
                            </ul>
                            <div style="margin-top: 12px; padding: 10px; background: #f0f9ff; border-left: 3px solid #3b82f6; border-radius: 4px;">
                                <strong>💡 操作提示：</strong>
                                <ul style="margin: 8px 0 0 15px; font-size: 12px;">
                                    <li>🔢 <strong>插入操作</strong>：输入1-99的数字，观察节点分裂过程</li>
                                    <li>🗑️ <strong>删除操作</strong>：删除现有关键字，观察合并过程</li>
                                    <li>📝 <strong>演示模式</strong>：自动插入序列展示B树构建过程</li>
                                    <li>🎯 <strong>阶数调整</strong>：切换不同阶数体验不同的B树结构</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="info">
                        <div class="info-box">
                            <h4>操作历史</h4>
                            <div class="sequence" id="btreeHistory"></div>
                            <div class="status" id="btreeStatus">B树就绪，可以开始操作</div>
                        </div>
                        <div class="info-box">
                            <h4>树的统计</h4>
                            <div class="sequence" id="btreeStats"></div>
                            <div class="status" id="btreeStructure">树高度: 0, 节点数: 0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 💻 代码实现 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">💻</span>
                代码实现
            </h2>

            <div class="code-implementation">
                <div class="code-tabs">
                    <button class="tab-btn active" onclick="showCode('cpp')">C++</button>
                    <button class="tab-btn" onclick="showCode('java')">Java</button>
                    <button class="tab-btn" onclick="showCode('python')">Python</button>
                </div>

                <div id="cpp-code" class="code-content active">
                    <div class="code-header">
                        <span>C++ 实现</span>
                        <button onclick="copyCode('cpp', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="cpp-source">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

template&lt;typename T&gt;
class BTree {
private:
    struct BTreeNode {
        vector&lt;T&gt; keys;        // 关键字数组
        vector&lt;BTreeNode*&gt; children; // 子节点指针数组
        bool isLeaf;           // 是否为叶子节点

        BTreeNode(bool leaf) : isLeaf(leaf) {}

        ~BTreeNode() {
            for (auto child : children) {
                delete child;
            }
        }
    };

    BTreeNode* root;
    int minDegree; // B树的最小度数 t，阶数为 2t

public:
    BTree(int degree) : minDegree(degree), root(nullptr) {}

    ~BTree() {
        delete root;
    }

    // 搜索关键字
    bool search(T key) {
        return searchHelper(root, key);
    }

    // 插入关键字
    void insert(T key) {
        if (root == nullptr) {
            root = new BTreeNode(true);
            root-&gt;keys.push_back(key);
        } else {
            // 如果根节点满了，需要分裂
            if (root-&gt;keys.size() == 2 * minDegree - 1) {
                BTreeNode* newRoot = new BTreeNode(false);
                newRoot-&gt;children.push_back(root);
                splitChild(newRoot, 0);
                root = newRoot;
            }
            insertNonFull(root, key);
        }
    }

    // 删除关键字
    void remove(T key) {
        if (root == nullptr) return;

        removeHelper(root, key);

        // 如果根节点为空，调整树结构
        if (root-&gt;keys.empty()) {
            BTreeNode* oldRoot = root;
            if (root-&gt;isLeaf) {
                root = nullptr;
            } else {
                root = root-&gt;children[0];
            }
            oldRoot-&gt;children.clear(); // 避免递归删除
            delete oldRoot;
        }
    }

    // 遍历B树
    void traverse() {
        if (root != nullptr) {
            traverseHelper(root);
        }
        cout &lt;&lt; endl;
    }

private:
    bool searchHelper(BTreeNode* node, T key) {
        if (node == nullptr) return false;

        int i = 0;
        while (i &lt; node-&gt;keys.size() && key &gt; node-&gt;keys[i]) {
            i++;
        }

        if (i &lt; node-&gt;keys.size() && key == node-&gt;keys[i]) {
            return true;
        }

        if (node-&gt;isLeaf) {
            return false;
        }

        return searchHelper(node-&gt;children[i], key);
    }

    void insertNonFull(BTreeNode* node, T key) {
        int i = node-&gt;keys.size() - 1;

        if (node-&gt;isLeaf) {
            node-&gt;keys.push_back(T());
            while (i &gt;= 0 && key &lt; node-&gt;keys[i]) {
                node-&gt;keys[i + 1] = node-&gt;keys[i];
                i--;
            }
            node-&gt;keys[i + 1] = key;
        } else {
            while (i &gt;= 0 && key &lt; node-&gt;keys[i]) {
                i--;
            }
            i++;

            if (node-&gt;children[i]-&gt;keys.size() == 2 * minDegree - 1) {
                splitChild(node, i);
                if (key &gt; node-&gt;keys[i]) {
                    i++;
                }
            }
            insertNonFull(node-&gt;children[i], key);
        }
    }

    void splitChild(BTreeNode* parent, int childIndex) {
        BTreeNode* fullChild = parent-&gt;children[childIndex];
        BTreeNode* newChild = new BTreeNode(fullChild-&gt;isLeaf);

        // 将后半部分关键字移到新节点
        int midIndex = minDegree - 1;
        for (int i = 0; i &lt; minDegree - 1; i++) {
            newChild-&gt;keys.push_back(fullChild-&gt;keys[midIndex + 1 + i]);
        }

        // 如果不是叶子节点，移动子指针
        if (!fullChild-&gt;isLeaf) {
            for (int i = 0; i &lt; minDegree; i++) {
                newChild-&gt;children.push_back(fullChild-&gt;children[midIndex + 1 + i]);
            }
            fullChild-&gt;children.resize(minDegree);
        }

        // 调整原节点大小
        T midKey = fullChild-&gt;keys[midIndex];
        fullChild-&gt;keys.resize(midIndex);

        // 在父节点中插入中间关键字和新子节点
        parent-&gt;children.insert(parent-&gt;children.begin() + childIndex + 1, newChild);
        parent-&gt;keys.insert(parent-&gt;keys.begin() + childIndex, midKey);
    }

    void removeHelper(BTreeNode* node, T key) {
        int keyIndex = findKey(node, key);

        if (keyIndex &lt; node-&gt;keys.size() && node-&gt;keys[keyIndex] == key) {
            if (node-&gt;isLeaf) {
                // 情况1: 关键字在叶子节点中
                node-&gt;keys.erase(node-&gt;keys.begin() + keyIndex);
            } else {
                // 情况2: 关键字在内部节点中
                removeFromNonLeaf(node, keyIndex);
            }
        } else if (!node-&gt;isLeaf) {
            // 关键字不在当前节点中，递归到子节点
            bool shouldGoToLastChild = (keyIndex == node-&gt;keys.size());

            if (node-&gt;children[keyIndex]-&gt;keys.size() &lt; minDegree) {
                fillChild(node, keyIndex);
            }

            if (shouldGoToLastChild && keyIndex &gt; node-&gt;keys.size()) {
                removeHelper(node-&gt;children[keyIndex - 1], key);
            } else {
                removeHelper(node-&gt;children[keyIndex], key);
            }
        }
    }

    int findKey(BTreeNode* node, T key) {
        int index = 0;
        while (index &lt; node-&gt;keys.size() && node-&gt;keys[index] &lt; key) {
            index++;
        }
        return index;
    }

    void removeFromNonLeaf(BTreeNode* node, int keyIndex) {
        T key = node-&gt;keys[keyIndex];

        if (node-&gt;children[keyIndex]-&gt;keys.size() &gt;= minDegree) {
            // 左子节点有足够的关键字，找前驱
            T predecessor = getPredecessor(node, keyIndex);
            node-&gt;keys[keyIndex] = predecessor;
            removeHelper(node-&gt;children[keyIndex], predecessor);
        } else if (node-&gt;children[keyIndex + 1]-&gt;keys.size() &gt;= minDegree) {
            // 右子节点有足够的关键字，找后继
            T successor = getSuccessor(node, keyIndex);
            node-&gt;keys[keyIndex] = successor;
            removeHelper(node-&gt;children[keyIndex + 1], successor);
        } else {
            // 两个子节点都只有最少关键字数，合并
            mergeChildren(node, keyIndex);
            removeHelper(node-&gt;children[keyIndex], key);
        }
    }

    T getPredecessor(BTreeNode* node, int keyIndex) {
        BTreeNode* current = node-&gt;children[keyIndex];
        while (!current-&gt;isLeaf) {
            current = current-&gt;children.back();
        }
        return current-&gt;keys.back();
    }

    T getSuccessor(BTreeNode* node, int keyIndex) {
        BTreeNode* current = node-&gt;children[keyIndex + 1];
        while (!current-&gt;isLeaf) {
            current = current-&gt;children[0];
        }
        return current-&gt;keys[0];
    }

    void fillChild(BTreeNode* node, int childIndex) {
        // 尝试从兄弟节点借关键字，或者合并节点
        if (childIndex != 0 && node-&gt;children[childIndex - 1]-&gt;keys.size() &gt;= minDegree) {
            borrowFromPrev(node, childIndex);
        } else if (childIndex != node-&gt;children.size() - 1 &&
                   node-&gt;children[childIndex + 1]-&gt;keys.size() &gt;= minDegree) {
            borrowFromNext(node, childIndex);
        } else {
            if (childIndex != node-&gt;children.size() - 1) {
                mergeChildren(node, childIndex);
            } else {
                mergeChildren(node, childIndex - 1);
            }
        }
    }

    void borrowFromPrev(BTreeNode* node, int childIndex) {
        BTreeNode* child = node-&gt;children[childIndex];
        BTreeNode* sibling = node-&gt;children[childIndex - 1];

        child-&gt;keys.insert(child-&gt;keys.begin(), node-&gt;keys[childIndex - 1]);
        node-&gt;keys[childIndex - 1] = sibling-&gt;keys.back();
        sibling-&gt;keys.pop_back();

        if (!child-&gt;isLeaf) {
            child-&gt;children.insert(child-&gt;children.begin(), sibling-&gt;children.back());
            sibling-&gt;children.pop_back();
        }
    }

    void borrowFromNext(BTreeNode* node, int childIndex) {
        BTreeNode* child = node-&gt;children[childIndex];
        BTreeNode* sibling = node-&gt;children[childIndex + 1];

        child-&gt;keys.push_back(node-&gt;keys[childIndex]);
        node-&gt;keys[childIndex] = sibling-&gt;keys[0];
        sibling-&gt;keys.erase(sibling-&gt;keys.begin());

        if (!child-&gt;isLeaf) {
            child-&gt;children.push_back(sibling-&gt;children[0]);
            sibling-&gt;children.erase(sibling-&gt;children.begin());
        }
    }

    void mergeChildren(BTreeNode* node, int childIndex) {
        BTreeNode* child = node-&gt;children[childIndex];
        BTreeNode* sibling = node-&gt;children[childIndex + 1];

        child-&gt;keys.push_back(node-&gt;keys[childIndex]);

        for (int i = 0; i &lt; sibling-&gt;keys.size(); i++) {
            child-&gt;keys.push_back(sibling-&gt;keys[i]);
        }

        if (!child-&gt;isLeaf) {
            for (int i = 0; i &lt; sibling-&gt;children.size(); i++) {
                child-&gt;children.push_back(sibling-&gt;children[i]);
            }
        }

        node-&gt;keys.erase(node-&gt;keys.begin() + childIndex);
        node-&gt;children.erase(node-&gt;children.begin() + childIndex + 1);

        sibling-&gt;children.clear(); // 避免递归删除
        delete sibling;
    }

    void traverseHelper(BTreeNode* node) {
        int i;
        for (i = 0; i &lt; node-&gt;keys.size(); i++) {
            if (!node-&gt;isLeaf) {
                traverseHelper(node-&gt;children[i]);
            }
            cout &lt;&lt; node-&gt;keys[i] &lt;&lt; " ";
        }
        if (!node-&gt;isLeaf) {
            traverseHelper(node-&gt;children[i]);
        }
    }
};</code></pre>
                </div>

                <div id="java-code" class="code-content">
                    <div class="code-header">
                        <span>Java 实现</span>
                        <button onclick="copyCode('java', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="java-source">import java.util.*;

public class BTree&lt;T extends Comparable&lt;T&gt;&gt; {
    private BTreeNode root;
    private int minDegree; // B树的最小度数 t

    private class BTreeNode {
        List&lt;T&gt; keys;           // 关键字列表
        List&lt;BTreeNode&gt; children; // 子节点列表
        boolean isLeaf;         // 是否为叶子节点

        BTreeNode(boolean isLeaf) {
            this.keys = new ArrayList&lt;&gt;();
            this.children = new ArrayList&lt;&gt;();
            this.isLeaf = isLeaf;
        }
    }

    public BTree(int degree) {
        this.minDegree = degree;
        this.root = null;
    }

    // 搜索关键字
    public boolean search(T key) {
        return search(root, key);
    }

    private boolean search(BTreeNode node, T key) {
        if (node == null) return false;

        int i = 0;
        while (i &lt; node.keys.size() && key.compareTo(node.keys.get(i)) &gt; 0) {
            i++;
        }

        if (i &lt; node.keys.size() && key.compareTo(node.keys.get(i)) == 0) {
            return true;
        }

        if (node.isLeaf) {
            return false;
        }

        return search(node.children.get(i), key);
    }

    // 插入关键字
    public void insert(T key) {
        if (root == null) {
            root = new BTreeNode(true);
            root.keys.add(key);
        } else {
            if (root.keys.size() == 2 * minDegree - 1) {
                BTreeNode newRoot = new BTreeNode(false);
                newRoot.children.add(root);
                splitChild(newRoot, 0);
                root = newRoot;
            }
            insertNonFull(root, key);
        }
    }

    private void insertNonFull(BTreeNode node, T key) {
        int i = node.keys.size() - 1;

        if (node.isLeaf) {
            node.keys.add(null);
            while (i &gt;= 0 && key.compareTo(node.keys.get(i)) &lt; 0) {
                node.keys.set(i + 1, node.keys.get(i));
                i--;
            }
            node.keys.set(i + 1, key);
        } else {
            while (i &gt;= 0 && key.compareTo(node.keys.get(i)) &lt; 0) {
                i--;
            }
            i++;

            if (node.children.get(i).keys.size() == 2 * minDegree - 1) {
                splitChild(node, i);
                if (key.compareTo(node.keys.get(i)) &gt; 0) {
                    i++;
                }
            }
            insertNonFull(node.children.get(i), key);
        }
    }

    private void splitChild(BTreeNode parent, int childIndex) {
        BTreeNode fullChild = parent.children.get(childIndex);
        BTreeNode newChild = new BTreeNode(fullChild.isLeaf);

        int midIndex = minDegree - 1;

        // 移动后半部分关键字
        for (int i = 0; i &lt; minDegree - 1; i++) {
            newChild.keys.add(fullChild.keys.get(midIndex + 1 + i));
        }

        // 如果不是叶子节点，移动子指针
        if (!fullChild.isLeaf) {
            for (int i = 0; i &lt; minDegree; i++) {
                newChild.children.add(fullChild.children.get(midIndex + 1 + i));
            }
            // 移除已移动的子节点
            for (int i = 0; i &lt; minDegree; i++) {
                fullChild.children.remove(fullChild.children.size() - 1);
            }
        }

        // 获取中间关键字
        T midKey = fullChild.keys.get(midIndex);

        // 移除已移动的关键字
        for (int i = 0; i &lt; minDegree; i++) {
            fullChild.keys.remove(fullChild.keys.size() - 1);
        }

        // 在父节点中插入中间关键字和新子节点
        parent.children.add(childIndex + 1, newChild);
        parent.keys.add(childIndex, midKey);
    }

    // 删除关键字
    public void remove(T key) {
        if (root == null) return;

        remove(root, key);

        if (root.keys.isEmpty()) {
            if (!root.isLeaf) {
                root = root.children.get(0);
            } else {
                root = null;
            }
        }
    }

    private void remove(BTreeNode node, T key) {
        int keyIndex = findKey(node, key);

        if (keyIndex &lt; node.keys.size() &&
            key.compareTo(node.keys.get(keyIndex)) == 0) {
            if (node.isLeaf) {
                node.keys.remove(keyIndex);
            } else {
                removeFromNonLeaf(node, keyIndex);
            }
        } else if (!node.isLeaf) {
            boolean shouldGoToLastChild = (keyIndex == node.keys.size());

            if (node.children.get(keyIndex).keys.size() &lt; minDegree) {
                fillChild(node, keyIndex);
            }

            if (shouldGoToLastChild && keyIndex &gt; node.keys.size()) {
                remove(node.children.get(keyIndex - 1), key);
            } else {
                remove(node.children.get(keyIndex), key);
            }
        }
    }

    private int findKey(BTreeNode node, T key) {
        int index = 0;
        while (index &lt; node.keys.size() &&
               key.compareTo(node.keys.get(index)) &gt; 0) {
            index++;
        }
        return index;
    }

    private void removeFromNonLeaf(BTreeNode node, int keyIndex) {
        T key = node.keys.get(keyIndex);

        if (node.children.get(keyIndex).keys.size() &gt;= minDegree) {
            T predecessor = getPredecessor(node, keyIndex);
            node.keys.set(keyIndex, predecessor);
            remove(node.children.get(keyIndex), predecessor);
        } else if (node.children.get(keyIndex + 1).keys.size() &gt;= minDegree) {
            T successor = getSuccessor(node, keyIndex);
            node.keys.set(keyIndex, successor);
            remove(node.children.get(keyIndex + 1), successor);
        } else {
            mergeChildren(node, keyIndex);
            remove(node.children.get(keyIndex), key);
        }
    }

    private T getPredecessor(BTreeNode node, int keyIndex) {
        BTreeNode current = node.children.get(keyIndex);
        while (!current.isLeaf) {
            current = current.children.get(current.children.size() - 1);
        }
        return current.keys.get(current.keys.size() - 1);
    }

    private T getSuccessor(BTreeNode node, int keyIndex) {
        BTreeNode current = node.children.get(keyIndex + 1);
        while (!current.isLeaf) {
            current = current.children.get(0);
        }
        return current.keys.get(0);
    }

    private void fillChild(BTreeNode node, int childIndex) {
        if (childIndex != 0 &&
            node.children.get(childIndex - 1).keys.size() &gt;= minDegree) {
            borrowFromPrev(node, childIndex);
        } else if (childIndex != node.children.size() - 1 &&
                   node.children.get(childIndex + 1).keys.size() &gt;= minDegree) {
            borrowFromNext(node, childIndex);
        } else {
            if (childIndex != node.children.size() - 1) {
                mergeChildren(node, childIndex);
            } else {
                mergeChildren(node, childIndex - 1);
            }
        }
    }

    private void borrowFromPrev(BTreeNode node, int childIndex) {
        BTreeNode child = node.children.get(childIndex);
        BTreeNode sibling = node.children.get(childIndex - 1);

        child.keys.add(0, node.keys.get(childIndex - 1));
        node.keys.set(childIndex - 1,
                     sibling.keys.get(sibling.keys.size() - 1));
        sibling.keys.remove(sibling.keys.size() - 1);

        if (!child.isLeaf) {
            child.children.add(0,
                sibling.children.get(sibling.children.size() - 1));
            sibling.children.remove(sibling.children.size() - 1);
        }
    }

    private void borrowFromNext(BTreeNode node, int childIndex) {
        BTreeNode child = node.children.get(childIndex);
        BTreeNode sibling = node.children.get(childIndex + 1);

        child.keys.add(node.keys.get(childIndex));
        node.keys.set(childIndex, sibling.keys.get(0));
        sibling.keys.remove(0);

        if (!child.isLeaf) {
            child.children.add(sibling.children.get(0));
            sibling.children.remove(0);
        }
    }

    private void mergeChildren(BTreeNode node, int childIndex) {
        BTreeNode child = node.children.get(childIndex);
        BTreeNode sibling = node.children.get(childIndex + 1);

        child.keys.add(node.keys.get(childIndex));
        child.keys.addAll(sibling.keys);

        if (!child.isLeaf) {
            child.children.addAll(sibling.children);
        }

        node.keys.remove(childIndex);
        node.children.remove(childIndex + 1);
    }

    // 遍历B树
    public void traverse() {
        if (root != null) {
            traverse(root);
        }
        System.out.println();
    }

    private void traverse(BTreeNode node) {
        int i;
        for (i = 0; i &lt; node.keys.size(); i++) {
            if (!node.isLeaf) {
                traverse(node.children.get(i));
            }
            System.out.print(node.keys.get(i) + " ");
        }
        if (!node.isLeaf) {
            traverse(node.children.get(i));
        }
    }
}</code></pre>
                </div>

                <div id="python-code" class="code-content">
                    <div class="code-header">
                        <span>Python 实现</span>
                        <button onclick="copyCode('python', this)" class="copy-btn">📋 复制代码</button>
                    </div>
                    <pre><code id="python-source">class BTreeNode:
    """B树节点类"""
    def __init__(self, is_leaf=False):
        self.keys = []          # 关键字列表
        self.children = []      # 子节点列表
        self.is_leaf = is_leaf  # 是否为叶子节点

class BTree:
    """B树类"""
    def __init__(self, min_degree):
        self.root = None
        self.min_degree = min_degree  # B树的最小度数 t

    def search(self, key, node=None):
        """搜索关键字"""
        if node is None:
            node = self.root

        if node is None:
            return False

        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and key == node.keys[i]:
            return True

        if node.is_leaf:
            return False

        return self.search(key, node.children[i])

    def insert(self, key):
        """插入关键字"""
        if self.root is None:
            self.root = BTreeNode(is_leaf=True)
            self.root.keys.append(key)
        else:
            if len(self.root.keys) == 2 * self.min_degree - 1:
                # 根节点满了，需要分裂
                new_root = BTreeNode(is_leaf=False)
                new_root.children.append(self.root)
                self._split_child(new_root, 0)
                self.root = new_root

            self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """向非满节点插入关键字"""
        i = len(node.keys) - 1

        if node.is_leaf:
            node.keys.append(None)
            while i >= 0 and key < node.keys[i]:
                node.keys[i + 1] = node.keys[i]
                i -= 1
            node.keys[i + 1] = key
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1

            if len(node.children[i].keys) == 2 * self.min_degree - 1:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1

            self._insert_non_full(node.children[i], key)

    def _split_child(self, parent, child_index):
        """分裂子节点"""
        full_child = parent.children[child_index]
        new_child = BTreeNode(is_leaf=full_child.is_leaf)

        mid_index = self.min_degree - 1

        # 将后半部分关键字移到新节点
        new_child.keys = full_child.keys[mid_index + 1:]
        full_child.keys = full_child.keys[:mid_index]

        # 如果不是叶子节点，移动子指针
        if not full_child.is_leaf:
            new_child.children = full_child.children[mid_index + 1:]
            full_child.children = full_child.children[:mid_index + 1]

        # 在父节点中插入中间关键字和新子节点
        mid_key = full_child.keys[mid_index] if mid_index < len(full_child.keys) else full_child.keys[-1]
        if mid_index < len(full_child.keys):
            full_child.keys.pop()

        parent.children.insert(child_index + 1, new_child)
        parent.keys.insert(child_index, mid_key)

    def remove(self, key):
        """删除关键字"""
        if self.root is None:
            return

        self._remove_helper(self.root, key)

        # 如果根节点为空，调整树结构
        if len(self.root.keys) == 0:
            if not self.root.is_leaf:
                self.root = self.root.children[0]
            else:
                self.root = None

    def _remove_helper(self, node, key):
        """删除辅助函数"""
        key_index = self._find_key_index(node, key)

        if key_index < len(node.keys) and node.keys[key_index] == key:
            if node.is_leaf:
                # 情况1: 关键字在叶子节点中
                node.keys.pop(key_index)
            else:
                # 情况2: 关键字在内部节点中
                self._remove_from_non_leaf(node, key_index)
        elif not node.is_leaf:
            # 关键字不在当前节点中，递归到子节点
            should_go_to_last_child = (key_index == len(node.keys))

            if len(node.children[key_index].keys) < self.min_degree:
                self._fill_child(node, key_index)

            if should_go_to_last_child and key_index > len(node.keys):
                self._remove_helper(node.children[key_index - 1], key)
            else:
                self._remove_helper(node.children[key_index], key)

    def _find_key_index(self, node, key):
        """在节点中找到关键字的索引位置"""
        index = 0
        while index < len(node.keys) and node.keys[index] < key:
            index += 1
        return index

    def _remove_from_non_leaf(self, node, key_index):
        """从非叶子节点删除关键字"""
        key = node.keys[key_index]

        if len(node.children[key_index].keys) >= self.min_degree:
            # 左子节点有足够关键字，找前驱
            predecessor = self._get_predecessor(node, key_index)
            node.keys[key_index] = predecessor
            self._remove_helper(node.children[key_index], predecessor)
        elif len(node.children[key_index + 1].keys) >= self.min_degree:
            # 右子节点有足够关键字，找后继
            successor = self._get_successor(node, key_index)
            node.keys[key_index] = successor
            self._remove_helper(node.children[key_index + 1], successor)
        else:
            # 合并节点
            self._merge_children(node, key_index)
            self._remove_helper(node.children[key_index], key)

    def _get_predecessor(self, node, key_index):
        """获取前驱关键字"""
        current = node.children[key_index]
        while not current.is_leaf:
            current = current.children[-1]
        return current.keys[-1]

    def _get_successor(self, node, key_index):
        """获取后继关键字"""
        current = node.children[key_index + 1]
        while not current.is_leaf:
            current = current.children[0]
        return current.keys[0]

    def _fill_child(self, node, child_index):
        """填充子节点"""
        if (child_index != 0 and
            len(node.children[child_index - 1].keys) >= self.min_degree):
            self._borrow_from_prev(node, child_index)
        elif (child_index != len(node.children) - 1 and
              len(node.children[child_index + 1].keys) >= self.min_degree):
            self._borrow_from_next(node, child_index)
        else:
            if child_index != len(node.children) - 1:
                self._merge_children(node, child_index)
            else:
                self._merge_children(node, child_index - 1)

    def _borrow_from_prev(self, node, child_index):
        """从前一个兄弟节点借关键字"""
        child = node.children[child_index]
        sibling = node.children[child_index - 1]

        child.keys.insert(0, node.keys[child_index - 1])
        node.keys[child_index - 1] = sibling.keys.pop()

        if not child.is_leaf:
            child.children.insert(0, sibling.children.pop())

    def _borrow_from_next(self, node, child_index):
        """从后一个兄弟节点借关键字"""
        child = node.children[child_index]
        sibling = node.children[child_index + 1]

        child.keys.append(node.keys[child_index])
        node.keys[child_index] = sibling.keys.pop(0)

        if not child.is_leaf:
            child.children.append(sibling.children.pop(0))

    def _merge_children(self, node, child_index):
        """合并子节点"""
        child = node.children[child_index]
        sibling = node.children[child_index + 1]

        child.keys.append(node.keys[child_index])
        child.keys.extend(sibling.keys)

        if not child.is_leaf:
            child.children.extend(sibling.children)

        node.keys.pop(child_index)
        node.children.pop(child_index + 1)

    def traverse(self):
        """遍历B树"""
        if self.root is not None:
            result = []
            self._traverse_helper(self.root, result)
            return result
        return []

    def _traverse_helper(self, node, result):
        """遍历辅助函数"""
        i = 0
        for i in range(len(node.keys)):
            if not node.is_leaf:
                self._traverse_helper(node.children[i], result)
            result.append(node.keys[i])

        if not node.is_leaf:
            self._traverse_helper(node.children[i + 1], result)

# 使用示例
def example_usage():
    # 创建一个3阶B树
    btree = BTree(min_degree=2)

    # 插入关键字
    keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17]
    for key in keys_to_insert:
        btree.insert(key)
        print(f"插入 {key} 后的B树: {btree.traverse()}")

    # 搜索关键字
    search_keys = [6, 15, 20]
    for key in search_keys:
        found = btree.search(key)
        print(f"搜索 {key}: {'找到' if found else '未找到'}")

    # 删除关键字
    keys_to_delete = [6, 12, 5]
    for key in keys_to_delete:
        print(f"删除 {key} 前的B树: {btree.traverse()}")
        btree.remove(key)
        print(f"删除 {key} 后的B树: {btree.traverse()}")

if __name__ == "__main__":
    example_usage()</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 🌟 实际应用 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🌟</span>
                实际应用
            </h2>

            <div class="applications">
                <div class="unified-grid unified-grid-2">
                    <div class="app-item">
                        <h4>🗄️ 数据库索引</h4>
                        <p><strong>应用场景：</strong>MySQL、PostgreSQL等数据库的主键索引</p>
                        <p><strong>优势：</strong>减少磁盘I/O次数，提高查询效率</p>
                        <p><strong>实现：</strong>每个节点对应一个磁盘块，最大化利用磁盘空间</p>
                    </div>

                    <div class="app-item">
                        <h4>📁 文件系统</h4>
                        <p><strong>应用场景：</strong>NTFS、HFS+等文件系统的目录索引</p>
                        <p><strong>优势：</strong>快速定位文件，支持大量文件存储</p>
                        <p><strong>实现：</strong>文件名和inode信息存储在B树节点中</p>
                    </div>

                    <div class="app-item">
                        <h4>💾 NoSQL数据库</h4>
                        <p><strong>应用场景：</strong>MongoDB、CouchDB的存储引擎</p>
                        <p><strong>优势：</strong>支持范围查询，适合大数据场景</p>
                        <p><strong>实现：</strong>文档ID作为关键字，支持快速检索</p>
                    </div>

                    <div class="app-item">
                        <h4>🔍 搜索引擎</h4>
                        <p><strong>应用场景：</strong>倒排索引的存储和检索</p>
                        <p><strong>优势：</strong>高效的词汇查找和文档匹配</p>
                        <p><strong>实现：</strong>词汇作为关键字，文档列表作为数据</p>
                    </div>
                </div>

                <div class="comparison-table">
                    <h4>📈 性能对比</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>数据结构</th>
                                <th>查找时间</th>
                                <th>插入时间</th>
                                <th>空间利用率</th>
                                <th>适用场景</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>二叉搜索树</td>
                                <td>O(log n) ~ O(n)</td>
                                <td>O(log n) ~ O(n)</td>
                                <td>低</td>
                                <td>内存数据</td>
                            </tr>
                            <tr>
                                <td>平衡二叉树</td>
                                <td>O(log n)</td>
                                <td>O(log n)</td>
                                <td>中等</td>
                                <td>内存索引</td>
                            </tr>
                            <tr>
                                <td>B树</td>
                                <td>O(log n)</td>
                                <td>O(log n)</td>
                                <td>高</td>
                                <td>磁盘存储</td>
                            </tr>
                            <tr>
                                <td>哈希表</td>
                                <td>O(1)</td>
                                <td>O(1)</td>
                                <td>中等</td>
                                <td>精确匹配</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="concept-item">
                    <h3>🎯 B树 vs B+树 对比</h3>
                    <div class="unified-grid unified-grid-2">
                        <div class="comparison-box">
                            <h4>🌳 B树特点</h4>
                            <ul>
                                <li><strong>数据分布：</strong>内部节点和叶子节点都存储数据</li>
                                <li><strong>查找效率：</strong>可能在内部节点就找到数据</li>
                                <li><strong>空间利用：</strong>节点利用率相对较低</li>
                                <li><strong>范围查询：</strong>需要中序遍历，效率较低</li>
                            </ul>
                        </div>
                        <div class="comparison-box">
                            <h4>🌲 B+树特点</h4>
                            <ul>
                                <li><strong>数据分布：</strong>只有叶子节点存储数据</li>
                                <li><strong>查找效率：</strong>查找路径稳定，都到叶子节点</li>
                                <li><strong>空间利用：</strong>内部节点可容纳更多关键字</li>
                                <li><strong>范围查询：</strong>叶子节点链表，效率很高</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ✅ 学习检验 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">✅</span>
                学习检验
            </h2>

            <div class="quiz-section">
                <div class="quiz-item">
                    <h4>🤔 问题1：B树性质理解</h4>
                    <p>一棵4阶B树，每个节点最多可以存储多少个关键字？最少需要多少个关键字（根节点除外）？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(1)">点击查看答案</button>
                    <div id="answer1" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>最多关键字数：</strong>4-1=3个关键字<br>
                        <strong>最少关键字数：</strong>⌈4/2⌉-1=1个关键字<br>
                        <strong>解释：</strong>对于m阶B树，每个节点最多有m-1个关键字，非根节点最少有⌈m/2⌉-1个关键字<br>
                        <strong>子树数量：</strong>最多4个子树，最少2个子树
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题2：插入操作分析</h4>
                    <p>向B树插入关键字时，什么情况下会发生节点分裂？分裂后中间关键字去哪里了？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(2)">点击查看答案</button>
                    <div id="answer2" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>分裂条件：</strong>当节点中关键字数量达到m-1个时，再插入新关键字就会触发分裂<br>
                        <strong>中间关键字：</strong>分裂时选择中位数关键字上升到父节点<br>
                        <strong>分裂过程：</strong>左半部分和右半部分分别形成两个新节点<br>
                        <strong>递归性：</strong>如果父节点也满了，分裂会向上传播，可能导致树高增加
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题3：B树优势分析</h4>
                    <p>为什么B树特别适合作为数据库索引？相比二叉搜索树有什么优势？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(3)">点击查看答案</button>
                    <div id="answer3" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>磁盘I/O优化：</strong><br>
                        • B树节点可以填满一个磁盘块，最大化每次I/O的数据量<br>
                        • 树高较低，减少磁盘访问次数<br>
                        <strong>相比二叉树优势：</strong><br>
                        • 多路结构减少树高：log₂(n) vs logₘ(n)<br>
                        • 更好的空间局部性和缓存效率<br>
                        • 节点内部可以使用二分查找快速定位<br>
                        • 平衡性保证稳定的查询性能
                    </div>
                </div>

                <div class="quiz-item">
                    <h4>🤔 问题4：删除操作复杂度</h4>
                    <p>B树删除操作中，什么情况下需要合并节点？合并和借位的区别是什么？</p>
                    <button class="quiz-btn" onclick="toggleAnswer(4)">点击查看答案</button>
                    <div id="answer4" class="quiz-answer">
                        <strong>答案：</strong><br>
                        <strong>合并条件：</strong><br>
                        • 当前节点关键字数量少于最小值<br>
                        • 相邻兄弟节点也只有最少关键字，无法借位<br>
                        <strong>借位 vs 合并：</strong><br>
                        • <strong>借位：</strong>兄弟节点有多余关键字，通过父节点转移一个关键字<br>
                        • <strong>合并：</strong>两个节点关键字都不足，将它们合并成一个节点<br>
                        <strong>影响：</strong>合并可能导致父节点关键字减少，向上传播可能降低树高
                    </div>
                </div>
            </div>

            <div class="next-steps">
                <h4>🚀 下一步学习建议</h4>
                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <span class="info-icon">📖</span>
                        <strong>深入学习：</strong>B+树、B*树的设计原理和实现细节
                    </div>
                    <div class="info-box info-box-success">
                        <span class="info-icon">💪</span>
                        <strong>实践建议：</strong>实现一个简单的B树，理解数据库索引的工作机制
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<style>
/* 页面基础样式 - 继承线索二叉树的样式框架 */
.page-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.breadcrumb {
    margin-bottom: 20px;
    font-size: 14px;
    color: #666;
}

.page-header {
    text-align: center;
    margin-bottom: 30px;
}

.page-header h1 {
    font-size: 2.5rem;
    color: #333;
    margin-bottom: 10px;
}

.page-icon {
    font-size: 3rem;
    margin-right: 15px;
}

.content-card {
    background: white;
    border-radius: 12px;
    padding: 30px;
    margin-bottom: 20px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
}

.section-title {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.section-icon {
    font-size: 1.8rem;
}

/* 网格布局 */
.unified-grid {
    display: grid;
    gap: 20px;
}

.unified-grid-2 {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

/* 信息框样式 */
.info-box {
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #4299e1;
}

.info-box-info {
    background: #ebf8ff;
    border-left-color: #4299e1;
}

.info-box-success {
    background: #f0fff4;
    border-left-color: #48bb78;
}

.info-box-warning {
    background: #fffaf0;
    border-left-color: #ed8936;
}

.info-icon {
    margin-right: 8px;
}

/* 概念详解样式 */
.concept-item {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
}

.concept-item h3 {
    color: #2d3748;
    margin-bottom: 10px;
}

.example-box {
    margin-top: 15px;
    padding: 15px;
    background: #e6fffa;
    border-left: 4px solid #38b2ac;
    border-radius: 4px;
}

/* 问题解决方案样式 */
.problem-solution {
    margin-top: 25px;
}

.problem-box {
    padding: 20px;
    background: #fef2f2;
    border-left: 4px solid #f56565;
    border-radius: 8px;
}

.solution-box {
    padding: 20px;
    background: #f0fff4;
    border-left: 4px solid #48bb78;
    border-radius: 8px;
}

/* 统计框样式 */
.stats-box {
    margin-top: 15px;
    padding: 15px;
    background: #f7fafc;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.stats-box h5 {
    color: #2d3748;
    margin-bottom: 10px;
}

/* B树类型样式 */
.thread-types {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.type-box {
    padding: 15px;
    background: #ebf4ff;
    border-radius: 8px;
    border-left: 4px solid #3182ce;
    text-align: center;
}

.type-box h4 {
    color: #2b6cb0;
    margin-bottom: 10px;
}

.type-feature {
    margin-top: 10px;
    font-size: 0.9rem;
    color: #4a5568;
    font-style: italic;
}

/* 过程步骤样式 */
.process-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.step-box {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
}

.step-number {
    background: #4299e1;
    color: white;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    flex-shrink: 0;
}

.step-content h5 {
    color: #2d3748;
    margin-bottom: 5px;
}

/* 遍历算法样式 */
.traversal-algorithm {
    margin-top: 15px;
}

.algorithm-steps {
    background: #f7fafc;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.algo-step {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 10px;
    padding: 8px 0;
}

.step-label {
    background: #ed8936;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    font-weight: bold;
    flex-shrink: 0;
}

/* B树可视化演示样式 */
.canvas-demo {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group label {
    font-size: 14px;
    color: #4a5568;
    font-weight: 500;
}

.control-group select,
.control-group input {
    padding: 6px 10px;
    border: 2px solid #e2e8f0;
    border-radius: 6px;
    font-size: 14px;
    min-width: 80px;
}

.control-group select:focus,
.control-group input:focus {
    outline: none;
    border-color: #4299e1;
}

.preset-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 25px;
    flex-wrap: wrap;
}

.preset-controls button {
    padding: 10px 20px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    color: white;
}

.insert-btn { background: linear-gradient(45deg, #16a34a, #22c55e); }
.delete-btn { background: linear-gradient(45deg, #dc2626, #ef4444); }
.demo-btn { background: linear-gradient(45deg, #7c3aed, #a855f7); }
.search-btn { background: linear-gradient(45deg, #0ea5e9, #38bdf8); }
.reset-btn { background: linear-gradient(45deg, #4a5568, #6b7280); }

.preset-controls button:hover,
.control-group button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
}

.canvas-container {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
}

#btreeCanvas {
    border: 2px solid #e2e8f0;
    border-radius: 10px;
    background: white;
}

/* B树图例样式 */
.legend {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    margin: 20px 0;
    border: 1px solid #e2e8f0;
}

.legend h4 {
    margin: 0 0 15px 0;
    color: #2d3748;
    font-size: 16px;
}

.legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 15px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* B树节点样式 */
.legend-node {
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    min-width: 50px;
    text-align: center;
    border: 2px solid;
}

.normal-node {
    background: #f3f4f6;
    border-color: #9ca3af;
    color: #374151;
}

.current-node {
    background: #ef4444;
    border-color: #dc2626;
    color: white;
}

.new-node {
    background: #22c55e;
    border-color: #16a34a;
    color: white;
}

.split-node {
    background: #f59e0b;
    border-color: #d97706;
    color: white;
}

.legend-connection {
    width: 30px;
    height: 3px;
    background: #374151;
}

.legend-explanation {
    background: white;
    padding: 12px;
    border-radius: 6px;
    border-left: 4px solid #3b82f6;
}

.legend-explanation p {
    margin: 0 0 8px 0;
    font-weight: bold;
    color: #2d3748;
}

.legend-explanation ul {
    margin: 0;
    padding-left: 20px;
}

.legend-explanation li {
    margin-bottom: 4px;
    font-size: 14px;
    color: #4a5568;
}

.info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.info .info-box {
    background: #f7fafc;
    border: 1px solid #e2e8f0;
}

.info h4 {
    margin-top: 0;
    color: #2d3748;
}

.sequence {
    font-size: 16px;
    font-weight: bold;
    color: #4299e1;
    min-height: 20px;
}

.status {
    font-size: 14px;
    color: #718096;
    margin-top: 8px;
}

/* 代码样式 */
.code-tabs {
    display: flex;
    border-bottom: 1px solid #e2e8f0;
    margin-bottom: 20px;
}

.tab-btn {
    padding: 12px 24px;
    border: none;
    background: none;
    cursor: pointer;
    font-size: 16px;
    border-bottom: 2px solid transparent;
    transition: all 0.3s ease;
}

.tab-btn.active {
    color: #4299e1;
    border-bottom-color: #4299e1;
}

.code-content {
    display: none;
}

.code-content.active {
    display: block;
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.copy-btn {
    background: #4299e1;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.copy-btn:hover {
    background: #3182ce;
}

pre {
    background: #2d3748;
    color: #e2e8f0;
    padding: 20px;
    border-radius: 8px;
    overflow-x: auto;
    line-height: 1.6;
    font-size: 14px;
}

/* 应用场景样式 */
.app-item {
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #4299e1;
}

.app-item h4 {
    color: #2d3748;
    margin-bottom: 15px;
}

/* 性能对比表格样式 */
.comparison-table {
    margin-top: 30px;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
}

.comparison-table th,
.comparison-table td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
}

.comparison-table th {
    background: #f7fafc;
    font-weight: bold;
    color: #2d3748;
}

/* 对比框样式 */
.comparison-box {
    padding: 20px;
    background: #f0f9ff;
    border-radius: 8px;
    border-left: 4px solid #0ea5e9;
}

.comparison-box h4 {
    color: #0c4a6e;
    margin-bottom: 15px;
}

.comparison-box ul {
    margin: 0;
    padding-left: 20px;
}

.comparison-box li {
    margin-bottom: 8px;
    color: #1e40af;
}

/* 术语列表样式 */
.terms-list .unified-grid-2 {
    margin-top: 15px;
}

.term-item {
    padding: 12px;
    background: white;
    border-radius: 6px;
    border-left: 3px solid #4299e1;
}

/* 测验样式 */
.quiz-item {
    margin-bottom: 25px;
    padding: 20px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
}

.quiz-btn {
    background: #4299e1;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    margin-top: 15px;
    transition: background 0.3s ease;
}

.quiz-btn:hover {
    background: #3182ce;
}

.quiz-answer {
    display: none;
    margin-top: 15px;
    padding: 15px;
    background: #f0fff4;
    border-left: 4px solid #48bb78;
    border-radius: 4px;
}

.quiz-answer.show {
    display: block;
}

.unified-btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 500;
    margin: 0 10px;
    transition: all 0.3s ease;
}

.unified-btn-primary {
    background: #4299e1;
    color: white;
}

.unified-btn-secondary {
    background: #718096;
    color: white;
}

.unified-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

@media (max-width: 768px) {
    .info {
        grid-template-columns: 1fr;
    }

    .controls {
        flex-direction: column;
    }

    .preset-controls {
        flex-direction: column;
        align-items: center;
    }

    .preset-controls button {
        width: 200px;
    }

    .unified-grid-2 {
        grid-template-columns: 1fr;
    }

    .thread-types {
        grid-template-columns: 1fr;
    }

    .process-steps {
        grid-template-columns: 1fr;
    }

    .comparison-table table {
        font-size: 12px;
    }
}
</style>

<script>
// B树可视化演示相关代码
const btreeCanvas = document.getElementById('btreeCanvas');
const btreeCtx = btreeCanvas.getContext('2d');

// B树节点类
class BTreeNode {
    constructor(isLeaf = true) {
        this.keys = [];
        this.children = [];
        this.isLeaf = isLeaf;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 40;
        this.state = 'normal'; // normal, current, new, split
    }
}

// B树类
class BTree {
    constructor(order = 4) {
        this.root = null;
        this.order = order;
        this.minKeys = Math.floor((order - 1) / 2);
        this.maxKeys = order - 1;
    }

    insert(key) {
        if (this.root === null) {
            this.root = new BTreeNode(true);
            this.root.keys.push(key);
            return { type: 'create', node: this.root };
        }

        if (this.root.keys.length === this.maxKeys) {
            const newRoot = new BTreeNode(false);
            newRoot.children.push(this.root);
            this.splitChild(newRoot, 0);
            this.root = newRoot;
        }

        return this.insertNonFull(this.root, key);
    }

    insertNonFull(node, key) {
        let i = node.keys.length - 1;

        if (node.isLeaf) {
            node.keys.push(0);
            while (i >= 0 && key < node.keys[i]) {
                node.keys[i + 1] = node.keys[i];
                i--;
            }
            node.keys[i + 1] = key;
            return { type: 'insert', node: node, key: key };
        } else {
            while (i >= 0 && key < node.keys[i]) {
                i--;
            }
            i++;

            if (node.children[i].keys.length === this.maxKeys) {
                this.splitChild(node, i);
                if (key > node.keys[i]) {
                    i++;
                }
            }
            return this.insertNonFull(node.children[i], key);
        }
    }

    splitChild(parent, childIndex) {
        const fullChild = parent.children[childIndex];
        const newChild = new BTreeNode(fullChild.isLeaf);

        const midIndex = Math.floor(this.maxKeys / 2);

        // 移动后半部分关键字
        newChild.keys = fullChild.keys.splice(midIndex + 1);

        // 如果不是叶子节点，移动子指针
        if (!fullChild.isLeaf) {
            newChild.children = fullChild.children.splice(midIndex + 1);
        }

        // 提升中间关键字
        const midKey = fullChild.keys.pop();

        // 插入到父节点
        parent.children.splice(childIndex + 1, 0, newChild);
        parent.keys.splice(childIndex, 0, midKey);

        return { type: 'split', parent: parent, oldChild: fullChild, newChild: newChild, midKey: midKey };
    }

    search(key, node = null) {
        if (node === null) node = this.root;
        if (node === null) return false;

        let i = 0;
        while (i < node.keys.length && key > node.keys[i]) {
            i++;
        }

        if (i < node.keys.length && key === node.keys[i]) {
            return { found: true, node: node, index: i };
        }

        if (node.isLeaf) {
            return { found: false };
        }

        return this.search(key, node.children[i]);
    }

    // 获取树的高度
    getHeight(node = null) {
        if (node === null) node = this.root;
        if (node === null) return 0;

        if (node.isLeaf) return 1;

        let maxHeight = 0;
        for (let child of node.children) {
            maxHeight = Math.max(maxHeight, this.getHeight(child));
        }
        return maxHeight + 1;
    }

    // 获取节点数量
    getNodeCount(node = null) {
        if (node === null) node = this.root;
        if (node === null) return 0;

        let count = 1;
        for (let child of node.children) {
            count += this.getNodeCount(child);
        }
        return count;
    }

    // 获取关键字总数
    getKeyCount(node = null) {
        if (node === null) node = this.root;
        if (node === null) return 0;

        let count = node.keys.length;
        for (let child of node.children) {
            count += this.getKeyCount(child);
        }
        return count;
    }
}

// 全局变量
let btree = new BTree(4);
let animationState = {
    isAnimating: false,
    history: []
};

// 计算节点布局
function calculateLayout(node, level = 0, x = 450, levelWidth = 800) {
    if (!node) return;

    const keyWidth = 35;
    const nodeMargin = 20;
    node.width = node.keys.length * keyWidth + nodeMargin;
    node.x = x;
    node.y = 80 + level * 80;

    if (!node.isLeaf && node.children.length > 0) {
        const childrenCount = node.children.length;
        const childWidth = levelWidth / childrenCount;
        const startX = x - levelWidth / 2 + childWidth / 2;

        for (let i = 0; i < node.children.length; i++) {
            const childX = startX + i * childWidth;
            calculateLayout(node.children[i], level + 1, childX, childWidth * 0.8);
        }
    }
}

// 绘制B树节点
function drawBTreeNode(node) {
    if (!node) return;

    const keyWidth = 35;
    const nodeHeight = 40;
    const x = node.x - node.width / 2;
    const y = node.y - nodeHeight / 2;

    // 根据状态设置颜色
    let fillColor, strokeColor, textColor;
    switch (node.state) {
        case 'current':
            fillColor = '#ef4444';
            strokeColor = '#dc2626';
            textColor = 'white';
            break;
        case 'new':
            fillColor = '#22c55e';
            strokeColor = '#16a34a';
            textColor = 'white';
            break;
        case 'split':
            fillColor = '#f59e0b';
            strokeColor = '#d97706';
            textColor = 'white';
            break;
        default:
            fillColor = '#f3f4f6';
            strokeColor = '#9ca3af';
            textColor = '#374151';
    }

    // 绘制节点背景
    btreeCtx.fillStyle = fillColor;
    btreeCtx.fillRect(x, y, node.width, nodeHeight);

    // 绘制节点边框
    btreeCtx.strokeStyle = strokeColor;
    btreeCtx.lineWidth = 2;
    btreeCtx.strokeRect(x, y, node.width, nodeHeight);

    // 绘制分隔线和关键字
    btreeCtx.strokeStyle = strokeColor;
    btreeCtx.lineWidth = 1;
    btreeCtx.fillStyle = textColor;
    btreeCtx.font = 'bold 14px Arial';
    btreeCtx.textAlign = 'center';
    btreeCtx.textBaseline = 'middle';

    for (let i = 0; i < node.keys.length; i++) {
        const keyX = x + (i + 0.5) * keyWidth + 10;
        const keyY = node.y;

        // 绘制分隔线
        if (i > 0) {
            btreeCtx.beginPath();
            btreeCtx.moveTo(x + i * keyWidth + 10, y);
            btreeCtx.lineTo(x + i * keyWidth + 10, y + nodeHeight);
            btreeCtx.stroke();
        }

        // 绘制关键字
        btreeCtx.fillText(node.keys[i].toString(), keyX, keyY);
    }
}

// 绘制连接线
function drawConnections(node) {
    if (!node || node.isLeaf) return;

    const nodeY = node.y + 20;

    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childY = child.y - 20;

        // 计算连接点
        const parentX = node.x + (i - node.children.length / 2 + 0.5) * 20;

        btreeCtx.strokeStyle = '#6b7280';
        btreeCtx.lineWidth = 2;
        btreeCtx.beginPath();
        btreeCtx.moveTo(parentX, nodeY);
        btreeCtx.lineTo(child.x, childY);
        btreeCtx.stroke();

        // 递归绘制子节点的连接
        drawConnections(child);
    }
}

// 绘制整个B树
function drawBTree() {
    btreeCtx.clearRect(0, 0, btreeCanvas.width, btreeCanvas.height);

    if (!btree.root) {
        btreeCtx.fillStyle = '#6b7280';
        btreeCtx.font = '18px Arial';
        btreeCtx.textAlign = 'center';
        btreeCtx.fillText('B树为空，请插入数据', btreeCanvas.width / 2, btreeCanvas.height / 2);
        return;
    }

    // 计算布局
    calculateLayout(btree.root);

    // 绘制连接线（底层）
    drawConnections(btree.root);

    // 绘制节点（顶层）
    function drawAllNodes(node) {
        if (node) {
            drawBTreeNode(node);
            for (let child of node.children) {
                drawAllNodes(child);
            }
        }
    }
    drawAllNodes(btree.root);
}

// 重置所有节点状态
function resetNodeStates(node = btree.root) {
    if (node) {
        node.state = 'normal';
        for (let child of node.children) {
            resetNodeStates(child);
        }
    }
}

// 更新统计信息
function updateStats() {
    const height = btree.getHeight();
    const nodeCount = btree.getNodeCount();
    const keyCount = btree.getKeyCount();

    document.getElementById('btreeStats').textContent =
        `关键字总数: ${keyCount}, 节点总数: ${nodeCount}`;
    document.getElementById('btreeStructure').textContent =
        `树高度: ${height}, 阶数: ${btree.order}`;
}

// 插入关键字
async function insertKey() {
    if (animationState.isAnimating) return;

    const input = document.getElementById('insertValue');
    const value = parseInt(input.value);

    if (isNaN(value) || value < 1 || value > 99) {
        alert('请输入1-99之间的数字');
        return;
    }

    // 检查是否已存在
    const searchResult = btree.search(value);
    if (searchResult.found) {
        alert(`关键字 ${value} 已经存在`);
        return;
    }

    animationState.isAnimating = true;

    try {
        resetNodeStates();
        const result = btree.insert(value);

        if (result.node) {
            result.node.state = 'new';
        }

        drawBTree();
        updateStats();

        // 添加到历史记录
        animationState.history.push(`插入 ${value}`);
        updateHistory();

        document.getElementById('btreeStatus').textContent = `成功插入关键字 ${value}`;

        // 重置状态
        setTimeout(() => {
            resetNodeStates();
            drawBTree();
        }, 2000);

    } catch (error) {
        console.error('插入操作出错:', error);
        document.getElementById('btreeStatus').textContent = '插入操作失败';
    }

    input.value = '';
    animationState.isAnimating = false;
}

// 删除关键字（简化版）
async function deleteKey() {
    const input = document.getElementById('deleteValue');
    const value = parseInt(input.value);

    if (isNaN(value)) {
        alert('请输入有效数字');
        return;
    }

    // 简化的删除操作 - 重新构建B树
    const allKeys = [];
    function collectKeys(node) {
        if (node) {
            allKeys.push(...node.keys);
            for (let child of node.children) {
                collectKeys(child);
            }
        }
    }

    collectKeys(btree.root);
    const filteredKeys = allKeys.filter(k => k !== value);

    if (filteredKeys.length === allKeys.length) {
        alert(`关键字 ${value} 不存在`);
        return;
    }

    // 重新构建B树
    btree = new BTree(btree.order);
    for (let key of filteredKeys) {
        btree.insert(key);
    }

    drawBTree();
    updateStats();

    animationState.history.push(`删除 ${value}`);
    updateHistory();

    document.getElementById('btreeStatus').textContent = `成功删除关键字 ${value}`;
    input.value = '';
}

// 查找演示
async function searchDemo() {
    if (!btree.root) {
        alert('请先插入一些数据');
        return;
    }

    const keys = [];
    function collectKeys(node) {
        if (node) {
            keys.push(...node.keys);
            for (let child of node.children) {
                collectKeys(child);
            }
        }
    }
    collectKeys(btree.root);

    if (keys.length === 0) return;

    const randomKey = keys[Math.floor(Math.random() * keys.length)];
    const result = btree.search(randomKey);

    if (result.found) {
        resetNodeStates();
        result.node.state = 'current';
        drawBTree();

        document.getElementById('btreeStatus').textContent =
            `找到关键字 ${randomKey} 在节点中`;

        setTimeout(() => {
            resetNodeStates();
            drawBTree();
        }, 2000);
    }
}

// 演示插入
async function insertDemo() {
    if (animationState.isAnimating) return;

    const demoKeys = [50, 25, 75, 10, 30, 60, 80, 5, 15, 35];
    animationState.isAnimating = true;

    for (let key of demoKeys) {
        const searchResult = btree.search(key);
        if (!searchResult.found) {
            await new Promise(resolve => {
                setTimeout(() => {
                    resetNodeStates();
                    const result = btree.insert(key);
                    if (result.node) {
                        result.node.state = 'new';
                    }
                    drawBTree();
                    updateStats();

                    animationState.history.push(`插入 ${key}`);
                    updateHistory();

                    document.getElementById('btreeStatus').textContent =
                        `演示插入关键字 ${key}`;

                    setTimeout(() => {
                        resetNodeStates();
                        drawBTree();
                        resolve();
                    }, 1500);
                }, 800);
            });
        }
    }

    animationState.isAnimating = false;
    document.getElementById('btreeStatus').textContent = '演示插入完成';
}

// 重置B树
function resetBTree() {
    btree = new BTree(btree.order);
    animationState.history = [];
    resetNodeStates();
    drawBTree();
    updateStats();
    updateHistory();
    document.getElementById('btreeStatus').textContent = 'B树已重置';
}

// 改变阶数
function changeOrder() {
    const select = document.getElementById('btreeOrder');
    const newOrder = parseInt(select.value);
    btree = new BTree(newOrder);
    resetBTree();
    document.getElementById('btreeStatus').textContent = `已切换到${newOrder}阶B树`;
}

// 更新历史记录
function updateHistory() {
    const history = animationState.history.slice(-10); // 只显示最近10条
    document.getElementById('btreeHistory').textContent =
        history.length > 0 ? history.join(' → ') : '暂无操作';
}

// 代码相关功能
function showCode(language) {
    const codeContents = document.querySelectorAll('.code-content');
    codeContents.forEach(content => content.classList.remove('active'));

    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => tab.classList.remove('active'));

    document.getElementById(`${language}-code`).classList.add('active');
    event.target.classList.add('active');
}

function copyCode(language, buttonElement) {
    let button = buttonElement;
    if (!button) {
        button = event ? event.target : null;
    }

    if (!button) {
        console.error('无法获取按钮元素');
        return;
    }

    const codeElement = document.getElementById(`${language}-source`);

    if (!codeElement) {
        console.error(`找不到代码元素: ${language}-source`);
        showCopyError(button);
        return;
    }

    const text = codeElement.textContent || codeElement.innerText;
    const cleanText = text.trim();

    if (!cleanText) {
        console.error('代码内容为空');
        showCopyError(button);
        return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(cleanText).then(() => {
            showCopySuccess(button);
        }).catch(err => {
            console.error('现代API复制失败:', err);
            fallbackCopyTextToClipboard(cleanText, button);
        });
    } else {
        fallbackCopyTextToClipboard(cleanText, button);
    }
}

function fallbackCopyTextToClipboard(text, button) {
    const textArea = document.createElement("textarea");
    textArea.value = text;

    textArea.style.position = "fixed";
    textArea.style.top = "-1000px";
    textArea.style.left = "-1000px";
    textArea.style.width = "1px";
    textArea.style.height = "1px";
    textArea.style.padding = "0";
    textArea.style.border = "none";
    textArea.style.outline = "none";
    textArea.style.boxShadow = "none";
    textArea.style.background = "transparent";

    document.body.appendChild(textArea);

    try {
        textArea.focus();
        textArea.select();
        textArea.setSelectionRange(0, text.length);

        const successful = document.execCommand('copy');

        if (successful) {
            showCopySuccess(button);
        } else {
            console.error('execCommand复制失败');
            showCopyError(button);
        }
    } catch (err) {
        console.error('降级复制方法出错:', err);
        showCopyError(button);
    } finally {
        document.body.removeChild(textArea);
    }
}

function showCopySuccess(button) {
    if (!button) return;

    const originalText = button.innerHTML;
    const originalClass = button.className;

    button.innerHTML = '✅ 已复制';
    button.className = originalClass + ' copy-success';
    button.disabled = true;

    const originalStyle = button.style.cssText;
    button.style.cssText = originalStyle + '; background: #22c55e !important; color: white !important;';

    setTimeout(() => {
        button.innerHTML = originalText;
        button.className = originalClass;
        button.disabled = false;
        button.style.cssText = originalStyle;
    }, 2000);
}

function showCopyError(button) {
    if (!button) return;

    const originalText = button.innerHTML;
    const originalClass = button.className;

    button.innerHTML = '❌ 复制失败';
    button.className = originalClass + ' copy-error';
    button.disabled = true;

    const originalStyle = button.style.cssText;
    button.style.cssText = originalStyle + '; background: #ef4444 !important; color: white !important;';

    setTimeout(() => {
        button.innerHTML = originalText;
        button.className = originalClass;
        button.disabled = false;
        button.style.cssText = originalStyle;
    }, 2000);
}

// 测验功能
function toggleAnswer(questionNumber) {
    const answer = document.getElementById(`answer${questionNumber}`);
    const button = event.target;

    if (answer.classList.contains('show')) {
        answer.classList.remove('show');
        button.textContent = '点击查看答案';
    } else {
        answer.classList.add('show');
        button.textContent = '隐藏答案';
    }
}

// 支持回车键插入
document.getElementById('insertValue').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        insertKey();
    }
});

document.getElementById('deleteValue').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        deleteKey();
    }
});

// 初始化
drawBTree();
updateStats();
updateHistory();
</script>

{% endblock %}