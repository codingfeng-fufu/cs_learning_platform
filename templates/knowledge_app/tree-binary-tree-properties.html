{% extends 'knowledge_app/base.html' %}

{% block title %}树与二叉树的性质 - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in"><!-- 面包屑导航 --><div class="breadcrumb"><a href="{% url 'knowledge_app:index' %}">首页</a><span>></span><span>数据结构</span><span>></span><span>树与二叉树的性质</span></div><!-- 页面头部 --><div class="page-header slide-in-left"><h1><span class="page-icon">🌳</span>
            树与二叉树的性质
        </h1><p>掌握树形数据结构的核心性质，理解节点关系的数学规律</p></div><!-- 知识点概述 --><div class="content-card slide-in-right"><div class="content-section"><h2 class="section-title"><span class="section-icon">📋</span>
                知识点概述
            </h2><div class="concept-overview"><div class="core-concept"><h3>🎯 核心概念</h3><p>树的性质是描述树形结构中节点数量、层级关系、度数等方面的数学规律。这些性质帮助我们理解树的结构特征，计算空间复杂度，分析算法效率。</p></div><div class="unified-grid unified-grid-2"><div class="info-box info-box-info"><span class="info-icon">📚</span><strong>学习难度：</strong>入门到进阶
                    </div><div class="info-box info-box-warning"><span class="info-icon">⚡</span><strong>前置知识：</strong>基本数学运算、对数概念、递归思想
                    </div></div><div class="key-terms"><h4>🔑 关键术语</h4><div class="terms-grid"><div class="term-item"><strong>度(Degree)：</strong>节点拥有的子节点个数
                        </div><div class="term-item"><strong>深度(Depth)：</strong>从根节点到该节点的路径长度
                        </div><div class="term-item"><strong>高度(Height)：</strong>从该节点到最深叶子节点的路径长度
                        </div><div class="term-item"><strong>层数(Level)：</strong>节点所在的层级（根节点为第0层或第1层）
                        </div><div class="term-item"><strong>路径长度：</strong>路径上边的数量
                        </div></div></div></div></div></div><!-- 树的基本性质 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌳</span>
                树的基本性质
            </h2><div class="properties-container"><div class="property-category"><h3>📊 节点与边的关系</h3><div class="property-list"><div class="property-item fundamental"><div class="property-header"><span class="property-number">性质1</span><h4>节点数与边数关系</h4></div><div class="property-content"><div class="formula"><strong>边数 = 节点数 - 1</strong></div><p><strong>证明：</strong>除根节点外，每个节点都有且仅有一条边连接到其父节点。n个节点的树有(n-1)条边。</p><div class="example"><strong>例子：</strong>7个节点的树一定有6条边
                                </div></div></div><div class="property-item"><div class="property-header"><span class="property-number">性质2</span><h4>度数关系</h4></div><div class="property-content"><div class="formula"><strong>∑(各节点的度) = 2 × (节点数 - 1)</strong></div><p><strong>解释：</strong>每条边都被计算两次（连接的两个节点各计算一次），所以度数总和是边数的2倍。</p></div></div><div class="property-item"><div class="property-header"><span class="property-number">性质3</span><h4>叶子节点与度数关系</h4></div><div class="property-content"><div class="formula"><strong>叶子节点数 = 1 + ∑(度≥2的节点数 × (度-2))</strong></div><p><strong>特例：</strong>对于度不超过m的树，如果有n₁个度为1的节点，n₂个度为2的节点...，则叶子节点数n₀ = 1 + n₂ + 2n₃ + ... + (m-1)nₘ</p></div></div></div></div><div class="property-category"><h3>📏 高度与深度性质</h3><div class="property-list"><div class="property-item"><div class="property-header"><span class="property-number">性质4</span><h4>最小高度</h4></div><div class="property-content"><div class="formula"><strong>h_min = ⌊log₂n⌋</strong></div><p><strong>条件：</strong>n个节点的二叉树的最小高度（最平衡时）</p></div></div><div class="property-item"><div class="property-header"><span class="property-number">性质5</span><h4>最大高度</h4></div><div class="property-content"><div class="formula"><strong>h_max = n - 1</strong></div><p><strong>条件：</strong>当树退化为链状结构时达到最大高度</p></div></div></div></div></div></div></div><!-- 二叉树的专门性质 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🔄</span>
                二叉树的专门性质
            </h2><div class="binary-properties"><div class="property-category"><h3>🎯 核心性质</h3><div class="property-list"><div class="property-item critical"><div class="property-header"><span class="property-number">性质6</span><h4>层级节点数</h4></div><div class="property-content"><div class="formula"><strong>第i层最多有 2^i 个节点</strong></div><p><strong>说明：</strong>根节点为第0层时。若根节点为第1层，则第i层最多有2^(i-1)个节点。</p><div class="layer-demo"><div>第0层：2⁰ = 1个节点</div><div>第1层：2¹ = 2个节点</div><div>第2层：2² = 4个节点</div><div>第3层：2³ = 8个节点</div></div></div></div><div class="property-item critical"><div class="property-header"><span class="property-number">性质7</span><h4>高度与节点总数关系</h4></div><div class="property-content"><div class="formula"><strong>高度为h的二叉树最多有 2^(h+1) - 1 个节点</strong></div><p><strong>推导：</strong>1 + 2 + 4 + ... + 2^h = 2^(h+1) - 1</p><div class="example"><strong>例子：</strong>高度为3的二叉树最多有2⁴-1=15个节点
                                </div></div></div><div class="property-item critical"><div class="property-header"><span class="property-number">性质8</span><h4>叶子节点与度为2的节点关系</h4></div><div class="property-content"><div class="formula"><strong>n₀ = n₂ + 1</strong></div><p><strong>证明：</strong>设n₀、n₁、n₂分别为度为0、1、2的节点数</p><div class="proof"><div>总节点数：n = n₀ + n₁ + n₂</div><div>总边数：n-1 = 0×n₀ + 1×n₁ + 2×n₂ = n₁ + 2n₂</div><div>所以：n₀ + n₁ + n₂ - 1 = n₁ + 2n₂</div><div>得到：n₀ = n₂ + 1</div></div></div></div></div></div><div class="property-category"><h3>🏗️ 特殊二叉树性质</h3><div class="special-trees"><div class="tree-type"><h4>🔵 完全二叉树</h4><div class="tree-properties"><div class="property-detail"><strong>定义：</strong>除最后一层外，每一层都完全填满，最后一层从左到右连续填充
                                </div><div class="property-detail"><strong>性质9：</strong>有n个节点的完全二叉树高度为 ⌊log₂n⌋
                                </div><div class="property-detail"><strong>性质10：</strong>节点编号规律（从1开始）：
                                    <ul><li>节点i的父节点编号：⌊i/2⌋</li><li>节点i的左孩子编号：2i</li><li>节点i的右孩子编号：2i+1</li></ul></div></div></div><div class="tree-type"><h4>🔴 满二叉树</h4><div class="tree-properties"><div class="property-detail"><strong>定义：</strong>每个节点要么是叶子节点，要么恰好有两个子节点
                                </div><div class="property-detail"><strong>性质11：</strong>有n个节点的满二叉树，叶子节点数为 (n+1)/2
                                </div><div class="property-detail"><strong>性质12：</strong>高度为h的满二叉树节点数为奇数：2^(h+1) - 1
                                </div></div></div><div class="tree-type"><h4>🟢 平衡二叉树</h4><div class="tree-properties"><div class="property-detail"><strong>定义：</strong>任意节点的左右子树高度差不超过1
                                </div><div class="property-detail"><strong>性质13：</strong>n个节点的平衡二叉树高度为 O(log n)
                                </div><div class="property-detail"><strong>性质14：</strong>高度为h的平衡二叉树最少节点数：F(h+2) - 1（斐波那契数列）
                                </div></div></div></div></div></div></div></div><!-- 可视化展示 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">📊</span>
                性质可视化验证
            </h2><div class="visualization-container"><div class="viz-controls"><button id="showProperty6" class="unified-btn unified-btn-primary">性质6: 层级节点数</button><button id="showProperty8" class="unified-btn unified-btn-secondary">性质8: n₀=n₂+1</button><button id="showCompleteTree" class="unified-btn unified-btn-success">完全二叉树性质</button><button id="showFullTree" class="unified-btn unified-btn-warning">满二叉树性质</button><button id="resetViz" class="unified-btn unified-btn-outline">重置</button></div><canvas id="treeCanvas" width="800" height="500"></canvas><div class="viz-info"><div id="vizDescription" class="viz-description">
                        点击上方按钮验证各种树的性质
                    </div><div id="propertyStats" class="property-stats"><div class="stat-item"><span class="stat-label">节点总数:</span><span class="stat-value" id="totalNodes">0</span></div><div class="stat-item"><span class="stat-label">边数:</span><span class="stat-value" id="totalEdges">0</span></div><div class="stat-item"><span class="stat-label">叶子节点:</span><span class="stat-value" id="leafNodes">0</span></div><div class="stat-item"><span class="stat-label">度为2的节点:</span><span class="stat-value" id="degree2Nodes">0</span></div><div class="stat-item"><span class="stat-label">树高度:</span><span class="stat-value" id="treeHeight">0</span></div></div></div></div><!-- 性质验证计算器 --><div class="property-calculator"><h3>🧮 性质计算器</h3><div class="calculator-section"><div class="calc-input"><label>输入节点数 n:</label><input type="number" id="nodeInput" value="7" min="1" max="31"><button id="calculateBtn" class="unified-btn unified-btn-primary">计算性质</button></div><div class="calc-results" id="calcResults"><div class="result-item"><strong>边数:</strong><span id="calcEdges">6</span></div><div class="result-item"><strong>最小高度:</strong><span id="calcMinHeight">2</span></div><div class="result-item"><strong>最大高度:</strong><span id="calcMaxHeight">6</span></div><div class="result-item"><strong>完全二叉树高度:</strong><span id="calcCompleteHeight">2</span></div></div></div></div></div></div><!-- 实际应用 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">🌟</span>
                性质的实际应用
            </h2><div class="applications"><div class="app-item"><h3>💾 存储空间计算</h3><p>根据节点数量计算指针存储空间：n个节点的二叉树需要2n个指针（每个节点2个子指针），其中有效指针(n-1)个，空指针(n+1)个。</p></div><div class="app-item"><h3>⚡ 算法复杂度分析</h3><p>利用高度性质分析时间复杂度：平衡二叉树的查找、插入、删除操作都是O(log n)，而链状退化树则是O(n)。</p></div><div class="app-item"><h3>🏗️ 数据结构设计</h3><p>完全二叉树的编号性质使得可以用数组实现，父子关系通过数组下标计算，无需额外指针。</p></div></div><!-- 代码示例 --><div class="code-examples"><h3>💻 性质验证代码</h3><div class="code-tabs"><button class="tab-btn active" data-lang="cpp">C++</button><button class="tab-btn" data-lang="java">Java</button><button class="tab-btn" data-lang="python">Python</button></div><div class="code-container"><div class="code-header"><span class="code-title">验证二叉树性质 n₀ = n₂ + 1</span><button class="copy-btn" data-lang="cpp">📋 复制</button></div><pre id="code-cpp" class="code-block active"><code>// C++ 验证二叉树性质
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 统计各种度的节点数
void countNodes(TreeNode* root, int& n0, int& n1, int& n2) {
    if (!root) return;

    int degree = 0;
    if (root->left) degree++;
    if (root->right) degree++;

    if (degree == 0) n0++;
    else if (degree == 1) n1++;
    else n2++;

    countNodes(root->left, n0, n1, n2);
    countNodes(root->right, n0, n1, n2);
}

// 验证性质
bool verifyProperty8(TreeNode* root) {
    int n0 = 0, n1 = 0, n2 = 0;
    countNodes(root, n0, n1, n2);

    cout << "叶子节点数 n0: " << n0 << endl;
    cout << "度为2的节点数 n2: " << n2 << endl;
    cout << "性质验证: n0 = n2 + 1 => " << n0 << " = " << n2 + 1 << endl;

    return n0 == n2 + 1;
}</code></pre><pre id="code-java" class="code-block"><code>// Java 验证二叉树性质
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

class TreeProperties {
    private int n0 = 0, n1 = 0, n2 = 0;

    // 统计各种度的节点数
    private void countNodes(TreeNode root) {
        if (root == null) return;

        int degree = 0;
        if (root.left != null) degree++;
        if (root.right != null) degree++;

        if (degree == 0) n0++;
        else if (degree == 1) n1++;
        else n2++;

        countNodes(root.left);
        countNodes(root.right);
    }

    // 验证性质
    public boolean verifyProperty8(TreeNode root) {
        n0 = n1 = n2 = 0;
        countNodes(root);

        System.out.println("叶子节点数 n0: " + n0);
        System.out.println("度为2的节点数 n2: " + n2);
        System.out.println("性质验证: n0 = n2 + 1 => " + n0 + " = " + (n2 + 1));

        return n0 == n2 + 1;
    }
}</code></pre><pre id="code-python" class="code-block"><code># Python 验证二叉树性质
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def count_nodes(root):
    """统计各种度的节点数"""
    if not root:
        return 0, 0, 0

    # 计算当前节点的度
    degree = 0
    if root.left:
        degree += 1
    if root.right:
        degree += 1

    # 递归统计子树
    left_n0, left_n1, left_n2 = count_nodes(root.left)
    right_n0, right_n1, right_n2 = count_nodes(root.right)

    # 累加结果
    if degree == 0:
        return left_n0 + right_n0 + 1, left_n1 + right_n1, left_n2 + right_n2
    elif degree == 1:
        return left_n0 + right_n0, left_n1 + right_n1 + 1, left_n2 + right_n2
    else:
        return left_n0 + right_n0, left_n1 + right_n1, left_n2 + right_n2 + 1

def verify_property8(root):
    """验证性质: n0 = n2 + 1"""
    n0, n1, n2 = count_nodes(root)

    print(f"叶子节点数 n0: {n0}")
    print(f"度为2的节点数 n2: {n2}")
    print(f"性质验证: n0 = n2 + 1 => {n0} = {n2 + 1}")

    return n0 == n2 + 1</code></pre></div></div></div></div><!-- 学习检验 --><div class="content-card"><div class="content-section"><h2 class="section-title"><span class="section-icon">✅</span>
                性质掌握检验
            </h2><div class="quiz-container"><div class="quiz-item"><div class="question"><h4>🤔 问题1：一棵有13个节点的完全二叉树，其高度是多少？叶子节点有几个？</h4><button class="show-answer-btn" data-answer="1">显示答案</button></div><div class="answer" id="answer-1" style="display: none;"><div class="answer-content"><strong>答案：</strong>高度为3，叶子节点7个<br><strong>解释：</strong><br>
                            • 高度 = ⌊log₂13⌋ = ⌊3.7⌋ = 3<br>
                            • 前3层(0,1,2层)共有节点：1+2+4=7个<br>
                            • 第3层有节点：13-7=6个<br>
                            • 第2层和第3层的叶子节点总共：4+6=10个，但要减去第2层有子节点的3个，所以是7个叶子节点
                        </div></div></div><div class="quiz-item"><div class="question"><h4>🤔 问题2：某二叉树有5个度为2的节点，3个度为1的节点，那么它有多少个叶子节点？总共多少个节点？</h4><button class="show-answer-btn" data-answer="2">显示答案</button></div><div class="answer" id="answer-2" style="display: none;"><div class="answer-content"><strong>答案：</strong>6个叶子节点，总共14个节点<br><strong>解释：</strong><br>
                            • 由性质8：n₀ = n₂ + 1 = 5 + 1 = 6个叶子节点<br>
                            • 总节点数：n₀ + n₁ + n₂ = 6 + 3 + 5 = 14个节点<br>
                            • 验证：边数 = 14 - 1 = 13，度数总和 = 0×6 + 1×3 + 2×5 = 13 ✓
                        </div></div></div><div class="quiz-item"><div class="question"><h4>🤔 问题3：高度为4的满二叉树和完全二叉树分别有多少个节点？它们的叶子节点各有多少个？</h4><button class="show-answer-btn" data-answer="3">显示答案</button></div><div class="answer" id="answer-3" style="display: none;"><div class="answer-content"><strong>答案：</strong><br><strong>满二叉树：</strong>31个节点，16个叶子节点<br><strong>完全二叉树：</strong>16-31个节点，叶子节点数不定<br><strong>解释：</strong><br>
                            • 满二叉树节点数：2⁵-1=31，叶子节点：2⁴=16<br>
                            • 完全二叉树：前4层装满是2⁴-1=15个，第5层可以有1-16个节点<br>
                            • 完全二叉树最少16个节点（只有根节点在第5层），最多31个节点（第5层满）
                        </div></div></div><div class="quiz-item"><div class="question"><h4>🤔 问题4：对于有1000个节点的完全二叉树，如果用数组存储（下标从1开始），节点900的父节点下标是多少？左右孩子下标是多少？</h4><button class="show-answer-btn" data-answer="4">显示答案</button></div><div class="answer" id="answer-4" style="display: none;"><div class="answer-content"><strong>答案：</strong>父节点下标450，左孩子1800，右孩子1801<br><strong>解释：</strong><br>
                            • 父节点：⌊900/2⌋ = 450<br>
                            • 左孩子：2×900 = 1800<br>
                            • 右孩子：2×900+1 = 1801<br><strong>注意：</strong>由于只有1000个节点，实际上900号节点的孩子不存在（超出范围）
                        </div></div></div><div class="quiz-item"><div class="question"><h4>🤔 问题5：证明为什么二叉树中度为0的节点数等于度为2的节点数加1？</h4><button class="show-answer-btn" data-answer="5">显示答案</button></div><div class="answer" id="answer-5" style="display: none;"><div class="answer-content"><strong>证明：</strong><br>
                            设n₀、n₁、n₂分别为度为0、1、2的节点数<br><strong>步骤1：</strong>总节点数 n = n₀ + n₁ + n₂<br><strong>步骤2：</strong>总边数 = n - 1（树的性质1）<br><strong>步骤3：</strong>从度数角度，总边数 = (0×n₀ + 1×n₁ + 2×n₂) = n₁ + 2n₂<br><strong>步骤4：</strong>因此 n - 1 = n₁ + 2n₂<br><strong>步骤5：</strong>即 n₀ + n₁ + n₂ - 1 = n₁ + 2n₂<br><strong>步骤6：</strong>化简得 n₀ = n₂ + 1 ✓
                        </div></div></div></div><div class="learning-path"><h3>🎯 进阶学习建议</h3><div class="unified-grid unified-grid-2"><div class="path-item"><h4>📚 掌握后继续学习</h4><ul><li>二叉搜索树的性质（中序遍历有序性）</li><li>AVL树的平衡性质</li><li>红黑树的颜色性质</li><li>堆的性质（父子节点大小关系）</li><li>B树的度数和高度性质</li></ul></div><div class="path-item"><h4>🛠️ 推荐练习</h4><ul><li>编程验证各种树的性质</li><li>计算不同类型树的时间复杂度</li><li>设计基于性质的算法优化</li><li>分析实际数据结构的空间效率</li><li>实现完全二叉树的数组表示</li></ul></div></div></div></div></div><!-- 导航按钮 --><div style="text-align: center; margin-top: 40px;"><a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary"><span>🏠</span>
            返回首页
        </a><a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary"><span>🌌</span>
            探索CS宇宙
        </a></div></div><style>.concept-overview {background:linear-gradient(135deg, #f8f9ff 0%, #e8f4f8 100%);padding:25px;border-radius:12px;margin-bottom:20px}.core-concept {background:white;padding:20px;border-radius:8px;margin-bottom:20px;border-left:4px solid #007bff}.key-terms {background:white;padding:20px;border-radius:8px}.terms-grid {display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:15px;margin-top:15px}.term-item {background:#f8f9fa;padding:12px;border-radius:6px;border-left:3px solid #28a745}.properties-container {margin-bottom:20px}.property-category {background:#f8f9ff;padding:25px;border-radius:12px;margin-bottom:25px}.property-category h3 {color:#495057;margin-bottom:20px;font-size:1.3em;font-weight:bold}.property-list {margin-bottom:20px}.property-item {background:white;border-radius:10px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.1);border:1px solid #e9ecef;margin-bottom:20px}.property-item.fundamental {border-left:5px solid #dc3545}.property-item.critical {border-left:5px solid #007bff}.property-header {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;padding:15px 20px;display:flex;align-items:center;gap:15px}.property-number {background:rgba(255,255,255,0.2);padding:5px 12px;border-radius:20px;font-weight:bold;font-size:0.9em}.property-header h4 {margin:0;font-size:1.1em}.property-content {padding:20px}.formula {background:#e8f5e8;padding:15px;border-radius:8px;border-left:4px solid #28a745;margin-bottom:15px;text-align:center;font-size:1.1em}.example {background:#fff3cd;padding:12px;border-radius:6px;border-left:3px solid #ffc107;margin-top:10px}.proof {background:#f8f9fa;padding:15px;border-radius:6px;margin-top:10px}.proof div {margin:5px 0;font-family:'Courier New', monospace}.layer-demo {background:#f8f9fa;padding:12px;border-radius:6px;margin-top:10px}.layer-demo div {margin:3px 0;font-family:'Courier New', monospace}.binary-properties {margin-bottom:20px}.special-trees {display:grid;grid-template-columns:repeat(auto-fit, minmax(350px, 1fr));gap:20px;margin-top:20px}.tree-type {background:white;padding:20px;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,0.1)}.tree-type h4 {margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #e9ecef}.tree-properties {margin-bottom:10px}.property-detail {background:#f8f9fa;padding:12px;border-radius:6px;margin-bottom:10px}.property-detail ul {margin:8px 0 0 20px}.visualization-container {background:#f8f9fa;padding:20px;border-radius:12px;text-align:center}.viz-controls {margin-bottom:20px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}#treeCanvas {border:2px solid #dee2e6;border-radius:8px;background:white;box-shadow:0 4px 6px rgba(0,0,0,0.1);max-width:100%}.viz-description {background:white;padding:15px;border-radius:8px;margin-top:15px;border-left:4px solid #007bff}.property-stats {display:grid;grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));gap:10px;margin-top:15px}.stat-item {background:white;padding:10px;border-radius:6px;text-align:center;box-shadow:0 1px 3px rgba(0,0,0,0.1)}.stat-label {display:block;font-size:0.9em;color:#6c757d;margin-bottom:5px}.stat-value {display:block;font-size:1.2em;font-weight:bold;color:#007bff}.property-calculator {background:linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);padding:20px;border-radius:12px;margin-top:20px}.calculator-section {background:white;padding:20px;border-radius:8px}.calc-input {display:flex;align-items:center;gap:15px;margin-bottom:20px;flex-wrap:wrap}.calc-input label {font-weight:bold;white-space:nowrap}.calc-input input {padding:8px 12px;border:1px solid #ced4da;border-radius:4px;width:100px}.calc-results {display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:15px}.result-item {background:#f8f9fa;padding:12px;border-radius:6px;border-left:3px solid #007bff}.result-item span {color:#007bff;font-weight:bold}.applications {display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:20px}.app-item {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;padding:20px;border-radius:10px}.code-examples {margin-top:30px}.code-tabs {display:flex;gap:5px;margin-bottom:0}.tab-btn {background:#6c757d;color:white;border:none;padding:10px 20px;border-radius:8px 8px 0 0;cursor:pointer;transition:background-color 0.3s}.tab-btn.active {background:#007bff}.tab-btn:hover {background:#5a6268}.tab-btn.active:hover {background:#0056b3}.code-container {background:#2d3748;border-radius:0 8px 8px 8px;overflow:hidden}.code-header {background:#1a202c;padding:10px 15px;display:flex;justify-content:space-between;align-items:center;color:#e2e8f0}.copy-btn {background:#4299e1;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:12px}.copy-btn:hover {background:#3182ce}.code-block {display:none;margin:0;padding:20px;background:#2d3748;color:#e2e8f0;font-family:'Courier New', monospace;line-height:1.5;overflow-x:auto}.code-block.active {display:block}.quiz-container {margin-bottom:20px}.quiz-item {background:#f8f9fa;border-radius:10px;overflow:hidden;margin-bottom:20px}.question {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:white;padding:20px;display:flex;justify-content:space-between;align-items:center}.show-answer-btn {background:rgba(255,255,255,0.2);color:white;border:1px solid rgba(255,255,255,0.3);padding:8px 16px;border-radius:6px;cursor:pointer;transition:all 0.3s;white-space:nowrap}.show-answer-btn:hover {background:rgba(255,255,255,0.3)}.answer {background:white;padding:20px;border-top:1px solid #e9ecef}.answer-content {background:#e8f5e8;padding:15px;border-radius:6px;border-left:4px solid #28a745;line-height:1.6}.learning-path {background:linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);padding:25px;border-radius:12px;margin-top:30px}.path-item {background:white;padding:20px;border-radius:8px}@media (max-width:768px) {.viz-controls {flex-direction:column;align-items:center}#treeCanvas {width:100%;height:auto}.question {flex-direction:column;gap:15px;text-align:center}.terms-grid {grid-template-columns:1fr}.special-trees {grid-template-columns:1fr}.calc-input {flex-direction:column;align-items:stretch}.calc-input input {width:100%}.property-stats {grid-template-columns:repeat(2, 1fr)}}</style><script>let canvas, ctx; let animationId; let nodes = []; let currentDemo = ''; let stats = { totalNodes: 0, totalEdges: 0, leafNodes: 0, degree2Nodes: 0, treeHeight: 0 }; function initCanvas() { canvas = document.getElementById('treeCanvas'); if (!canvas) return; ctx = canvas.getContext('2d'); const rect = canvas.getBoundingClientRect(); canvas.width = Math.min(800, rect.width); canvas.height = 500; } class TreeNode { constructor(x, y, value, color = '#007bff') { this.x = x; this.y = y; this.value = value; this.color = color; this.radius = 25; this.left = null; this.right = null; this.parent = null; this.highlight = false; this.degree = 0; this.level = 0; } draw() { if (!ctx) return; if (this.parent) { ctx.strokeStyle = '#6c757d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.parent.x, this.parent.y); ctx.lineTo(this.x, this.y); ctx.stroke(); } ctx.fillStyle = this.highlight ? '#ffc107' : this.color; ctx.strokeStyle = '#343a40'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.value, this.x, this.y); if (currentDemo === 'property6') { ctx.fillStyle = '#666'; ctx.font = '10px Arial'; ctx.fillText(`L${this.level}`, this.x, this.y + 35); } if (currentDemo === 'property8') { ctx.fillStyle = '#666'; ctx.font = '10px Arial'; ctx.fillText(`度${this.degree}`, this.x, this.y + 35); } } } function clearCanvas() { if (!ctx) return; ctx.clearRect(0, 0, canvas.width, canvas.height); nodes = []; currentDemo = ''; updateStats(); if (animationId) { cancelAnimationFrame(animationId); } } function updateStats() { const elements = { totalNodes: document.getElementById('totalNodes'), totalEdges: document.getElementById('totalEdges'), leafNodes: document.getElementById('leafNodes'), degree2Nodes: document.getElementById('degree2Nodes'), treeHeight: document.getElementById('treeHeight') }; if (elements.totalNodes) elements.totalNodes.textContent = stats.totalNodes; if (elements.totalEdges) elements.totalEdges.textContent = stats.totalEdges; if (elements.leafNodes) elements.leafNodes.textContent = stats.leafNodes; if (elements.degree2Nodes) elements.degree2Nodes.textContent = stats.degree2Nodes; if (elements.treeHeight) elements.treeHeight.textContent = stats.treeHeight; } function calculateStats() { stats.totalNodes = nodes.length; stats.totalEdges = nodes.length > 0 ? nodes.length - 1 : 0; stats.leafNodes = 0; stats.degree2Nodes = 0; stats.treeHeight = 0; nodes.forEach(node => { let degree = 0; if (node.left) degree++; if (node.right) degree++; node.degree = degree; if (degree === 0) stats.leafNodes++; if (degree === 2) stats.degree2Nodes++; if (node.level > stats.treeHeight) { stats.treeHeight = node.level; } }); updateStats(); } function showProperty6() { if (!canvas) return; clearCanvas(); currentDemo = 'property6'; const descEl = document.getElementById('vizDescription'); if (descEl) { descEl.innerHTML = '性质6演示：第i层最多有2^i个节点（根节点为第0层）'; } const nodePositions = [ [{x: 400, y: 80}], [{x: 300, y: 150}, {x: 500, y: 150}], [{x: 250, y: 220}, {x: 350, y: 220}, {x: 450, y: 220}, {x: 550, y: 220}], [{x: 225, y: 290}, {x: 275, y: 290}, {x: 325, y: 290}, {x: 375, y: 290}, {x: 425, y: 290}, {x: 475, y: 290}, {x: 525, y: 290}, {x: 575, y: 290}] ]; let nodeIndex = 1; nodePositions.forEach((level, levelIndex) => { level.forEach(pos => { if (pos.x <= canvas.width - 50) { const node = new TreeNode(pos.x, pos.y, nodeIndex++, '#007bff'); node.level = levelIndex; nodes.push(node); } }); }); for (let i = 0; i < nodes.length; i++) { const leftChildIndex = 2 * i + 1; const rightChildIndex = 2 * i + 2; if (leftChildIndex < nodes.length) { nodes[i].left = nodes[leftChildIndex]; nodes[leftChildIndex].parent = nodes[i]; } if (rightChildIndex < nodes.length) { nodes[i].right = nodes[rightChildIndex]; nodes[rightChildIndex].parent = nodes[i]; } } let levelIndex = 0; function drawLevel() { if (levelIndex < nodePositions.length) { const levelNodes = nodePositions[levelIndex]; const startIndex = Math.pow(2, levelIndex) - 1; for (let i = 0; i < levelNodes.length && startIndex + i < nodes.length; i++) { if (nodes[startIndex + i]) { nodes[startIndex + i].draw(); } } ctx.fillStyle = '#dc3545'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'left'; ctx.fillText(`第${levelIndex}层: ${levelNodes.length}个节点 (2^${levelIndex} = ${Math.pow(2, levelIndex)})`, 20, 30 + levelIndex * 25); levelIndex++; setTimeout(drawLevel, 1000); } else { calculateStats(); if (descEl) { descEl.innerHTML += '<br>✅ 验证完成！每层节点数符合2^i规律'; } } } drawLevel(); } function showProperty8() { if (!canvas) return; clearCanvas(); currentDemo = 'property8'; const descEl = document.getElementById('vizDescription'); if (descEl) { descEl.innerHTML = '性质8演示：叶子节点数 = 度为2的节点数 + 1'; } const positions = [ {x: 400, y: 80, val: 'A'}, {x: 300, y: 150, val: 'B'}, {x: 500, y: 150, val: 'C'}, {x: 250, y: 220, val: 'D'}, {x: 350, y: 220, val: 'E'}, {x: 550, y: 220, val: 'F'}, {x: 200, y: 290, val: 'G'}, {x: 300, y: 290, val: 'H'}, {x: 580, y: 290, val: 'I'} ]; positions.forEach(pos => { if (pos.x <= canvas.width - 50) { const node = new TreeNode(pos.x, pos.y, pos.val, '#007bff'); nodes.push(node); } }); const connections = [ [0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 6], [3, 7], [5, 8] ]; connections.forEach(([parentIdx, childIdx]) => { if (nodes[childIdx] && nodes[parentIdx]) { nodes[childIdx].parent = nodes[parentIdx]; if (!nodes[parentIdx].left) { nodes[parentIdx].left = nodes[childIdx]; } else { nodes[parentIdx].right = nodes[childIdx]; } } }); let i = 0; function drawNext() { if (i < nodes.length) { nodes[i].draw(); i++; setTimeout(drawNext, 300); } else { calculateStats(); setTimeout(() => { nodes.forEach(node => { if (node.degree === 0) node.color = '#28a745'; else if (node.degree === 2) node.color = '#dc3545'; else node.color = '#ffc107'; }); ctx.clearRect(0, 0, canvas.width, canvas.height); nodes.forEach(node => node.draw()); if (descEl) { descEl.innerHTML = `性质验证：叶子节点(绿色) = ${stats.leafNodes}，度为2的节点(红色) = ${stats.degree2Nodes}<br>` + `✅ 验证结果：${stats.leafNodes} = ${stats.degree2Nodes} + 1`; } }, 1000); } } drawNext(); } function showCompleteTree() { if (!canvas) return; clearCanvas(); currentDemo = 'complete'; const descEl = document.getElementById('vizDescription'); if (descEl) { descEl.innerHTML = '完全二叉树演示：节点编号规律（父节点⌊i/2⌋，左孩子2i，右孩子2i+1）'; } const positions = [ {x: 400, y: 80}, {x: 300, y: 150}, {x: 500, y: 150}, {x: 250, y: 220}, {x: 350, y: 220}, {x: 450, y: 220}, {x: 550, y: 220} ]; positions.forEach((pos, index) => { if (pos.x <= canvas.width - 50) { const node = new TreeNode(pos.x, pos.y, index + 1, '#007bff'); nodes.push(node); } }); for (let i = 0; i < nodes.length; i++) { const leftChildIndex = 2 * (i + 1) - 1; const rightChildIndex = 2 * (i + 1); if (leftChildIndex < nodes.length) { nodes[i].left = nodes[leftChildIndex]; nodes[leftChildIndex].parent = nodes[i]; } if (rightChildIndex < nodes.length) { nodes[i].right = nodes[rightChildIndex]; nodes[rightChildIndex].parent = nodes[i]; } } let i = 0; function drawNext() { if (i < nodes.length) { nodes[i].draw(); const nodeNum = i + 1; const parentNum = Math.floor(nodeNum / 2); const leftChild = 2 * nodeNum; const rightChild = 2 * nodeNum + 1; ctx.fillStyle = '#666'; ctx.font = '12px Arial'; ctx.textAlign = 'left'; const info = `节点${nodeNum}: 父${parentNum > 0 ? parentNum : '无'}, 左${leftChild <= 7 ? leftChild : '无'}, 右${rightChild <= 7 ? rightChild : '无'}`; ctx.fillText(info, 20, 30 + i * 20); i++; setTimeout(drawNext, 500); } else { calculateStats(); if (descEl) { descEl.innerHTML += '<br>✅ 完全二叉树编号规律验证完成！'; } } } drawNext(); } function showFullTree() { if (!canvas) return; clearCanvas(); currentDemo = 'full'; const descEl = document.getElementById('vizDescription'); if (descEl) { descEl.innerHTML = '满二叉树演示：每个节点要么是叶子节点，要么恰好有两个子节点'; } const positions = [ {x: 400, y: 80}, {x: 300, y: 150}, {x: 500, y: 150}, {x: 250, y: 220}, {x: 350, y: 220}, {x: 450, y: 220}, {x: 550, y: 220} ]; positions.forEach((pos, index) => { if (pos.x <= canvas.width - 50) { const node = new TreeNode(pos.x, pos.y, String.fromCharCode(65 + index), '#007bff'); nodes.push(node); } }); const connections = [ [0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6] ]; connections.forEach(([parentIdx, childIdx]) => { if (nodes[childIdx] && nodes[parentIdx]) { nodes[childIdx].parent = nodes[parentIdx]; if (!nodes[parentIdx].left) { nodes[parentIdx].left = nodes[childIdx]; } else { nodes[parentIdx].right = nodes[childIdx]; } } }); let i = 0; function drawNext() { if (i < nodes.length) { nodes[i].draw(); i++; setTimeout(drawNext, 400); } else { calculateStats(); nodes.forEach(node => { if (node.degree === 0) node.color = '#28a745'; else if (node.degree === 2) node.color = '#dc3545'; }); ctx.clearRect(0, 0, canvas.width, canvas.height); nodes.forEach(node => node.draw()); if (descEl) { descEl.innerHTML = `满二叉树性质验证：<br>` + `• 内部节点(红色，度为2): ${stats.degree2Nodes}个<br>` + `• 叶子节点(绿色，度为0): ${stats.leafNodes}个<br>` + `• 总节点数: ${stats.totalNodes}个（奇数）<br>` + `✅ 满足满二叉树性质：每个节点度为0或2`; } } } drawNext(); } function calculateProperties() { const nodeInput = document.getElementById('nodeInput'); if (!nodeInput) return; const n = parseInt(nodeInput.value); if (n < 1 || n > 1000) { alert('请输入1-1000之间的节点数'); return; } const edges = n - 1; const minHeight = Math.floor(Math.log2(n)); const maxHeight = n - 1; const completeHeight = Math.floor(Math.log2(n)); const elements = { calcEdges: document.getElementById('calcEdges'), calcMinHeight: document.getElementById('calcMinHeight'), calcMaxHeight: document.getElementById('calcMaxHeight'), calcCompleteHeight: document.getElementById('calcCompleteHeight') }; if (elements.calcEdges) elements.calcEdges.textContent = edges; if (elements.calcMinHeight) elements.calcMinHeight.textContent = minHeight; if (elements.calcMaxHeight) elements.calcMaxHeight.textContent = maxHeight; if (elements.calcCompleteHeight) elements.calcCompleteHeight.textContent = completeHeight; } function initCodeTabs() { const tabBtns = document.querySelectorAll('.tab-btn'); const codeBlocks = document.querySelectorAll('.code-block'); const copyBtns = document.querySelectorAll('.copy-btn'); tabBtns.forEach(btn => { btn.addEventListener('click', () => { const lang = btn.dataset.lang; tabBtns.forEach(tab => tab.classList.remove('active')); btn.classList.add('active'); codeBlocks.forEach(block => { block.classList.remove('active'); if (block.id === `code-${lang}`) { block.classList.add('active'); } }); copyBtns.forEach(copyBtn => { copyBtn.dataset.lang = lang; }); }); }); copyBtns.forEach(btn => { btn.addEventListener('click', () => { const lang = btn.dataset.lang; const codeBlock = document.getElementById(`code-${lang}`); if (!codeBlock) return; const code = codeBlock.textContent; if (navigator.clipboard) { navigator.clipboard.writeText(code).then(() => { btn.textContent = '✅ 已复制'; setTimeout(() => { btn.textContent = '📋 复制'; }, 2000); }).catch(() => { fallbackCopyTextToClipboard(code, btn); }); } else { fallbackCopyTextToClipboard(code, btn); } }); }); } function fallbackCopyTextToClipboard(text, btn) { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.top = "0"; textArea.style.left = "0"; textArea.style.position = "fixed"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { const successful = document.execCommand('copy'); if (successful) { btn.textContent = '✅ 已复制'; setTimeout(() => { btn.textContent = '📋 复制'; }, 2000); } } catch (err) { console.error('复制失败', err); } document.body.removeChild(textArea); } function initQuizAnswers() { const answerBtns = document.querySelectorAll('.show-answer-btn'); answerBtns.forEach(btn => { btn.addEventListener('click', () => { const answerId = btn.dataset.answer; const answerDiv = document.getElementById(`answer-${answerId}`); if (!answerDiv) return; if (answerDiv.style.display === 'none') { answerDiv.style.display = 'block'; btn.textContent = '隐藏答案'; } else { answerDiv.style.display = 'none'; btn.textContent = '显示答案'; } }); }); } document.addEventListener('DOMContentLoaded', () => { initCanvas(); initCodeTabs(); initQuizAnswers(); const vizButtons = { showProperty6: document.getElementById('showProperty6'), showProperty8: document.getElementById('showProperty8'), showCompleteTree: document.getElementById('showCompleteTree'), showFullTree: document.getElementById('showFullTree'), resetViz: document.getElementById('resetViz') }; if (vizButtons.showProperty6) { vizButtons.showProperty6.addEventListener('click', showProperty6); } if (vizButtons.showProperty8) { vizButtons.showProperty8.addEventListener('click', showProperty8); } if (vizButtons.showCompleteTree) { vizButtons.showCompleteTree.addEventListener('click', showCompleteTree); } if (vizButtons.showFullTree) { vizButtons.showFullTree.addEventListener('click', showFullTree); } if (vizButtons.resetViz) { vizButtons.resetViz.addEventListener('click', () => { clearCanvas(); const descEl = document.getElementById('vizDescription'); if (descEl) { descEl.innerHTML = '点击上方按钮验证各种树的性质'; } }); } const calculateBtn = document.getElementById('calculateBtn'); const nodeInput = document.getElementById('nodeInput'); if (calculateBtn) { calculateBtn.addEventListener('click', calculateProperties); } if (nodeInput) { nodeInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { calculateProperties(); } }); calculateProperties(); } }); window.addEventListener('resize', () => { if (canvas) { const rect = canvas.getBoundingClientRect(); canvas.width = Math.min(800, rect.width); canvas.height = 500; if (nodes.length > 0) { ctx.clearRect(0, 0, canvas.width, canvas.height); nodes.forEach(node => { if (node.x > canvas.width - 50) { node.x = canvas.width - 50; } node.draw(); }); } } }); window.addEventListener('error', (e) => { console.error('页面错误:', e.error); });</script>

{% endblock %}