{% extends 'knowledge_app/base.html' %}

{% block title %}{{ page_title|default:"并查集(Union-Find)" }} - 计算机科学学习平台{% endblock %}

{% block content %}
<div class="page-container fade-in">
    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <a href="{% url 'knowledge_app:index' %}">首页</a>
        <span>></span>
        <span>{{ breadcrumb_category|default:"数据结构" }}</span>
        <span>></span>
        <span>{{ page_title|default:"并查集(Union-Find)" }}</span>
    </div>

    <!-- 页面头部 -->
    <div class="page-header slide-in-left">
        <h1>
            <span class="page-icon">{{ page_icon|default:"🌐" }}</span>
            {{ page_title|default:"并查集(Union-Find)" }}
        </h1>
        <p>{{ page_description|default:"高效处理动态连通性问题的神器，让复杂的集合操作变得简单" }}</p>
    </div>

    <!-- 📋 知识点概述 -->
    <div class="content-card slide-in-right">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📋</span>
                知识点概述
            </h2>
            <div class="overview-content">
                <div class="concept-intro">
                    <p><strong>核心概念：</strong>并查集就像一个智能的"朋友圈管理系统"，能快速判断两个人是否在同一个朋友圈，以及合并不同的朋友圈，让复杂的群体关系管理变得超级简单！</p>
                </div>

                <div class="unified-grid unified-grid-2">
                    <div class="info-box info-box-info">
                        <h3>🏷️ 关键术语</h3>
                        <ul>
                            <li><strong>不相交集合：</strong>没有公共元素的集合族</li>
                            <li><strong>Find操作：</strong>查找元素属于哪个集合</li>
                            <li><strong>Union操作：</strong>合并两个不同的集合</li>
                            <li><strong>路径压缩：</strong>优化查找路径的技术</li>
                            <li><strong>按秩合并：</strong>按树的高度合并的策略</li>
                        </ul>
                    </div>

                    <div class="info-box info-box-success">
                        <h3>📊 学习指标</h3>
                        <p><strong>难度等级：</strong> <span class="badge badge-hard">高级</span></p>
                        <p><strong>前置知识：</strong></p>
                        <ul>
                            <li>树形结构理解 ✓</li>
                            <li>递归思想 ✓</li>
                            <li>算法复杂度分析 ✓</li>
                            <li>图论基础概念 ✓</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 🔍 概念详解 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🔍</span>
                概念详解
            </h2>

            <div class="concept-details">
                <div class="concept-item">
                    <h3>🏗️ 并查集的基本思想</h3>
                    <p>想象一个大型社交网络平台：</p>
                    <ul>
                        <li>每个人(元素)都有一个"家长"指针指向上级</li>
                        <li>每个朋友圈有一个"圈主"(根节点)代表整个圈子</li>
                        <li>查找朋友圈：一直找家长，直到找到圈主</li>
                        <li>合并朋友圈：让一个圈主认另一个圈主当家长</li>
                    </ul>

                    <div class="example-box">
                        <h4>🎯 生活例子</h4>
                        <p>假设有学生 A、B、C、D、E：</p>
                        <ul>
                            <li>初始：每人都是独立的"单人圈"</li>
                            <li>A和B成为朋友 → 合并A、B的圈子</li>
                            <li>C和D成为朋友 → 合并C、D的圈子</li>
                            <li>判断A和C是否为朋友 → 查看是否在同一圈</li>
                            <li>B和C成为朋友 → 两个圈子合并成一个大圈</li>
                        </ul>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🔄 两大核心操作</h3>
                    <div class="operations-grid">
                        <div class="operation-card find-card">
                            <span class="op-icon">🔍</span>
                            <h4>Find(查找)</h4>
                            <p><strong>功能：</strong>找到元素x所在集合的代表元</p>
                            <p><strong>过程：</strong>沿着父指针一直向上，直到找到根节点</p>
                            <p><strong>优化：</strong>路径压缩 - 把路径上所有节点直接连到根</p>
                            <div class="complexity">时间复杂度: O(α(n)) ≈ 常数</div>
                        </div>
                        <div class="operation-card union-card">
                            <span class="op-icon">🔗</span>
                            <h4>Union(合并)</h4>
                            <p><strong>功能：</strong>合并元素x和y所在的两个集合</p>
                            <p><strong>过程：</strong>找到两个元素的根，让一个根指向另一个根</p>
                            <p><strong>优化：</strong>按秩合并 - 让矮树的根指向高树的根</p>
                            <div class="complexity">时间复杂度: O(α(n)) ≈ 常数</div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>🚀 优化技术详解</h3>
                    <div class="optimization-techniques">
                        <div class="tech-card">
                            <h4>⚡ 路径压缩 (Path Compression)</h4>
                            <div class="tech-content">
                                <div class="before-after">
                                    <div class="before">
                                        <h5>优化前：</h5>
                                        <p>查找需要逐层向上</p>
                                        <div class="path-demo">A → B → C → D(根)</div>
                                        <p>时间复杂度：O(n)</p>
                                    </div>
                                    <div class="arrow">→</div>
                                    <div class="after">
                                        <h5>优化后：</h5>
                                        <p>所有节点直连根节点</p>
                                        <div class="path-demo">A → D(根), B → D(根), C → D(根)</div>
                                        <p>时间复杂度：O(1)</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="tech-card">
                            <h4>⚖️ 按秩合并 (Union by Rank)</h4>
                            <div class="tech-content">
                                <p><strong>策略：</strong>总是让深度小的树的根指向深度大的树的根</p>
                                <p><strong>好处：</strong>避免树变得过高，保持平衡</p>
                                <div class="rank-example">
                                    <span class="good">✅ 正确：矮树→高树</span>
                                    <span class="bad">❌ 错误：高树→矮树</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-item">
                    <h3>⚠️ 关键理解点</h3>
                    <div class="key-points">
                        <div class="point-card">
                            <span class="point-icon">🎯</span>
                            <h4>阿克曼函数</h4>
                            <p>α(n)是阿克曼函数的反函数，实际应用中可视为常数，即使n=10^80也只有5</p>
                        </div>
                        <div class="point-card">
                            <span class="point-icon">🔄</span>
                            <h4>动态连通性</h4>
                            <p>并查集专门解决"动态连通性"问题：在线地处理连接和查询操作</p>
                        </div>
                        <div class="point-card">
                            <span class="point-icon">📍</span>
                            <h4>应用特点</h4>
                            <p>只支持合并，不支持分离。一旦两个集合合并，就无法再拆分</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 📊 可视化展示 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">📊</span>
                可视化展示
            </h2>

            <!-- 静态结构图 -->
            <div class="visualization-container">
                <h3>🏛️ 并查集基本结构</h3>
                <div class="static-diagram">
                    <div class="structure-comparison">
                        <div class="structure-view">
                            <h4>数组表示</h4>
                            <div class="array-view">
                                <div class="array-header">
                                    <span>索引</span>
                                    <span>0</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>3</span>
                                    <span>4</span>
                                    <span>5</span>
                                </div>
                                <div class="array-content">
                                    <span>parent</span>
                                    <span class="root">0</span>
                                    <span class="child">0</span>
                                    <span class="root">2</span>
                                    <span class="child">2</span>
                                    <span class="child">2</span>
                                    <span class="root">5</span>
                                </div>
                                <div class="array-content">
                                    <span>rank</span>
                                    <span>2</span>
                                    <span>0</span>
                                    <span>2</span>
                                    <span>0</span>
                                    <span>0</span>
                                    <span>0</span>
                                </div>
                            </div>
                        </div>

                        <div class="structure-view">
                            <h4>树形结构</h4>
                            <svg width="100%" height="200" viewBox="0 0 400 200">
                                <!-- 第一棵树 -->
                                <g>
                                    <circle cx="100" cy="50" r="20" fill="#4CAF50" stroke="#2E7D32" stroke-width="2"/>
                                    <text x="100" y="55" text-anchor="middle" fill="white" font-weight="bold">0</text>

                                    <circle cx="100" cy="120" r="20" fill="#2196F3" stroke="#1976D2" stroke-width="2"/>
                                    <text x="100" y="125" text-anchor="middle" fill="white" font-weight="bold">1</text>

                                    <line x1="100" y1="70" x2="100" y2="100" stroke="#666" stroke-width="2"/>

                                    <text x="100" y="40" text-anchor="middle" font-size="12" fill="#2E7D32">集合1</text>
                                </g>

                                <!-- 第二棵树 -->
                                <g>
                                    <circle cx="250" cy="50" r="20" fill="#4CAF50" stroke="#2E7D32" stroke-width="2"/>
                                    <text x="250" y="55" text-anchor="middle" fill="white" font-weight="bold">2</text>

                                    <circle cx="220" cy="120" r="20" fill="#2196F3" stroke="#1976D2" stroke-width="2"/>
                                    <text x="220" y="125" text-anchor="middle" fill="white" font-weight="bold">3</text>

                                    <circle cx="280" cy="120" r="20" fill="#2196F3" stroke="#1976D2" stroke-width="2"/>
                                    <text x="280" y="125" text-anchor="middle" fill="white" font-weight="bold">4</text>

                                    <line x1="250" y1="70" x2="220" y2="100" stroke="#666" stroke-width="2"/>
                                    <line x1="250" y1="70" x2="280" y2="100" stroke="#666" stroke-width="2"/>

                                    <text x="250" y="40" text-anchor="middle" font-size="12" fill="#2E7D32">集合2</text>
                                </g>

                                <!-- 第三棵树 -->
                                <g>
                                    <circle cx="350" cy="85" r="20" fill="#4CAF50" stroke="#2E7D32" stroke-width="2"/>
                                    <text x="350" y="90" text-anchor="middle" fill="white" font-weight="bold">5</text>

                                    <text x="350" y="75" text-anchor="middle" font-size="12" fill="#2E7D32">集合3</text>
                                </g>
                            </svg>
                        </div>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color root-color"></div>
                            <span>根节点(集合代表)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color child-color"></div>
                            <span>子节点</span>
                        </div>
                        <div class="legend-item">
                            <span>parent[i] = i 表示 i 是根节点</span>
                        </div>
                    </div>
                </div>

                <!-- 动态操作演示 -->
                <h3>🎬 动态操作演示</h3>
                <div class="animation-controls">
                    <div class="control-panel">
                        <button id="findBtn" class="unified-btn unified-btn-primary">查找操作</button>
                        <button id="unionBtn" class="unified-btn unified-btn-secondary">合并操作</button>
                        <input type="number" id="findElement" placeholder="查找元素" min="0" max="7" value="1">
                        <input type="number" id="unionX" placeholder="元素X" min="0" max="7" value="1">
                        <input type="number" id="unionY" placeholder="元素Y" min="0" max="7" value="3">
                        <button id="resetBtn" class="unified-btn">重置</button>
                    </div>
                    <div class="optimization-controls">
                        <label class="checkbox-label">
                            <input type="checkbox" id="pathCompression" checked> 启用路径压缩
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="unionByRank" checked> 启用按秩合并
                        </label>
                    </div>
                    <div class="step-info" id="stepInfo">点击操作按钮开始演示</div>
                </div>

                <div class="canvas-container">
                    <canvas id="unionFindCanvas" width="1000" height="600"></canvas>
                </div>

                <!-- 复杂度对比 -->
                <div class="complexity-comparison">
                    <h3>⏱️ 复杂度对比</h3>
                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>实现方式</th>
                                    <th>Find操作</th>
                                    <th>Union操作</th>
                                    <th>空间复杂度</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>朴素实现</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr class="highlighted">
                                    <td>路径压缩</td>
                                    <td>O(log n)</td>
                                    <td>O(log n)</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr class="highlighted">
                                    <td>按秩合并</td>
                                    <td>O(log n)</td>
                                    <td>O(log n)</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr class="best">
                                    <td>双重优化</td>
                                    <td>O(α(n))</td>
                                    <td>O(α(n))</td>
                                    <td>O(n)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- 操作步骤说明 -->
                <div class="operation-steps">
                    <div class="step-card">
                        <h4>🔍 Find操作步骤</h4>
                        <ol>
                            <li>从目标元素开始</li>
                            <li>沿着parent指针向上查找</li>
                            <li>直到找到根节点(parent[i] = i)</li>
                            <li><strong>路径压缩：</strong>将路径上所有节点直接指向根</li>
                            <li>返回根节点作为集合代表</li>
                        </ol>
                    </div>

                    <div class="step-card">
                        <h4>🔗 Union操作步骤</h4>
                        <ol>
                            <li>分别查找两个元素的根节点</li>
                            <li>如果根节点相同，说明已在同一集合</li>
                            <li><strong>按秩合并：</strong>比较两棵树的rank</li>
                            <li>让rank小的根指向rank大的根</li>
                            <li>如果rank相等，任选一个，被指向的rank+1</li>
                        </ol>
                    </div>

                    <div class="step-card">
                        <h4>⚡ 优化技术原理</h4>
                        <div class="optimization-details">
                            <div class="optimization-item">
                                <h5>路径压缩</h5>
                                <p>将查找路径上的所有节点直接连到根，使得后续查找更快</p>
                            </div>
                            <div class="optimization-item">
                                <h5>按秩合并</h5>
                                <p>维护树的深度信息，总是让浅树指向深树，保持树的平衡</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 🌟 实际应用 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">🌟</span>
                实际应用
            </h2>

            <div class="applications">
                <div class="application-item featured">
                    <h3>🌲 Kruskal最小生成树算法</h3>
                    <p>在图的所有边中选择权重最小的边，用并查集判断是否会形成环，构建最小生成树。</p>
                    <div class="application-details">
                        <h4>算法流程：</h4>
                        <ol>
                            <li>将所有边按权重从小到大排序</li>
                            <li>对每条边(u,v)，检查u和v是否在同一连通分量</li>
                            <li>如果不在，执行Union(u,v)并将边加入结果</li>
                            <li>重复直到选出n-1条边</li>
                        </ol>
                    </div>
                </div>

                <div class="application-item">
                    <h3>👥 社交网络朋友圈</h3>
                    <p>快速判断两个用户是否在同一个朋友圈，或者合并两个朋友圈。</p>
                </div>

                <div class="application-item">
                    <h3>🏝️ 岛屿数量问题</h3>
                    <p>在二维网格中统计由1组成的岛屿数量，使用并查集合并相邻的陆地。</p>
                </div>

                <div class="application-item">
                    <h3>🔌 网络连通性</h3>
                    <p>判断计算机网络中两台主机是否连通，或者在线路故障时快速重组网络。</p>
                </div>

                <div class="application-item">
                    <h3>🧬 基因序列聚类</h3>
                    <p>根据相似度将基因序列分组，使用并查集管理不同的基因家族。</p>
                </div>
            </div>

            <!-- 代码示例 -->
            <div class="code-examples">
                <h3>💻 代码实现</h3>
                <div class="code-tabs">
                    <button class="tab-btn active" data-lang="cpp">C++</button>
                    <button class="tab-btn" data-lang="java">Java</button>
                    <button class="tab-btn" data-lang="python">Python</button>
                </div>

                <!-- C++ 代码 -->
                <div class="code-content active" data-lang="cpp">
                    <div class="code-header">
                        <span>并查集完整实现 - C++</span>
                        <button class="copy-btn" data-clipboard-target="cpp-code">📋 复制</button>
                    </div>
                    <pre id="cpp-code"><code>
class UnionFind {
private:
    vector&lt;int&gt; parent;  // 父节点数组
    vector&lt;int&gt; rank;   // 秩数组(树的深度)
    int count;          // 连通分量个数

public:
    UnionFind(int n) : count(n) {
        parent.resize(n);
        rank.resize(n, 0);
        // 初始化：每个元素的父节点是自己
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // 查找操作 + 路径压缩
    int find(int x) {
        if (parent[x] != x) {
            // 路径压缩：让路径上所有节点直接指向根
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 合并操作 + 按秩合并
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return false;  // 已经在同一集合中
        }

        // 按秩合并：让rank小的根指向rank大的根
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;  // rank相等时，被指向的根的rank增加
        }

        count--;  // 连通分量减一
        return true;
    }

    // 判断两个元素是否在同一集合
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }

    // 获取连通分量个数
    int getCount() const {
        return count;
    }

    // 获取集合大小(需要额外维护size数组)
    int getSize(int x) {
        return size[find(x)];
    }
};

// 使用示例：Kruskal最小生成树
struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

int kruskalMST(int n, vector&lt;Edge&gt;& edges) {
    sort(edges.begin(), edges.end());
    UnionFind uf(n);

    int mstWeight = 0;
    int edgesUsed = 0;

    for (const Edge& edge : edges) {
        if (uf.unionSets(edge.u, edge.v)) {
            mstWeight += edge.weight;
            edgesUsed++;

            if (edgesUsed == n - 1) {
                break;  // MST完成
            }
        }
    }

    return mstWeight;
}
                    </code></pre>
                </div>

                <!-- Java 代码 -->
                <div class="code-content" data-lang="java">
                    <div class="code-header">
                        <span>并查集完整实现 - Java</span>
                        <button class="copy-btn" data-clipboard-target="java-code">📋 复制</button>
                    </div>
                    <pre id="java-code"><code>
public class UnionFind {
    private int[] parent;  // 父节点数组
    private int[] rank;    // 秩数组
    private int count;     // 连通分量个数

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        count = n;

        // 初始化：每个元素的父节点是自己
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    // 查找操作 + 路径压缩
    public int find(int x) {
        if (parent[x] != x) {
            // 路径压缩
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 合并操作 + 按秩合并
    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return false;  // 已在同一集合
        }

        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }

        count--;
        return true;
    }

    // 判断连通性
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    // 获取连通分量个数
    public int getCount() {
        return count;
    }
}

// 使用示例：朋友圈问题
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        UnionFind uf = new UnionFind(n);

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }

        return uf.getCount();
    }
}

// 使用示例：岛屿数量
class Solution2 {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int m = grid.length, n = grid[0].length;
        UnionFind uf = new UnionFind(m * n);
        int waterCount = 0;

        int[][] directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '0') {
                    waterCount++;
                } else {
                    // 检查四个方向
                    for (int[] dir : directions) {
                        int x = i + dir[0], y = j + dir[1];
                        if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1') {
                            uf.union(i * n + j, x * n + y);
                        }
                    }
                }
            }
        }

        return uf.getCount() - waterCount;
    }
}
                    </code></pre>
                </div>

                <!-- Python 代码 -->
                <div class="code-content" data-lang="python">
                    <div class="code-header">
                        <span>并查集完整实现 - Python</span>
                        <button class="copy-btn" data-clipboard-target="python-code">📋 复制</button>
                    </div>
                    <pre id="python-code"><code>
class UnionFind:
    def __init__(self, n):
        """初始化并查集"""
        self.parent = list(range(n))  # 父节点数组
        self.rank = [0] * n           # 秩数组
        self.count = n                # 连通分量个数
        self.size = [1] * n           # 每个集合的大小

    def find(self, x):
        """查找 + 路径压缩"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        """合并 + 按秩合并"""
        root_x, root_y = self.find(x), self.find(y)

        if root_x == root_y:
            return False  # 已在同一集合

        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        else:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
            self.rank[root_x] += 1

        self.count -= 1
        return True

    def is_connected(self, x, y):
        """判断连通性"""
        return self.find(x) == self.find(y)

    def get_count(self):
        """获取连通分量个数"""
        return self.count

    def get_size(self, x):
        """获取x所在集合的大小"""
        return self.size[self.find(x)]

# 使用示例1：朋友圈问题
def find_circle_num(is_connected):
    """
    计算朋友圈数量
    :param is_connected: 二维数组，is_connected[i][j] = 1表示i和j是朋友
    :return: 朋友圈数量
    """
    n = len(is_connected)
    uf = UnionFind(n)

    for i in range(n):
        for j in range(i + 1, n):
            if is_connected[i][j] == 1:
                uf.union(i, j)

    return uf.get_count()

# 使用示例2：岛屿数量
def num_islands(grid):
    """
    计算岛屿数量
    :param grid: 二维字符数组，'1'表示陆地，'0'表示水
    :return: 岛屿数量
    """
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    uf = UnionFind(m * n)
    water_count = 0

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '0':
                water_count += 1
            else:
                # 检查四个方向
                for di, dj in directions:
                    x, y = i + di, j + dj
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':
                        uf.union(i * n + j, x * n + y)

    return uf.get_count() - water_count

# 使用示例3：Kruskal最小生成树
def kruskal_mst(n, edges):
    """
    Kruskal算法求最小生成树
    :param n: 节点数量
    :param edges: 边列表，每个元素为(u, v, weight)
    :return: 最小生成树的总权重
    """
    # 按权重排序
    edges.sort(key=lambda x: x[2])

    uf = UnionFind(n)
    mst_weight = 0
    edges_used = 0

    for u, v, weight in edges:
        if uf.union(u, v):
            mst_weight += weight
            edges_used += 1

            if edges_used == n - 1:
                break

    return mst_weight

# 使用示例
if __name__ == "__main__":
    # 测试并查集基本操作
    uf = UnionFind(6)

    # 合并一些元素
    uf.union(0, 1)
    uf.union(2, 3)
    uf.union(4, 5)

    print(f"连通分量数: {uf.get_count()}")  # 3
    print(f"0和1连通: {uf.is_connected(0, 1)}")  # True
    print(f"0和2连通: {uf.is_connected(0, 2)}")  # False

    # 继续合并
    uf.union(1, 2)
    print(f"合并后连通分量数: {uf.get_count()}")  # 2
    print(f"0和3连通: {uf.is_connected(0, 3)}")  # True
                    </code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- ✅ 学习检验 -->
    <div class="content-card">
        <div class="content-section">
            <h2 class="section-title">
                <span class="section-icon">✅</span>
                学习检验
            </h2>

            <div class="quiz-container">
                <div class="quiz-item">
                    <h3>🤔 思考题1：阿克曼函数理解</h3>
                    <p><strong>问题：</strong>为什么说并查集的时间复杂度是O(α(n))而不是O(1)？α(n)在实际应用中有多大？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer1')">点击查看答案</button>
                    <div class="answer-content" id="answer1">
                        <p><strong>答案：</strong>α(n)是阿克曼函数的反函数，虽然理论上不是常数，但在实际中可视为常数。</p>
                        <p><strong>解释：</strong>α(n)增长极其缓慢：α(1)=1, α(3)=2, α(7)=3, α(2047)=4, α(2^65536-3)=5。即使宇宙中原子数(约10^80)，α值也只有5。所以实际应用中完全可以当作常数时间操作。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题2：优化技术的必要性</h3>
                    <p><strong>问题：</strong>如果只使用路径压缩而不使用按秩合并，或者只使用按秩合并而不使用路径压缩，时间复杂度分别是多少？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer2')">点击查看答案</button>
                    <div class="answer-content" id="answer2">
                        <p><strong>答案：</strong>单独使用任一优化技术，时间复杂度都是O(log n)；两者结合才能达到O(α(n))。</p>
                        <p><strong>解释：</strong>①只用路径压缩：虽然能压缩路径，但Union时可能产生长链；②只用按秩合并：能保持树平衡，但查找路径不压缩；③双重优化：按秩合并保持平衡+路径压缩加速查找=近乎常数时间。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题3：应用场景判断</h3>
                    <p><strong>问题：</strong>什么情况下应该使用并查集而不是DFS/BFS来解决连通性问题？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer3')">点击查看答案</button>
                    <div class="answer-content" id="answer3">
                        <p><strong>答案：</strong>当需要动态地添加边和查询连通性时，应该使用并查集。</p>
                        <p><strong>解释：</strong>DFS/BFS适合静态图的连通性查询，时间复杂度O(V+E)；并查集适合动态图，可以在线地处理"添加边"和"查询连通性"操作，均摊复杂度O(α(n))。例如：网络连接实时监控、Kruskal算法、在线判断图的连通性变化等。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题4：数据结构变种</h3>
                    <p><strong>问题：</strong>如何在并查集的基础上实现"撤销"操作，即支持删除之前添加的边？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer4')">点击查看答案</button>
                    <div class="answer-content" id="answer4">
                        <p><strong>答案：</strong>标准并查集不支持撤销，需要使用"可持久化并查集"或者记录操作历史。</p>
                        <p><strong>解释：</strong>①可持久化方法：为每次操作创建新版本；②历史记录方法：记录每次Union的详细信息，支持回滚；③线段树+并查集：对时间轴建线段树；④注意：路径压缩会破坏历史信息，撤销场景下通常只用按秩合并。</p>
                    </div>
                </div>

                <div class="quiz-item">
                    <h3>🤔 思考题5：实际优化考虑</h3>
                    <p><strong>问题：</strong>在实际项目中，什么情况下可能不使用路径压缩优化？</p>
                    <button class="answer-btn" onclick="toggleAnswer('answer5')">点击查看答案</button>
                    <div class="answer-content" id="answer5">
                        <p><strong>答案：</strong>需要保持树结构信息、支持撤销操作、或者在多线程环境中时。</p>
                        <p><strong>解释：</strong>①需要树结构：某些应用需要知道具体的父子关系；②撤销操作：路径压缩会破坏历史信息；③多线程：路径压缩的递归修改在并发环境下复杂；④内存敏感：路径压缩可能增加某些操作的内存访问；⑤实时系统：需要保证每次操作的时间上界。</p>
                    </div>
                </div>
            </div>

            <!-- 进阶学习建议 -->
            <div class="learning-progress">
                <h3>📚 进阶学习路径</h3>
                <div class="progress-steps">
                    <div class="progress-step completed">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <h4>并查集基础</h4>
                            <p>掌握Find和Union操作</p>
                        </div>
                    </div>
                    <div class="progress-step next">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <h4>图算法应用</h4>
                            <p>Kruskal、连通分量</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <h4>动态连通性</h4>
                            <p>在线算法、实时查询</p>
                        </div>
                    </div>
                    <div class="progress-step">
                        <span class="step-number">4</span>
                        <div class="step-content">
                            <h4>高级变种</h4>
                            <p>可持久化、带权并查集</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div style="text-align: center; margin-top: 40px;">
        <a href="{% url 'knowledge_app:index' %}" class="unified-btn unified-btn-primary">
            <span>🏠</span>
            返回首页
        </a>
        <a href="{% url 'knowledge_app:cs_universe' %}" class="unified-btn unified-btn-secondary">
            <span>🌌</span>
            探索CS宇宙
        </a>
    </div>
</div>

<!-- CSS样式 -->
<style>
.overview-content {
    margin-top: 20px;
}

.concept-intro {
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 4px solid #2196F3;
}

.badge {
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    color: white;
}

.badge-hard {
    background: #f44336;
}

.concept-details {
    margin-top: 20px;
}

.concept-item {
    margin-bottom: 30px;
    padding: 20px;
    background: #fafafa;
    border-radius: 8px;
    border-left: 4px solid #4CAF50;
}

.example-box {
    background: white;
    padding: 15px;
    border-radius: 8px;
    margin-top: 15px;
    border: 1px solid #e0e0e0;
}

.example-box h4 {
    color: #FF5722;
    margin-top: 0;
}

.operations-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 20px;
    margin-top: 15px;
}

.operation-card {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s;
}

.operation-card:hover {
    transform: translateY(-5px);
}

.find-card {
    border-left: 4px solid #2196F3;
}

.union-card {
    border-left: 4px solid #FF9800;
}

.op-icon {
    font-size: 2.5em;
    display: block;
    margin-bottom: 15px;
}

.complexity {
    background: #e8f5e8;
    padding: 8px 12px;
    border-radius: 4px;
    font-weight: bold;
    color: #2E7D32;
    margin-top: 10px;
    font-size: 14px;
}

.optimization-techniques {
    margin-top: 15px;
}

.tech-card {
    background: white;
    border-radius: 8px;
    margin-bottom: 20px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.tech-card h4 {
    background: linear-gradient(135deg, #4CAF50, #66BB6A);
    color: white;
    margin: 0;
    padding: 15px 20px;
}

.tech-content {
    padding: 20px;
}

.before-after {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 20px;
    align-items: center;
    margin-top: 15px;
}

.before, .after {
    text-align: center;
}

.path-demo {
    background: #f5f5f5;
    padding: 10px;
    border-radius: 4px;
    font-family: monospace;
    margin: 8px 0;
}

.arrow {
    font-size: 24px;
    font-weight: bold;
    color: #4CAF50;
}

.rank-example {
    margin-top: 10px;
}

.good {
    color: #4CAF50;
    margin-right: 15px;
}

.bad {
    color: #f44336;
}

.key-points {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.point-card {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border-left: 4px solid #FF5722;
    display: flex;
    align-items: flex-start;
    gap: 12px;
}

.point-icon {
    font-size: 1.5em;
    flex-shrink: 0;
}

.point-card h4 {
    margin: 0 0 8px 0;
    color: #333;
    font-size: 16px;
}

.point-card p {
    margin: 0;
    color: #666;
    font-size: 14px;
    line-height: 1.4;
}

.visualization-container {
    margin-top: 20px;
}

.static-diagram {
    text-align: center;
    margin: 20px 0;
    padding: 20px;
    background: #f9f9f9;
    border-radius: 8px;
}

.structure-comparison {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 30px;
    margin: 20px 0;
}

.structure-view {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.structure-view h4 {
    text-align: center;
    color: #333;
    margin-top: 0;
}

.array-view {
    font-family: monospace;
    font-size: 14px;
}

.array-header, .array-content {
    display: grid;
    grid-template-columns: 80px repeat(6, 1fr);
    text-align: center;
    border-bottom: 1px solid #ddd;
}

.array-header {
    background: #f5f5f5;
    font-weight: bold;
    padding: 8px 0;
}

.array-content {
    padding: 8px 0;
}

.array-content span:first-child {
    background: #f5f5f5;
    font-weight: bold;
    border-right: 1px solid #ddd;
}

.root {
    background: #4CAF50;
    color: white;
    font-weight: bold;
}

.child {
    background: #2196F3;
    color: white;
    font-weight: bold;
}

.legend {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid #ddd;
}

.root-color {
    background: #4CAF50;
}

.child-color {
    background: #2196F3;
}

.animation-controls {
    margin: 20px 0;
    text-align: center;
}

.control-panel {
    margin-bottom: 15px;
}

.control-panel button,
.control-panel input {
    margin: 5px;
}

.control-panel input {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    width: 100px;
}

.optimization-controls {
    margin-bottom: 15px;
}

.checkbox-label {
    margin: 0 20px;
    font-size: 14px;
}

.checkbox-label input {
    margin-right: 5px;
}

.step-info {
    padding: 10px;
    background: #e3f2fd;
    border-radius: 4px;
    margin-bottom: 15px;
    font-weight: bold;
}

.canvas-container {
    text-align: center;
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    margin: 15px 0;
}

#unionFindCanvas {
    border: 1px solid #eee;
    border-radius: 4px;
}

.complexity-comparison {
    margin: 30px 0;
}

.comparison-table {
    overflow-x: auto;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.comparison-table th,
.comparison-table td {
    border: 1px solid #ddd;
    padding: 12px 15px;
    text-align: center;
}

.comparison-table th {
    background: #f5f5f5;
    font-weight: bold;
    color: #333;
}

.comparison-table .highlighted {
    background: #e8f5e8;
}

.comparison-table .best {
    background: #c8e6c9;
    font-weight: bold;
}

.operation-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.step-card {
    background: white;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #2196F3;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.step-card h4 {
    margin-top: 0;
    color: #1976D2;
}

.step-card ol {
    margin: 10px 0 0 20px;
}

.optimization-details {
    margin-top: 10px;
}

.optimization-item {
    margin-bottom: 10px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 4px;
}

.optimization-item h5 {
    margin: 0 0 5px 0;
    color: #333;
}

.applications {
    margin-top: 20px;
}

.application-item {
    margin-bottom: 20px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #FF5722;
}

.application-item.featured {
    background: linear-gradient(135deg, #fff3e0, #ffffff);
    border-left-color: #FF9800;
}

.application-details {
    margin-top: 15px;
    padding: 15px;
    background: white;
    border-radius: 6px;
    border: 1px solid #e0e0e0;
}

.application-details h4 {
    margin-top: 0;
    color: #FF9800;
}

.application-details ol {
    margin: 10px 0 0 20px;
}

.code-examples {
    margin-top: 30px;
}

.code-tabs {
    display: flex;
    margin-bottom: 0;
    border-bottom: 2px solid #e0e0e0;
}

.tab-btn {
    padding: 12px 24px;
    background: #f5f5f5;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
}

.tab-btn.active {
    background: #2196F3;
    color: white;
    border-bottom-color: #2196F3;
}

.code-content {
    display: none;
    background: #1e1e1e;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
}

.code-content.active {
    display: block;
}

.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: #333;
    color: white;
    font-size: 14px;
}

.copy-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.2s;
}

.copy-btn:hover {
    background: #45a049;
}

pre {
    margin: 0;
    overflow-x: auto;
}

code {
    color: #f8f8f2;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.5;
    display: block;
    padding: 20px;
}

.quiz-container {
    margin-top: 20px;
}

.quiz-item {
    margin-bottom: 25px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.quiz-item h3 {
    color: #1976D2;
    margin-top: 0;
}

.answer-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin: 10px 0;
    font-weight: bold;
    transition: background 0.2s;
}

.answer-btn:hover {
    background: #45a049;
}

.answer-content {
    display: none;
    margin-top: 15px;
    padding: 15px;
    background: #e8f5e8;
    border-radius: 5px;
    border-left: 4px solid #4CAF50;
}

.answer-content.show {
    display: block;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.learning-progress {
    margin-top: 30px;
    padding: 20px;
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    border-radius: 10px;
}

.progress-steps {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.progress-step {
    display: flex;
    align-items: center;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    opacity: 0.6;
    transition: all 0.3s;
}

.progress-step.completed {
    opacity: 1;
    border-left: 4px solid #4CAF50;
}

.progress-step.next {
    opacity: 1;
    border-left: 4px solid #FF9800;
    transform: scale(1.05);
}

.step-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: #e0e0e0;
    color: white;
    border-radius: 50%;
    margin-right: 15px;
    font-weight: bold;
}

.progress-step.completed .step-number {
    background: #4CAF50;
}

.progress-step.next .step-number {
    background: #FF9800;
}

.step-content h4 {
    margin: 0 0 5px 0;
    color: #333;
}

.step-content p {
    margin: 0;
    color: #666;
    font-size: 14px;
}

@media (max-width: 768px) {
    .operations-grid {
        grid-template-columns: 1fr;
    }

    .key-points {
        grid-template-columns: 1fr;
    }

    .operation-steps {
        grid-template-columns: 1fr;
    }

    .progress-steps {
        grid-template-columns: 1fr;
    }

    .code-tabs {
        flex-wrap: wrap;
    }

    .tab-btn {
        flex: 1;
        min-width: 80px;
    }

    .structure-comparison {
        grid-template-columns: 1fr;
    }

    .before-after {
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .arrow {
        transform: rotate(90deg);
    }
}
</style>

<!-- JavaScript -->
<script>
// 并查集动画相关变量
let canvas, ctx;
let unionFind = null;
let animationInProgress = false;
let pathCompressionEnabled = true;
let unionByRankEnabled = true;

// 并查集类
class UnionFindVisual {
    constructor(n) {
        this.n = n;
        this.parent = Array.from({length: n}, (_, i) => i);
        this.rank = new Array(n).fill(0);
        this.size = new Array(n).fill(1);
        this.count = n;

        // 可视化相关
        this.positions = this.calculatePositions();
        this.highlightedNodes = new Set();
        this.animationPath = [];
    }

    calculatePositions() {
        const positions = [];
        const centerX = 500;
        const centerY = 300;
        const radius = 200;

        for (let i = 0; i < this.n; i++) {
            const angle = (2 * Math.PI * i) / this.n;
            positions.push({
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            });
        }
        return positions;
    }

    find(x, recordPath = false) {
        const path = [];
        let current = x;

        // 记录查找路径
        while (this.parent[current] !== current) {
            path.push(current);
            current = this.parent[current];
        }
        path.push(current); // 添加根节点

        if (recordPath) {
            this.animationPath = path;
        }

        // 路径压缩
        if (pathCompressionEnabled && path.length > 1) {
            for (let i = 0; i < path.length - 1; i++) {
                this.parent[path[i]] = current;
            }
        }

        return current;
    }

    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);

        if (rootX === rootY) {
            return false;
        }

        if (unionByRankEnabled) {
            // 按秩合并
            if (this.rank[rootX] < this.rank[rootY]) {
                this.parent[rootX] = rootY;
                this.size[rootY] += this.size[rootX];
            } else if (this.rank[rootX] > this.rank[rootY]) {
                this.parent[rootY] = rootX;
                this.size[rootX] += this.size[rootY];
            } else {
                this.parent[rootY] = rootX;
                this.size[rootX] += this.size[rootY];
                this.rank[rootX]++;
            }
        } else {
            // 简单合并
            this.parent[rootX] = rootY;
            this.size[rootY] += this.size[rootX];
        }

        this.count--;
        return true;
    }

    isConnected(x, y) {
        return this.find(x) === this.find(y);
    }
}

// 初始化并查集演示
document.addEventListener('DOMContentLoaded', function() {
    canvas = document.getElementById('unionFindCanvas');
    ctx = canvas.getContext('2d');

    // 初始化8个元素的并查集
    initializeUnionFind();
    drawUnionFind();

    // 绑定事件
    document.getElementById('findBtn').addEventListener('click', () => {
        if (animationInProgress) return;

        const element = parseInt(document.getElementById('findElement').value);
        if (isNaN(element) || element < 0 || element >= unionFind.n) {
            alert('请输入有效的元素编号（0-7）');
            return;
        }

        startFindAnimation(element);
    });

    document.getElementById('unionBtn').addEventListener('click', () => {
        if (animationInProgress) return;

        const x = parseInt(document.getElementById('unionX').value);
        const y = parseInt(document.getElementById('unionY').value);

        if (isNaN(x) || isNaN(y) || x < 0 || x >= unionFind.n || y < 0 || y >= unionFind.n) {
            alert('请输入有效的元素编号（0-7）');
            return;
        }

        if (x === y) {
            alert('两个元素不能相同');
            return;
        }

        startUnionAnimation(x, y);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        if (animationInProgress) return;

        initializeUnionFind();
        drawUnionFind();
        document.getElementById('stepInfo').textContent = '已重置，点击操作按钮开始演示';
    });

    // 优化选项
    document.getElementById('pathCompression').addEventListener('change', function() {
        pathCompressionEnabled = this.checked;
    });

    document.getElementById('unionByRank').addEventListener('change', function() {
        unionByRankEnabled = this.checked;
    });
});

// 初始化并查集
function initializeUnionFind() {
    unionFind = new UnionFindVisual(8);

    // 创建一些初始连接，让结构更有趣
    unionFind.union(0, 1);
    unionFind.union(2, 3);
    unionFind.union(4, 5);
    unionFind.union(5, 6);
}

// 绘制并查集
function drawUnionFind() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制连接线
    drawConnections();

    // 绘制节点
    drawNodes();

    // 绘制信息
    drawInfo();
}

// 绘制连接线
function drawConnections() {
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;

    for (let i = 0; i < unionFind.n; i++) {
        if (unionFind.parent[i] !== i) {
            const parentIndex = unionFind.parent[i];
            const from = unionFind.positions[i];
            const to = unionFind.positions[parentIndex];

            // 高亮动画路径上的连线
            if (unionFind.animationPath.includes(i) && unionFind.animationPath.includes(parentIndex)) {
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 4;
            } else {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
            }

            drawArrow(from.x, from.y, to.x, to.y);
        }
    }
}

// 绘制箭头
function drawArrow(x1, y1, x2, y2) {
    // 计算方向向量
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);

    // 标准化方向向量
    const unitX = dx / length;
    const unitY = dy / length;

    // 调整起点和终点，避免被节点遮挡
    const radius = 25;
    const startX = x1 + unitX * radius;
    const startY = y1 + unitY * radius;
    const endX = x2 - unitX * radius;
    const endY = y2 - unitY * radius;

    // 绘制线条
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // 绘制箭头头部
    const arrowLength = 15;
    const arrowAngle = Math.PI / 6;
    const angle = Math.atan2(endY - startY, endX - startX);

    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - arrowLength * Math.cos(angle - arrowAngle),
        endY - arrowLength * Math.sin(angle - arrowAngle)
    );
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - arrowLength * Math.cos(angle + arrowAngle),
        endY - arrowLength * Math.sin(angle + arrowAngle)
    );
    ctx.stroke();
}

// 绘制节点
function drawNodes() {
    for (let i = 0; i < unionFind.n; i++) {
        const pos = unionFind.positions[i];
        let color, strokeColor;

        // 确定节点颜色
        if (unionFind.parent[i] === i) {
            // 根节点
            color = '#4CAF50';
            strokeColor = '#2E7D32';
        } else {
            // 子节点
            color = '#2196F3';
            strokeColor = '#1976D2';
        }

        // 高亮节点
        if (unionFind.highlightedNodes.has(i)) {
            color = '#FF5722';
            strokeColor = '#E64A19';
        }

        // 在动画路径中的节点
        if (unionFind.animationPath.includes(i)) {
            strokeColor = '#FF9800';
            ctx.lineWidth = 4;
        } else {
            ctx.lineWidth = 3;
        }

        // 绘制圆圈
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = strokeColor;
        ctx.stroke();

        // 绘制节点编号
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), pos.x, pos.y);

        // 显示rank信息（如果是根节点）
        if (unionFind.parent[i] === i && unionByRankEnabled) {
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText(`rank:${unionFind.rank[i]}`, pos.x, pos.y + 40);
        }
    }
}

// 绘制信息面板
function drawInfo() {
    // 绘制集合信息
    const sets = new Map();
    for (let i = 0; i < unionFind.n; i++) {
        const root = unionFind.find(i);
        if (!sets.has(root)) {
            sets.set(root, []);
        }
        sets.get(root).push(i);
    }

    ctx.fillStyle = '#333';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';

    let y = 30;
    ctx.fillText(`连通分量数: ${unionFind.count}`, 20, y);
    y += 20;

    ctx.fillText('集合详情:', 20, y);
    y += 20;

    sets.forEach((members, root) => {
        ctx.fillText(`集合${root}: {${members.join(', ')}}`, 20, y);
        y += 18;
    });

    // 绘制优化状态
    const optimizations = [];
    if (pathCompressionEnabled) optimizations.push('路径压缩');
    if (unionByRankEnabled) optimizations.push('按秩合并');

    if (optimizations.length > 0) {
        ctx.fillText(`优化: ${optimizations.join(', ')}`, 20, y + 10);
    }
}

// Find操作动画
function startFindAnimation(element) {
    animationInProgress = true;
    unionFind.highlightedNodes.clear();
    unionFind.animationPath = [];

    let step = 1;
    document.getElementById('stepInfo').textContent = `步骤${step}: 开始查找元素 ${element} 的根节点`;

    // 记录查找路径
    const originalPathCompression = pathCompressionEnabled;
    pathCompressionEnabled = false; // 暂时禁用路径压缩以显示完整路径

    const root = unionFind.find(element, true);

    setTimeout(() => {
        step++;
        document.getElementById('stepInfo').textContent = `步骤${step}: 查找路径: ${unionFind.animationPath.join(' → ')}`;
        drawUnionFind();

        setTimeout(() => {
            if (originalPathCompression && unionFind.animationPath.length > 2) {
                step++;
                document.getElementById('stepInfo').textContent = `步骤${step}: 应用路径压缩优化`;

                // 重新启用路径压缩并执行
                pathCompressionEnabled = true;
                unionFind.find(element);
                drawUnionFind();

                setTimeout(() => {
                    step++;
                    document.getElementById('stepInfo').textContent = `步骤${step}: 查找完成！元素 ${element} 的根节点是 ${root}`;
                    unionFind.animationPath = [];
                    unionFind.highlightedNodes.add(root);
                    drawUnionFind();

                    setTimeout(() => {
                        unionFind.highlightedNodes.clear();
                        drawUnionFind();
                        animationInProgress = false;
                    }, 2000);
                }, 2000);
            } else {
                step++;
                document.getElementById('stepInfo').textContent = `步骤${step}: 查找完成！元素 ${element} 的根节点是 ${root}`;
                unionFind.highlightedNodes.add(root);
                drawUnionFind();

                setTimeout(() => {
                    unionFind.highlightedNodes.clear();
                    unionFind.animationPath = [];
                    drawUnionFind();
                    animationInProgress = false;
                }, 2000);
            }
        }, 2000);
    }, 1500);
}

// Union操作动画
function startUnionAnimation(x, y) {
    animationInProgress = true;
    unionFind.highlightedNodes.clear();
    unionFind.animationPath = [];

    let step = 1;
    document.getElementById('stepInfo').textContent = `步骤${step}: 开始合并元素 ${x} 和 ${y}`;

    // 高亮要合并的元素
    unionFind.highlightedNodes.add(x);
    unionFind.highlightedNodes.add(y);
    drawUnionFind();

    setTimeout(() => {
        step++;
        const rootX = unionFind.find(x);
        const rootY = unionFind.find(y);

        document.getElementById('stepInfo').textContent = `步骤${step}: 查找根节点 - ${x}的根是${rootX}，${y}的根是${rootY}`;

        unionFind.highlightedNodes.clear();
        unionFind.highlightedNodes.add(rootX);
        unionFind.highlightedNodes.add(rootY);
        drawUnionFind();

        setTimeout(() => {
            step++;
            if (rootX === rootY) {
                document.getElementById('stepInfo').textContent = `步骤${step}: 元素已在同一集合中，无需合并`;
                setTimeout(() => {
                    unionFind.highlightedNodes.clear();
                    drawUnionFind();
                    animationInProgress = false;
                }, 2000);
                return;
            }

            // 执行合并
            if (unionByRankEnabled) {
                const rankX = unionFind.rank[rootX];
                const rankY = unionFind.rank[rootY];
                document.getElementById('stepInfo').textContent = `步骤${step}: 按秩合并 - rank[${rootX}]=${rankX}, rank[${rootY}]=${rankY}`;
            } else {
                document.getElementById('stepInfo').textContent = `步骤${step}: 执行简单合并`;
            }

            setTimeout(() => {
                step++;
                unionFind.union(x, y);
                document.getElementById('stepInfo').textContent = `步骤${step}: 合并完成！连通分量数: ${unionFind.count}`;

                unionFind.highlightedNodes.clear();
                drawUnionFind();

                setTimeout(() => {
                    animationInProgress = false;
                }, 2000);
            }, 2000);
        }, 2000);
    }, 1500);
}

// 代码标签页切换
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        // 移除所有active类
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));

        // 添加active类到当前标签
        this.classList.add('active');
        const lang = this.getAttribute('data-lang');
        document.querySelector(`.code-content[data-lang="${lang}"]`).classList.add('active');
    });
});

// 复制代码功能
document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const targetId = this.getAttribute('data-clipboard-target');
        const codeElement = document.getElementById(targetId);

        if (codeElement) {
            // 创建临时文本区域
            const textarea = document.createElement('textarea');
            textarea.value = codeElement.textContent;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            // 显示复制成功提示
            const originalText = this.textContent;
            this.textContent = '✅ 已复制';
            setTimeout(() => {
                this.textContent = originalText;
            }, 2000);
        }
    });
});

// 答案切换功能
function toggleAnswer(answerId) {
    const answerElement = document.getElementById(answerId);
    const button = answerElement.previousElementSibling;

    if (answerElement.classList.contains('show')) {
        answerElement.classList.remove('show');
        button.textContent = '点击查看答案';
    } else {
        answerElement.classList.add('show');
        button.textContent = '隐藏答案';
    }
}
</script>

{% endblock %}