# 练习题示例模板

## 📝 单选题示例

### 题目信息
- **标题**：快速排序的平均时间复杂度
- **URL标识**：quick-sort-average-complexity
- **分类**：算法设计
- **难度**：中级
- **题目类型**：单选题
- **标签**：快速排序,时间复杂度,分治算法

### 题目内容
**题目描述**：
```
快速排序算法在平均情况下的时间复杂度是多少？
```

**选项**：
```json
{
  "A": "O(n)",
  "B": "O(n log n)",
  "C": "O(n²)",
  "D": "O(2ⁿ)"
}
```

**正确答案**：
```
B
```

**答案解析**：
```
快速排序的时间复杂度分析：

1. 最好情况：O(n log n)
   - 每次划分都能将数组分成两个大小相等的子数组
   
2. 平均情况：O(n log n)
   - 在随机输入下，期望的划分是相对均匀的
   
3. 最坏情况：O(n²)
   - 每次划分都极不均匀（如已排序数组）
   
快速排序之所以被广泛使用，是因为其平均性能优秀，且常数因子较小。
```

**提示**：
```json
[
  "考虑分治算法的特点",
  "想想每层递归的操作次数",
  "快速排序的名字暗示了什么？"
]
```

**时间限制**：90秒

---

## 🔢 多选题示例

### 题目信息
- **标题**：哈希表的冲突解决方法
- **URL标识**：hash-table-collision-resolution
- **分类**：数据结构
- **难度**：中级
- **题目类型**：多选题

### 题目内容
**题目描述**：
```
以下哪些是哈希表解决冲突的常用方法？（多选）
```

**选项**：
```json
{
  "A": "链地址法（拉链法）",
  "B": "开放地址法",
  "C": "再哈希法",
  "D": "二分查找法"
}
```

**正确答案**：
```
A,B,C
```

**答案解析**：
```
哈希表冲突解决方法：

A. 链地址法（拉链法）✓
   - 在每个哈希位置维护一个链表
   - 冲突的元素都存储在同一个链表中

B. 开放地址法✓
   - 线性探测：依次检查下一个位置
   - 二次探测：按二次函数序列探测
   - 双重哈希：使用第二个哈希函数

C. 再哈希法✓
   - 使用多个哈希函数
   - 当发生冲突时使用下一个哈希函数

D. 二分查找法✗
   - 这是查找算法，不是冲突解决方法
```

**提示**：
```json
[
  "想想当两个键映射到同一个位置时怎么办",
  "考虑在哈希位置存储多个值的方法",
  "二分查找适用于有序数组，与哈希表无关"
]
```

---

## ✅ 判断题示例

### 题目信息
- **标题**：栈的LIFO特性
- **URL标识**：stack-lifo-property
- **分类**：数据结构
- **难度**：初级
- **题目类型**：判断题

### 题目内容
**题目描述**：
```
栈是一种后进先出（LIFO）的数据结构。
```

**选项**：
```json
{}
```

**正确答案**：
```
true
```

**答案解析**：
```
正确。栈（Stack）确实是一种后进先出（Last In First Out, LIFO）的数据结构。

栈的特点：
1. 只能在栈顶进行插入和删除操作
2. 最后压入栈的元素最先被弹出
3. 类似于一摞盘子，只能从顶部取放

基本操作：
- push()：压栈（入栈）
- pop()：弹栈（出栈）
- top()：查看栈顶元素
- empty()：判断栈是否为空
```

**提示**：
```json
[
  "想想栈的英文名称Stack的含义",
  "类比一摞盘子的取放过程"
]
```

---

## 📝 填空题示例

### 题目信息
- **标题**：二叉搜索树的性质
- **URL标识**：binary-search-tree-property
- **分类**：数据结构
- **难度**：中级
- **题目类型**：填空题

### 题目内容
**题目描述**：
```
二叉搜索树的性质：对于树中的任意节点，其左子树中所有节点的值都____该节点的值，其右子树中所有节点的值都____该节点的值。
```

**选项**：
```json
{}
```

**正确答案**：
```
小于,大于
```

**答案解析**：
```
二叉搜索树（Binary Search Tree, BST）的核心性质：

对于树中的任意节点：
- 左子树中所有节点的值都小于该节点的值
- 右子树中所有节点的值都大于该节点的值

这个性质使得：
1. 中序遍历BST可以得到有序序列
2. 查找、插入、删除操作的平均时间复杂度为O(log n)
3. 可以高效地进行范围查询

注意：通常BST不允许重复值，如果允许重复，则约定相等的值放在左子树或右子树。
```

**提示**：
```json
[
  "想想二叉搜索树的查找过程",
  "考虑如何保证查找的高效性",
  "左小右大是基本规则"
]
```

---

## 📖 简答题示例

### 题目信息
- **标题**：解释死锁的概念和条件
- **URL标识**：deadlock-concept-conditions
- **分类**：操作系统
- **难度**：高级
- **题目类型**：简答题

### 题目内容
**题目描述**：
```
请解释什么是死锁，并说明产生死锁的四个必要条件。
```

**选项**：
```json
{}
```

**正确答案**：
```
死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象。

死锁产生的四个必要条件：
1. 互斥条件：资源不能被多个进程同时使用
2. 请求和保持条件：进程已获得部分资源，同时等待其他资源
3. 不剥夺条件：已分配的资源不能被强制回收
4. 环路等待条件：存在进程资源的循环等待链
```

**答案解析**：
```
死锁详细解释：

定义：
死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。

四个必要条件（缺一不可）：

1. 互斥条件（Mutual Exclusion）
   - 资源不能被多个进程同时使用
   - 例如：打印机同时只能被一个进程使用

2. 请求和保持条件（Hold and Wait）
   - 进程已经保持了至少一个资源
   - 同时又请求其他被别的进程占用的资源

3. 不剥夺条件（No Preemption）
   - 已分配给进程的资源不能被强制性地抢占
   - 只能由持有资源的进程主动释放

4. 环路等待条件（Circular Wait）
   - 存在一个进程资源的循环等待链
   - P1等待P2的资源，P2等待P3的资源，...，Pn等待P1的资源

预防死锁的方法就是破坏这四个条件中的任意一个。
```

**提示**：
```json
[
  "想想多个进程竞争资源的场景",
  "考虑什么情况下进程会永远等待下去",
  "四个条件必须同时满足才会发生死锁"
]
```

---

## 💻 编程题示例

### 题目信息
- **标题**：实现栈的基本操作
- **URL标识**：implement-stack-operations
- **分类**：数据结构
- **难度**：中级
- **题目类型**：编程题

### 题目内容
**题目描述**：
```
请用Python实现一个栈类，包含以下方法：
- push(item): 将元素压入栈顶
- pop(): 弹出栈顶元素并返回
- peek(): 查看栈顶元素但不弹出
- is_empty(): 判断栈是否为空
- size(): 返回栈的大小
```

**选项**：
```json
{}
```

**正确答案**：
```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise IndexError("pop from empty stack")
        return self.items.pop()
    
    def peek(self):
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self.items[-1]
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)
```

**答案解析**：
```
栈的实现要点：

1. 数据存储：
   - 使用列表（list）作为底层存储结构
   - 列表的末尾作为栈顶

2. 核心操作：
   - push(): 使用append()在列表末尾添加元素
   - pop(): 使用pop()移除并返回列表末尾元素
   - peek(): 返回items[-1]但不移除

3. 异常处理：
   - 空栈时pop()和peek()应该抛出异常
   - 提供清晰的错误信息

4. 辅助方法：
   - is_empty(): 检查列表长度是否为0
   - size(): 返回列表长度

时间复杂度：
- 所有操作都是O(1)常数时间
```

**提示**：
```json
[
  "考虑使用Python的列表作为底层存储",
  "列表的哪一端作为栈顶比较高效？",
  "记得处理空栈的异常情况",
  "所有操作都应该是O(1)时间复杂度"
]
```

---

## 🎯 题目质量检查清单

### ✅ 内容质量
- [ ] 题目描述清晰明确
- [ ] 选项没有歧义
- [ ] 正确答案准确无误
- [ ] 解析详细且有教育价值
- [ ] 提示循序渐进

### ✅ 技术规范
- [ ] JSON格式正确
- [ ] 答案格式符合要求
- [ ] 标签设置合理
- [ ] 难度等级适当
- [ ] 时间限制合理

### ✅ 用户体验
- [ ] 题目有一定挑战性
- [ ] 解析有助于学习
- [ ] 提示不直接给出答案
- [ ] 符合目标用户水平

使用这些模板，您可以快速创建高质量的练习题！
